//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/net/PSocketProcessChild.h"
#include "mozilla/ProfilerLabels.h"
#include "mozilla/ProfilerMarkers.h"
#include "mozilla/ipc/URIUtils.h"
#include "mozilla/net/SocketProcessChild.h"
#include "nsID.h"

#include "mozilla/net/PDNSRequestChild.h"
#include "mozilla/net/PSocketProcessBridgeChild.h"
#include "mozilla/PProfilerChild.h"
#include "mozilla/net/PWebrtcTCPSocketChild.h"
#include "mozilla/net/PHttpTransactionChild.h"
#include "mozilla/net/PHttpConnectionMgrChild.h"
#include "mozilla/ipc/PFileDescriptorSetChild.h"
#include "mozilla/ipc/PChildToParentStreamChild.h"
#include "mozilla/ipc/PParentToChildStreamChild.h"
#include "mozilla/net/PInputChannelThrottleQueueChild.h"
#include "mozilla/ipc/PBackgroundChild.h"
#include "mozilla/net/PAltServiceChild.h"
#include "mozilla/net/PAltSvcTransactionChild.h"
#include "mozilla/net/PTRRServiceChild.h"
#include "mozilla/net/PProxyConfigLookupChild.h"
#include "mozilla/net/PNativeDNSResolverOverrideChild.h"
#include "mozilla/PRemoteLazyInputStreamChild.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace net {


auto PSocketProcessChild::RecvPHttpTransactionConstructor(PHttpTransactionChild* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PSocketProcessChild::RecvPParentToChildStreamConstructor(PParentToChildStreamChild* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PSocketProcessChild::RecvPHttpConnectionMgrConstructor(
        PHttpConnectionMgrChild* actor,
        const HttpHandlerInitArgs& aArgs) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PSocketProcessChild::RecvPInputChannelThrottleQueueConstructor(
        PInputChannelThrottleQueueChild* actor,
        const uint32_t& meanBytesPerSecond,
        const uint32_t& maxBytesPerSecond) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PSocketProcessChild::RecvPAltSvcTransactionConstructor(
        PAltSvcTransactionChild* actor,
        const HttpConnectionInfoCloneArgs& aConnInfo,
        const uint32_t& aCaps) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PSocketProcessChild::RecvPTRRServiceConstructor(
        PTRRServiceChild* actor,
        const bool& aCaptiveIsPassed,
        const bool& aParentalControlEnabled,
        nsTArray<nsCString>&& aDNSSuffixList) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PSocketProcessChild::RecvPNativeDNSResolverOverrideConstructor(PNativeDNSResolverOverrideChild* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PSocketProcessChild::RecvPRemoteLazyInputStreamConstructor(
        PRemoteLazyInputStreamChild* actor,
        const nsID& aID,
        const uint64_t& aSize) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PSocketProcessChild::RecvPFileDescriptorSetConstructor(
        PFileDescriptorSetChild* actor,
        const FileDescriptor& fd) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PSocketProcessChild::RecvPDNSRequestConstructor(
        PDNSRequestChild* actor,
        const nsCString& hostName,
        const nsCString& trrServer,
        const uint16_t& type,
        const OriginAttributes& originAttributes,
        const uint32_t& flags) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PSocketProcessChild::ProcessingError(
        Result aCode,
        const char* aReason) -> void
{
}

auto PSocketProcessChild::ShouldContinueFromReplyTimeout() -> bool
{
    return true;
}

auto PSocketProcessChild::EnteredCxxStack() -> void
{
}

auto PSocketProcessChild::ExitedCxxStack() -> void
{
}

auto PSocketProcessChild::EnteredCall() -> void
{
}

auto PSocketProcessChild::ExitedCall() -> void
{
}

MOZ_IMPLICIT PSocketProcessChild::PSocketProcessChild() :
    mozilla::ipc::IToplevelProtocol("PSocketProcessChild", PSocketProcessMsgStart, mozilla::ipc::ChildSide)
{
    MOZ_COUNT_CTOR(PSocketProcessChild);
}

PSocketProcessChild::~PSocketProcessChild()
{
    MOZ_COUNT_DTOR(PSocketProcessChild);
}

auto PSocketProcessChild::ManagedPDNSRequestChild(nsTArray<PDNSRequestChild*>& aArr) const -> void
{
    mManagedPDNSRequestChild.ToArray(aArr);
}

auto PSocketProcessChild::ManagedPDNSRequestChild() const -> const ManagedContainer<PDNSRequestChild>&
{
    return mManagedPDNSRequestChild;
}

auto PSocketProcessChild::ManagedPWebrtcTCPSocketChild(nsTArray<PWebrtcTCPSocketChild*>& aArr) const -> void
{
    mManagedPWebrtcTCPSocketChild.ToArray(aArr);
}

auto PSocketProcessChild::ManagedPWebrtcTCPSocketChild() const -> const ManagedContainer<PWebrtcTCPSocketChild>&
{
    return mManagedPWebrtcTCPSocketChild;
}

auto PSocketProcessChild::ManagedPFileDescriptorSetChild(nsTArray<PFileDescriptorSetChild*>& aArr) const -> void
{
    mManagedPFileDescriptorSetChild.ToArray(aArr);
}

auto PSocketProcessChild::ManagedPFileDescriptorSetChild() const -> const ManagedContainer<PFileDescriptorSetChild>&
{
    return mManagedPFileDescriptorSetChild;
}

auto PSocketProcessChild::ManagedPHttpTransactionChild(nsTArray<PHttpTransactionChild*>& aArr) const -> void
{
    mManagedPHttpTransactionChild.ToArray(aArr);
}

auto PSocketProcessChild::ManagedPHttpTransactionChild() const -> const ManagedContainer<PHttpTransactionChild>&
{
    return mManagedPHttpTransactionChild;
}

auto PSocketProcessChild::ManagedPHttpConnectionMgrChild(nsTArray<PHttpConnectionMgrChild*>& aArr) const -> void
{
    mManagedPHttpConnectionMgrChild.ToArray(aArr);
}

auto PSocketProcessChild::ManagedPHttpConnectionMgrChild() const -> const ManagedContainer<PHttpConnectionMgrChild>&
{
    return mManagedPHttpConnectionMgrChild;
}

auto PSocketProcessChild::ManagedPChildToParentStreamChild(nsTArray<PChildToParentStreamChild*>& aArr) const -> void
{
    mManagedPChildToParentStreamChild.ToArray(aArr);
}

auto PSocketProcessChild::ManagedPChildToParentStreamChild() const -> const ManagedContainer<PChildToParentStreamChild>&
{
    return mManagedPChildToParentStreamChild;
}

auto PSocketProcessChild::ManagedPParentToChildStreamChild(nsTArray<PParentToChildStreamChild*>& aArr) const -> void
{
    mManagedPParentToChildStreamChild.ToArray(aArr);
}

auto PSocketProcessChild::ManagedPParentToChildStreamChild() const -> const ManagedContainer<PParentToChildStreamChild>&
{
    return mManagedPParentToChildStreamChild;
}

auto PSocketProcessChild::ManagedPInputChannelThrottleQueueChild(nsTArray<PInputChannelThrottleQueueChild*>& aArr) const -> void
{
    mManagedPInputChannelThrottleQueueChild.ToArray(aArr);
}

auto PSocketProcessChild::ManagedPInputChannelThrottleQueueChild() const -> const ManagedContainer<PInputChannelThrottleQueueChild>&
{
    return mManagedPInputChannelThrottleQueueChild;
}

auto PSocketProcessChild::ManagedPAltServiceChild(nsTArray<PAltServiceChild*>& aArr) const -> void
{
    mManagedPAltServiceChild.ToArray(aArr);
}

auto PSocketProcessChild::ManagedPAltServiceChild() const -> const ManagedContainer<PAltServiceChild>&
{
    return mManagedPAltServiceChild;
}

auto PSocketProcessChild::ManagedPAltSvcTransactionChild(nsTArray<PAltSvcTransactionChild*>& aArr) const -> void
{
    mManagedPAltSvcTransactionChild.ToArray(aArr);
}

auto PSocketProcessChild::ManagedPAltSvcTransactionChild() const -> const ManagedContainer<PAltSvcTransactionChild>&
{
    return mManagedPAltSvcTransactionChild;
}

auto PSocketProcessChild::ManagedPTRRServiceChild(nsTArray<PTRRServiceChild*>& aArr) const -> void
{
    mManagedPTRRServiceChild.ToArray(aArr);
}

auto PSocketProcessChild::ManagedPTRRServiceChild() const -> const ManagedContainer<PTRRServiceChild>&
{
    return mManagedPTRRServiceChild;
}

auto PSocketProcessChild::ManagedPProxyConfigLookupChild(nsTArray<PProxyConfigLookupChild*>& aArr) const -> void
{
    mManagedPProxyConfigLookupChild.ToArray(aArr);
}

auto PSocketProcessChild::ManagedPProxyConfigLookupChild() const -> const ManagedContainer<PProxyConfigLookupChild>&
{
    return mManagedPProxyConfigLookupChild;
}

auto PSocketProcessChild::ManagedPNativeDNSResolverOverrideChild(nsTArray<PNativeDNSResolverOverrideChild*>& aArr) const -> void
{
    mManagedPNativeDNSResolverOverrideChild.ToArray(aArr);
}

auto PSocketProcessChild::ManagedPNativeDNSResolverOverrideChild() const -> const ManagedContainer<PNativeDNSResolverOverrideChild>&
{
    return mManagedPNativeDNSResolverOverrideChild;
}

auto PSocketProcessChild::ManagedPRemoteLazyInputStreamChild(nsTArray<PRemoteLazyInputStreamChild*>& aArr) const -> void
{
    mManagedPRemoteLazyInputStreamChild.ToArray(aArr);
}

auto PSocketProcessChild::ManagedPRemoteLazyInputStreamChild() const -> const ManagedContainer<PRemoteLazyInputStreamChild>&
{
    return mManagedPRemoteLazyInputStreamChild;
}

auto PSocketProcessChild::AllManagedActors(nsTArray<RefPtr<mozilla::ipc::ActorLifecycleProxy>>& arr__) const -> void
{
    uint32_t total = 0;
    total += mManagedPDNSRequestChild.Count();
    total += mManagedPWebrtcTCPSocketChild.Count();
    total += mManagedPFileDescriptorSetChild.Count();
    total += mManagedPHttpTransactionChild.Count();
    total += mManagedPHttpConnectionMgrChild.Count();
    total += mManagedPChildToParentStreamChild.Count();
    total += mManagedPParentToChildStreamChild.Count();
    total += mManagedPInputChannelThrottleQueueChild.Count();
    total += mManagedPAltServiceChild.Count();
    total += mManagedPAltSvcTransactionChild.Count();
    total += mManagedPTRRServiceChild.Count();
    total += mManagedPProxyConfigLookupChild.Count();
    total += mManagedPNativeDNSResolverOverrideChild.Count();
    total += mManagedPRemoteLazyInputStreamChild.Count();
    arr__.SetCapacity(total);

    for (auto it = mManagedPDNSRequestChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPWebrtcTCPSocketChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPFileDescriptorSetChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPHttpTransactionChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPHttpConnectionMgrChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPChildToParentStreamChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPParentToChildStreamChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPInputChannelThrottleQueueChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPAltServiceChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPAltSvcTransactionChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPTRRServiceChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPProxyConfigLookupChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPNativeDNSResolverOverrideChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPRemoteLazyInputStreamChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

}

auto PSocketProcessChild::OpenPDNSRequestEndpoint(PDNSRequestChild* aActor) -> ManagedEndpoint<PDNSRequestParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PDNSRequestChild actor");
        return ManagedEndpoint<PDNSRequestParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPDNSRequestChild.PutEntry(aActor);

    return ManagedEndpoint<PDNSRequestParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessChild::BindPDNSRequestEndpoint(
        ManagedEndpoint<PDNSRequestChild> aEndpoint,
        PDNSRequestChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PDNSRequestChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPDNSRequestChild.PutEntry(aActor);

    return true;
}

auto PSocketProcessChild::OpenPWebrtcTCPSocketEndpoint(PWebrtcTCPSocketChild* aActor) -> ManagedEndpoint<PWebrtcTCPSocketParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebrtcTCPSocketChild actor");
        return ManagedEndpoint<PWebrtcTCPSocketParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPWebrtcTCPSocketChild.PutEntry(aActor);

    return ManagedEndpoint<PWebrtcTCPSocketParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessChild::BindPWebrtcTCPSocketEndpoint(
        ManagedEndpoint<PWebrtcTCPSocketChild> aEndpoint,
        PWebrtcTCPSocketChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebrtcTCPSocketChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPWebrtcTCPSocketChild.PutEntry(aActor);

    return true;
}

auto PSocketProcessChild::OpenPFileDescriptorSetEndpoint(PFileDescriptorSetChild* aActor) -> ManagedEndpoint<PFileDescriptorSetParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PFileDescriptorSetChild actor");
        return ManagedEndpoint<PFileDescriptorSetParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPFileDescriptorSetChild.PutEntry(aActor);

    return ManagedEndpoint<PFileDescriptorSetParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessChild::BindPFileDescriptorSetEndpoint(
        ManagedEndpoint<PFileDescriptorSetChild> aEndpoint,
        PFileDescriptorSetChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PFileDescriptorSetChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPFileDescriptorSetChild.PutEntry(aActor);

    return true;
}

auto PSocketProcessChild::OpenPHttpTransactionEndpoint(PHttpTransactionChild* aActor) -> ManagedEndpoint<PHttpTransactionParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PHttpTransactionChild actor");
        return ManagedEndpoint<PHttpTransactionParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPHttpTransactionChild.PutEntry(aActor);

    return ManagedEndpoint<PHttpTransactionParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessChild::BindPHttpTransactionEndpoint(
        ManagedEndpoint<PHttpTransactionChild> aEndpoint,
        PHttpTransactionChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PHttpTransactionChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPHttpTransactionChild.PutEntry(aActor);

    return true;
}

auto PSocketProcessChild::OpenPHttpConnectionMgrEndpoint(PHttpConnectionMgrChild* aActor) -> ManagedEndpoint<PHttpConnectionMgrParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PHttpConnectionMgrChild actor");
        return ManagedEndpoint<PHttpConnectionMgrParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPHttpConnectionMgrChild.PutEntry(aActor);

    return ManagedEndpoint<PHttpConnectionMgrParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessChild::BindPHttpConnectionMgrEndpoint(
        ManagedEndpoint<PHttpConnectionMgrChild> aEndpoint,
        PHttpConnectionMgrChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PHttpConnectionMgrChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPHttpConnectionMgrChild.PutEntry(aActor);

    return true;
}

auto PSocketProcessChild::OpenPChildToParentStreamEndpoint(PChildToParentStreamChild* aActor) -> ManagedEndpoint<PChildToParentStreamParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PChildToParentStreamChild actor");
        return ManagedEndpoint<PChildToParentStreamParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPChildToParentStreamChild.PutEntry(aActor);

    return ManagedEndpoint<PChildToParentStreamParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessChild::BindPChildToParentStreamEndpoint(
        ManagedEndpoint<PChildToParentStreamChild> aEndpoint,
        PChildToParentStreamChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PChildToParentStreamChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPChildToParentStreamChild.PutEntry(aActor);

    return true;
}

auto PSocketProcessChild::OpenPParentToChildStreamEndpoint(PParentToChildStreamChild* aActor) -> ManagedEndpoint<PParentToChildStreamParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PParentToChildStreamChild actor");
        return ManagedEndpoint<PParentToChildStreamParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPParentToChildStreamChild.PutEntry(aActor);

    return ManagedEndpoint<PParentToChildStreamParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessChild::BindPParentToChildStreamEndpoint(
        ManagedEndpoint<PParentToChildStreamChild> aEndpoint,
        PParentToChildStreamChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PParentToChildStreamChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPParentToChildStreamChild.PutEntry(aActor);

    return true;
}

auto PSocketProcessChild::OpenPInputChannelThrottleQueueEndpoint(PInputChannelThrottleQueueChild* aActor) -> ManagedEndpoint<PInputChannelThrottleQueueParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PInputChannelThrottleQueueChild actor");
        return ManagedEndpoint<PInputChannelThrottleQueueParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPInputChannelThrottleQueueChild.PutEntry(aActor);

    return ManagedEndpoint<PInputChannelThrottleQueueParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessChild::BindPInputChannelThrottleQueueEndpoint(
        ManagedEndpoint<PInputChannelThrottleQueueChild> aEndpoint,
        PInputChannelThrottleQueueChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PInputChannelThrottleQueueChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPInputChannelThrottleQueueChild.PutEntry(aActor);

    return true;
}

auto PSocketProcessChild::OpenPAltServiceEndpoint(PAltServiceChild* aActor) -> ManagedEndpoint<PAltServiceParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PAltServiceChild actor");
        return ManagedEndpoint<PAltServiceParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPAltServiceChild.PutEntry(aActor);

    return ManagedEndpoint<PAltServiceParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessChild::BindPAltServiceEndpoint(
        ManagedEndpoint<PAltServiceChild> aEndpoint,
        PAltServiceChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PAltServiceChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPAltServiceChild.PutEntry(aActor);

    return true;
}

auto PSocketProcessChild::OpenPAltSvcTransactionEndpoint(PAltSvcTransactionChild* aActor) -> ManagedEndpoint<PAltSvcTransactionParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PAltSvcTransactionChild actor");
        return ManagedEndpoint<PAltSvcTransactionParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPAltSvcTransactionChild.PutEntry(aActor);

    return ManagedEndpoint<PAltSvcTransactionParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessChild::BindPAltSvcTransactionEndpoint(
        ManagedEndpoint<PAltSvcTransactionChild> aEndpoint,
        PAltSvcTransactionChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PAltSvcTransactionChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPAltSvcTransactionChild.PutEntry(aActor);

    return true;
}

auto PSocketProcessChild::OpenPTRRServiceEndpoint(PTRRServiceChild* aActor) -> ManagedEndpoint<PTRRServiceParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PTRRServiceChild actor");
        return ManagedEndpoint<PTRRServiceParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPTRRServiceChild.PutEntry(aActor);

    return ManagedEndpoint<PTRRServiceParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessChild::BindPTRRServiceEndpoint(
        ManagedEndpoint<PTRRServiceChild> aEndpoint,
        PTRRServiceChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PTRRServiceChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPTRRServiceChild.PutEntry(aActor);

    return true;
}

auto PSocketProcessChild::OpenPProxyConfigLookupEndpoint(PProxyConfigLookupChild* aActor) -> ManagedEndpoint<PProxyConfigLookupParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PProxyConfigLookupChild actor");
        return ManagedEndpoint<PProxyConfigLookupParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPProxyConfigLookupChild.PutEntry(aActor);

    return ManagedEndpoint<PProxyConfigLookupParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessChild::BindPProxyConfigLookupEndpoint(
        ManagedEndpoint<PProxyConfigLookupChild> aEndpoint,
        PProxyConfigLookupChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PProxyConfigLookupChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPProxyConfigLookupChild.PutEntry(aActor);

    return true;
}

auto PSocketProcessChild::OpenPNativeDNSResolverOverrideEndpoint(PNativeDNSResolverOverrideChild* aActor) -> ManagedEndpoint<PNativeDNSResolverOverrideParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PNativeDNSResolverOverrideChild actor");
        return ManagedEndpoint<PNativeDNSResolverOverrideParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPNativeDNSResolverOverrideChild.PutEntry(aActor);

    return ManagedEndpoint<PNativeDNSResolverOverrideParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessChild::BindPNativeDNSResolverOverrideEndpoint(
        ManagedEndpoint<PNativeDNSResolverOverrideChild> aEndpoint,
        PNativeDNSResolverOverrideChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PNativeDNSResolverOverrideChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPNativeDNSResolverOverrideChild.PutEntry(aActor);

    return true;
}

auto PSocketProcessChild::OpenPRemoteLazyInputStreamEndpoint(PRemoteLazyInputStreamChild* aActor) -> ManagedEndpoint<PRemoteLazyInputStreamParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PRemoteLazyInputStreamChild actor");
        return ManagedEndpoint<PRemoteLazyInputStreamParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPRemoteLazyInputStreamChild.PutEntry(aActor);

    return ManagedEndpoint<PRemoteLazyInputStreamParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessChild::BindPRemoteLazyInputStreamEndpoint(
        ManagedEndpoint<PRemoteLazyInputStreamChild> aEndpoint,
        PRemoteLazyInputStreamChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PRemoteLazyInputStreamChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPRemoteLazyInputStreamChild.PutEntry(aActor);

    return true;
}

auto PSocketProcessChild::SendInitCrashReporter(const NativeThreadId& threadId) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_InitCrashReporter(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, threadId);
    // Sentinel = 'threadId'
    (msg__)->WriteSentinel(248185638);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_InitCrashReporter", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessChild::SendAddMemoryReport(const MemoryReport& aReport) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_AddMemoryReport(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, aReport);
    // Sentinel = 'aReport'
    (msg__)->WriteSentinel(184025822);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_AddMemoryReport", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessChild::SendAccumulateChildHistograms(const nsTArray<HistogramAccumulation>& accumulations) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_AccumulateChildHistograms(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, accumulations);
    // Sentinel = 'accumulations'
    (msg__)->WriteSentinel(632030585);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_AccumulateChildHistograms", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessChild::SendAccumulateChildKeyedHistograms(const nsTArray<KeyedHistogramAccumulation>& accumulations) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_AccumulateChildKeyedHistograms(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, accumulations);
    // Sentinel = 'accumulations'
    (msg__)->WriteSentinel(632030585);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_AccumulateChildKeyedHistograms", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessChild::SendUpdateChildScalars(const nsTArray<ScalarAction>& actions) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_UpdateChildScalars(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, actions);
    // Sentinel = 'actions'
    (msg__)->WriteSentinel(193200882);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_UpdateChildScalars", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessChild::SendUpdateChildKeyedScalars(const nsTArray<KeyedScalarAction>& actions) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_UpdateChildKeyedScalars(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, actions);
    // Sentinel = 'actions'
    (msg__)->WriteSentinel(193200882);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_UpdateChildKeyedScalars", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessChild::SendRecordChildEvents(const nsTArray<ChildEventData>& events) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_RecordChildEvents(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, events);
    // Sentinel = 'events'
    (msg__)->WriteSentinel(149619350);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_RecordChildEvents", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessChild::SendRecordDiscardedData(const DiscardedData& data) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_RecordDiscardedData(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, data);
    // Sentinel = 'data'
    (msg__)->WriteSentinel(67109275);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_RecordDiscardedData", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessChild::SendPWebrtcTCPSocketConstructor(const mozilla::Maybe<TabId>& tabId) -> PWebrtcTCPSocketChild*
{
    PWebrtcTCPSocketChild* actor = (static_cast<SocketProcessChild*>(this))->AllocPWebrtcTCPSocketChild(tabId);
    return SendPWebrtcTCPSocketConstructor(actor, tabId);
}

auto PSocketProcessChild::SendPWebrtcTCPSocketConstructor(
        PWebrtcTCPSocketChild* actor,
        const mozilla::Maybe<TabId>& tabId) -> PWebrtcTCPSocketChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PWebrtcTCPSocketChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPWebrtcTCPSocketChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PSocketProcess::Msg_PWebrtcTCPSocketConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, tabId);
    // Sentinel = 'tabId'
    (msg__)->WriteSentinel(99156453);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_PWebrtcTCPSocketConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PWebrtcTCPSocketChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PWebrtcTCPSocketMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PSocketProcessChild::SendPChildToParentStreamConstructor() -> PChildToParentStreamChild*
{
    PChildToParentStreamChild* actor = (static_cast<SocketProcessChild*>(this))->AllocPChildToParentStreamChild();
    return SendPChildToParentStreamConstructor(actor);
}

auto PSocketProcessChild::SendPChildToParentStreamConstructor(PChildToParentStreamChild* actor) -> PChildToParentStreamChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PChildToParentStreamChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPChildToParentStreamChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PSocketProcess::Msg_PChildToParentStreamConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_PChildToParentStreamConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PChildToParentStreamChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PChildToParentStreamMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PSocketProcessChild::SendObserveHttpActivity(
        const HttpActivityArgs& aActivityArgs,
        const uint32_t& aActivityType,
        const uint32_t& aActivitySubtype,
        const PRTime& aTimestamp,
        const uint64_t& aExtraSizeData,
        const nsCString& aExtraStringData) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_ObserveHttpActivity(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, aActivityArgs);
    // Sentinel = 'aActivityArgs'
    (msg__)->WriteSentinel(599721276);
    WriteIPDLParam(msg__, this, aActivityType);
    // Sentinel = 'aActivityType'
    (msg__)->WriteSentinel(606340433);
    WriteIPDLParam(msg__, this, aActivitySubtype);
    // Sentinel = 'aActivitySubtype'
    (msg__)->WriteSentinel(916326043);
    WriteIPDLParam(msg__, this, aTimestamp);
    // Sentinel = 'aTimestamp'
    (msg__)->WriteSentinel(367330326);
    WriteIPDLParam(msg__, this, aExtraSizeData);
    // Sentinel = 'aExtraSizeData'
    (msg__)->WriteSentinel(689833339);
    WriteIPDLParam(msg__, this, aExtraStringData);
    // Sentinel = 'aExtraStringData'
    (msg__)->WriteSentinel(905315927);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_ObserveHttpActivity", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessChild::SendInitBackground(Endpoint<mozilla::ipc::PBackgroundParent>&& aEndpoint) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_InitBackground(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, std::move(aEndpoint));
    // Sentinel = 'aEndpoint'
    (msg__)->WriteSentinel(292225955);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_InitBackground", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessChild::SendPAltServiceConstructor(PAltServiceChild* actor) -> PAltServiceChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PAltServiceChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPAltServiceChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PSocketProcess::Msg_PAltServiceConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_PAltServiceConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PAltServiceChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PAltServiceMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PSocketProcessChild::SendGetTLSClientCert(
        const nsCString& aHostName,
        const OriginAttributes& aOriginAttributes,
        const int32_t& aPort,
        const uint32_t& aProviderFlags,
        const uint32_t& aProviderTlsFlags,
        const ByteArray& aServerCert,
        const mozilla::Maybe<ByteArray>& aClientCert,
        const nsTArray<ByteArray>& aCollectedCANames,
        bool* aSucceeded,
        ByteArray* aOutCert,
        ByteArray* aOutKey,
        nsTArray<ByteArray>* aBuiltChain) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_GetTLSClientCert(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, aHostName);
    // Sentinel = 'aHostName'
    (msg__)->WriteSentinel(290128769);
    WriteIPDLParam(msg__, this, aOriginAttributes);
    // Sentinel = 'aOriginAttributes'
    (msg__)->WriteSentinel(1021839089);
    WriteIPDLParam(msg__, this, aPort);
    // Sentinel = 'aPort'
    (msg__)->WriteSentinel(97452551);
    WriteIPDLParam(msg__, this, aProviderFlags);
    // Sentinel = 'aProviderFlags'
    (msg__)->WriteSentinel(701957530);
    WriteIPDLParam(msg__, this, aProviderTlsFlags);
    // Sentinel = 'aProviderTlsFlags'
    (msg__)->WriteSentinel(1025771213);
    WriteIPDLParam(msg__, this, aServerCert);
    // Sentinel = 'aServerCert'
    (msg__)->WriteSentinel(435553383);
    WriteIPDLParam(msg__, this, aClientCert);
    // Sentinel = 'aClientCert'
    (msg__)->WriteSentinel(420873295);
    WriteIPDLParam(msg__, this, aCollectedCANames);
    // Sentinel = 'aCollectedCANames'
    (msg__)->WriteSentinel(967968361);



    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_GetTLSClientCert", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PSocketProcess::Msg_GetTLSClientCert", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    PickleIterator iter__{reply__};

    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, aSucceeded)))) {
        FatalError("Error deserializing 'bool'");
        return false;
    }
    // Sentinel = 'aSucceeded'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 357893095)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
        return false;
    }
    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, aOutCert)))) {
        FatalError("Error deserializing 'ByteArray'");
        return false;
    }
    // Sentinel = 'aOutCert'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 231605032)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'ByteArray'");
        return false;
    }
    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, aOutKey)))) {
        FatalError("Error deserializing 'ByteArray'");
        return false;
    }
    // Sentinel = 'aOutKey'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 180683459)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'ByteArray'");
        return false;
    }
    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, aBuiltChain)))) {
        FatalError("Error deserializing 'ByteArray[]'");
        return false;
    }
    // Sentinel = 'aBuiltChain'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 422380613)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'ByteArray[]'");
        return false;
    }
    reply__.EndRead(iter__, reply__.type());

    return true;
}

auto PSocketProcessChild::SendPProxyConfigLookupConstructor(
        PProxyConfigLookupChild* actor,
        nsIURI* aUri,
        const uint32_t& aFlags) -> PProxyConfigLookupChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PProxyConfigLookupChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPProxyConfigLookupChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PSocketProcess::Msg_PProxyConfigLookupConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, aUri);
    // Sentinel = 'aUri'
    (msg__)->WriteSentinel(64225682);
    WriteIPDLParam(msg__, this, aFlags);
    // Sentinel = 'aFlags'
    (msg__)->WriteSentinel(129892943);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_PProxyConfigLookupConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PProxyConfigLookupChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PProxyConfigLookupMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PSocketProcessChild::SendCachePushCheck(
        nsIURI* aPushedURL,
        const OriginAttributes& aOriginAttributes,
        const nsCString& aRequestString,
        mozilla::ipc::ResolveCallback<bool>&& aResolve,
        mozilla::ipc::RejectCallback&& aReject) -> void
{
    IPC::Message* msg__ = PSocketProcess::Msg_CachePushCheck(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, aPushedURL);
    // Sentinel = 'aPushedURL'
    (msg__)->WriteSentinel(358155198);
    WriteIPDLParam(msg__, this, aOriginAttributes);
    // Sentinel = 'aOriginAttributes'
    (msg__)->WriteSentinel(1021839089);
    WriteIPDLParam(msg__, this, aRequestString);
    // Sentinel = 'aRequestString'
    (msg__)->WriteSentinel(712771010);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_CachePushCheck", OTHER);

    ChannelSend(msg__, std::move(aResolve), std::move(aReject));
    return;
}

auto PSocketProcessChild::SendCachePushCheck(
        nsIURI* aPushedURL,
        const OriginAttributes& aOriginAttributes,
        const nsCString& aRequestString) -> RefPtr<CachePushCheckPromise>
{
    RefPtr<MozPromise<bool, ResponseRejectReason, true>::Private> promise__ = new MozPromise<bool, ResponseRejectReason, true>::Private(__func__);
    promise__->UseDirectTaskDispatch(__func__);
    SendCachePushCheck(std::move(aPushedURL), std::move(aOriginAttributes), std::move(aRequestString), [promise__](bool&& aValue) {
        promise__->Resolve(std::move(aValue), __func__);
    }, [promise__](ResponseRejectReason&& aReason) {
        promise__->Reject(std::move(aReason), __func__);
    });
    return promise__;
}

auto PSocketProcessChild::SendODoHServiceActivated(const bool& aActivated) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_ODoHServiceActivated(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, aActivated);
    // Sentinel = 'aActivated'
    (msg__)->WriteSentinel(355664887);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_ODoHServiceActivated", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessChild::SendPFileDescriptorSetConstructor(const FileDescriptor& fd) -> PFileDescriptorSetChild*
{
    PFileDescriptorSetChild* actor = (static_cast<SocketProcessChild*>(this))->AllocPFileDescriptorSetChild(fd);
    return SendPFileDescriptorSetConstructor(actor, fd);
}

auto PSocketProcessChild::SendPFileDescriptorSetConstructor(
        PFileDescriptorSetChild* actor,
        const FileDescriptor& fd) -> PFileDescriptorSetChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PFileDescriptorSetChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPFileDescriptorSetChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PSocketProcess::Msg_PFileDescriptorSetConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, fd);
    // Sentinel = 'fd'
    (msg__)->WriteSentinel(20054219);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_PFileDescriptorSetConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PFileDescriptorSetChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PFileDescriptorSetMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PSocketProcessChild::SendPDNSRequestConstructor(
        PDNSRequestChild* actor,
        const nsCString& hostName,
        const nsCString& trrServer,
        const uint16_t& type,
        const OriginAttributes& originAttributes,
        const uint32_t& flags) -> PDNSRequestChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PDNSRequestChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPDNSRequestChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PSocketProcess::Msg_PDNSRequestConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, hostName);
    // Sentinel = 'hostName'
    (msg__)->WriteSentinel(249627456);
    WriteIPDLParam(msg__, this, trrServer);
    // Sentinel = 'trrServer'
    (msg__)->WriteSentinel(320603088);
    WriteIPDLParam(msg__, this, type);
    // Sentinel = 'type'
    (msg__)->WriteSentinel(75760067);
    WriteIPDLParam(msg__, this, originAttributes);
    // Sentinel = 'originAttributes'
    (msg__)->WriteSentinel(947259056);
    WriteIPDLParam(msg__, this, flags);
    // Sentinel = 'flags'
    (msg__)->WriteSentinel(102171150);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_PDNSRequestConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PDNSRequestChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PDNSRequestMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PSocketProcessChild::RemoveManagee(
        int32_t aProtocolId,
        IProtocol* aListener) -> void
{
    switch (aProtocolId) {
    case PDNSRequestMsgStart:
{
            PDNSRequestChild* actor = static_cast<PDNSRequestChild*>(aListener);
            auto& container = mManagedPDNSRequestChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PWebrtcTCPSocketMsgStart:
{
            PWebrtcTCPSocketChild* actor = static_cast<PWebrtcTCPSocketChild*>(aListener);
            auto& container = mManagedPWebrtcTCPSocketChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PFileDescriptorSetMsgStart:
{
            PFileDescriptorSetChild* actor = static_cast<PFileDescriptorSetChild*>(aListener);
            auto& container = mManagedPFileDescriptorSetChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PHttpTransactionMsgStart:
{
            PHttpTransactionChild* actor = static_cast<PHttpTransactionChild*>(aListener);
            auto& container = mManagedPHttpTransactionChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PHttpConnectionMgrMsgStart:
{
            PHttpConnectionMgrChild* actor = static_cast<PHttpConnectionMgrChild*>(aListener);
            auto& container = mManagedPHttpConnectionMgrChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PChildToParentStreamMsgStart:
{
            PChildToParentStreamChild* actor = static_cast<PChildToParentStreamChild*>(aListener);
            auto& container = mManagedPChildToParentStreamChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PParentToChildStreamMsgStart:
{
            PParentToChildStreamChild* actor = static_cast<PParentToChildStreamChild*>(aListener);
            auto& container = mManagedPParentToChildStreamChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PInputChannelThrottleQueueMsgStart:
{
            PInputChannelThrottleQueueChild* actor = static_cast<PInputChannelThrottleQueueChild*>(aListener);
            auto& container = mManagedPInputChannelThrottleQueueChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PAltServiceMsgStart:
{
            PAltServiceChild* actor = static_cast<PAltServiceChild*>(aListener);
            auto& container = mManagedPAltServiceChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PAltSvcTransactionMsgStart:
{
            PAltSvcTransactionChild* actor = static_cast<PAltSvcTransactionChild*>(aListener);
            auto& container = mManagedPAltSvcTransactionChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PTRRServiceMsgStart:
{
            PTRRServiceChild* actor = static_cast<PTRRServiceChild*>(aListener);
            auto& container = mManagedPTRRServiceChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PProxyConfigLookupMsgStart:
{
            PProxyConfigLookupChild* actor = static_cast<PProxyConfigLookupChild*>(aListener);
            auto& container = mManagedPProxyConfigLookupChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PNativeDNSResolverOverrideMsgStart:
{
            PNativeDNSResolverOverrideChild* actor = static_cast<PNativeDNSResolverOverrideChild*>(aListener);
            auto& container = mManagedPNativeDNSResolverOverrideChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PRemoteLazyInputStreamMsgStart:
{
            PRemoteLazyInputStreamChild* actor = static_cast<PRemoteLazyInputStreamChild*>(aListener);
            auto& container = mManagedPRemoteLazyInputStreamChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    default:
FatalError("unreached");
        return;    }
}

auto PSocketProcessChild::DeallocManagee(
        int32_t aProtocolId,
        IProtocol* aListener) -> void
{
    switch (aProtocolId) {
    case PWebrtcTCPSocketMsgStart:
        static_cast<SocketProcessChild*>(this)->DeallocPWebrtcTCPSocketChild(static_cast<PWebrtcTCPSocketChild*>(aListener));
        return;
    case PFileDescriptorSetMsgStart:
        static_cast<SocketProcessChild*>(this)->DeallocPFileDescriptorSetChild(static_cast<PFileDescriptorSetChild*>(aListener));
        return;
    case PChildToParentStreamMsgStart:
        static_cast<SocketProcessChild*>(this)->DeallocPChildToParentStreamChild(static_cast<PChildToParentStreamChild*>(aListener));
        return;
    case PParentToChildStreamMsgStart:
        static_cast<SocketProcessChild*>(this)->DeallocPParentToChildStreamChild(static_cast<PParentToChildStreamChild*>(aListener));
        return;
    default:
        FatalError("unreached");
        return;
    }
}

auto PSocketProcessChild::OnMessageReceived(const Message& msg__) -> PSocketProcessChild::Result
{
    int32_t route__ = msg__.routing_id();
    if (MSG_ROUTING_CONTROL != route__) {
        IProtocol* routed__ = Lookup(route__);
        if (!routed__ || !routed__->GetLifecycleProxy()) {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Ignored message for dead actor",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eSending);
            }

            return MsgProcessed;
        }

        RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
            routed__->GetLifecycleProxy();
        return proxy__->Get()->OnMessageReceived(msg__);
    }

    switch (msg__.type()) {
    case PSocketProcess::Reply_PWebrtcTCPSocketConstructor__ID:
        {
            return MsgProcessed;
        }
    case PSocketProcess::Reply_PChildToParentStreamConstructor__ID:
        {
            return MsgProcessed;
        }
    case PSocketProcess::Reply_PAltServiceConstructor__ID:
        {
            return MsgProcessed;
        }
    case PSocketProcess::Reply_PProxyConfigLookupConstructor__ID:
        {
            return MsgProcessed;
        }
    case PSocketProcess::Reply_CachePushCheck__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_CachePushCheck", OTHER);

            PickleIterator iter__{msg__};
            bool resolve__ = false;
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(resolve__)))))) {
                FatalError("Error deserializing 'resolve__'");
                return MsgValueError;
            }
            // Sentinel = 'resolve__'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 322044863)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'resolve__'");
                return MsgValueError;
            }


            UniquePtr<MessageChannel::UntypedCallbackHolder> untypedCallback =
                GetIPCChannel()->PopCallback(msg__);

            typedef MessageChannel::CallbackHolder<bool> CallbackHolder;
            auto* callback = static_cast<CallbackHolder*>(untypedCallback.get());
            if (!callback) {
                FatalError("Error unknown callback");
                return MsgProcessingError;
            }

            if (resolve__) {
                bool aAccepted{};

                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aAccepted)))))) {
                    FatalError("Error deserializing 'bool'");
                    return MsgValueError;
                }
                // Sentinel = 'aAccepted'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 281281403)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Resolve(std::move(aAccepted));
            } else {
                ResponseRejectReason reason__{};
                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(reason__)))))) {
                    FatalError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                // Sentinel = 'reason__'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 251855687)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Reject(std::move(reason__));
            }
            return MsgProcessed;
        }
    case PSocketProcess::Msg_Init__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_Init", OTHER);

            PickleIterator iter__{msg__};
            SocketPorcessInitAttributes aAttributes{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aAttributes)))))) {
                FatalError("Error deserializing 'SocketPorcessInitAttributes'");
                return MsgValueError;
            }
            // Sentinel = 'aAttributes'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 442434697)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'SocketPorcessInitAttributes'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessChild*>(this))->RecvInit(std::move(aAttributes))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_PreferenceUpdate__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_PreferenceUpdate", OTHER);

            PickleIterator iter__{msg__};
            Pref pref{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(pref)))))) {
                FatalError("Error deserializing 'Pref'");
                return MsgValueError;
            }
            // Sentinel = 'pref'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 71958958)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'Pref'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessChild*>(this))->RecvPreferenceUpdate(std::move(pref))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_RequestMemoryReport__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_RequestMemoryReport", OTHER);

            PickleIterator iter__{msg__};
            uint32_t generation{};
            bool anonymize{};
            bool minimizeMemoryUsage{};
            mozilla::Maybe<FileDescriptor> DMDFile{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(generation)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'generation'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 381158445)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(anonymize)))))) {
                FatalError("Error deserializing 'bool'");
                return MsgValueError;
            }
            // Sentinel = 'anonymize'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 321127387)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(minimizeMemoryUsage)))))) {
                FatalError("Error deserializing 'bool'");
                return MsgValueError;
            }
            // Sentinel = 'minimizeMemoryUsage'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 1321600977)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(DMDFile)))))) {
                FatalError("Error deserializing 'FileDescriptor?'");
                return MsgValueError;
            }
            // Sentinel = 'DMDFile'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 143983190)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'FileDescriptor?'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            int32_t id__ = MSG_ROUTING_CONTROL;
            int32_t seqno__ = msg__.seqno();
            RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
                GetLifecycleProxy();

            RequestMemoryReportResolver resolver = [proxy__, seqno__, id__](const uint32_t& aParam) {
                if (!proxy__->Get()) {
                    NS_WARNING("Not resolving response because actor is dead.");
                    return;
                }
                PSocketProcessChild* self__ = static_cast<PSocketProcessChild*>(proxy__->Get());

                IPC::Message* reply__ = PSocketProcess::Reply_RequestMemoryReport(id__);
                reply__->set_seqno(seqno__);

                bool resolve__ = true;
                WriteIPDLParam(reply__, self__, resolve__);
                // Sentinel = 'resolve__'
                (reply__)->WriteSentinel(322044863);
                WriteIPDLParam(reply__, self__, aParam);
                // Sentinel = 'aGeneration'
                (reply__)->WriteSentinel(430179438);

                if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                    mozilla::ipc::LogMessageForProtocol(
                        "PSocketProcessChild",
                        (self__)->OtherPid(),
                        "Sending reply ",
                        reply__->type(),
                        mozilla::ipc::MessageDirection::eSending);
                }

                bool sendok__ = self__->ChannelSend(reply__);
                if (!sendok__) {
                    NS_WARNING("Error sending reply");
                }
            };
            if ((!((static_cast<SocketProcessChild*>(this))->RecvRequestMemoryReport(std::move(generation), std::move(anonymize), std::move(minimizeMemoryUsage), std::move(DMDFile), std::move(resolver))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_SetOffline__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_SetOffline", OTHER);

            PickleIterator iter__{msg__};
            bool offline{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(offline)))))) {
                FatalError("Error deserializing 'bool'");
                return MsgValueError;
            }
            // Sentinel = 'offline'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 194904804)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessChild*>(this))->RecvSetOffline(std::move(offline))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_SetConnectivity__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_SetConnectivity", OTHER);

            PickleIterator iter__{msg__};
            bool connectivity{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(connectivity)))))) {
                FatalError("Error deserializing 'bool'");
                return MsgValueError;
            }
            // Sentinel = 'connectivity'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 548734240)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessChild*>(this))->RecvSetConnectivity(std::move(connectivity))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_InitLinuxSandbox__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_InitLinuxSandbox", OTHER);

            PickleIterator iter__{msg__};
            mozilla::Maybe<FileDescriptor> sandboxBroker{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(sandboxBroker)))))) {
                FatalError("Error deserializing 'FileDescriptor?'");
                return MsgValueError;
            }
            // Sentinel = 'sandboxBroker'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 625149269)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'FileDescriptor?'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessChild*>(this))->RecvInitLinuxSandbox(std::move(sandboxBroker))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_InitSocketProcessBridgeParent__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_InitSocketProcessBridgeParent", OTHER);

            PickleIterator iter__{msg__};
            ProcessId processId{};
            Endpoint<mozilla::net::PSocketProcessBridgeParent> endpoint{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(processId)))))) {
                FatalError("Error deserializing 'ProcessId'");
                return MsgValueError;
            }
            // Sentinel = 'processId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 318243757)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ProcessId'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(endpoint)))))) {
                FatalError("Error deserializing 'Endpoint<mozilla::net::PSocketProcessBridgeParent>'");
                return MsgValueError;
            }
            // Sentinel = 'endpoint'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 251724642)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'Endpoint<mozilla::net::PSocketProcessBridgeParent>'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessChild*>(this))->RecvInitSocketProcessBridgeParent(std::move(processId), std::move(endpoint))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_InitProfiler__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_InitProfiler", OTHER);

            PickleIterator iter__{msg__};
            Endpoint<mozilla::PProfilerChild> aEndpoint{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aEndpoint)))))) {
                FatalError("Error deserializing 'Endpoint<mozilla::PProfilerChild>'");
                return MsgValueError;
            }
            // Sentinel = 'aEndpoint'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 292225955)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'Endpoint<mozilla::PProfilerChild>'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessChild*>(this))->RecvInitProfiler(std::move(aEndpoint))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_SocketProcessTelemetryPing__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_SocketProcessTelemetryPing", OTHER);

            if ((!((static_cast<SocketProcessChild*>(this))->RecvSocketProcessTelemetryPing()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_PHttpTransactionConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_PHttpTransactionConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PHttpTransactionChild> actor = (static_cast<SocketProcessChild*>(this))->AllocPHttpTransactionChild();
            if (!actor) {
                NS_WARNING("Cannot bind null PHttpTransactionChild actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPHttpTransactionChild.PutEntry(actor);

            if ((!((static_cast<SocketProcessChild*>(this))->RecvPHttpTransactionConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_PParentToChildStreamConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_PParentToChildStreamConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PParentToChildStreamChild* actor = (static_cast<SocketProcessChild*>(this))->AllocPParentToChildStreamChild();
            if (!actor) {
                NS_WARNING("Cannot bind null PParentToChildStreamChild actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPParentToChildStreamChild.PutEntry(actor);

            if ((!((static_cast<SocketProcessChild*>(this))->RecvPParentToChildStreamConstructor(std::move(actor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_PHttpConnectionMgrConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_PHttpConnectionMgrConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            HttpHandlerInitArgs aArgs{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aArgs)))))) {
                FatalError("Error deserializing 'HttpHandlerInitArgs'");
                return MsgValueError;
            }
            // Sentinel = 'aArgs'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 92602863)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'HttpHandlerInitArgs'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PHttpConnectionMgrChild> actor = (static_cast<SocketProcessChild*>(this))->AllocPHttpConnectionMgrChild(aArgs);
            if (!actor) {
                NS_WARNING("Cannot bind null PHttpConnectionMgrChild actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPHttpConnectionMgrChild.PutEntry(actor);

            if ((!((static_cast<SocketProcessChild*>(this))->RecvPHttpConnectionMgrConstructor(actor, std::move(aArgs))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_UpdateDeviceModelId__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_UpdateDeviceModelId", OTHER);

            PickleIterator iter__{msg__};
            nsCString aModelId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aModelId)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'aModelId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 226951936)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessChild*>(this))->RecvUpdateDeviceModelId(std::move(aModelId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_OnHttpActivityDistributorActivated__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_OnHttpActivityDistributorActivated", OTHER);

            PickleIterator iter__{msg__};
            bool aIsActivated{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aIsActivated)))))) {
                FatalError("Error deserializing 'bool'");
                return MsgValueError;
            }
            // Sentinel = 'aIsActivated'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 496501939)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessChild*>(this))->RecvOnHttpActivityDistributorActivated(std::move(aIsActivated))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_PInputChannelThrottleQueueConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_PInputChannelThrottleQueueConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            uint32_t meanBytesPerSecond{};
            uint32_t maxBytesPerSecond{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(meanBytesPerSecond)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'meanBytesPerSecond'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 1142097708)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(maxBytesPerSecond)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'maxBytesPerSecond'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 1032193745)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PInputChannelThrottleQueueChild> actor = (static_cast<SocketProcessChild*>(this))->AllocPInputChannelThrottleQueueChild(meanBytesPerSecond, maxBytesPerSecond);
            if (!actor) {
                NS_WARNING("Cannot bind null PInputChannelThrottleQueueChild actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPInputChannelThrottleQueueChild.PutEntry(actor);

            if ((!((static_cast<SocketProcessChild*>(this))->RecvPInputChannelThrottleQueueConstructor(actor, std::move(meanBytesPerSecond), std::move(maxBytesPerSecond))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_PAltSvcTransactionConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_PAltSvcTransactionConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            HttpConnectionInfoCloneArgs aConnInfo{};
            uint32_t aCaps{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aConnInfo)))))) {
                FatalError("Error deserializing 'HttpConnectionInfoCloneArgs'");
                return MsgValueError;
            }
            // Sentinel = 'aConnInfo'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 284558204)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'HttpConnectionInfoCloneArgs'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aCaps)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'aCaps'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 90964457)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PAltSvcTransactionChild> actor = (static_cast<SocketProcessChild*>(this))->AllocPAltSvcTransactionChild(aConnInfo, aCaps);
            if (!actor) {
                NS_WARNING("Cannot bind null PAltSvcTransactionChild actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPAltSvcTransactionChild.PutEntry(actor);

            if ((!((static_cast<SocketProcessChild*>(this))->RecvPAltSvcTransactionConstructor(actor, std::move(aConnInfo), std::move(aCaps))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_ClearSessionCache__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_ClearSessionCache", OTHER);

            if ((!((static_cast<SocketProcessChild*>(this))->RecvClearSessionCache()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_PTRRServiceConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_PTRRServiceConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            bool aCaptiveIsPassed{};
            bool aParentalControlEnabled{};
            nsTArray<nsCString> aDNSSuffixList{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aCaptiveIsPassed)))))) {
                FatalError("Error deserializing 'bool'");
                return MsgValueError;
            }
            // Sentinel = 'aCaptiveIsPassed'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 883689034)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aParentalControlEnabled)))))) {
                FatalError("Error deserializing 'bool'");
                return MsgValueError;
            }
            // Sentinel = 'aParentalControlEnabled'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 1835010341)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aDNSSuffixList)))))) {
                FatalError("Error deserializing 'nsCString[]'");
                return MsgValueError;
            }
            // Sentinel = 'aDNSSuffixList'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 636552536)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString[]'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PTRRServiceChild> actor = (static_cast<SocketProcessChild*>(this))->AllocPTRRServiceChild(aCaptiveIsPassed, aParentalControlEnabled, aDNSSuffixList);
            if (!actor) {
                NS_WARNING("Cannot bind null PTRRServiceChild actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPTRRServiceChild.PutEntry(actor);

            if ((!((static_cast<SocketProcessChild*>(this))->RecvPTRRServiceConstructor(actor, std::move(aCaptiveIsPassed), std::move(aParentalControlEnabled), std::move(aDNSSuffixList))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_PNativeDNSResolverOverrideConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_PNativeDNSResolverOverrideConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PNativeDNSResolverOverrideChild> actor = (static_cast<SocketProcessChild*>(this))->AllocPNativeDNSResolverOverrideChild();
            if (!actor) {
                NS_WARNING("Cannot bind null PNativeDNSResolverOverrideChild actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPNativeDNSResolverOverrideChild.PutEntry(actor);

            if ((!((static_cast<SocketProcessChild*>(this))->RecvPNativeDNSResolverOverrideConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_NotifyObserver__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_NotifyObserver", OTHER);

            PickleIterator iter__{msg__};
            nsCString aTopic{};
            nsString aData{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aTopic)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'aTopic'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 137429601)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aData)))))) {
                FatalError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            // Sentinel = 'aData'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 90571228)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessChild*>(this))->RecvNotifyObserver(std::move(aTopic), std::move(aData))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_PRemoteLazyInputStreamConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_PRemoteLazyInputStreamConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            nsID aID{};
            uint64_t aSize{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aID)))))) {
                FatalError("Error deserializing 'nsID'");
                return MsgValueError;
            }
            // Sentinel = 'aID'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 33292527)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsID'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aSize)))))) {
                FatalError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            // Sentinel = 'aSize'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 97124861)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PRemoteLazyInputStreamChild> actor = (static_cast<SocketProcessChild*>(this))->AllocPRemoteLazyInputStreamChild(aID, aSize);
            if (!actor) {
                NS_WARNING("Cannot bind null PRemoteLazyInputStreamChild actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPRemoteLazyInputStreamChild.PutEntry(actor);

            if ((!((static_cast<SocketProcessChild*>(this))->RecvPRemoteLazyInputStreamConstructor(actor, std::move(aID), std::move(aSize))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_GetSocketData__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_GetSocketData", OTHER);

            int32_t id__ = MSG_ROUTING_CONTROL;
            int32_t seqno__ = msg__.seqno();
            RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
                GetLifecycleProxy();

            GetSocketDataResolver resolver = [proxy__, seqno__, id__](const SocketDataArgs& aParam) {
                if (!proxy__->Get()) {
                    NS_WARNING("Not resolving response because actor is dead.");
                    return;
                }
                PSocketProcessChild* self__ = static_cast<PSocketProcessChild*>(proxy__->Get());

                IPC::Message* reply__ = PSocketProcess::Reply_GetSocketData(id__);
                reply__->set_seqno(seqno__);

                bool resolve__ = true;
                WriteIPDLParam(reply__, self__, resolve__);
                // Sentinel = 'resolve__'
                (reply__)->WriteSentinel(322044863);
                WriteIPDLParam(reply__, self__, aParam);
                // Sentinel = 'data'
                (reply__)->WriteSentinel(67109275);

                if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                    mozilla::ipc::LogMessageForProtocol(
                        "PSocketProcessChild",
                        (self__)->OtherPid(),
                        "Sending reply ",
                        reply__->type(),
                        mozilla::ipc::MessageDirection::eSending);
                }

                bool sendok__ = self__->ChannelSend(reply__);
                if (!sendok__) {
                    NS_WARNING("Error sending reply");
                }
            };
            if ((!((static_cast<SocketProcessChild*>(this))->RecvGetSocketData(std::move(resolver))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_GetDNSCacheEntries__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_GetDNSCacheEntries", OTHER);

            int32_t id__ = MSG_ROUTING_CONTROL;
            int32_t seqno__ = msg__.seqno();
            RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
                GetLifecycleProxy();

            GetDNSCacheEntriesResolver resolver = [proxy__, seqno__, id__](nsTArray<DNSCacheEntries>&& aParam) {
                if (!proxy__->Get()) {
                    NS_WARNING("Not resolving response because actor is dead.");
                    return;
                }
                PSocketProcessChild* self__ = static_cast<PSocketProcessChild*>(proxy__->Get());

                IPC::Message* reply__ = PSocketProcess::Reply_GetDNSCacheEntries(id__);
                reply__->set_seqno(seqno__);

                bool resolve__ = true;
                WriteIPDLParam(reply__, self__, resolve__);
                // Sentinel = 'resolve__'
                (reply__)->WriteSentinel(322044863);
                WriteIPDLParam(reply__, self__, aParam);
                // Sentinel = 'entries'
                (reply__)->WriteSentinel(199361275);

                if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                    mozilla::ipc::LogMessageForProtocol(
                        "PSocketProcessChild",
                        (self__)->OtherPid(),
                        "Sending reply ",
                        reply__->type(),
                        mozilla::ipc::MessageDirection::eSending);
                }

                bool sendok__ = self__->ChannelSend(reply__);
                if (!sendok__) {
                    NS_WARNING("Error sending reply");
                }
            };
            if ((!((static_cast<SocketProcessChild*>(this))->RecvGetDNSCacheEntries(std::move(resolver))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_GetHttpConnectionData__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_GetHttpConnectionData", OTHER);

            int32_t id__ = MSG_ROUTING_CONTROL;
            int32_t seqno__ = msg__.seqno();
            RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
                GetLifecycleProxy();

            GetHttpConnectionDataResolver resolver = [proxy__, seqno__, id__](nsTArray<HttpRetParams>&& aParam) {
                if (!proxy__->Get()) {
                    NS_WARNING("Not resolving response because actor is dead.");
                    return;
                }
                PSocketProcessChild* self__ = static_cast<PSocketProcessChild*>(proxy__->Get());

                IPC::Message* reply__ = PSocketProcess::Reply_GetHttpConnectionData(id__);
                reply__->set_seqno(seqno__);

                bool resolve__ = true;
                WriteIPDLParam(reply__, self__, resolve__);
                // Sentinel = 'resolve__'
                (reply__)->WriteSentinel(322044863);
                WriteIPDLParam(reply__, self__, aParam);
                // Sentinel = 'params'
                (reply__)->WriteSentinel(146997893);

                if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                    mozilla::ipc::LogMessageForProtocol(
                        "PSocketProcessChild",
                        (self__)->OtherPid(),
                        "Sending reply ",
                        reply__->type(),
                        mozilla::ipc::MessageDirection::eSending);
                }

                bool sendok__ = self__->ChannelSend(reply__);
                if (!sendok__) {
                    NS_WARNING("Error sending reply");
                }
            };
            if ((!((static_cast<SocketProcessChild*>(this))->RecvGetHttpConnectionData(std::move(resolver))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Reply_PFileDescriptorSetConstructor__ID:
        {
            return MsgProcessed;
        }
    case PSocketProcess::Msg_PFileDescriptorSetConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_PFileDescriptorSetConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            FileDescriptor fd{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(fd)))))) {
                FatalError("Error deserializing 'FileDescriptor'");
                return MsgValueError;
            }
            // Sentinel = 'fd'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 20054219)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'FileDescriptor'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PFileDescriptorSetChild* actor = (static_cast<SocketProcessChild*>(this))->AllocPFileDescriptorSetChild(fd);
            if (!actor) {
                NS_WARNING("Cannot bind null PFileDescriptorSetChild actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPFileDescriptorSetChild.PutEntry(actor);

            if ((!((static_cast<SocketProcessChild*>(this))->RecvPFileDescriptorSetConstructor(std::move(actor), std::move(fd))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Reply_PDNSRequestConstructor__ID:
        {
            return MsgProcessed;
        }
    case PSocketProcess::Msg_PDNSRequestConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_PDNSRequestConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            nsCString hostName{};
            nsCString trrServer{};
            uint16_t type{};
            OriginAttributes originAttributes{};
            uint32_t flags{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(hostName)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'hostName'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 249627456)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(trrServer)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'trrServer'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 320603088)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(type)))))) {
                FatalError("Error deserializing 'uint16_t'");
                return MsgValueError;
            }
            // Sentinel = 'type'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 75760067)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint16_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(originAttributes)))))) {
                FatalError("Error deserializing 'OriginAttributes'");
                return MsgValueError;
            }
            // Sentinel = 'originAttributes'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 947259056)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'OriginAttributes'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(flags)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'flags'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102171150)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PDNSRequestChild> actor = (static_cast<SocketProcessChild*>(this))->AllocPDNSRequestChild(hostName, trrServer, type, originAttributes, flags);
            if (!actor) {
                NS_WARNING("Cannot bind null PDNSRequestChild actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPDNSRequestChild.PutEntry(actor);

            if ((!((static_cast<SocketProcessChild*>(this))->RecvPDNSRequestConstructor(actor, std::move(hostName), std::move(trrServer), std::move(type), std::move(originAttributes), std::move(flags))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    default:
        return MsgNotKnown;
    case SHMEM_CREATED_MESSAGE_TYPE:
        {
            FatalError("this protocol tree does not use shmem");
            return MsgNotKnown;
        }
    case SHMEM_DESTROYED_MESSAGE_TYPE:
        {
            FatalError("this protocol tree does not use shmem");
            return MsgNotKnown;
        }
    }
}

auto PSocketProcessChild::OnMessageReceived(
        const Message& msg__,
        Message*& reply__) -> PSocketProcessChild::Result
{
    int32_t route__ = msg__.routing_id();
    if (MSG_ROUTING_CONTROL != route__) {
        IProtocol* routed__ = Lookup(route__);
        if (!routed__ || !routed__->GetLifecycleProxy()) {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessChild",
                    OtherPid(),
                    "Ignored message for dead actor",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eSending);
            }

            return MsgProcessed;
        }

        RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
            routed__->GetLifecycleProxy();
        return proxy__->Get()->OnMessageReceived(msg__, reply__);
    }

    return MsgNotKnown;
}

auto PSocketProcessChild::OnCallReceived(
        const Message& msg__,
        Message*& reply__) -> PSocketProcessChild::Result
{
    MOZ_ASSERT_UNREACHABLE("message protocol not supported");
    return MsgNotKnown;
}

auto PSocketProcessChild::OnChannelClose() -> void
{
    DestroySubtree(NormalShutdown);
    ClearSubtree();
    DeallocShmems();
    if (GetLifecycleProxy()) {
        GetLifecycleProxy()->Release();
    }
}

auto PSocketProcessChild::OnChannelError() -> void
{
    DestroySubtree(AbnormalShutdown);
    ClearSubtree();
    DeallocShmems();
    if (GetLifecycleProxy()) {
        GetLifecycleProxy()->Release();
    }
}

auto PSocketProcessChild::ClearSubtree() -> void
{
    for (auto it = mManagedPDNSRequestChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPDNSRequestChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPDNSRequestChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPDNSRequestChild.Clear();

    for (auto it = mManagedPWebrtcTCPSocketChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPWebrtcTCPSocketChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPWebrtcTCPSocketChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPWebrtcTCPSocketChild.Clear();

    for (auto it = mManagedPFileDescriptorSetChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPFileDescriptorSetChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPFileDescriptorSetChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPFileDescriptorSetChild.Clear();

    for (auto it = mManagedPHttpTransactionChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPHttpTransactionChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPHttpTransactionChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPHttpTransactionChild.Clear();

    for (auto it = mManagedPHttpConnectionMgrChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPHttpConnectionMgrChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPHttpConnectionMgrChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPHttpConnectionMgrChild.Clear();

    for (auto it = mManagedPChildToParentStreamChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPChildToParentStreamChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPChildToParentStreamChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPChildToParentStreamChild.Clear();

    for (auto it = mManagedPParentToChildStreamChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPParentToChildStreamChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPParentToChildStreamChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPParentToChildStreamChild.Clear();

    for (auto it = mManagedPInputChannelThrottleQueueChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPInputChannelThrottleQueueChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPInputChannelThrottleQueueChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPInputChannelThrottleQueueChild.Clear();

    for (auto it = mManagedPAltServiceChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPAltServiceChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPAltServiceChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPAltServiceChild.Clear();

    for (auto it = mManagedPAltSvcTransactionChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPAltSvcTransactionChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPAltSvcTransactionChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPAltSvcTransactionChild.Clear();

    for (auto it = mManagedPTRRServiceChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPTRRServiceChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPTRRServiceChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPTRRServiceChild.Clear();

    for (auto it = mManagedPProxyConfigLookupChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPProxyConfigLookupChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPProxyConfigLookupChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPProxyConfigLookupChild.Clear();

    for (auto it = mManagedPNativeDNSResolverOverrideChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPNativeDNSResolverOverrideChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPNativeDNSResolverOverrideChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPNativeDNSResolverOverrideChild.Clear();

    for (auto it = mManagedPRemoteLazyInputStreamChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPRemoteLazyInputStreamChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPRemoteLazyInputStreamChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPRemoteLazyInputStreamChild.Clear();

}



} // namespace net
} // namespace mozilla
namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::net::PSocketProcessChild*>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    int32_t id;
    if (!aVar) {
        id = 0;  // kNullActorId
    } else {
        id = aVar->Id();
        if (id == 1) {  // kFreedActorId
            aVar->FatalError("Actor has been |delete|d");
        }
        MOZ_RELEASE_ASSERT(
            aActor->GetIPCChannel() == aVar->GetIPCChannel(),
            "Actor must be from the same channel as the"
            " actor it's being sent over");
        MOZ_RELEASE_ASSERT(
            aVar->CanSend(),
            "Actor must still be open when sending");
    }

    WriteIPDLParam(aMsg, aActor, id);
}

auto IPDLParamTraits<mozilla::net::PSocketProcessChild*>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    mozilla::Maybe<mozilla::ipc::IProtocol*> actor =
        aActor->ReadActor(aMsg, aIter, true, "PSocketProcess", PSocketProcessMsgStart);
    if (actor.isNothing()) {
        return false;
    }

    *aVar = static_cast<mozilla::net::PSocketProcessChild*>(actor.value());
    return true;
}

} // namespace ipc
} // namespace mozilla
