//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "GMPMessageUtils.h"
#include "mozilla/gmp/GMPTypes.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"


//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct NodeIdParts|
//
namespace mozilla {
namespace gmp {
} // namespace gmp
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::gmp::NodeIdParts>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).mOrigin());
    // Sentinel = 'mOrigin'
    (aMsg)->WriteSentinel(187630294);
    WriteIPDLParam(aMsg, aActor, (aVar).mTopLevelOrigin());
    // Sentinel = 'mTopLevelOrigin'
    (aMsg)->WriteSentinel(798098945);
    WriteIPDLParam(aMsg, aActor, (aVar).mGMPName());
    // Sentinel = 'mGMPName'
    (aMsg)->WriteSentinel(207160019);
}

auto IPDLParamTraits<mozilla::gmp::NodeIdParts>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mOrigin())))))) {
        aActor->FatalError("Error deserializing 'mOrigin' (nsString) member of 'NodeIdParts'");
        return false;
    }
    // Sentinel = 'mOrigin'
    if ((!((aMsg)->ReadSentinel(aIter, 187630294)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mOrigin' (nsString) member of 'NodeIdParts'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mTopLevelOrigin())))))) {
        aActor->FatalError("Error deserializing 'mTopLevelOrigin' (nsString) member of 'NodeIdParts'");
        return false;
    }
    // Sentinel = 'mTopLevelOrigin'
    if ((!((aMsg)->ReadSentinel(aIter, 798098945)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mTopLevelOrigin' (nsString) member of 'NodeIdParts'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mGMPName())))))) {
        aActor->FatalError("Error deserializing 'mGMPName' (nsString) member of 'NodeIdParts'");
        return false;
    }
    // Sentinel = 'mGMPName'
    if ((!((aMsg)->ReadSentinel(aIter, 207160019)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mGMPName' (nsString) member of 'NodeIdParts'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union NodeIdVariant|
//
namespace mozilla {
namespace gmp {
auto NodeIdVariant::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TnsCString:
        {
            (ptr_nsCString())->~nsCString__tdef();
            break;
        }
    case TNodeIdParts:
        {
            (ptr_NodeIdParts())->~NodeIdParts__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT NodeIdVariant::NodeIdVariant(const nsCString& aOther)
{
    new (mozilla::KnownNotNull, ptr_nsCString()) nsCString(aOther);
    mType = TnsCString;
}

MOZ_IMPLICIT NodeIdVariant::NodeIdVariant(nsCString&& aOther)
{
    new (mozilla::KnownNotNull, ptr_nsCString()) nsCString(std::move(aOther));
    mType = TnsCString;
}

MOZ_IMPLICIT NodeIdVariant::NodeIdVariant(const NodeIdParts& aOther)
{
    new (mozilla::KnownNotNull, ptr_NodeIdParts()) NodeIdParts(aOther);
    mType = TNodeIdParts;
}

MOZ_IMPLICIT NodeIdVariant::NodeIdVariant(NodeIdParts&& aOther)
{
    new (mozilla::KnownNotNull, ptr_NodeIdParts()) NodeIdParts(std::move(aOther));
    mType = TNodeIdParts;
}

MOZ_IMPLICIT NodeIdVariant::NodeIdVariant(const NodeIdVariant& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TnsCString:
        {
            new (mozilla::KnownNotNull, ptr_nsCString()) nsCString((aOther).get_nsCString());
            break;
        }
    case TNodeIdParts:
        {
            new (mozilla::KnownNotNull, ptr_NodeIdParts()) NodeIdParts((aOther).get_NodeIdParts());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT NodeIdVariant::NodeIdVariant(NodeIdVariant&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TnsCString:
        {
            new (mozilla::KnownNotNull, ptr_nsCString()) nsCString(std::move((aOther).get_nsCString()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TNodeIdParts:
        {
            new (mozilla::KnownNotNull, ptr_NodeIdParts()) NodeIdParts(std::move((aOther).get_NodeIdParts()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

NodeIdVariant::~NodeIdVariant()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto NodeIdVariant::operator=(const nsCString& aRhs) -> NodeIdVariant&
{
    if (MaybeDestroy(TnsCString)) {
        new (mozilla::KnownNotNull, ptr_nsCString()) nsCString;
    }
    (*(ptr_nsCString())) = aRhs;
    mType = TnsCString;
    return (*(this));
}

auto NodeIdVariant::operator=(nsCString&& aRhs) -> NodeIdVariant&
{
    if (MaybeDestroy(TnsCString)) {
        new (mozilla::KnownNotNull, ptr_nsCString()) nsCString;
    }
    (*(ptr_nsCString())) = std::move(aRhs);
    mType = TnsCString;
    return (*(this));
}

auto NodeIdVariant::operator=(const NodeIdParts& aRhs) -> NodeIdVariant&
{
    if (MaybeDestroy(TNodeIdParts)) {
        new (mozilla::KnownNotNull, ptr_NodeIdParts()) NodeIdParts;
    }
    (*(ptr_NodeIdParts())) = aRhs;
    mType = TNodeIdParts;
    return (*(this));
}

auto NodeIdVariant::operator=(NodeIdParts&& aRhs) -> NodeIdVariant&
{
    if (MaybeDestroy(TNodeIdParts)) {
        new (mozilla::KnownNotNull, ptr_NodeIdParts()) NodeIdParts;
    }
    (*(ptr_NodeIdParts())) = std::move(aRhs);
    mType = TNodeIdParts;
    return (*(this));
}

auto NodeIdVariant::operator=(const NodeIdVariant& aRhs) -> NodeIdVariant&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TnsCString:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_nsCString()) nsCString;
            }
            (*(ptr_nsCString())) = (aRhs).get_nsCString();
            break;
        }
    case TNodeIdParts:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_NodeIdParts()) NodeIdParts;
            }
            (*(ptr_NodeIdParts())) = (aRhs).get_NodeIdParts();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto NodeIdVariant::operator=(NodeIdVariant&& aRhs) -> NodeIdVariant&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TnsCString:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_nsCString()) nsCString;
            }
            (*(ptr_nsCString())) = std::move((aRhs).get_nsCString());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TNodeIdParts:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_NodeIdParts()) NodeIdParts;
            }
            (*(ptr_NodeIdParts())) = std::move((aRhs).get_NodeIdParts());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace gmp
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::gmp::NodeIdVariant>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::gmp::NodeIdVariant union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'NodeIdVariant'
    (aMsg)->WriteSentinel(571933961);

    switch (type) {
    case union__::TnsCString:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_nsCString());
            // Sentinel = 'TnsCString'
            (aMsg)->WriteSentinel(353960944);
            return;
        }
    case union__::TNodeIdParts:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_NodeIdParts());
            // Sentinel = 'TNodeIdParts'
            (aMsg)->WriteSentinel(477365394);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::gmp::NodeIdVariant>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::gmp::NodeIdVariant union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union NodeIdVariant");
        return false;
    }
    // Sentinel = 'NodeIdVariant'
    if ((!((aMsg)->ReadSentinel(aIter, 571933961)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union NodeIdVariant");
        return false;
    }

    switch (type) {
    case union__::TnsCString:
        {
            nsCString tmp = nsCString();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_nsCString())))))) {
                aActor->FatalError("Error deserializing variant TnsCString of union NodeIdVariant");
                return false;
            }
            // Sentinel = 'TnsCString'
            if ((!((aMsg)->ReadSentinel(aIter, 353960944)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TnsCString of union NodeIdVariant");
                return false;
            }
            return true;
        }
    case union__::TNodeIdParts:
        {
            mozilla::gmp::NodeIdParts tmp = mozilla::gmp::NodeIdParts();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_NodeIdParts())))))) {
                aActor->FatalError("Error deserializing variant TNodeIdParts of union NodeIdVariant");
                return false;
            }
            // Sentinel = 'TNodeIdParts'
            if ((!((aMsg)->ReadSentinel(aIter, 477365394)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TNodeIdParts of union NodeIdVariant");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct GMPVideoEncodedFrameData|
//
namespace mozilla {
namespace gmp {
auto GMPVideoEncodedFrameData::StaticAssertions() const -> void
{
    static_assert(
        (offsetof(GMPVideoEncodedFrameData, mDuration_) - offsetof(GMPVideoEncodedFrameData, mTimestamp_)) == 8,
        "Bad assumptions about field layout!");
    static_assert(
        (offsetof(GMPVideoEncodedFrameData, mSize_) - offsetof(GMPVideoEncodedFrameData, mEncodedWidth_)) == 12,
        "Bad assumptions about field layout!");
}

} // namespace gmp
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::gmp::GMPVideoEncodedFrameData>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).mBufferType());
    // Sentinel = 'mBufferType'
    (aMsg)->WriteSentinel(436012138);
    WriteIPDLParam(aMsg, aActor, std::move((aVar).mBuffer()));
    // Sentinel = 'mBuffer'
    (aMsg)->WriteSentinel(182256328);
    WriteIPDLParam(aMsg, aActor, (aVar).mCompleteFrame());
    // Sentinel = 'mCompleteFrame'
    (aMsg)->WriteSentinel(699663762);
    (aMsg)->WriteBytes((&((aVar).mTimestamp())), 16);
    // Sentinel = 'mTimestamp | mDuration'
    (aMsg)->WriteSentinel(1645807761);
    (aMsg)->WriteBytes((&((aVar).mEncodedWidth())), 16);
    // Sentinel = 'mEncodedWidth | mEncodedHeight | mFrameType | mSize'
    (aMsg)->WriteSentinel(3954250446);
}

auto IPDLParamTraits<mozilla::gmp::GMPVideoEncodedFrameData>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mBufferType())))))) {
        aActor->FatalError("Error deserializing 'mBufferType' (GMPBufferType) member of 'GMPVideoEncodedFrameData'");
        return false;
    }
    // Sentinel = 'mBufferType'
    if ((!((aMsg)->ReadSentinel(aIter, 436012138)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mBufferType' (GMPBufferType) member of 'GMPVideoEncodedFrameData'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mBuffer())))))) {
        aActor->FatalError("Error deserializing 'mBuffer' (Shmem) member of 'GMPVideoEncodedFrameData'");
        return false;
    }
    // Sentinel = 'mBuffer'
    if ((!((aMsg)->ReadSentinel(aIter, 182256328)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mBuffer' (Shmem) member of 'GMPVideoEncodedFrameData'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mCompleteFrame())))))) {
        aActor->FatalError("Error deserializing 'mCompleteFrame' (bool) member of 'GMPVideoEncodedFrameData'");
        return false;
    }
    // Sentinel = 'mCompleteFrame'
    if ((!((aMsg)->ReadSentinel(aIter, 699663762)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mCompleteFrame' (bool) member of 'GMPVideoEncodedFrameData'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->mTimestamp())), 16)))) {
        aActor->FatalError("Error bulk reading fields from uint64_t");
        return false;
    }
    // Sentinel = 'mTimestamp | mDuration'
    if ((!((aMsg)->ReadSentinel(aIter, 1645807761)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint64_t");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->mEncodedWidth())), 16)))) {
        aActor->FatalError("Error bulk reading fields from uint32_t");
        return false;
    }
    // Sentinel = 'mEncodedWidth | mEncodedHeight | mFrameType | mSize'
    if ((!((aMsg)->ReadSentinel(aIter, 3954250446)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint32_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct GMPPlaneData|
//
namespace mozilla {
namespace gmp {
auto GMPPlaneData::StaticAssertions() const -> void
{
    static_assert(
        (offsetof(GMPPlaneData, mStride_) - offsetof(GMPPlaneData, mSize_)) == 4,
        "Bad assumptions about field layout!");
}

} // namespace gmp
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::gmp::GMPPlaneData>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, std::move((aVar).mBuffer()));
    // Sentinel = 'mBuffer'
    (aMsg)->WriteSentinel(182256328);
    (aMsg)->WriteBytes((&((aVar).mSize())), 8);
    // Sentinel = 'mSize | mStride'
    (aMsg)->WriteSentinel(744293789);
}

auto IPDLParamTraits<mozilla::gmp::GMPPlaneData>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mBuffer())))))) {
        aActor->FatalError("Error deserializing 'mBuffer' (Shmem) member of 'GMPPlaneData'");
        return false;
    }
    // Sentinel = 'mBuffer'
    if ((!((aMsg)->ReadSentinel(aIter, 182256328)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mBuffer' (Shmem) member of 'GMPPlaneData'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->mSize())), 8)))) {
        aActor->FatalError("Error bulk reading fields from int32_t");
        return false;
    }
    // Sentinel = 'mSize | mStride'
    if ((!((aMsg)->ReadSentinel(aIter, 744293789)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from int32_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct GMPVideoi420FrameData|
//
namespace mozilla {
namespace gmp {
auto GMPVideoi420FrameData::StaticAssertions() const -> void
{
    static_assert(
        (offsetof(GMPVideoi420FrameData, mDuration_) - offsetof(GMPVideoi420FrameData, mTimestamp_)) == 8,
        "Bad assumptions about field layout!");
    static_assert(
        (offsetof(GMPVideoi420FrameData, mHeight_) - offsetof(GMPVideoi420FrameData, mWidth_)) == 4,
        "Bad assumptions about field layout!");
}

} // namespace gmp
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::gmp::GMPVideoi420FrameData>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).mYPlane());
    // Sentinel = 'mYPlane'
    (aMsg)->WriteSentinel(180093623);
    WriteIPDLParam(aMsg, aActor, (aVar).mUPlane());
    // Sentinel = 'mUPlane'
    (aMsg)->WriteSentinel(178520755);
    WriteIPDLParam(aMsg, aActor, (aVar).mVPlane());
    // Sentinel = 'mVPlane'
    (aMsg)->WriteSentinel(178913972);
    (aMsg)->WriteBytes((&((aVar).mTimestamp())), 16);
    // Sentinel = 'mTimestamp | mDuration'
    (aMsg)->WriteSentinel(1645807761);
    (aMsg)->WriteBytes((&((aVar).mWidth())), 8);
    // Sentinel = 'mWidth | mHeight'
    (aMsg)->WriteSentinel(839910896);
}

auto IPDLParamTraits<mozilla::gmp::GMPVideoi420FrameData>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mYPlane())))))) {
        aActor->FatalError("Error deserializing 'mYPlane' (GMPPlaneData) member of 'GMPVideoi420FrameData'");
        return false;
    }
    // Sentinel = 'mYPlane'
    if ((!((aMsg)->ReadSentinel(aIter, 180093623)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mYPlane' (GMPPlaneData) member of 'GMPVideoi420FrameData'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mUPlane())))))) {
        aActor->FatalError("Error deserializing 'mUPlane' (GMPPlaneData) member of 'GMPVideoi420FrameData'");
        return false;
    }
    // Sentinel = 'mUPlane'
    if ((!((aMsg)->ReadSentinel(aIter, 178520755)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mUPlane' (GMPPlaneData) member of 'GMPVideoi420FrameData'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mVPlane())))))) {
        aActor->FatalError("Error deserializing 'mVPlane' (GMPPlaneData) member of 'GMPVideoi420FrameData'");
        return false;
    }
    // Sentinel = 'mVPlane'
    if ((!((aMsg)->ReadSentinel(aIter, 178913972)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mVPlane' (GMPPlaneData) member of 'GMPVideoi420FrameData'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->mTimestamp())), 16)))) {
        aActor->FatalError("Error bulk reading fields from uint64_t");
        return false;
    }
    // Sentinel = 'mTimestamp | mDuration'
    if ((!((aMsg)->ReadSentinel(aIter, 1645807761)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint64_t");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->mWidth())), 8)))) {
        aActor->FatalError("Error bulk reading fields from int32_t");
        return false;
    }
    // Sentinel = 'mWidth | mHeight'
    if ((!((aMsg)->ReadSentinel(aIter, 839910896)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from int32_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct CDMInputBuffer|
//
namespace mozilla {
namespace gmp {
auto CDMInputBuffer::StaticAssertions() const -> void
{
    static_assert(
        (offsetof(CDMInputBuffer, mDuration_) - offsetof(CDMInputBuffer, mTimestamp_)) == 8,
        "Bad assumptions about field layout!");
    static_assert(
        (offsetof(CDMInputBuffer, mSkipByteBlock_) - offsetof(CDMInputBuffer, mCryptByteBlock_)) == 1,
        "Bad assumptions about field layout!");
}

} // namespace gmp
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::gmp::CDMInputBuffer>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, std::move((aVar).mData()));
    // Sentinel = 'mData'
    (aMsg)->WriteSentinel(94503400);
    WriteIPDLParam(aMsg, aActor, (aVar).mKeyId());
    // Sentinel = 'mKeyId'
    (aMsg)->WriteSentinel(134218308);
    WriteIPDLParam(aMsg, aActor, (aVar).mIV());
    // Sentinel = 'mIV'
    (aMsg)->WriteSentinel(36831501);
    WriteIPDLParam(aMsg, aActor, (aVar).mClearBytes());
    // Sentinel = 'mClearBytes'
    (aMsg)->WriteSentinel(426116188);
    WriteIPDLParam(aMsg, aActor, (aVar).mCipherBytes());
    // Sentinel = 'mCipherBytes'
    (aMsg)->WriteSentinel(512296144);
    WriteIPDLParam(aMsg, aActor, (aVar).mEncryptionScheme());
    // Sentinel = 'mEncryptionScheme'
    (aMsg)->WriteSentinel(1046611694);
    (aMsg)->WriteBytes((&((aVar).mTimestamp())), 16);
    // Sentinel = 'mTimestamp | mDuration'
    (aMsg)->WriteSentinel(1645807761);
    (aMsg)->WriteBytes((&((aVar).mCryptByteBlock())), 2);
    // Sentinel = 'mCryptByteBlock | mSkipByteBlock'
    (aMsg)->WriteSentinel(3404008510);
}

auto IPDLParamTraits<mozilla::gmp::CDMInputBuffer>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mData())))))) {
        aActor->FatalError("Error deserializing 'mData' (Shmem) member of 'CDMInputBuffer'");
        return false;
    }
    // Sentinel = 'mData'
    if ((!((aMsg)->ReadSentinel(aIter, 94503400)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mData' (Shmem) member of 'CDMInputBuffer'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mKeyId())))))) {
        aActor->FatalError("Error deserializing 'mKeyId' (uint8_t[]) member of 'CDMInputBuffer'");
        return false;
    }
    // Sentinel = 'mKeyId'
    if ((!((aMsg)->ReadSentinel(aIter, 134218308)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mKeyId' (uint8_t[]) member of 'CDMInputBuffer'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mIV())))))) {
        aActor->FatalError("Error deserializing 'mIV' (uint8_t[]) member of 'CDMInputBuffer'");
        return false;
    }
    // Sentinel = 'mIV'
    if ((!((aMsg)->ReadSentinel(aIter, 36831501)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mIV' (uint8_t[]) member of 'CDMInputBuffer'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mClearBytes())))))) {
        aActor->FatalError("Error deserializing 'mClearBytes' (uint32_t[]) member of 'CDMInputBuffer'");
        return false;
    }
    // Sentinel = 'mClearBytes'
    if ((!((aMsg)->ReadSentinel(aIter, 426116188)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mClearBytes' (uint32_t[]) member of 'CDMInputBuffer'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mCipherBytes())))))) {
        aActor->FatalError("Error deserializing 'mCipherBytes' (uint32_t[]) member of 'CDMInputBuffer'");
        return false;
    }
    // Sentinel = 'mCipherBytes'
    if ((!((aMsg)->ReadSentinel(aIter, 512296144)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mCipherBytes' (uint32_t[]) member of 'CDMInputBuffer'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mEncryptionScheme())))))) {
        aActor->FatalError("Error deserializing 'mEncryptionScheme' (EncryptionScheme) member of 'CDMInputBuffer'");
        return false;
    }
    // Sentinel = 'mEncryptionScheme'
    if ((!((aMsg)->ReadSentinel(aIter, 1046611694)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mEncryptionScheme' (EncryptionScheme) member of 'CDMInputBuffer'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->mTimestamp())), 16)))) {
        aActor->FatalError("Error bulk reading fields from int64_t");
        return false;
    }
    // Sentinel = 'mTimestamp | mDuration'
    if ((!((aMsg)->ReadSentinel(aIter, 1645807761)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from int64_t");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->mCryptByteBlock())), 2)))) {
        aActor->FatalError("Error bulk reading fields from uint8_t");
        return false;
    }
    // Sentinel = 'mCryptByteBlock | mSkipByteBlock'
    if ((!((aMsg)->ReadSentinel(aIter, 3404008510)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint8_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct CDMVideoDecoderConfig|
//
namespace mozilla {
namespace gmp {
auto CDMVideoDecoderConfig::StaticAssertions() const -> void
{
    static_assert(
        (offsetof(CDMVideoDecoderConfig, mImageHeight_) - offsetof(CDMVideoDecoderConfig, mCodec_)) == 16,
        "Bad assumptions about field layout!");
}

} // namespace gmp
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::gmp::CDMVideoDecoderConfig>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).mExtraData());
    // Sentinel = 'mExtraData'
    (aMsg)->WriteSentinel(363987948);
    WriteIPDLParam(aMsg, aActor, (aVar).mEncryptionScheme());
    // Sentinel = 'mEncryptionScheme'
    (aMsg)->WriteSentinel(1046611694);
    (aMsg)->WriteBytes((&((aVar).mCodec())), 20);
    // Sentinel = 'mCodec | mProfile | mFormat | mImageWidth | mImageHeight'
    (aMsg)->WriteSentinel(1001067593);
}

auto IPDLParamTraits<mozilla::gmp::CDMVideoDecoderConfig>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mExtraData())))))) {
        aActor->FatalError("Error deserializing 'mExtraData' (uint8_t[]) member of 'CDMVideoDecoderConfig'");
        return false;
    }
    // Sentinel = 'mExtraData'
    if ((!((aMsg)->ReadSentinel(aIter, 363987948)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mExtraData' (uint8_t[]) member of 'CDMVideoDecoderConfig'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mEncryptionScheme())))))) {
        aActor->FatalError("Error deserializing 'mEncryptionScheme' (EncryptionScheme) member of 'CDMVideoDecoderConfig'");
        return false;
    }
    // Sentinel = 'mEncryptionScheme'
    if ((!((aMsg)->ReadSentinel(aIter, 1046611694)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mEncryptionScheme' (EncryptionScheme) member of 'CDMVideoDecoderConfig'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->mCodec())), 20)))) {
        aActor->FatalError("Error bulk reading fields from uint32_t");
        return false;
    }
    // Sentinel = 'mCodec | mProfile | mFormat | mImageWidth | mImageHeight'
    if ((!((aMsg)->ReadSentinel(aIter, 1001067593)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint32_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct CDMKeyInformation|
//
namespace mozilla {
namespace gmp {
auto CDMKeyInformation::StaticAssertions() const -> void
{
    static_assert(
        (offsetof(CDMKeyInformation, mSystemCode_) - offsetof(CDMKeyInformation, mStatus_)) == 4,
        "Bad assumptions about field layout!");
}

} // namespace gmp
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::gmp::CDMKeyInformation>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).mKeyId());
    // Sentinel = 'mKeyId'
    (aMsg)->WriteSentinel(134218308);
    (aMsg)->WriteBytes((&((aVar).mStatus())), 8);
    // Sentinel = 'mStatus | mSystemCode'
    (aMsg)->WriteSentinel(1496582171);
}

auto IPDLParamTraits<mozilla::gmp::CDMKeyInformation>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mKeyId())))))) {
        aActor->FatalError("Error deserializing 'mKeyId' (uint8_t[]) member of 'CDMKeyInformation'");
        return false;
    }
    // Sentinel = 'mKeyId'
    if ((!((aMsg)->ReadSentinel(aIter, 134218308)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mKeyId' (uint8_t[]) member of 'CDMKeyInformation'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->mStatus())), 8)))) {
        aActor->FatalError("Error bulk reading fields from uint32_t");
        return false;
    }
    // Sentinel = 'mStatus | mSystemCode'
    if ((!((aMsg)->ReadSentinel(aIter, 1496582171)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint32_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct CDMVideoPlane|
//
namespace mozilla {
namespace gmp {
auto CDMVideoPlane::StaticAssertions() const -> void
{
    static_assert(
        (offsetof(CDMVideoPlane, mStride_) - offsetof(CDMVideoPlane, mPlaneOffset_)) == 4,
        "Bad assumptions about field layout!");
}

} // namespace gmp
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::gmp::CDMVideoPlane>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    (aMsg)->WriteBytes((&((aVar).mPlaneOffset())), 8);
    // Sentinel = 'mPlaneOffset | mStride'
    (aMsg)->WriteSentinel(1612843097);
}

auto IPDLParamTraits<mozilla::gmp::CDMVideoPlane>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->mPlaneOffset())), 8)))) {
        aActor->FatalError("Error bulk reading fields from uint32_t");
        return false;
    }
    // Sentinel = 'mPlaneOffset | mStride'
    if ((!((aMsg)->ReadSentinel(aIter, 1612843097)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint32_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct CDMVideoFrame|
//
namespace mozilla {
namespace gmp {
auto CDMVideoFrame::StaticAssertions() const -> void
{
    static_assert(
        (offsetof(CDMVideoFrame, mDuration_) - offsetof(CDMVideoFrame, mTimestamp_)) == 8,
        "Bad assumptions about field layout!");
    static_assert(
        (offsetof(CDMVideoFrame, mImageHeight_) - offsetof(CDMVideoFrame, mFormat_)) == 8,
        "Bad assumptions about field layout!");
}

} // namespace gmp
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::gmp::CDMVideoFrame>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).mYPlane());
    // Sentinel = 'mYPlane'
    (aMsg)->WriteSentinel(180093623);
    WriteIPDLParam(aMsg, aActor, (aVar).mUPlane());
    // Sentinel = 'mUPlane'
    (aMsg)->WriteSentinel(178520755);
    WriteIPDLParam(aMsg, aActor, (aVar).mVPlane());
    // Sentinel = 'mVPlane'
    (aMsg)->WriteSentinel(178913972);
    (aMsg)->WriteBytes((&((aVar).mTimestamp())), 16);
    // Sentinel = 'mTimestamp | mDuration'
    (aMsg)->WriteSentinel(1645807761);
    (aMsg)->WriteBytes((&((aVar).mFormat())), 12);
    // Sentinel = 'mFormat | mImageWidth | mImageHeight'
    (aMsg)->WriteSentinel(4094430536);
}

auto IPDLParamTraits<mozilla::gmp::CDMVideoFrame>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mYPlane())))))) {
        aActor->FatalError("Error deserializing 'mYPlane' (CDMVideoPlane) member of 'CDMVideoFrame'");
        return false;
    }
    // Sentinel = 'mYPlane'
    if ((!((aMsg)->ReadSentinel(aIter, 180093623)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mYPlane' (CDMVideoPlane) member of 'CDMVideoFrame'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mUPlane())))))) {
        aActor->FatalError("Error deserializing 'mUPlane' (CDMVideoPlane) member of 'CDMVideoFrame'");
        return false;
    }
    // Sentinel = 'mUPlane'
    if ((!((aMsg)->ReadSentinel(aIter, 178520755)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mUPlane' (CDMVideoPlane) member of 'CDMVideoFrame'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mVPlane())))))) {
        aActor->FatalError("Error deserializing 'mVPlane' (CDMVideoPlane) member of 'CDMVideoFrame'");
        return false;
    }
    // Sentinel = 'mVPlane'
    if ((!((aMsg)->ReadSentinel(aIter, 178913972)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mVPlane' (CDMVideoPlane) member of 'CDMVideoFrame'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->mTimestamp())), 16)))) {
        aActor->FatalError("Error bulk reading fields from int64_t");
        return false;
    }
    // Sentinel = 'mTimestamp | mDuration'
    if ((!((aMsg)->ReadSentinel(aIter, 1645807761)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from int64_t");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->mFormat())), 12)))) {
        aActor->FatalError("Error bulk reading fields from uint32_t");
        return false;
    }
    // Sentinel = 'mFormat | mImageWidth | mImageHeight'
    if ((!((aMsg)->ReadSentinel(aIter, 4094430536)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint32_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla
