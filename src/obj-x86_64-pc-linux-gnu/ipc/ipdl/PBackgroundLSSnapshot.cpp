//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/localstorage/SerializationHelpers.h"
#include "mozilla/ipc/PBackgroundParent.h"
#include "mozilla/ipc/PBackgroundChild.h"
#include "mozilla/dom/PBackgroundLSDatabaseParent.h"
#include "mozilla/dom/PBackgroundLSDatabaseChild.h"
#include "mozilla/dom/PBackgroundLSSnapshot.h"
#include "mozilla/dom/PBackgroundLSSnapshotParent.h"
#include "mozilla/dom/PBackgroundLSSnapshotChild.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace dom {
namespace PBackgroundLSSnapshot {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::dom::PBackgroundLSSnapshotParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::dom::PBackgroundLSSnapshotChild>* aChild)
{
    return mozilla::ipc::CreateEndpoints(
        mozilla::ipc::PrivateIPDLInterface(),
        aParentDestPid, aChildDestPid,
        aParent, aChild);
}
IPC::Message*
Msg_DeleteMe(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_DeleteMe__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_Checkpoint(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Checkpoint__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_CheckpointAndNotify(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_CheckpointAndNotify__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_Finish(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Finish__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_Loaded(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Loaded__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_LoadValueAndMoreItems(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_LoadValueAndMoreItems__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply_LoadValueAndMoreItems(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply_LoadValueAndMoreItems__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg_LoadKeys(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_LoadKeys__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply_LoadKeys(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply_LoadKeys__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg_IncreasePeakUsage(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_IncreasePeakUsage__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply_IncreasePeakUsage(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply_IncreasePeakUsage__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg_Ping(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Ping__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply_Ping(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply_Ping__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg_MarkDirty(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_MarkDirty__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg___delete__(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg___delete____ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply___delete__(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply___delete____ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}

} // namespace PBackgroundLSSnapshot
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct LSSetItemInfo|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::LSSetItemInfo>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).key());
    // Sentinel = 'key'
    (aMsg)->WriteSentinel(42402122);
    WriteIPDLParam(aMsg, aActor, (aVar).value());
    // Sentinel = 'value'
    (aMsg)->WriteSentinel(107610654);
}

auto IPDLParamTraits<mozilla::dom::LSSetItemInfo>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->key())))))) {
        aActor->FatalError("Error deserializing 'key' (nsString) member of 'LSSetItemInfo'");
        return false;
    }
    // Sentinel = 'key'
    if ((!((aMsg)->ReadSentinel(aIter, 42402122)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'key' (nsString) member of 'LSSetItemInfo'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->value())))))) {
        aActor->FatalError("Error deserializing 'value' (LSValue) member of 'LSSetItemInfo'");
        return false;
    }
    // Sentinel = 'value'
    if ((!((aMsg)->ReadSentinel(aIter, 107610654)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'value' (LSValue) member of 'LSSetItemInfo'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct LSRemoveItemInfo|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::LSRemoveItemInfo>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).key());
    // Sentinel = 'key'
    (aMsg)->WriteSentinel(42402122);
}

auto IPDLParamTraits<mozilla::dom::LSRemoveItemInfo>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->key())))))) {
        aActor->FatalError("Error deserializing 'key' (nsString) member of 'LSRemoveItemInfo'");
        return false;
    }
    // Sentinel = 'key'
    if ((!((aMsg)->ReadSentinel(aIter, 42402122)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'key' (nsString) member of 'LSRemoveItemInfo'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct LSClearInfo|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::LSClearInfo>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
}

auto IPDLParamTraits<mozilla::dom::LSClearInfo>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union LSWriteInfo|
//
namespace mozilla {
namespace dom {
auto LSWriteInfo::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TLSSetItemInfo:
        {
            (ptr_LSSetItemInfo())->~LSSetItemInfo__tdef();
            break;
        }
    case TLSRemoveItemInfo:
        {
            (ptr_LSRemoveItemInfo())->~LSRemoveItemInfo__tdef();
            break;
        }
    case TLSClearInfo:
        {
            (ptr_LSClearInfo())->~LSClearInfo__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT LSWriteInfo::LSWriteInfo(const LSSetItemInfo& aOther)
{
    new (mozilla::KnownNotNull, ptr_LSSetItemInfo()) LSSetItemInfo(aOther);
    mType = TLSSetItemInfo;
}

MOZ_IMPLICIT LSWriteInfo::LSWriteInfo(LSSetItemInfo&& aOther)
{
    new (mozilla::KnownNotNull, ptr_LSSetItemInfo()) LSSetItemInfo(std::move(aOther));
    mType = TLSSetItemInfo;
}

MOZ_IMPLICIT LSWriteInfo::LSWriteInfo(const LSRemoveItemInfo& aOther)
{
    new (mozilla::KnownNotNull, ptr_LSRemoveItemInfo()) LSRemoveItemInfo(aOther);
    mType = TLSRemoveItemInfo;
}

MOZ_IMPLICIT LSWriteInfo::LSWriteInfo(LSRemoveItemInfo&& aOther)
{
    new (mozilla::KnownNotNull, ptr_LSRemoveItemInfo()) LSRemoveItemInfo(std::move(aOther));
    mType = TLSRemoveItemInfo;
}

MOZ_IMPLICIT LSWriteInfo::LSWriteInfo(const LSClearInfo& aOther)
{
    new (mozilla::KnownNotNull, ptr_LSClearInfo()) LSClearInfo(aOther);
    mType = TLSClearInfo;
}

MOZ_IMPLICIT LSWriteInfo::LSWriteInfo(LSClearInfo&& aOther)
{
    new (mozilla::KnownNotNull, ptr_LSClearInfo()) LSClearInfo(std::move(aOther));
    mType = TLSClearInfo;
}

MOZ_IMPLICIT LSWriteInfo::LSWriteInfo(const LSWriteInfo& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TLSSetItemInfo:
        {
            new (mozilla::KnownNotNull, ptr_LSSetItemInfo()) LSSetItemInfo((aOther).get_LSSetItemInfo());
            break;
        }
    case TLSRemoveItemInfo:
        {
            new (mozilla::KnownNotNull, ptr_LSRemoveItemInfo()) LSRemoveItemInfo((aOther).get_LSRemoveItemInfo());
            break;
        }
    case TLSClearInfo:
        {
            new (mozilla::KnownNotNull, ptr_LSClearInfo()) LSClearInfo((aOther).get_LSClearInfo());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT LSWriteInfo::LSWriteInfo(LSWriteInfo&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TLSSetItemInfo:
        {
            new (mozilla::KnownNotNull, ptr_LSSetItemInfo()) LSSetItemInfo(std::move((aOther).get_LSSetItemInfo()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TLSRemoveItemInfo:
        {
            new (mozilla::KnownNotNull, ptr_LSRemoveItemInfo()) LSRemoveItemInfo(std::move((aOther).get_LSRemoveItemInfo()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TLSClearInfo:
        {
            new (mozilla::KnownNotNull, ptr_LSClearInfo()) LSClearInfo(std::move((aOther).get_LSClearInfo()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

LSWriteInfo::~LSWriteInfo()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto LSWriteInfo::operator=(const LSSetItemInfo& aRhs) -> LSWriteInfo&
{
    if (MaybeDestroy(TLSSetItemInfo)) {
        new (mozilla::KnownNotNull, ptr_LSSetItemInfo()) LSSetItemInfo;
    }
    (*(ptr_LSSetItemInfo())) = aRhs;
    mType = TLSSetItemInfo;
    return (*(this));
}

auto LSWriteInfo::operator=(LSSetItemInfo&& aRhs) -> LSWriteInfo&
{
    if (MaybeDestroy(TLSSetItemInfo)) {
        new (mozilla::KnownNotNull, ptr_LSSetItemInfo()) LSSetItemInfo;
    }
    (*(ptr_LSSetItemInfo())) = std::move(aRhs);
    mType = TLSSetItemInfo;
    return (*(this));
}

auto LSWriteInfo::operator=(const LSRemoveItemInfo& aRhs) -> LSWriteInfo&
{
    if (MaybeDestroy(TLSRemoveItemInfo)) {
        new (mozilla::KnownNotNull, ptr_LSRemoveItemInfo()) LSRemoveItemInfo;
    }
    (*(ptr_LSRemoveItemInfo())) = aRhs;
    mType = TLSRemoveItemInfo;
    return (*(this));
}

auto LSWriteInfo::operator=(LSRemoveItemInfo&& aRhs) -> LSWriteInfo&
{
    if (MaybeDestroy(TLSRemoveItemInfo)) {
        new (mozilla::KnownNotNull, ptr_LSRemoveItemInfo()) LSRemoveItemInfo;
    }
    (*(ptr_LSRemoveItemInfo())) = std::move(aRhs);
    mType = TLSRemoveItemInfo;
    return (*(this));
}

auto LSWriteInfo::operator=(const LSClearInfo& aRhs) -> LSWriteInfo&
{
    if (MaybeDestroy(TLSClearInfo)) {
        new (mozilla::KnownNotNull, ptr_LSClearInfo()) LSClearInfo;
    }
    (*(ptr_LSClearInfo())) = aRhs;
    mType = TLSClearInfo;
    return (*(this));
}

auto LSWriteInfo::operator=(LSClearInfo&& aRhs) -> LSWriteInfo&
{
    if (MaybeDestroy(TLSClearInfo)) {
        new (mozilla::KnownNotNull, ptr_LSClearInfo()) LSClearInfo;
    }
    (*(ptr_LSClearInfo())) = std::move(aRhs);
    mType = TLSClearInfo;
    return (*(this));
}

auto LSWriteInfo::operator=(const LSWriteInfo& aRhs) -> LSWriteInfo&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TLSSetItemInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_LSSetItemInfo()) LSSetItemInfo;
            }
            (*(ptr_LSSetItemInfo())) = (aRhs).get_LSSetItemInfo();
            break;
        }
    case TLSRemoveItemInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_LSRemoveItemInfo()) LSRemoveItemInfo;
            }
            (*(ptr_LSRemoveItemInfo())) = (aRhs).get_LSRemoveItemInfo();
            break;
        }
    case TLSClearInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_LSClearInfo()) LSClearInfo;
            }
            (*(ptr_LSClearInfo())) = (aRhs).get_LSClearInfo();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto LSWriteInfo::operator=(LSWriteInfo&& aRhs) -> LSWriteInfo&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TLSSetItemInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_LSSetItemInfo()) LSSetItemInfo;
            }
            (*(ptr_LSSetItemInfo())) = std::move((aRhs).get_LSSetItemInfo());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TLSRemoveItemInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_LSRemoveItemInfo()) LSRemoveItemInfo;
            }
            (*(ptr_LSRemoveItemInfo())) = std::move((aRhs).get_LSRemoveItemInfo());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TLSClearInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_LSClearInfo()) LSClearInfo;
            }
            (*(ptr_LSClearInfo())) = std::move((aRhs).get_LSClearInfo());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::LSWriteInfo>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::dom::LSWriteInfo union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'LSWriteInfo'
    (aMsg)->WriteSentinel(409273399);

    switch (type) {
    case union__::TLSSetItemInfo:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_LSSetItemInfo());
            // Sentinel = 'TLSSetItemInfo'
            (aMsg)->WriteSentinel(630785339);
            return;
        }
    case union__::TLSRemoveItemInfo:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_LSRemoveItemInfo());
            // Sentinel = 'TLSRemoveItemInfo'
            (aMsg)->WriteSentinel(948242045);
            return;
        }
    case union__::TLSClearInfo:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_LSClearInfo());
            // Sentinel = 'TLSClearInfo'
            (aMsg)->WriteSentinel(455410791);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::dom::LSWriteInfo>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::dom::LSWriteInfo union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union LSWriteInfo");
        return false;
    }
    // Sentinel = 'LSWriteInfo'
    if ((!((aMsg)->ReadSentinel(aIter, 409273399)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union LSWriteInfo");
        return false;
    }

    switch (type) {
    case union__::TLSSetItemInfo:
        {
            mozilla::dom::LSSetItemInfo tmp = mozilla::dom::LSSetItemInfo();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_LSSetItemInfo())))))) {
                aActor->FatalError("Error deserializing variant TLSSetItemInfo of union LSWriteInfo");
                return false;
            }
            // Sentinel = 'TLSSetItemInfo'
            if ((!((aMsg)->ReadSentinel(aIter, 630785339)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TLSSetItemInfo of union LSWriteInfo");
                return false;
            }
            return true;
        }
    case union__::TLSRemoveItemInfo:
        {
            mozilla::dom::LSRemoveItemInfo tmp = mozilla::dom::LSRemoveItemInfo();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_LSRemoveItemInfo())))))) {
                aActor->FatalError("Error deserializing variant TLSRemoveItemInfo of union LSWriteInfo");
                return false;
            }
            // Sentinel = 'TLSRemoveItemInfo'
            if ((!((aMsg)->ReadSentinel(aIter, 948242045)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TLSRemoveItemInfo of union LSWriteInfo");
                return false;
            }
            return true;
        }
    case union__::TLSClearInfo:
        {
            mozilla::dom::LSClearInfo tmp = mozilla::dom::LSClearInfo();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_LSClearInfo())))))) {
                aActor->FatalError("Error deserializing variant TLSClearInfo of union LSWriteInfo");
                return false;
            }
            // Sentinel = 'TLSClearInfo'
            if ((!((aMsg)->ReadSentinel(aIter, 455410791)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TLSClearInfo of union LSWriteInfo");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct LSSetItemAndNotifyInfo|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::LSSetItemAndNotifyInfo>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).key());
    // Sentinel = 'key'
    (aMsg)->WriteSentinel(42402122);
    WriteIPDLParam(aMsg, aActor, (aVar).oldValue());
    // Sentinel = 'oldValue'
    (aMsg)->WriteSentinel(244384573);
    WriteIPDLParam(aMsg, aActor, (aVar).value());
    // Sentinel = 'value'
    (aMsg)->WriteSentinel(107610654);
}

auto IPDLParamTraits<mozilla::dom::LSSetItemAndNotifyInfo>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->key())))))) {
        aActor->FatalError("Error deserializing 'key' (nsString) member of 'LSSetItemAndNotifyInfo'");
        return false;
    }
    // Sentinel = 'key'
    if ((!((aMsg)->ReadSentinel(aIter, 42402122)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'key' (nsString) member of 'LSSetItemAndNotifyInfo'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->oldValue())))))) {
        aActor->FatalError("Error deserializing 'oldValue' (LSValue) member of 'LSSetItemAndNotifyInfo'");
        return false;
    }
    // Sentinel = 'oldValue'
    if ((!((aMsg)->ReadSentinel(aIter, 244384573)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'oldValue' (LSValue) member of 'LSSetItemAndNotifyInfo'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->value())))))) {
        aActor->FatalError("Error deserializing 'value' (LSValue) member of 'LSSetItemAndNotifyInfo'");
        return false;
    }
    // Sentinel = 'value'
    if ((!((aMsg)->ReadSentinel(aIter, 107610654)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'value' (LSValue) member of 'LSSetItemAndNotifyInfo'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct LSRemoveItemAndNotifyInfo|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::LSRemoveItemAndNotifyInfo>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).key());
    // Sentinel = 'key'
    (aMsg)->WriteSentinel(42402122);
    WriteIPDLParam(aMsg, aActor, (aVar).oldValue());
    // Sentinel = 'oldValue'
    (aMsg)->WriteSentinel(244384573);
}

auto IPDLParamTraits<mozilla::dom::LSRemoveItemAndNotifyInfo>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->key())))))) {
        aActor->FatalError("Error deserializing 'key' (nsString) member of 'LSRemoveItemAndNotifyInfo'");
        return false;
    }
    // Sentinel = 'key'
    if ((!((aMsg)->ReadSentinel(aIter, 42402122)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'key' (nsString) member of 'LSRemoveItemAndNotifyInfo'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->oldValue())))))) {
        aActor->FatalError("Error deserializing 'oldValue' (LSValue) member of 'LSRemoveItemAndNotifyInfo'");
        return false;
    }
    // Sentinel = 'oldValue'
    if ((!((aMsg)->ReadSentinel(aIter, 244384573)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'oldValue' (LSValue) member of 'LSRemoveItemAndNotifyInfo'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union LSWriteAndNotifyInfo|
//
namespace mozilla {
namespace dom {
auto LSWriteAndNotifyInfo::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TLSSetItemAndNotifyInfo:
        {
            (ptr_LSSetItemAndNotifyInfo())->~LSSetItemAndNotifyInfo__tdef();
            break;
        }
    case TLSRemoveItemAndNotifyInfo:
        {
            (ptr_LSRemoveItemAndNotifyInfo())->~LSRemoveItemAndNotifyInfo__tdef();
            break;
        }
    case TLSClearInfo:
        {
            (ptr_LSClearInfo())->~LSClearInfo__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT LSWriteAndNotifyInfo::LSWriteAndNotifyInfo(const LSSetItemAndNotifyInfo& aOther)
{
    new (mozilla::KnownNotNull, ptr_LSSetItemAndNotifyInfo()) LSSetItemAndNotifyInfo(aOther);
    mType = TLSSetItemAndNotifyInfo;
}

MOZ_IMPLICIT LSWriteAndNotifyInfo::LSWriteAndNotifyInfo(LSSetItemAndNotifyInfo&& aOther)
{
    new (mozilla::KnownNotNull, ptr_LSSetItemAndNotifyInfo()) LSSetItemAndNotifyInfo(std::move(aOther));
    mType = TLSSetItemAndNotifyInfo;
}

MOZ_IMPLICIT LSWriteAndNotifyInfo::LSWriteAndNotifyInfo(const LSRemoveItemAndNotifyInfo& aOther)
{
    new (mozilla::KnownNotNull, ptr_LSRemoveItemAndNotifyInfo()) LSRemoveItemAndNotifyInfo(aOther);
    mType = TLSRemoveItemAndNotifyInfo;
}

MOZ_IMPLICIT LSWriteAndNotifyInfo::LSWriteAndNotifyInfo(LSRemoveItemAndNotifyInfo&& aOther)
{
    new (mozilla::KnownNotNull, ptr_LSRemoveItemAndNotifyInfo()) LSRemoveItemAndNotifyInfo(std::move(aOther));
    mType = TLSRemoveItemAndNotifyInfo;
}

MOZ_IMPLICIT LSWriteAndNotifyInfo::LSWriteAndNotifyInfo(const LSClearInfo& aOther)
{
    new (mozilla::KnownNotNull, ptr_LSClearInfo()) LSClearInfo(aOther);
    mType = TLSClearInfo;
}

MOZ_IMPLICIT LSWriteAndNotifyInfo::LSWriteAndNotifyInfo(LSClearInfo&& aOther)
{
    new (mozilla::KnownNotNull, ptr_LSClearInfo()) LSClearInfo(std::move(aOther));
    mType = TLSClearInfo;
}

MOZ_IMPLICIT LSWriteAndNotifyInfo::LSWriteAndNotifyInfo(const LSWriteAndNotifyInfo& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TLSSetItemAndNotifyInfo:
        {
            new (mozilla::KnownNotNull, ptr_LSSetItemAndNotifyInfo()) LSSetItemAndNotifyInfo((aOther).get_LSSetItemAndNotifyInfo());
            break;
        }
    case TLSRemoveItemAndNotifyInfo:
        {
            new (mozilla::KnownNotNull, ptr_LSRemoveItemAndNotifyInfo()) LSRemoveItemAndNotifyInfo((aOther).get_LSRemoveItemAndNotifyInfo());
            break;
        }
    case TLSClearInfo:
        {
            new (mozilla::KnownNotNull, ptr_LSClearInfo()) LSClearInfo((aOther).get_LSClearInfo());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT LSWriteAndNotifyInfo::LSWriteAndNotifyInfo(LSWriteAndNotifyInfo&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TLSSetItemAndNotifyInfo:
        {
            new (mozilla::KnownNotNull, ptr_LSSetItemAndNotifyInfo()) LSSetItemAndNotifyInfo(std::move((aOther).get_LSSetItemAndNotifyInfo()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TLSRemoveItemAndNotifyInfo:
        {
            new (mozilla::KnownNotNull, ptr_LSRemoveItemAndNotifyInfo()) LSRemoveItemAndNotifyInfo(std::move((aOther).get_LSRemoveItemAndNotifyInfo()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TLSClearInfo:
        {
            new (mozilla::KnownNotNull, ptr_LSClearInfo()) LSClearInfo(std::move((aOther).get_LSClearInfo()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

LSWriteAndNotifyInfo::~LSWriteAndNotifyInfo()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto LSWriteAndNotifyInfo::operator=(const LSSetItemAndNotifyInfo& aRhs) -> LSWriteAndNotifyInfo&
{
    if (MaybeDestroy(TLSSetItemAndNotifyInfo)) {
        new (mozilla::KnownNotNull, ptr_LSSetItemAndNotifyInfo()) LSSetItemAndNotifyInfo;
    }
    (*(ptr_LSSetItemAndNotifyInfo())) = aRhs;
    mType = TLSSetItemAndNotifyInfo;
    return (*(this));
}

auto LSWriteAndNotifyInfo::operator=(LSSetItemAndNotifyInfo&& aRhs) -> LSWriteAndNotifyInfo&
{
    if (MaybeDestroy(TLSSetItemAndNotifyInfo)) {
        new (mozilla::KnownNotNull, ptr_LSSetItemAndNotifyInfo()) LSSetItemAndNotifyInfo;
    }
    (*(ptr_LSSetItemAndNotifyInfo())) = std::move(aRhs);
    mType = TLSSetItemAndNotifyInfo;
    return (*(this));
}

auto LSWriteAndNotifyInfo::operator=(const LSRemoveItemAndNotifyInfo& aRhs) -> LSWriteAndNotifyInfo&
{
    if (MaybeDestroy(TLSRemoveItemAndNotifyInfo)) {
        new (mozilla::KnownNotNull, ptr_LSRemoveItemAndNotifyInfo()) LSRemoveItemAndNotifyInfo;
    }
    (*(ptr_LSRemoveItemAndNotifyInfo())) = aRhs;
    mType = TLSRemoveItemAndNotifyInfo;
    return (*(this));
}

auto LSWriteAndNotifyInfo::operator=(LSRemoveItemAndNotifyInfo&& aRhs) -> LSWriteAndNotifyInfo&
{
    if (MaybeDestroy(TLSRemoveItemAndNotifyInfo)) {
        new (mozilla::KnownNotNull, ptr_LSRemoveItemAndNotifyInfo()) LSRemoveItemAndNotifyInfo;
    }
    (*(ptr_LSRemoveItemAndNotifyInfo())) = std::move(aRhs);
    mType = TLSRemoveItemAndNotifyInfo;
    return (*(this));
}

auto LSWriteAndNotifyInfo::operator=(const LSClearInfo& aRhs) -> LSWriteAndNotifyInfo&
{
    if (MaybeDestroy(TLSClearInfo)) {
        new (mozilla::KnownNotNull, ptr_LSClearInfo()) LSClearInfo;
    }
    (*(ptr_LSClearInfo())) = aRhs;
    mType = TLSClearInfo;
    return (*(this));
}

auto LSWriteAndNotifyInfo::operator=(LSClearInfo&& aRhs) -> LSWriteAndNotifyInfo&
{
    if (MaybeDestroy(TLSClearInfo)) {
        new (mozilla::KnownNotNull, ptr_LSClearInfo()) LSClearInfo;
    }
    (*(ptr_LSClearInfo())) = std::move(aRhs);
    mType = TLSClearInfo;
    return (*(this));
}

auto LSWriteAndNotifyInfo::operator=(const LSWriteAndNotifyInfo& aRhs) -> LSWriteAndNotifyInfo&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TLSSetItemAndNotifyInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_LSSetItemAndNotifyInfo()) LSSetItemAndNotifyInfo;
            }
            (*(ptr_LSSetItemAndNotifyInfo())) = (aRhs).get_LSSetItemAndNotifyInfo();
            break;
        }
    case TLSRemoveItemAndNotifyInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_LSRemoveItemAndNotifyInfo()) LSRemoveItemAndNotifyInfo;
            }
            (*(ptr_LSRemoveItemAndNotifyInfo())) = (aRhs).get_LSRemoveItemAndNotifyInfo();
            break;
        }
    case TLSClearInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_LSClearInfo()) LSClearInfo;
            }
            (*(ptr_LSClearInfo())) = (aRhs).get_LSClearInfo();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto LSWriteAndNotifyInfo::operator=(LSWriteAndNotifyInfo&& aRhs) -> LSWriteAndNotifyInfo&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TLSSetItemAndNotifyInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_LSSetItemAndNotifyInfo()) LSSetItemAndNotifyInfo;
            }
            (*(ptr_LSSetItemAndNotifyInfo())) = std::move((aRhs).get_LSSetItemAndNotifyInfo());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TLSRemoveItemAndNotifyInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_LSRemoveItemAndNotifyInfo()) LSRemoveItemAndNotifyInfo;
            }
            (*(ptr_LSRemoveItemAndNotifyInfo())) = std::move((aRhs).get_LSRemoveItemAndNotifyInfo());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TLSClearInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_LSClearInfo()) LSClearInfo;
            }
            (*(ptr_LSClearInfo())) = std::move((aRhs).get_LSClearInfo());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::LSWriteAndNotifyInfo>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::dom::LSWriteAndNotifyInfo union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'LSWriteAndNotifyInfo'
    (aMsg)->WriteSentinel(1331431363);

    switch (type) {
    case union__::TLSSetItemAndNotifyInfo:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_LSSetItemAndNotifyInfo());
            // Sentinel = 'TLSSetItemAndNotifyInfo'
            (aMsg)->WriteSentinel(1706297543);
            return;
        }
    case union__::TLSRemoveItemAndNotifyInfo:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_LSRemoveItemAndNotifyInfo());
            // Sentinel = 'TLSRemoveItemAndNotifyInfo'
            (aMsg)->WriteSentinel(2213677577);
            return;
        }
    case union__::TLSClearInfo:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_LSClearInfo());
            // Sentinel = 'TLSClearInfo'
            (aMsg)->WriteSentinel(455410791);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::dom::LSWriteAndNotifyInfo>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::dom::LSWriteAndNotifyInfo union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union LSWriteAndNotifyInfo");
        return false;
    }
    // Sentinel = 'LSWriteAndNotifyInfo'
    if ((!((aMsg)->ReadSentinel(aIter, 1331431363)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union LSWriteAndNotifyInfo");
        return false;
    }

    switch (type) {
    case union__::TLSSetItemAndNotifyInfo:
        {
            mozilla::dom::LSSetItemAndNotifyInfo tmp = mozilla::dom::LSSetItemAndNotifyInfo();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_LSSetItemAndNotifyInfo())))))) {
                aActor->FatalError("Error deserializing variant TLSSetItemAndNotifyInfo of union LSWriteAndNotifyInfo");
                return false;
            }
            // Sentinel = 'TLSSetItemAndNotifyInfo'
            if ((!((aMsg)->ReadSentinel(aIter, 1706297543)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TLSSetItemAndNotifyInfo of union LSWriteAndNotifyInfo");
                return false;
            }
            return true;
        }
    case union__::TLSRemoveItemAndNotifyInfo:
        {
            mozilla::dom::LSRemoveItemAndNotifyInfo tmp = mozilla::dom::LSRemoveItemAndNotifyInfo();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_LSRemoveItemAndNotifyInfo())))))) {
                aActor->FatalError("Error deserializing variant TLSRemoveItemAndNotifyInfo of union LSWriteAndNotifyInfo");
                return false;
            }
            // Sentinel = 'TLSRemoveItemAndNotifyInfo'
            if ((!((aMsg)->ReadSentinel(aIter, 2213677577)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TLSRemoveItemAndNotifyInfo of union LSWriteAndNotifyInfo");
                return false;
            }
            return true;
        }
    case union__::TLSClearInfo:
        {
            mozilla::dom::LSClearInfo tmp = mozilla::dom::LSClearInfo();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_LSClearInfo())))))) {
                aActor->FatalError("Error deserializing variant TLSClearInfo of union LSWriteAndNotifyInfo");
                return false;
            }
            // Sentinel = 'TLSClearInfo'
            if ((!((aMsg)->ReadSentinel(aIter, 455410791)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TLSClearInfo of union LSWriteAndNotifyInfo");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla
