//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/gfx/PGPUChild.h"
#include "mozilla/ProfilerLabels.h"
#include "mozilla/ProfilerMarkers.h"
#include "mozilla/gfx/GPUChild.h"
#include "mozilla/layers/LayersMessageUtils.h"

#include "mozilla/layers/PAPZInputBridgeChild.h"
#include "mozilla/layers/PCompositorManagerChild.h"
#include "mozilla/layers/PImageBridgeChild.h"
#include "mozilla/PProfilerChild.h"
#include "mozilla/gfx/PVRGPUChild.h"
#include "mozilla/gfx/PVRManagerChild.h"
#include "mozilla/layers/PVideoBridgeChild.h"
#include "mozilla/gfx/PVsyncBridgeChild.h"
#include "mozilla/layers/PUiCompositorControllerChild.h"
#include "mozilla/PRemoteDecoderManagerChild.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace gfx {


auto PGPUChild::ProcessingError(
        Result aCode,
        const char* aReason) -> void
{
}

auto PGPUChild::ShouldContinueFromReplyTimeout() -> bool
{
    return true;
}

auto PGPUChild::EnteredCxxStack() -> void
{
}

auto PGPUChild::ExitedCxxStack() -> void
{
}

auto PGPUChild::EnteredCall() -> void
{
}

auto PGPUChild::ExitedCall() -> void
{
}

MOZ_IMPLICIT PGPUChild::PGPUChild() :
    mozilla::ipc::IToplevelProtocol("PGPUChild", PGPUMsgStart, mozilla::ipc::ChildSide)
{
    MOZ_COUNT_CTOR(PGPUChild);
}

PGPUChild::~PGPUChild()
{
    MOZ_COUNT_DTOR(PGPUChild);
}

auto PGPUChild::ManagedPAPZInputBridgeChild(nsTArray<PAPZInputBridgeChild*>& aArr) const -> void
{
    mManagedPAPZInputBridgeChild.ToArray(aArr);
}

auto PGPUChild::ManagedPAPZInputBridgeChild() const -> const ManagedContainer<PAPZInputBridgeChild>&
{
    return mManagedPAPZInputBridgeChild;
}

auto PGPUChild::AllManagedActors(nsTArray<RefPtr<mozilla::ipc::ActorLifecycleProxy>>& arr__) const -> void
{
    uint32_t total = 0;
    total += mManagedPAPZInputBridgeChild.Count();
    arr__.SetCapacity(total);

    for (auto it = mManagedPAPZInputBridgeChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

}

auto PGPUChild::OpenPAPZInputBridgeEndpoint(PAPZInputBridgeChild* aActor) -> ManagedEndpoint<PAPZInputBridgeParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PAPZInputBridgeChild actor");
        return ManagedEndpoint<PAPZInputBridgeParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPAPZInputBridgeChild.PutEntry(aActor);

    return ManagedEndpoint<PAPZInputBridgeParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PGPUChild::BindPAPZInputBridgeEndpoint(
        ManagedEndpoint<PAPZInputBridgeChild> aEndpoint,
        PAPZInputBridgeChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PAPZInputBridgeChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPAPZInputBridgeChild.PutEntry(aActor);

    return true;
}

auto PGPUChild::SendPAPZInputBridgeConstructor(
        PAPZInputBridgeChild* actor,
        const LayersId& aLayersId) -> PAPZInputBridgeChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PAPZInputBridgeChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPAPZInputBridgeChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PGPU::Msg_PAPZInputBridgeConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, aLayersId);
    // Sentinel = 'aLayersId'
    (msg__)->WriteSentinel(291439487);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_PAPZInputBridgeConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PAPZInputBridgeChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PAPZInputBridgeMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PGPUChild::SendInit(
        const nsTArray<GfxVarUpdate>& vars,
        const DevicePrefs& devicePrefs,
        const nsTArray<LayerTreeIdMapping>& mapping,
        const nsTArray<GfxInfoFeatureStatus>& features) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_Init(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, vars);
    // Sentinel = 'vars'
    (msg__)->WriteSentinel(72745405);
    WriteIPDLParam(msg__, this, devicePrefs);
    // Sentinel = 'devicePrefs'
    (msg__)->WriteSentinel(445645937);
    WriteIPDLParam(msg__, this, mapping);
    // Sentinel = 'mapping'
    (msg__)->WriteSentinel(196477677);
    WriteIPDLParam(msg__, this, features);
    // Sentinel = 'features'
    (msg__)->WriteSentinel(250348384);




    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_Init", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PGPUChild::SendInitCompositorManager(Endpoint<mozilla::layers::PCompositorManagerParent>&& endpoint) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_InitCompositorManager(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, std::move(endpoint));
    // Sentinel = 'endpoint'
    (msg__)->WriteSentinel(251724642);




    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_InitCompositorManager", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PGPUChild::SendInitVsyncBridge(Endpoint<mozilla::gfx::PVsyncBridgeParent>&& endpoint) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_InitVsyncBridge(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, std::move(endpoint));
    // Sentinel = 'endpoint'
    (msg__)->WriteSentinel(251724642);




    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_InitVsyncBridge", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PGPUChild::SendInitImageBridge(Endpoint<mozilla::layers::PImageBridgeParent>&& endpoint) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_InitImageBridge(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, std::move(endpoint));
    // Sentinel = 'endpoint'
    (msg__)->WriteSentinel(251724642);




    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_InitImageBridge", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PGPUChild::SendInitVideoBridge(Endpoint<mozilla::layers::PVideoBridgeParent>&& endpoint) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_InitVideoBridge(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, std::move(endpoint));
    // Sentinel = 'endpoint'
    (msg__)->WriteSentinel(251724642);




    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_InitVideoBridge", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PGPUChild::SendInitVRManager(Endpoint<mozilla::gfx::PVRManagerParent>&& endpoint) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_InitVRManager(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, std::move(endpoint));
    // Sentinel = 'endpoint'
    (msg__)->WriteSentinel(251724642);




    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_InitVRManager", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PGPUChild::SendInitUiCompositorController(
        const LayersId& rootLayerTreeId,
        Endpoint<mozilla::layers::PUiCompositorControllerParent>&& endpoint) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_InitUiCompositorController(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, rootLayerTreeId);
    // Sentinel = 'rootLayerTreeId'
    (msg__)->WriteSentinel(828507647);
    WriteIPDLParam(msg__, this, std::move(endpoint));
    // Sentinel = 'endpoint'
    (msg__)->WriteSentinel(251724642);




    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_InitUiCompositorController", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PGPUChild::SendInitProfiler(Endpoint<mozilla::PProfilerChild>&& endpoint) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_InitProfiler(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, std::move(endpoint));
    // Sentinel = 'endpoint'
    (msg__)->WriteSentinel(251724642);




    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_InitProfiler", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PGPUChild::SendInitVR(Endpoint<mozilla::gfx::PVRGPUChild>&& endpoint) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_InitVR(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, std::move(endpoint));
    // Sentinel = 'endpoint'
    (msg__)->WriteSentinel(251724642);




    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_InitVR", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PGPUChild::SendUpdateVar(const GfxVarUpdate& var) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_UpdateVar(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, var);
    // Sentinel = 'var'
    (msg__)->WriteSentinel(43581770);




    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_UpdateVar", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PGPUChild::SendPreferenceUpdate(const Pref& pref) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_PreferenceUpdate(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, pref);
    // Sentinel = 'pref'
    (msg__)->WriteSentinel(71958958);




    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_PreferenceUpdate", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PGPUChild::SendNewContentCompositorManager(Endpoint<mozilla::layers::PCompositorManagerParent>&& endpoint) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_NewContentCompositorManager(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, std::move(endpoint));
    // Sentinel = 'endpoint'
    (msg__)->WriteSentinel(251724642);




    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_NewContentCompositorManager", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PGPUChild::SendNewContentImageBridge(Endpoint<mozilla::layers::PImageBridgeParent>&& endpoint) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_NewContentImageBridge(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, std::move(endpoint));
    // Sentinel = 'endpoint'
    (msg__)->WriteSentinel(251724642);




    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_NewContentImageBridge", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PGPUChild::SendNewContentVRManager(Endpoint<mozilla::gfx::PVRManagerParent>&& endpoint) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_NewContentVRManager(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, std::move(endpoint));
    // Sentinel = 'endpoint'
    (msg__)->WriteSentinel(251724642);




    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_NewContentVRManager", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PGPUChild::SendNewContentRemoteDecoderManager(Endpoint<mozilla::PRemoteDecoderManagerParent>&& endpoint) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_NewContentRemoteDecoderManager(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, std::move(endpoint));
    // Sentinel = 'endpoint'
    (msg__)->WriteSentinel(251724642);




    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_NewContentRemoteDecoderManager", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PGPUChild::SendAddLayerTreeIdMapping(const LayerTreeIdMapping& mapping) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_AddLayerTreeIdMapping(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, mapping);
    // Sentinel = 'mapping'
    (msg__)->WriteSentinel(196477677);



    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_AddLayerTreeIdMapping", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PGPU::Msg_AddLayerTreeIdMapping", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    return true;
}

auto PGPUChild::SendRemoveLayerTreeIdMapping(const LayerTreeIdMapping& mapping) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_RemoveLayerTreeIdMapping(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, mapping);
    // Sentinel = 'mapping'
    (msg__)->WriteSentinel(196477677);




    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_RemoveLayerTreeIdMapping", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PGPUChild::SendGetDeviceStatus(GPUDeviceData* status) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_GetDeviceStatus(MSG_ROUTING_CONTROL);




    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_GetDeviceStatus", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PGPU::Msg_GetDeviceStatus", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    PickleIterator iter__{reply__};

    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, status)))) {
        FatalError("Error deserializing 'GPUDeviceData'");
        return false;
    }
    // Sentinel = 'status'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 154731173)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'GPUDeviceData'");
        return false;
    }
    reply__.EndRead(iter__, reply__.type());

    return true;
}

auto PGPUChild::SendSimulateDeviceReset(GPUDeviceData* status) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_SimulateDeviceReset(MSG_ROUTING_CONTROL);




    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_SimulateDeviceReset", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PGPU::Msg_SimulateDeviceReset", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    PickleIterator iter__{reply__};

    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, status)))) {
        FatalError("Error deserializing 'GPUDeviceData'");
        return false;
    }
    // Sentinel = 'status'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 154731173)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'GPUDeviceData'");
        return false;
    }
    reply__.EndRead(iter__, reply__.type());

    return true;
}

auto PGPUChild::SendNotifyGpuObservers(const nsCString& aTopic) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_NotifyGpuObservers(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, aTopic);
    // Sentinel = 'aTopic'
    (msg__)->WriteSentinel(137429601);




    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_NotifyGpuObservers", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PGPUChild::SendRequestMemoryReport(
        const uint32_t& generation,
        const bool& anonymize,
        const bool& minimizeMemoryUsage,
        const mozilla::Maybe<FileDescriptor>& DMDFile,
        mozilla::ipc::ResolveCallback<uint32_t>&& aResolve,
        mozilla::ipc::RejectCallback&& aReject) -> void
{
    IPC::Message* msg__ = PGPU::Msg_RequestMemoryReport(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, generation);
    // Sentinel = 'generation'
    (msg__)->WriteSentinel(381158445);
    WriteIPDLParam(msg__, this, anonymize);
    // Sentinel = 'anonymize'
    (msg__)->WriteSentinel(321127387);
    WriteIPDLParam(msg__, this, minimizeMemoryUsage);
    // Sentinel = 'minimizeMemoryUsage'
    (msg__)->WriteSentinel(1321600977);
    WriteIPDLParam(msg__, this, DMDFile);
    // Sentinel = 'DMDFile'
    (msg__)->WriteSentinel(143983190);




    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_RequestMemoryReport", OTHER);

    ChannelSend(msg__, std::move(aResolve), std::move(aReject));
    return;
}

auto PGPUChild::SendRequestMemoryReport(
        const uint32_t& generation,
        const bool& anonymize,
        const bool& minimizeMemoryUsage,
        const mozilla::Maybe<FileDescriptor>& DMDFile) -> RefPtr<RequestMemoryReportPromise>
{
    RefPtr<MozPromise<uint32_t, ResponseRejectReason, true>::Private> promise__ = new MozPromise<uint32_t, ResponseRejectReason, true>::Private(__func__);
    promise__->UseDirectTaskDispatch(__func__);
    SendRequestMemoryReport(std::move(generation), std::move(anonymize), std::move(minimizeMemoryUsage), std::move(DMDFile), [promise__](uint32_t&& aValue) {
        promise__->Resolve(std::move(aValue), __func__);
    }, [promise__](ResponseRejectReason&& aReason) {
        promise__->Reject(std::move(aReason), __func__);
    });
    return promise__;
}

auto PGPUChild::SendShutdownVR() -> bool
{
    IPC::Message* msg__ = PGPU::Msg_ShutdownVR(MSG_ROUTING_CONTROL);





    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_ShutdownVR", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PGPUChild::SendUpdatePerfStatsCollectionMask(const uint64_t& aMask) -> bool
{
    IPC::Message* msg__ = PGPU::Msg_UpdatePerfStatsCollectionMask(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, aMask);
    // Sentinel = 'aMask'
    (msg__)->WriteSentinel(93454830);




    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_UpdatePerfStatsCollectionMask", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PGPUChild::SendCollectPerfStatsJSON(
        mozilla::ipc::ResolveCallback<nsCString>&& aResolve,
        mozilla::ipc::RejectCallback&& aReject) -> void
{
    IPC::Message* msg__ = PGPU::Msg_CollectPerfStatsJSON(MSG_ROUTING_CONTROL);





    if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGPUChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGPU::Msg_CollectPerfStatsJSON", OTHER);

    ChannelSend(msg__, std::move(aResolve), std::move(aReject));
    return;
}

auto PGPUChild::SendCollectPerfStatsJSON() -> RefPtr<CollectPerfStatsJSONPromise>
{
    RefPtr<MozPromise<nsCString, ResponseRejectReason, true>::Private> promise__ = new MozPromise<nsCString, ResponseRejectReason, true>::Private(__func__);
    promise__->UseDirectTaskDispatch(__func__);
    SendCollectPerfStatsJSON([promise__](nsCString&& aValue) {
        promise__->Resolve(std::move(aValue), __func__);
    }, [promise__](ResponseRejectReason&& aReason) {
        promise__->Reject(std::move(aReason), __func__);
    });
    return promise__;
}

auto PGPUChild::RemoveManagee(
        int32_t aProtocolId,
        IProtocol* aListener) -> void
{
    switch (aProtocolId) {
    case PAPZInputBridgeMsgStart:
{
            PAPZInputBridgeChild* actor = static_cast<PAPZInputBridgeChild*>(aListener);
            auto& container = mManagedPAPZInputBridgeChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    default:
FatalError("unreached");
        return;    }
}

auto PGPUChild::DeallocManagee(
        int32_t aProtocolId,
        IProtocol* aListener) -> void
{
    switch (aProtocolId) {
    default:
        FatalError("unreached");
        return;
    }
}

auto PGPUChild::OnMessageReceived(const Message& msg__) -> PGPUChild::Result
{
    int32_t route__ = msg__.routing_id();
    if (MSG_ROUTING_CONTROL != route__) {
        IProtocol* routed__ = Lookup(route__);
        if (!routed__ || !routed__->GetLifecycleProxy()) {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Ignored message for dead actor",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eSending);
            }

            return MsgProcessed;
        }

        RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
            routed__->GetLifecycleProxy();
        return proxy__->Get()->OnMessageReceived(msg__);
    }

    switch (msg__.type()) {
    case PGPU::Reply_PAPZInputBridgeConstructor__ID:
        {
            return MsgProcessed;
        }
    case PGPU::Reply_RequestMemoryReport__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_RequestMemoryReport", OTHER);

            PickleIterator iter__{msg__};
            bool resolve__ = false;
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(resolve__)))))) {
                FatalError("Error deserializing 'resolve__'");
                return MsgValueError;
            }
            // Sentinel = 'resolve__'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 322044863)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'resolve__'");
                return MsgValueError;
            }


            UniquePtr<MessageChannel::UntypedCallbackHolder> untypedCallback =
                GetIPCChannel()->PopCallback(msg__);

            typedef MessageChannel::CallbackHolder<uint32_t> CallbackHolder;
            auto* callback = static_cast<CallbackHolder*>(untypedCallback.get());
            if (!callback) {
                FatalError("Error unknown callback");
                return MsgProcessingError;
            }

            if (resolve__) {
                uint32_t aGeneration{};

                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aGeneration)))))) {
                    FatalError("Error deserializing 'uint32_t'");
                    return MsgValueError;
                }
                // Sentinel = 'aGeneration'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 430179438)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Resolve(std::move(aGeneration));
            } else {
                ResponseRejectReason reason__{};
                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(reason__)))))) {
                    FatalError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                // Sentinel = 'reason__'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 251855687)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Reject(std::move(reason__));
            }
            return MsgProcessed;
        }
    case PGPU::Reply_CollectPerfStatsJSON__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_CollectPerfStatsJSON", OTHER);

            PickleIterator iter__{msg__};
            bool resolve__ = false;
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(resolve__)))))) {
                FatalError("Error deserializing 'resolve__'");
                return MsgValueError;
            }
            // Sentinel = 'resolve__'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 322044863)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'resolve__'");
                return MsgValueError;
            }


            UniquePtr<MessageChannel::UntypedCallbackHolder> untypedCallback =
                GetIPCChannel()->PopCallback(msg__);

            typedef MessageChannel::CallbackHolder<nsCString> CallbackHolder;
            auto* callback = static_cast<CallbackHolder*>(untypedCallback.get());
            if (!callback) {
                FatalError("Error unknown callback");
                return MsgProcessingError;
            }

            if (resolve__) {
                nsCString aStats{};

                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aStats)))))) {
                    FatalError("Error deserializing 'nsCString'");
                    return MsgValueError;
                }
                // Sentinel = 'aStats'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 137953905)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Resolve(std::move(aStats));
            } else {
                ResponseRejectReason reason__{};
                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(reason__)))))) {
                    FatalError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                // Sentinel = 'reason__'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 251855687)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Reject(std::move(reason__));
            }
            return MsgProcessed;
        }
    case PGPU::Msg_InitComplete__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_InitComplete", OTHER);

            PickleIterator iter__{msg__};
            GPUDeviceData data{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(data)))))) {
                FatalError("Error deserializing 'GPUDeviceData'");
                return MsgValueError;
            }
            // Sentinel = 'data'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 67109275)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'GPUDeviceData'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<GPUChild*>(this))->RecvInitComplete(std::move(data))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PGPU::Msg_ReportCheckerboard__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_ReportCheckerboard", OTHER);

            PickleIterator iter__{msg__};
            uint32_t severity{};
            nsCString log{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(severity)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'severity'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 260309884)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(log)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'log'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 42729795)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<GPUChild*>(this))->RecvReportCheckerboard(std::move(severity), std::move(log))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PGPU::Msg_GraphicsError__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_GraphicsError", OTHER);

            PickleIterator iter__{msg__};
            nsCString aError{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aError)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'aError'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 135463532)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<GPUChild*>(this))->RecvGraphicsError(std::move(aError))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PGPU::Msg_InitCrashReporter__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_InitCrashReporter", OTHER);

            PickleIterator iter__{msg__};
            NativeThreadId threadId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(threadId)))))) {
                FatalError("Error deserializing 'NativeThreadId'");
                return MsgValueError;
            }
            // Sentinel = 'threadId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 248185638)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'NativeThreadId'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<GPUChild*>(this))->RecvInitCrashReporter(std::move(threadId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PGPU::Msg_CreateVRProcess__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_CreateVRProcess", OTHER);

            if ((!((static_cast<GPUChild*>(this))->RecvCreateVRProcess()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PGPU::Msg_ShutdownVRProcess__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_ShutdownVRProcess", OTHER);

            if ((!((static_cast<GPUChild*>(this))->RecvShutdownVRProcess()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PGPU::Msg_NotifyUiObservers__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_NotifyUiObservers", OTHER);

            PickleIterator iter__{msg__};
            nsCString aTopic{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aTopic)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'aTopic'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 137429601)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<GPUChild*>(this))->RecvNotifyUiObservers(std::move(aTopic))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PGPU::Msg_AccumulateChildHistograms__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_AccumulateChildHistograms", OTHER);

            PickleIterator iter__{msg__};
            nsTArray<HistogramAccumulation> accumulations{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(accumulations)))))) {
                FatalError("Error deserializing 'HistogramAccumulation[]'");
                return MsgValueError;
            }
            // Sentinel = 'accumulations'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 632030585)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'HistogramAccumulation[]'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<GPUChild*>(this))->RecvAccumulateChildHistograms(std::move(accumulations))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PGPU::Msg_AccumulateChildKeyedHistograms__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_AccumulateChildKeyedHistograms", OTHER);

            PickleIterator iter__{msg__};
            nsTArray<KeyedHistogramAccumulation> accumulations{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(accumulations)))))) {
                FatalError("Error deserializing 'KeyedHistogramAccumulation[]'");
                return MsgValueError;
            }
            // Sentinel = 'accumulations'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 632030585)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'KeyedHistogramAccumulation[]'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<GPUChild*>(this))->RecvAccumulateChildKeyedHistograms(std::move(accumulations))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PGPU::Msg_UpdateChildScalars__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_UpdateChildScalars", OTHER);

            PickleIterator iter__{msg__};
            nsTArray<ScalarAction> actions{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(actions)))))) {
                FatalError("Error deserializing 'ScalarAction[]'");
                return MsgValueError;
            }
            // Sentinel = 'actions'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 193200882)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ScalarAction[]'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<GPUChild*>(this))->RecvUpdateChildScalars(std::move(actions))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PGPU::Msg_UpdateChildKeyedScalars__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_UpdateChildKeyedScalars", OTHER);

            PickleIterator iter__{msg__};
            nsTArray<KeyedScalarAction> actions{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(actions)))))) {
                FatalError("Error deserializing 'KeyedScalarAction[]'");
                return MsgValueError;
            }
            // Sentinel = 'actions'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 193200882)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'KeyedScalarAction[]'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<GPUChild*>(this))->RecvUpdateChildKeyedScalars(std::move(actions))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PGPU::Msg_RecordChildEvents__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_RecordChildEvents", OTHER);

            PickleIterator iter__{msg__};
            nsTArray<ChildEventData> events{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(events)))))) {
                FatalError("Error deserializing 'ChildEventData[]'");
                return MsgValueError;
            }
            // Sentinel = 'events'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 149619350)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ChildEventData[]'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<GPUChild*>(this))->RecvRecordChildEvents(std::move(events))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PGPU::Msg_RecordDiscardedData__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_RecordDiscardedData", OTHER);

            PickleIterator iter__{msg__};
            DiscardedData data{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(data)))))) {
                FatalError("Error deserializing 'DiscardedData'");
                return MsgValueError;
            }
            // Sentinel = 'data'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 67109275)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'DiscardedData'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<GPUChild*>(this))->RecvRecordDiscardedData(std::move(data))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PGPU::Msg_NotifyDeviceReset__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_NotifyDeviceReset", OTHER);

            PickleIterator iter__{msg__};
            GPUDeviceData status{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(status)))))) {
                FatalError("Error deserializing 'GPUDeviceData'");
                return MsgValueError;
            }
            // Sentinel = 'status'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 154731173)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'GPUDeviceData'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<GPUChild*>(this))->RecvNotifyDeviceReset(std::move(status))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PGPU::Msg_AddMemoryReport__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_AddMemoryReport", OTHER);

            PickleIterator iter__{msg__};
            MemoryReport aReport{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aReport)))))) {
                FatalError("Error deserializing 'MemoryReport'");
                return MsgValueError;
            }
            // Sentinel = 'aReport'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 184025822)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'MemoryReport'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<GPUChild*>(this))->RecvAddMemoryReport(std::move(aReport))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PGPU::Msg_UpdateFeature__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_UpdateFeature", OTHER);

            PickleIterator iter__{msg__};
            Feature aFeature{};
            FeatureFailure aChange{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aFeature)))))) {
                FatalError("Error deserializing 'Feature'");
                return MsgValueError;
            }
            // Sentinel = 'aFeature'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 229966638)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'Feature'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aChange)))))) {
                FatalError("Error deserializing 'FeatureFailure'");
                return MsgValueError;
            }
            // Sentinel = 'aChange'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 172556968)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'FeatureFailure'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<GPUChild*>(this))->RecvUpdateFeature(std::move(aFeature), std::move(aChange))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PGPU::Msg_UsedFallback__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_UsedFallback", OTHER);

            PickleIterator iter__{msg__};
            Fallback aFallback{};
            nsCString message{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aFallback)))))) {
                FatalError("Error deserializing 'Fallback'");
                return MsgValueError;
            }
            // Sentinel = 'aFallback'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 281609074)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'Fallback'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(message)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'message'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 197198566)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<GPUChild*>(this))->RecvUsedFallback(std::move(aFallback), std::move(message))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PGPU::Msg_BHRThreadHang__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_BHRThreadHang", OTHER);

            PickleIterator iter__{msg__};
            HangDetails aDetails{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aDetails)))))) {
                FatalError("Error deserializing 'HangDetails'");
                return MsgValueError;
            }
            // Sentinel = 'aDetails'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 228066088)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'HangDetails'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<GPUChild*>(this))->RecvBHRThreadHang(std::move(aDetails))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PGPU::Msg_UpdateMediaCodecsSupported__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGPU::Msg_UpdateMediaCodecsSupported", OTHER);

            PickleIterator iter__{msg__};
            MediaCodecsSupported aSupported{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aSupported)))))) {
                FatalError("Error deserializing 'MediaCodecsSupported'");
                return MsgValueError;
            }
            // Sentinel = 'aSupported'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 378799144)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'MediaCodecsSupported'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<GPUChild*>(this))->RecvUpdateMediaCodecsSupported(std::move(aSupported))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    default:
        return MsgNotKnown;
    case SHMEM_CREATED_MESSAGE_TYPE:
        {
            FatalError("this protocol tree does not use shmem");
            return MsgNotKnown;
        }
    case SHMEM_DESTROYED_MESSAGE_TYPE:
        {
            FatalError("this protocol tree does not use shmem");
            return MsgNotKnown;
        }
    }
}

auto PGPUChild::OnMessageReceived(
        const Message& msg__,
        Message*& reply__) -> PGPUChild::Result
{
    int32_t route__ = msg__.routing_id();
    if (MSG_ROUTING_CONTROL != route__) {
        IProtocol* routed__ = Lookup(route__);
        if (!routed__ || !routed__->GetLifecycleProxy()) {
            if (mozilla::ipc::LoggingEnabledFor("PGPUChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGPUChild",
                    OtherPid(),
                    "Ignored message for dead actor",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eSending);
            }

            return MsgProcessed;
        }

        RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
            routed__->GetLifecycleProxy();
        return proxy__->Get()->OnMessageReceived(msg__, reply__);
    }

    return MsgNotKnown;
}

auto PGPUChild::OnCallReceived(
        const Message& msg__,
        Message*& reply__) -> PGPUChild::Result
{
    MOZ_ASSERT_UNREACHABLE("message protocol not supported");
    return MsgNotKnown;
}

auto PGPUChild::OnChannelClose() -> void
{
    DestroySubtree(NormalShutdown);
    ClearSubtree();
    DeallocShmems();
    if (GetLifecycleProxy()) {
        GetLifecycleProxy()->Release();
    }
}

auto PGPUChild::OnChannelError() -> void
{
    DestroySubtree(AbnormalShutdown);
    ClearSubtree();
    DeallocShmems();
    if (GetLifecycleProxy()) {
        GetLifecycleProxy()->Release();
    }
}

auto PGPUChild::ClearSubtree() -> void
{
    for (auto it = mManagedPAPZInputBridgeChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPAPZInputBridgeChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPAPZInputBridgeChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPAPZInputBridgeChild.Clear();

}



} // namespace gfx
} // namespace mozilla
namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::gfx::PGPUChild*>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    int32_t id;
    if (!aVar) {
        id = 0;  // kNullActorId
    } else {
        id = aVar->Id();
        if (id == 1) {  // kFreedActorId
            aVar->FatalError("Actor has been |delete|d");
        }
        MOZ_RELEASE_ASSERT(
            aActor->GetIPCChannel() == aVar->GetIPCChannel(),
            "Actor must be from the same channel as the"
            " actor it's being sent over");
        MOZ_RELEASE_ASSERT(
            aVar->CanSend(),
            "Actor must still be open when sending");
    }

    WriteIPDLParam(aMsg, aActor, id);
}

auto IPDLParamTraits<mozilla::gfx::PGPUChild*>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    mozilla::Maybe<mozilla::ipc::IProtocol*> actor =
        aActor->ReadActor(aMsg, aIter, true, "PGPU", PGPUMsgStart);
    if (actor.isNothing()) {
        return false;
    }

    *aVar = static_cast<mozilla::gfx::PGPUChild*>(actor.value());
    return true;
}

} // namespace ipc
} // namespace mozilla
