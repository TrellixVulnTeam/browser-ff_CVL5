//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/quota/PQuotaChild.h"
#include "mozilla/ProfilerLabels.h"
#include "mozilla/dom/quota/SerializationHelpers.h"

#include "mozilla/ipc/PBackgroundChild.h"
#include "mozilla/dom/quota/PQuotaRequestChild.h"
#include "mozilla/dom/quota/PQuotaUsageRequestChild.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace dom {
namespace quota {


MOZ_IMPLICIT PQuotaChild::PQuotaChild() :
    mozilla::ipc::IProtocol(PQuotaMsgStart, mozilla::ipc::ChildSide)
{
    MOZ_COUNT_CTOR(PQuotaChild);
}

PQuotaChild::~PQuotaChild()
{
    MOZ_COUNT_DTOR(PQuotaChild);
}

auto PQuotaChild::Manager() const -> PBackgroundChild*
{
    return static_cast<PBackgroundChild*>(IProtocol::Manager());
}

auto PQuotaChild::ManagedPQuotaRequestChild(nsTArray<PQuotaRequestChild*>& aArr) const -> void
{
    mManagedPQuotaRequestChild.ToArray(aArr);
}

auto PQuotaChild::ManagedPQuotaRequestChild() const -> const ManagedContainer<PQuotaRequestChild>&
{
    return mManagedPQuotaRequestChild;
}

auto PQuotaChild::ManagedPQuotaUsageRequestChild(nsTArray<PQuotaUsageRequestChild*>& aArr) const -> void
{
    mManagedPQuotaUsageRequestChild.ToArray(aArr);
}

auto PQuotaChild::ManagedPQuotaUsageRequestChild() const -> const ManagedContainer<PQuotaUsageRequestChild>&
{
    return mManagedPQuotaUsageRequestChild;
}

auto PQuotaChild::AllManagedActors(nsTArray<RefPtr<mozilla::ipc::ActorLifecycleProxy>>& arr__) const -> void
{
    uint32_t total = 0;
    total += mManagedPQuotaRequestChild.Count();
    total += mManagedPQuotaUsageRequestChild.Count();
    arr__.SetCapacity(total);

    for (auto it = mManagedPQuotaRequestChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPQuotaUsageRequestChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

}

auto PQuotaChild::OpenPQuotaRequestEndpoint(PQuotaRequestChild* aActor) -> ManagedEndpoint<PQuotaRequestParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PQuotaRequestChild actor");
        return ManagedEndpoint<PQuotaRequestParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPQuotaRequestChild.PutEntry(aActor);

    return ManagedEndpoint<PQuotaRequestParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PQuotaChild::BindPQuotaRequestEndpoint(
        ManagedEndpoint<PQuotaRequestChild> aEndpoint,
        PQuotaRequestChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PQuotaRequestChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPQuotaRequestChild.PutEntry(aActor);

    return true;
}

auto PQuotaChild::OpenPQuotaUsageRequestEndpoint(PQuotaUsageRequestChild* aActor) -> ManagedEndpoint<PQuotaUsageRequestParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PQuotaUsageRequestChild actor");
        return ManagedEndpoint<PQuotaUsageRequestParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPQuotaUsageRequestChild.PutEntry(aActor);

    return ManagedEndpoint<PQuotaUsageRequestParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PQuotaChild::BindPQuotaUsageRequestEndpoint(
        ManagedEndpoint<PQuotaUsageRequestChild> aEndpoint,
        PQuotaUsageRequestChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PQuotaUsageRequestChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPQuotaUsageRequestChild.PutEntry(aActor);

    return true;
}

auto PQuotaChild::Send__delete__(PQuotaChild* actor) -> bool
{
    if (!actor || !actor->CanSend()) {
        NS_WARNING("Attempt to __delete__ missing or closed actor");
        return false;
    }
    IPC::Message* msg__ = PQuota::Msg___delete__((actor)->Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, actor, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);



    if (mozilla::ipc::LoggingEnabledFor("PQuotaChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PQuotaChild",
            (actor)->OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PQuota::Msg___delete__", OTHER);

    bool sendok__ = (actor)->ChannelSend(msg__);

    IProtocol* mgr = actor->Manager();
    actor->DestroySubtree(Deletion);
    actor->ClearSubtree();
    mgr->RemoveManagee(PQuotaMsgStart, actor);
    return sendok__;
}

auto PQuotaChild::SendPQuotaUsageRequestConstructor(const UsageRequestParams& params) -> PQuotaUsageRequestChild*
{
    PQuotaUsageRequestChild* actor = (this)->AllocPQuotaUsageRequestChild(params);
    return SendPQuotaUsageRequestConstructor(actor, params);
}

auto PQuotaChild::SendPQuotaUsageRequestConstructor(
        PQuotaUsageRequestChild* actor,
        const UsageRequestParams& params) -> PQuotaUsageRequestChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PQuotaUsageRequestChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPQuotaUsageRequestChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PQuota::Msg_PQuotaUsageRequestConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, params);
    // Sentinel = 'params'
    (msg__)->WriteSentinel(146997893);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PQuotaChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PQuotaChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PQuota::Msg_PQuotaUsageRequestConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PQuotaUsageRequestChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PQuotaUsageRequestMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PQuotaChild::SendPQuotaRequestConstructor(const RequestParams& params) -> PQuotaRequestChild*
{
    PQuotaRequestChild* actor = (this)->AllocPQuotaRequestChild(params);
    return SendPQuotaRequestConstructor(actor, params);
}

auto PQuotaChild::SendPQuotaRequestConstructor(
        PQuotaRequestChild* actor,
        const RequestParams& params) -> PQuotaRequestChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PQuotaRequestChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPQuotaRequestChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PQuota::Msg_PQuotaRequestConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, params);
    // Sentinel = 'params'
    (msg__)->WriteSentinel(146997893);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PQuotaChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PQuotaChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PQuota::Msg_PQuotaRequestConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PQuotaRequestChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PQuotaRequestMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PQuotaChild::SendStartIdleMaintenance() -> bool
{
    IPC::Message* msg__ = PQuota::Msg_StartIdleMaintenance(Id());





    if (mozilla::ipc::LoggingEnabledFor("PQuotaChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PQuotaChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PQuota::Msg_StartIdleMaintenance", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PQuotaChild::SendStopIdleMaintenance() -> bool
{
    IPC::Message* msg__ = PQuota::Msg_StopIdleMaintenance(Id());





    if (mozilla::ipc::LoggingEnabledFor("PQuotaChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PQuotaChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PQuota::Msg_StopIdleMaintenance", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PQuotaChild::SendAbortOperationsForProcess(const ContentParentId& contentParentId) -> bool
{
    IPC::Message* msg__ = PQuota::Msg_AbortOperationsForProcess(Id());

    WriteIPDLParam(msg__, this, contentParentId);
    // Sentinel = 'contentParentId'
    (msg__)->WriteSentinel(830539283);




    if (mozilla::ipc::LoggingEnabledFor("PQuotaChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PQuotaChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PQuota::Msg_AbortOperationsForProcess", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PQuotaChild::RemoveManagee(
        int32_t aProtocolId,
        IProtocol* aListener) -> void
{
    switch (aProtocolId) {
    case PQuotaRequestMsgStart:
{
            PQuotaRequestChild* actor = static_cast<PQuotaRequestChild*>(aListener);
            auto& container = mManagedPQuotaRequestChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PQuotaUsageRequestMsgStart:
{
            PQuotaUsageRequestChild* actor = static_cast<PQuotaUsageRequestChild*>(aListener);
            auto& container = mManagedPQuotaUsageRequestChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    default:
FatalError("unreached");
        return;    }
}

auto PQuotaChild::DeallocManagee(
        int32_t aProtocolId,
        IProtocol* aListener) -> void
{
    switch (aProtocolId) {
    case PQuotaRequestMsgStart:
        this->DeallocPQuotaRequestChild(static_cast<PQuotaRequestChild*>(aListener));
        return;
    case PQuotaUsageRequestMsgStart:
        this->DeallocPQuotaUsageRequestChild(static_cast<PQuotaUsageRequestChild*>(aListener));
        return;
    default:
        FatalError("unreached");
        return;
    }
}

auto PQuotaChild::OnMessageReceived(const Message& msg__) -> PQuotaChild::Result
{
    switch (msg__.type()) {
    case PQuota::Reply___delete____ID:
        {
            return MsgProcessed;
        }
    case PQuota::Reply_PQuotaUsageRequestConstructor__ID:
        {
            return MsgProcessed;
        }
    case PQuota::Reply_PQuotaRequestConstructor__ID:
        {
            return MsgProcessed;
        }
    default:
        return MsgNotKnown;
    }
}

auto PQuotaChild::OnMessageReceived(
        const Message& msg__,
        Message*& reply__) -> PQuotaChild::Result
{
    return MsgNotKnown;
}

auto PQuotaChild::OnCallReceived(
        const Message& msg__,
        Message*& reply__) -> PQuotaChild::Result
{
    MOZ_ASSERT_UNREACHABLE("message protocol not supported");
    return MsgNotKnown;
}

auto PQuotaChild::ClearSubtree() -> void
{
    for (auto it = mManagedPQuotaRequestChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPQuotaRequestChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPQuotaRequestChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPQuotaRequestChild.Clear();

    for (auto it = mManagedPQuotaUsageRequestChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPQuotaUsageRequestChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPQuotaUsageRequestChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPQuotaUsageRequestChild.Clear();

}



} // namespace quota
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::quota::PQuotaChild*>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    int32_t id;
    if (!aVar) {
        id = 0;  // kNullActorId
    } else {
        id = aVar->Id();
        if (id == 1) {  // kFreedActorId
            aVar->FatalError("Actor has been |delete|d");
        }
        MOZ_RELEASE_ASSERT(
            aActor->GetIPCChannel() == aVar->GetIPCChannel(),
            "Actor must be from the same channel as the"
            " actor it's being sent over");
        MOZ_RELEASE_ASSERT(
            aVar->CanSend(),
            "Actor must still be open when sending");
    }

    WriteIPDLParam(aMsg, aActor, id);
}

auto IPDLParamTraits<mozilla::dom::quota::PQuotaChild*>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    mozilla::Maybe<mozilla::ipc::IProtocol*> actor =
        aActor->ReadActor(aMsg, aIter, true, "PQuota", PQuotaMsgStart);
    if (actor.isNothing()) {
        return false;
    }

    *aVar = static_cast<mozilla::dom::quota::PQuotaChild*>(actor.value());
    return true;
}

} // namespace ipc
} // namespace mozilla
