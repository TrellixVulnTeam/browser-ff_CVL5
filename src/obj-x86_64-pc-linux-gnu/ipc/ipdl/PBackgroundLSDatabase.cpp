//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/localstorage/SerializationHelpers.h"
#include "mozilla/ipc/PBackgroundParent.h"
#include "mozilla/ipc/PBackgroundChild.h"
#include "mozilla/dom/PBackgroundLSSnapshotParent.h"
#include "mozilla/dom/PBackgroundLSSnapshotChild.h"
#include "mozilla/dom/PBackgroundLSDatabase.h"
#include "mozilla/dom/PBackgroundLSDatabaseParent.h"
#include "mozilla/dom/PBackgroundLSDatabaseChild.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace dom {
namespace PBackgroundLSDatabase {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::dom::PBackgroundLSDatabaseParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::dom::PBackgroundLSDatabaseChild>* aChild)
{
    return mozilla::ipc::CreateEndpoints(
        mozilla::ipc::PrivateIPDLInterface(),
        aParentDestPid, aChildDestPid,
        aParent, aChild);
}
IPC::Message*
Msg_DeleteMe(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_DeleteMe__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_AllowToClose(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_AllowToClose__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_PBackgroundLSSnapshotConstructor(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_PBackgroundLSSnapshotConstructor__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply_PBackgroundLSSnapshotConstructor(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply_PBackgroundLSSnapshotConstructor__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg___delete__(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg___delete____ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply___delete__(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply___delete____ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg_RequestAllowToClose(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_RequestAllowToClose__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}

} // namespace PBackgroundLSDatabase
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct LSSnapshotInitInfo|
//
namespace mozilla {
namespace dom {
auto LSSnapshotInitInfo::StaticAssertions() const -> void
{
    static_assert(
        (offsetof(LSSnapshotInitInfo, peakUsage_) - offsetof(LSSnapshotInitInfo, initialUsage_)) == 8,
        "Bad assumptions about field layout!");
}

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::LSSnapshotInitInfo>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).addKeyToUnknownItems());
    // Sentinel = 'addKeyToUnknownItems'
    (aMsg)->WriteSentinel(1384187912);
    WriteIPDLParam(aMsg, aActor, (aVar).itemInfos());
    // Sentinel = 'itemInfos'
    (aMsg)->WriteSentinel(307430319);
    WriteIPDLParam(aMsg, aActor, (aVar).loadState());
    // Sentinel = 'loadState'
    (aMsg)->WriteSentinel(304808866);
    WriteIPDLParam(aMsg, aActor, (aVar).hasOtherProcessObservers());
    // Sentinel = 'hasOtherProcessObservers'
    (aMsg)->WriteSentinel(2034502105);
    (aMsg)->WriteBytes((&((aVar).initialUsage())), 16);
    // Sentinel = 'initialUsage | peakUsage'
    (aMsg)->WriteSentinel(1958873394);
    (aMsg)->WriteBytes((&((aVar).totalLength())), 4);
    // Sentinel = 'totalLength'
    (aMsg)->WriteSentinel(459998343);
}

auto IPDLParamTraits<mozilla::dom::LSSnapshotInitInfo>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->addKeyToUnknownItems())))))) {
        aActor->FatalError("Error deserializing 'addKeyToUnknownItems' (bool) member of 'LSSnapshotInitInfo'");
        return false;
    }
    // Sentinel = 'addKeyToUnknownItems'
    if ((!((aMsg)->ReadSentinel(aIter, 1384187912)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'addKeyToUnknownItems' (bool) member of 'LSSnapshotInitInfo'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->itemInfos())))))) {
        aActor->FatalError("Error deserializing 'itemInfos' (LSItemInfo[]) member of 'LSSnapshotInitInfo'");
        return false;
    }
    // Sentinel = 'itemInfos'
    if ((!((aMsg)->ReadSentinel(aIter, 307430319)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'itemInfos' (LSItemInfo[]) member of 'LSSnapshotInitInfo'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->loadState())))))) {
        aActor->FatalError("Error deserializing 'loadState' (LoadState) member of 'LSSnapshotInitInfo'");
        return false;
    }
    // Sentinel = 'loadState'
    if ((!((aMsg)->ReadSentinel(aIter, 304808866)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'loadState' (LoadState) member of 'LSSnapshotInitInfo'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->hasOtherProcessObservers())))))) {
        aActor->FatalError("Error deserializing 'hasOtherProcessObservers' (bool) member of 'LSSnapshotInitInfo'");
        return false;
    }
    // Sentinel = 'hasOtherProcessObservers'
    if ((!((aMsg)->ReadSentinel(aIter, 2034502105)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'hasOtherProcessObservers' (bool) member of 'LSSnapshotInitInfo'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->initialUsage())), 16)))) {
        aActor->FatalError("Error bulk reading fields from int64_t");
        return false;
    }
    // Sentinel = 'initialUsage | peakUsage'
    if ((!((aMsg)->ReadSentinel(aIter, 1958873394)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from int64_t");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->totalLength())), 4)))) {
        aActor->FatalError("Error bulk reading fields from uint32_t");
        return false;
    }
    // Sentinel = 'totalLength'
    if ((!((aMsg)->ReadSentinel(aIter, 459998343)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint32_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla
