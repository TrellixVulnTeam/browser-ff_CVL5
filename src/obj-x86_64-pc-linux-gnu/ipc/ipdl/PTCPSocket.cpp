//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/net/NeckoMessageUtils.h"
#include "mozilla/net/PNeckoParent.h"
#include "mozilla/net/PNeckoChild.h"
#include "mozilla/net/PTCPSocket.h"
#include "mozilla/net/PTCPSocketParent.h"
#include "mozilla/net/PTCPSocketChild.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace net {
namespace PTCPSocket {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::net::PTCPSocketParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::net::PTCPSocketChild>* aChild)
{
    return mozilla::ipc::CreateEndpoints(
        mozilla::ipc::PrivateIPDLInterface(),
        aParentDestPid, aChildDestPid,
        aParent, aChild);
}
IPC::Message*
Msg_Open(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Open__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_Data(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Data__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_StartTLS(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_StartTLS__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_Suspend(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Suspend__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_Resume(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Resume__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_Close(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Close__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_Callback(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Callback__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_UpdateBufferedAmount(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_UpdateBufferedAmount__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_RequestDelete(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_RequestDelete__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg___delete__(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg___delete____ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply___delete__(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply___delete____ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}

} // namespace PTCPSocket
} // namespace net
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct TCPError|
//

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<TCPError>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).name());
    // Sentinel = 'name'
    (aMsg)->WriteSentinel(69075362);
    WriteIPDLParam(aMsg, aActor, (aVar).message());
    // Sentinel = 'message'
    (aMsg)->WriteSentinel(197198566);
}

auto IPDLParamTraits<TCPError>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->name())))))) {
        aActor->FatalError("Error deserializing 'name' (nsString) member of 'TCPError'");
        return false;
    }
    // Sentinel = 'name'
    if ((!((aMsg)->ReadSentinel(aIter, 69075362)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'name' (nsString) member of 'TCPError'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->message())))))) {
        aActor->FatalError("Error deserializing 'message' (nsString) member of 'TCPError'");
        return false;
    }
    // Sentinel = 'message'
    if ((!((aMsg)->ReadSentinel(aIter, 197198566)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'message' (nsString) member of 'TCPError'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union SendableData|
//
auto SendableData::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TArrayOfuint8_t:
        {
            (ptr_ArrayOfuint8_t())->~ArrayOfuint8_t__tdef();
            break;
        }
    case TnsCString:
        {
            (ptr_nsCString())->~nsCString__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT SendableData::SendableData(const nsTArray<uint8_t>& aOther)
{
    new (mozilla::KnownNotNull, ptr_ArrayOfuint8_t()) nsTArray<uint8_t>((aOther).Clone());
    mType = TArrayOfuint8_t;
}

MOZ_IMPLICIT SendableData::SendableData(nsTArray<uint8_t>&& aOther)
{
    new (mozilla::KnownNotNull, ptr_ArrayOfuint8_t()) nsTArray<uint8_t>(std::move(aOther));
    mType = TArrayOfuint8_t;
}

MOZ_IMPLICIT SendableData::SendableData(const nsCString& aOther)
{
    new (mozilla::KnownNotNull, ptr_nsCString()) nsCString(aOther);
    mType = TnsCString;
}

MOZ_IMPLICIT SendableData::SendableData(nsCString&& aOther)
{
    new (mozilla::KnownNotNull, ptr_nsCString()) nsCString(std::move(aOther));
    mType = TnsCString;
}

MOZ_IMPLICIT SendableData::SendableData(const SendableData& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TArrayOfuint8_t:
        {
            new (mozilla::KnownNotNull, ptr_ArrayOfuint8_t()) nsTArray<uint8_t>(((aOther).get_ArrayOfuint8_t()).Clone());
            break;
        }
    case TnsCString:
        {
            new (mozilla::KnownNotNull, ptr_nsCString()) nsCString((aOther).get_nsCString());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT SendableData::SendableData(SendableData&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TArrayOfuint8_t:
        {
            new (mozilla::KnownNotNull, ptr_ArrayOfuint8_t()) nsTArray<uint8_t>(std::move((aOther).get_ArrayOfuint8_t()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TnsCString:
        {
            new (mozilla::KnownNotNull, ptr_nsCString()) nsCString(std::move((aOther).get_nsCString()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

SendableData::~SendableData()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto SendableData::operator=(const nsTArray<uint8_t>& aRhs) -> SendableData&
{
    if (MaybeDestroy(TArrayOfuint8_t)) {
        new (mozilla::KnownNotNull, ptr_ArrayOfuint8_t()) nsTArray<uint8_t>;
    }
    (*(ptr_ArrayOfuint8_t())) = (aRhs).Clone();
    mType = TArrayOfuint8_t;
    return (*(this));
}

auto SendableData::operator=(nsTArray<uint8_t>&& aRhs) -> SendableData&
{
    if (MaybeDestroy(TArrayOfuint8_t)) {
        new (mozilla::KnownNotNull, ptr_ArrayOfuint8_t()) nsTArray<uint8_t>;
    }
    (*(ptr_ArrayOfuint8_t())) = std::move(aRhs);
    mType = TArrayOfuint8_t;
    return (*(this));
}

auto SendableData::operator=(const nsCString& aRhs) -> SendableData&
{
    if (MaybeDestroy(TnsCString)) {
        new (mozilla::KnownNotNull, ptr_nsCString()) nsCString;
    }
    (*(ptr_nsCString())) = aRhs;
    mType = TnsCString;
    return (*(this));
}

auto SendableData::operator=(nsCString&& aRhs) -> SendableData&
{
    if (MaybeDestroy(TnsCString)) {
        new (mozilla::KnownNotNull, ptr_nsCString()) nsCString;
    }
    (*(ptr_nsCString())) = std::move(aRhs);
    mType = TnsCString;
    return (*(this));
}

auto SendableData::operator=(const SendableData& aRhs) -> SendableData&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TArrayOfuint8_t:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ArrayOfuint8_t()) nsTArray<uint8_t>;
            }
            (*(ptr_ArrayOfuint8_t())) = ((aRhs).get_ArrayOfuint8_t()).Clone();
            break;
        }
    case TnsCString:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_nsCString()) nsCString;
            }
            (*(ptr_nsCString())) = (aRhs).get_nsCString();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto SendableData::operator=(SendableData&& aRhs) -> SendableData&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TArrayOfuint8_t:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ArrayOfuint8_t()) nsTArray<uint8_t>;
            }
            (*(ptr_ArrayOfuint8_t())) = std::move((aRhs).get_ArrayOfuint8_t());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TnsCString:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_nsCString()) nsCString;
            }
            (*(ptr_nsCString())) = std::move((aRhs).get_nsCString());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}


namespace mozilla {
namespace ipc {
auto IPDLParamTraits<SendableData>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef SendableData union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'SendableData'
    (aMsg)->WriteSentinel(499778713);

    switch (type) {
    case union__::TArrayOfuint8_t:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_ArrayOfuint8_t());
            // Sentinel = 'TArrayOfuint8_t'
            (aMsg)->WriteSentinel(771753428);
            return;
        }
    case union__::TnsCString:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_nsCString());
            // Sentinel = 'TnsCString'
            (aMsg)->WriteSentinel(353960944);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<SendableData>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef SendableData union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union SendableData");
        return false;
    }
    // Sentinel = 'SendableData'
    if ((!((aMsg)->ReadSentinel(aIter, 499778713)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union SendableData");
        return false;
    }

    switch (type) {
    case union__::TArrayOfuint8_t:
        {
            nsTArray<uint8_t> tmp;
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_ArrayOfuint8_t())))))) {
                aActor->FatalError("Error deserializing variant TArrayOfuint8_t of union SendableData");
                return false;
            }
            // Sentinel = 'TArrayOfuint8_t'
            if ((!((aMsg)->ReadSentinel(aIter, 771753428)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TArrayOfuint8_t of union SendableData");
                return false;
            }
            return true;
        }
    case union__::TnsCString:
        {
            nsCString tmp = nsCString();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_nsCString())))))) {
                aActor->FatalError("Error deserializing variant TnsCString of union SendableData");
                return false;
            }
            // Sentinel = 'TnsCString'
            if ((!((aMsg)->ReadSentinel(aIter, 353960944)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TnsCString of union SendableData");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union CallbackData|
//
auto CallbackData::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case Tvoid_t:
        {
            (ptr_void_t())->~void_t__tdef();
            break;
        }
    case TSendableData:
        {
            (ptr_SendableData())->~SendableData__tdef();
            break;
        }
    case TTCPError:
        {
            (ptr_TCPError())->~TCPError__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT CallbackData::CallbackData(const void_t& aOther)
{
    new (mozilla::KnownNotNull, ptr_void_t()) void_t(aOther);
    mType = Tvoid_t;
}

MOZ_IMPLICIT CallbackData::CallbackData(void_t&& aOther)
{
    new (mozilla::KnownNotNull, ptr_void_t()) void_t(std::move(aOther));
    mType = Tvoid_t;
}

MOZ_IMPLICIT CallbackData::CallbackData(const SendableData& aOther)
{
    new (mozilla::KnownNotNull, ptr_SendableData()) SendableData(aOther);
    mType = TSendableData;
}

MOZ_IMPLICIT CallbackData::CallbackData(SendableData&& aOther)
{
    new (mozilla::KnownNotNull, ptr_SendableData()) SendableData(std::move(aOther));
    mType = TSendableData;
}

MOZ_IMPLICIT CallbackData::CallbackData(const TCPError& aOther)
{
    new (mozilla::KnownNotNull, ptr_TCPError()) TCPError(aOther);
    mType = TTCPError;
}

MOZ_IMPLICIT CallbackData::CallbackData(TCPError&& aOther)
{
    new (mozilla::KnownNotNull, ptr_TCPError()) TCPError(std::move(aOther));
    mType = TTCPError;
}

MOZ_IMPLICIT CallbackData::CallbackData(const CallbackData& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case Tvoid_t:
        {
            new (mozilla::KnownNotNull, ptr_void_t()) void_t((aOther).get_void_t());
            break;
        }
    case TSendableData:
        {
            new (mozilla::KnownNotNull, ptr_SendableData()) SendableData((aOther).get_SendableData());
            break;
        }
    case TTCPError:
        {
            new (mozilla::KnownNotNull, ptr_TCPError()) TCPError((aOther).get_TCPError());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT CallbackData::CallbackData(CallbackData&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case Tvoid_t:
        {
            new (mozilla::KnownNotNull, ptr_void_t()) void_t(std::move((aOther).get_void_t()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TSendableData:
        {
            new (mozilla::KnownNotNull, ptr_SendableData()) SendableData(std::move((aOther).get_SendableData()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TTCPError:
        {
            new (mozilla::KnownNotNull, ptr_TCPError()) TCPError(std::move((aOther).get_TCPError()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

CallbackData::~CallbackData()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto CallbackData::operator=(const void_t& aRhs) -> CallbackData&
{
    if (MaybeDestroy(Tvoid_t)) {
        new (mozilla::KnownNotNull, ptr_void_t()) void_t;
    }
    (*(ptr_void_t())) = aRhs;
    mType = Tvoid_t;
    return (*(this));
}

auto CallbackData::operator=(void_t&& aRhs) -> CallbackData&
{
    if (MaybeDestroy(Tvoid_t)) {
        new (mozilla::KnownNotNull, ptr_void_t()) void_t;
    }
    (*(ptr_void_t())) = std::move(aRhs);
    mType = Tvoid_t;
    return (*(this));
}

auto CallbackData::operator=(const SendableData& aRhs) -> CallbackData&
{
    if (MaybeDestroy(TSendableData)) {
        new (mozilla::KnownNotNull, ptr_SendableData()) SendableData;
    }
    (*(ptr_SendableData())) = aRhs;
    mType = TSendableData;
    return (*(this));
}

auto CallbackData::operator=(SendableData&& aRhs) -> CallbackData&
{
    if (MaybeDestroy(TSendableData)) {
        new (mozilla::KnownNotNull, ptr_SendableData()) SendableData;
    }
    (*(ptr_SendableData())) = std::move(aRhs);
    mType = TSendableData;
    return (*(this));
}

auto CallbackData::operator=(const TCPError& aRhs) -> CallbackData&
{
    if (MaybeDestroy(TTCPError)) {
        new (mozilla::KnownNotNull, ptr_TCPError()) TCPError;
    }
    (*(ptr_TCPError())) = aRhs;
    mType = TTCPError;
    return (*(this));
}

auto CallbackData::operator=(TCPError&& aRhs) -> CallbackData&
{
    if (MaybeDestroy(TTCPError)) {
        new (mozilla::KnownNotNull, ptr_TCPError()) TCPError;
    }
    (*(ptr_TCPError())) = std::move(aRhs);
    mType = TTCPError;
    return (*(this));
}

auto CallbackData::operator=(const CallbackData& aRhs) -> CallbackData&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case Tvoid_t:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_void_t()) void_t;
            }
            (*(ptr_void_t())) = (aRhs).get_void_t();
            break;
        }
    case TSendableData:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_SendableData()) SendableData;
            }
            (*(ptr_SendableData())) = (aRhs).get_SendableData();
            break;
        }
    case TTCPError:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_TCPError()) TCPError;
            }
            (*(ptr_TCPError())) = (aRhs).get_TCPError();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto CallbackData::operator=(CallbackData&& aRhs) -> CallbackData&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case Tvoid_t:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_void_t()) void_t;
            }
            (*(ptr_void_t())) = std::move((aRhs).get_void_t());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TSendableData:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_SendableData()) SendableData;
            }
            (*(ptr_SendableData())) = std::move((aRhs).get_SendableData());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TTCPError:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_TCPError()) TCPError;
            }
            (*(ptr_TCPError())) = std::move((aRhs).get_TCPError());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}


namespace mozilla {
namespace ipc {
auto IPDLParamTraits<CallbackData>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef CallbackData union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'CallbackData'
    (aMsg)->WriteSentinel(486212744);

    switch (type) {
    case union__::Tvoid_t:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_void_t());
            // Sentinel = 'Tvoid_t'
            (aMsg)->WriteSentinel(189006554);
            return;
        }
    case union__::TSendableData:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_SendableData());
            // Sentinel = 'TSendableData'
            (aMsg)->WriteSentinel(571409645);
            return;
        }
    case union__::TTCPError:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_TCPError());
            // Sentinel = 'TTCPError'
            (aMsg)->WriteSentinel(253297478);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<CallbackData>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef CallbackData union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union CallbackData");
        return false;
    }
    // Sentinel = 'CallbackData'
    if ((!((aMsg)->ReadSentinel(aIter, 486212744)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union CallbackData");
        return false;
    }

    switch (type) {
    case union__::Tvoid_t:
        {
            mozilla::void_t tmp = mozilla::void_t();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_void_t())))))) {
                aActor->FatalError("Error deserializing variant Tvoid_t of union CallbackData");
                return false;
            }
            // Sentinel = 'Tvoid_t'
            if ((!((aMsg)->ReadSentinel(aIter, 189006554)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant Tvoid_t of union CallbackData");
                return false;
            }
            return true;
        }
    case union__::TSendableData:
        {
            SendableData tmp = SendableData();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_SendableData())))))) {
                aActor->FatalError("Error deserializing variant TSendableData of union CallbackData");
                return false;
            }
            // Sentinel = 'TSendableData'
            if ((!((aMsg)->ReadSentinel(aIter, 571409645)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TSendableData of union CallbackData");
                return false;
            }
            return true;
        }
    case union__::TTCPError:
        {
            TCPError tmp = TCPError();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_TCPError())))))) {
                aActor->FatalError("Error deserializing variant TTCPError of union CallbackData");
                return false;
            }
            // Sentinel = 'TTCPError'
            if ((!((aMsg)->ReadSentinel(aIter, 253297478)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TTCPError of union CallbackData");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla
