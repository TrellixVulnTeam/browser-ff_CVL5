//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/GfxMessageUtils.h"
#include "mozilla/dom/IPCBlobUtils.h"
#include "mozilla/PresState.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"


//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct SelectContentData|
//
namespace mozilla {
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::SelectContentData>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).indices());
    // Sentinel = 'indices'
    (aMsg)->WriteSentinel(192414432);
    WriteIPDLParam(aMsg, aActor, (aVar).values());
    // Sentinel = 'values'
    (aMsg)->WriteSentinel(150667921);
}

auto IPDLParamTraits<mozilla::SelectContentData>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->indices())))))) {
        aActor->FatalError("Error deserializing 'indices' (uint32_t[]) member of 'SelectContentData'");
        return false;
    }
    // Sentinel = 'indices'
    if ((!((aMsg)->ReadSentinel(aIter, 192414432)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'indices' (uint32_t[]) member of 'SelectContentData'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->values())))))) {
        aActor->FatalError("Error deserializing 'values' (nsString[]) member of 'SelectContentData'");
        return false;
    }
    // Sentinel = 'values'
    if ((!((aMsg)->ReadSentinel(aIter, 150667921)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'values' (nsString[]) member of 'SelectContentData'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct CheckedContentData|
//
namespace mozilla {
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::CheckedContentData>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).checked());
    // Sentinel = 'checked'
    (aMsg)->WriteSentinel(186647240);
}

auto IPDLParamTraits<mozilla::CheckedContentData>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->checked())))))) {
        aActor->FatalError("Error deserializing 'checked' (bool) member of 'CheckedContentData'");
        return false;
    }
    // Sentinel = 'checked'
    if ((!((aMsg)->ReadSentinel(aIter, 186647240)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'checked' (bool) member of 'CheckedContentData'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union FileContentData|
//
namespace mozilla {
auto FileContentData::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TBlobImpl:
        {
            (ptr_BlobImpl())->~BlobImpl__tdef();
            break;
        }
    case TnsString:
        {
            (ptr_nsString())->~nsString__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT FileContentData::FileContentData(BlobImpl* aOther)
{
    new (mozilla::KnownNotNull, ptr_BlobImpl()) RefPtr<BlobImpl>(aOther);
    mType = TBlobImpl;
}

MOZ_IMPLICIT FileContentData::FileContentData(RefPtr<BlobImpl>&& aOther)
{
    new (mozilla::KnownNotNull, ptr_BlobImpl()) RefPtr<BlobImpl>(std::move(aOther));
    mType = TBlobImpl;
}

MOZ_IMPLICIT FileContentData::FileContentData(const nsString& aOther)
{
    new (mozilla::KnownNotNull, ptr_nsString()) nsString(aOther);
    mType = TnsString;
}

MOZ_IMPLICIT FileContentData::FileContentData(nsString&& aOther)
{
    new (mozilla::KnownNotNull, ptr_nsString()) nsString(std::move(aOther));
    mType = TnsString;
}

MOZ_IMPLICIT FileContentData::FileContentData(const FileContentData& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TBlobImpl:
        {
            new (mozilla::KnownNotNull, ptr_BlobImpl()) RefPtr<BlobImpl>((aOther).get_BlobImpl());
            break;
        }
    case TnsString:
        {
            new (mozilla::KnownNotNull, ptr_nsString()) nsString((aOther).get_nsString());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT FileContentData::FileContentData(FileContentData&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TBlobImpl:
        {
            new (mozilla::KnownNotNull, ptr_BlobImpl()) RefPtr<BlobImpl>(std::move((aOther).get_BlobImpl()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TnsString:
        {
            new (mozilla::KnownNotNull, ptr_nsString()) nsString(std::move((aOther).get_nsString()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

FileContentData::~FileContentData()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto FileContentData::operator=(BlobImpl* aRhs) -> FileContentData&
{
    if (MaybeDestroy(TBlobImpl)) {
        new (mozilla::KnownNotNull, ptr_BlobImpl()) RefPtr<BlobImpl>;
    }
    (*(ptr_BlobImpl())) = aRhs;
    mType = TBlobImpl;
    return (*(this));
}

auto FileContentData::operator=(RefPtr<BlobImpl>&& aRhs) -> FileContentData&
{
    if (MaybeDestroy(TBlobImpl)) {
        new (mozilla::KnownNotNull, ptr_BlobImpl()) RefPtr<BlobImpl>;
    }
    (*(ptr_BlobImpl())) = std::move(aRhs);
    mType = TBlobImpl;
    return (*(this));
}

auto FileContentData::operator=(const nsString& aRhs) -> FileContentData&
{
    if (MaybeDestroy(TnsString)) {
        new (mozilla::KnownNotNull, ptr_nsString()) nsString;
    }
    (*(ptr_nsString())) = aRhs;
    mType = TnsString;
    return (*(this));
}

auto FileContentData::operator=(nsString&& aRhs) -> FileContentData&
{
    if (MaybeDestroy(TnsString)) {
        new (mozilla::KnownNotNull, ptr_nsString()) nsString;
    }
    (*(ptr_nsString())) = std::move(aRhs);
    mType = TnsString;
    return (*(this));
}

auto FileContentData::operator=(const FileContentData& aRhs) -> FileContentData&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TBlobImpl:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_BlobImpl()) RefPtr<BlobImpl>;
            }
            (*(ptr_BlobImpl())) = (aRhs).get_BlobImpl();
            break;
        }
    case TnsString:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_nsString()) nsString;
            }
            (*(ptr_nsString())) = (aRhs).get_nsString();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto FileContentData::operator=(FileContentData&& aRhs) -> FileContentData&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TBlobImpl:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_BlobImpl()) RefPtr<BlobImpl>;
            }
            (*(ptr_BlobImpl())) = std::move((aRhs).get_BlobImpl());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TnsString:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_nsString()) nsString;
            }
            (*(ptr_nsString())) = std::move((aRhs).get_nsString());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::FileContentData>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::FileContentData union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'FileContentData'
    (aMsg)->WriteSentinel(770377174);

    switch (type) {
    case union__::TBlobImpl:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_BlobImpl());
            // Sentinel = 'TBlobImpl'
            (aMsg)->WriteSentinel(272368486);
            return;
        }
    case union__::TnsString:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_nsString());
            // Sentinel = 'TnsString'
            (aMsg)->WriteSentinel(302908333);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::FileContentData>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::FileContentData union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union FileContentData");
        return false;
    }
    // Sentinel = 'FileContentData'
    if ((!((aMsg)->ReadSentinel(aIter, 770377174)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union FileContentData");
        return false;
    }

    switch (type) {
    case union__::TBlobImpl:
        {
            RefPtr<mozilla::dom::BlobImpl> tmp = RefPtr<mozilla::dom::BlobImpl>();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_BlobImpl())))))) {
                aActor->FatalError("Error deserializing variant TBlobImpl of union FileContentData");
                return false;
            }
            // Sentinel = 'TBlobImpl'
            if ((!((aMsg)->ReadSentinel(aIter, 272368486)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TBlobImpl of union FileContentData");
                return false;
            }
            return true;
        }
    case union__::TnsString:
        {
            nsString tmp = nsString();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_nsString())))))) {
                aActor->FatalError("Error deserializing variant TnsString of union FileContentData");
                return false;
            }
            // Sentinel = 'TnsString'
            if ((!((aMsg)->ReadSentinel(aIter, 302908333)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TnsString of union FileContentData");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct TextContentData|
//
namespace mozilla {
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::TextContentData>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).value());
    // Sentinel = 'value'
    (aMsg)->WriteSentinel(107610654);
    WriteIPDLParam(aMsg, aActor, (aVar).lastValueChangeWasInteractive());
    // Sentinel = 'lastValueChangeWasInteractive'
    (aMsg)->WriteSentinel(2906852257);
}

auto IPDLParamTraits<mozilla::TextContentData>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->value())))))) {
        aActor->FatalError("Error deserializing 'value' (nsString) member of 'TextContentData'");
        return false;
    }
    // Sentinel = 'value'
    if ((!((aMsg)->ReadSentinel(aIter, 107610654)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'value' (nsString) member of 'TextContentData'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->lastValueChangeWasInteractive())))))) {
        aActor->FatalError("Error deserializing 'lastValueChangeWasInteractive' (bool) member of 'TextContentData'");
        return false;
    }
    // Sentinel = 'lastValueChangeWasInteractive'
    if ((!((aMsg)->ReadSentinel(aIter, 2906852257)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'lastValueChangeWasInteractive' (bool) member of 'TextContentData'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union PresContentData|
//
namespace mozilla {
auto PresContentData::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case Tvoid_t:
        {
            (ptr_void_t())->~void_t__tdef();
            break;
        }
    case TTextContentData:
        {
            (ptr_TextContentData())->~TextContentData__tdef();
            break;
        }
    case TSelectContentData:
        {
            (ptr_SelectContentData())->~SelectContentData__tdef();
            break;
        }
    case TCheckedContentData:
        {
            (ptr_CheckedContentData())->~CheckedContentData__tdef();
            break;
        }
    case TArrayOfFileContentData:
        {
            (ptr_ArrayOfFileContentData())->~ArrayOfFileContentData__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT PresContentData::PresContentData(const void_t& aOther)
{
    new (mozilla::KnownNotNull, ptr_void_t()) void_t(aOther);
    mType = Tvoid_t;
}

MOZ_IMPLICIT PresContentData::PresContentData(void_t&& aOther)
{
    new (mozilla::KnownNotNull, ptr_void_t()) void_t(std::move(aOther));
    mType = Tvoid_t;
}

MOZ_IMPLICIT PresContentData::PresContentData(const TextContentData& aOther)
{
    new (mozilla::KnownNotNull, ptr_TextContentData()) TextContentData(aOther);
    mType = TTextContentData;
}

MOZ_IMPLICIT PresContentData::PresContentData(TextContentData&& aOther)
{
    new (mozilla::KnownNotNull, ptr_TextContentData()) TextContentData(std::move(aOther));
    mType = TTextContentData;
}

MOZ_IMPLICIT PresContentData::PresContentData(const SelectContentData& aOther)
{
    new (mozilla::KnownNotNull, ptr_SelectContentData()) SelectContentData(aOther);
    mType = TSelectContentData;
}

MOZ_IMPLICIT PresContentData::PresContentData(SelectContentData&& aOther)
{
    new (mozilla::KnownNotNull, ptr_SelectContentData()) SelectContentData(std::move(aOther));
    mType = TSelectContentData;
}

MOZ_IMPLICIT PresContentData::PresContentData(const CheckedContentData& aOther)
{
    new (mozilla::KnownNotNull, ptr_CheckedContentData()) CheckedContentData(aOther);
    mType = TCheckedContentData;
}

MOZ_IMPLICIT PresContentData::PresContentData(CheckedContentData&& aOther)
{
    new (mozilla::KnownNotNull, ptr_CheckedContentData()) CheckedContentData(std::move(aOther));
    mType = TCheckedContentData;
}

MOZ_IMPLICIT PresContentData::PresContentData(const nsTArray<FileContentData>& aOther)
{
    new (mozilla::KnownNotNull, ptr_ArrayOfFileContentData()) nsTArray<FileContentData>((aOther).Clone());
    mType = TArrayOfFileContentData;
}

MOZ_IMPLICIT PresContentData::PresContentData(nsTArray<FileContentData>&& aOther)
{
    new (mozilla::KnownNotNull, ptr_ArrayOfFileContentData()) nsTArray<FileContentData>(std::move(aOther));
    mType = TArrayOfFileContentData;
}

MOZ_IMPLICIT PresContentData::PresContentData(const PresContentData& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case Tvoid_t:
        {
            new (mozilla::KnownNotNull, ptr_void_t()) void_t((aOther).get_void_t());
            break;
        }
    case TTextContentData:
        {
            new (mozilla::KnownNotNull, ptr_TextContentData()) TextContentData((aOther).get_TextContentData());
            break;
        }
    case TSelectContentData:
        {
            new (mozilla::KnownNotNull, ptr_SelectContentData()) SelectContentData((aOther).get_SelectContentData());
            break;
        }
    case TCheckedContentData:
        {
            new (mozilla::KnownNotNull, ptr_CheckedContentData()) CheckedContentData((aOther).get_CheckedContentData());
            break;
        }
    case TArrayOfFileContentData:
        {
            new (mozilla::KnownNotNull, ptr_ArrayOfFileContentData()) nsTArray<FileContentData>(((aOther).get_ArrayOfFileContentData()).Clone());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT PresContentData::PresContentData(PresContentData&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case Tvoid_t:
        {
            new (mozilla::KnownNotNull, ptr_void_t()) void_t(std::move((aOther).get_void_t()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TTextContentData:
        {
            new (mozilla::KnownNotNull, ptr_TextContentData()) TextContentData(std::move((aOther).get_TextContentData()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TSelectContentData:
        {
            new (mozilla::KnownNotNull, ptr_SelectContentData()) SelectContentData(std::move((aOther).get_SelectContentData()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TCheckedContentData:
        {
            new (mozilla::KnownNotNull, ptr_CheckedContentData()) CheckedContentData(std::move((aOther).get_CheckedContentData()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TArrayOfFileContentData:
        {
            new (mozilla::KnownNotNull, ptr_ArrayOfFileContentData()) nsTArray<FileContentData>(std::move((aOther).get_ArrayOfFileContentData()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

PresContentData::~PresContentData()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto PresContentData::operator=(const void_t& aRhs) -> PresContentData&
{
    if (MaybeDestroy(Tvoid_t)) {
        new (mozilla::KnownNotNull, ptr_void_t()) void_t;
    }
    (*(ptr_void_t())) = aRhs;
    mType = Tvoid_t;
    return (*(this));
}

auto PresContentData::operator=(void_t&& aRhs) -> PresContentData&
{
    if (MaybeDestroy(Tvoid_t)) {
        new (mozilla::KnownNotNull, ptr_void_t()) void_t;
    }
    (*(ptr_void_t())) = std::move(aRhs);
    mType = Tvoid_t;
    return (*(this));
}

auto PresContentData::operator=(const TextContentData& aRhs) -> PresContentData&
{
    if (MaybeDestroy(TTextContentData)) {
        new (mozilla::KnownNotNull, ptr_TextContentData()) TextContentData;
    }
    (*(ptr_TextContentData())) = aRhs;
    mType = TTextContentData;
    return (*(this));
}

auto PresContentData::operator=(TextContentData&& aRhs) -> PresContentData&
{
    if (MaybeDestroy(TTextContentData)) {
        new (mozilla::KnownNotNull, ptr_TextContentData()) TextContentData;
    }
    (*(ptr_TextContentData())) = std::move(aRhs);
    mType = TTextContentData;
    return (*(this));
}

auto PresContentData::operator=(const SelectContentData& aRhs) -> PresContentData&
{
    if (MaybeDestroy(TSelectContentData)) {
        new (mozilla::KnownNotNull, ptr_SelectContentData()) SelectContentData;
    }
    (*(ptr_SelectContentData())) = aRhs;
    mType = TSelectContentData;
    return (*(this));
}

auto PresContentData::operator=(SelectContentData&& aRhs) -> PresContentData&
{
    if (MaybeDestroy(TSelectContentData)) {
        new (mozilla::KnownNotNull, ptr_SelectContentData()) SelectContentData;
    }
    (*(ptr_SelectContentData())) = std::move(aRhs);
    mType = TSelectContentData;
    return (*(this));
}

auto PresContentData::operator=(const CheckedContentData& aRhs) -> PresContentData&
{
    if (MaybeDestroy(TCheckedContentData)) {
        new (mozilla::KnownNotNull, ptr_CheckedContentData()) CheckedContentData;
    }
    (*(ptr_CheckedContentData())) = aRhs;
    mType = TCheckedContentData;
    return (*(this));
}

auto PresContentData::operator=(CheckedContentData&& aRhs) -> PresContentData&
{
    if (MaybeDestroy(TCheckedContentData)) {
        new (mozilla::KnownNotNull, ptr_CheckedContentData()) CheckedContentData;
    }
    (*(ptr_CheckedContentData())) = std::move(aRhs);
    mType = TCheckedContentData;
    return (*(this));
}

auto PresContentData::operator=(const nsTArray<FileContentData>& aRhs) -> PresContentData&
{
    if (MaybeDestroy(TArrayOfFileContentData)) {
        new (mozilla::KnownNotNull, ptr_ArrayOfFileContentData()) nsTArray<FileContentData>;
    }
    (*(ptr_ArrayOfFileContentData())) = (aRhs).Clone();
    mType = TArrayOfFileContentData;
    return (*(this));
}

auto PresContentData::operator=(nsTArray<FileContentData>&& aRhs) -> PresContentData&
{
    if (MaybeDestroy(TArrayOfFileContentData)) {
        new (mozilla::KnownNotNull, ptr_ArrayOfFileContentData()) nsTArray<FileContentData>;
    }
    (*(ptr_ArrayOfFileContentData())) = std::move(aRhs);
    mType = TArrayOfFileContentData;
    return (*(this));
}

auto PresContentData::operator=(const PresContentData& aRhs) -> PresContentData&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case Tvoid_t:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_void_t()) void_t;
            }
            (*(ptr_void_t())) = (aRhs).get_void_t();
            break;
        }
    case TTextContentData:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_TextContentData()) TextContentData;
            }
            (*(ptr_TextContentData())) = (aRhs).get_TextContentData();
            break;
        }
    case TSelectContentData:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_SelectContentData()) SelectContentData;
            }
            (*(ptr_SelectContentData())) = (aRhs).get_SelectContentData();
            break;
        }
    case TCheckedContentData:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_CheckedContentData()) CheckedContentData;
            }
            (*(ptr_CheckedContentData())) = (aRhs).get_CheckedContentData();
            break;
        }
    case TArrayOfFileContentData:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ArrayOfFileContentData()) nsTArray<FileContentData>;
            }
            (*(ptr_ArrayOfFileContentData())) = ((aRhs).get_ArrayOfFileContentData()).Clone();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto PresContentData::operator=(PresContentData&& aRhs) -> PresContentData&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case Tvoid_t:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_void_t()) void_t;
            }
            (*(ptr_void_t())) = std::move((aRhs).get_void_t());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TTextContentData:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_TextContentData()) TextContentData;
            }
            (*(ptr_TextContentData())) = std::move((aRhs).get_TextContentData());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TSelectContentData:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_SelectContentData()) SelectContentData;
            }
            (*(ptr_SelectContentData())) = std::move((aRhs).get_SelectContentData());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TCheckedContentData:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_CheckedContentData()) CheckedContentData;
            }
            (*(ptr_CheckedContentData())) = std::move((aRhs).get_CheckedContentData());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TArrayOfFileContentData:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ArrayOfFileContentData()) nsTArray<FileContentData>;
            }
            (*(ptr_ArrayOfFileContentData())) = std::move((aRhs).get_ArrayOfFileContentData());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::PresContentData>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::PresContentData union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'PresContentData'
    (aMsg)->WriteSentinel(793511408);

    switch (type) {
    case union__::Tvoid_t:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_void_t());
            // Sentinel = 'Tvoid_t'
            (aMsg)->WriteSentinel(189006554);
            return;
        }
    case union__::TTextContentData:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_TextContentData());
            // Sentinel = 'TTextContentData'
            (aMsg)->WriteSentinel(890635855);
            return;
        }
    case union__::TSelectContentData:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_SelectContentData());
            // Sentinel = 'TSelectContentData'
            (aMsg)->WriteSentinel(1105856266);
            return;
        }
    case union__::TCheckedContentData:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_CheckedContentData());
            // Sentinel = 'TCheckedContentData'
            (aMsg)->WriteSentinel(1199638353);
            return;
        }
    case union__::TArrayOfFileContentData:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_ArrayOfFileContentData());
            // Sentinel = 'TArrayOfFileContentData'
            (aMsg)->WriteSentinel(1756039390);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::PresContentData>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::PresContentData union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union PresContentData");
        return false;
    }
    // Sentinel = 'PresContentData'
    if ((!((aMsg)->ReadSentinel(aIter, 793511408)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union PresContentData");
        return false;
    }

    switch (type) {
    case union__::Tvoid_t:
        {
            mozilla::void_t tmp = mozilla::void_t();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_void_t())))))) {
                aActor->FatalError("Error deserializing variant Tvoid_t of union PresContentData");
                return false;
            }
            // Sentinel = 'Tvoid_t'
            if ((!((aMsg)->ReadSentinel(aIter, 189006554)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant Tvoid_t of union PresContentData");
                return false;
            }
            return true;
        }
    case union__::TTextContentData:
        {
            mozilla::TextContentData tmp = mozilla::TextContentData();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_TextContentData())))))) {
                aActor->FatalError("Error deserializing variant TTextContentData of union PresContentData");
                return false;
            }
            // Sentinel = 'TTextContentData'
            if ((!((aMsg)->ReadSentinel(aIter, 890635855)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TTextContentData of union PresContentData");
                return false;
            }
            return true;
        }
    case union__::TSelectContentData:
        {
            mozilla::SelectContentData tmp = mozilla::SelectContentData();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_SelectContentData())))))) {
                aActor->FatalError("Error deserializing variant TSelectContentData of union PresContentData");
                return false;
            }
            // Sentinel = 'TSelectContentData'
            if ((!((aMsg)->ReadSentinel(aIter, 1105856266)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TSelectContentData of union PresContentData");
                return false;
            }
            return true;
        }
    case union__::TCheckedContentData:
        {
            mozilla::CheckedContentData tmp = mozilla::CheckedContentData();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_CheckedContentData())))))) {
                aActor->FatalError("Error deserializing variant TCheckedContentData of union PresContentData");
                return false;
            }
            // Sentinel = 'TCheckedContentData'
            if ((!((aMsg)->ReadSentinel(aIter, 1199638353)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TCheckedContentData of union PresContentData");
                return false;
            }
            return true;
        }
    case union__::TArrayOfFileContentData:
        {
            nsTArray<mozilla::FileContentData> tmp;
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_ArrayOfFileContentData())))))) {
                aActor->FatalError("Error deserializing variant TArrayOfFileContentData of union PresContentData");
                return false;
            }
            // Sentinel = 'TArrayOfFileContentData'
            if ((!((aMsg)->ReadSentinel(aIter, 1756039390)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TArrayOfFileContentData of union PresContentData");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct PresState|
//
namespace mozilla {
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::PresState>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).contentData());
    // Sentinel = 'contentData'
    (aMsg)->WriteSentinel(456590454);
    WriteIPDLParam(aMsg, aActor, (aVar).scrollState());
    // Sentinel = 'scrollState'
    (aMsg)->WriteSentinel(464454801);
    WriteIPDLParam(aMsg, aActor, (aVar).allowScrollOriginDowngrade());
    // Sentinel = 'allowScrollOriginDowngrade'
    (aMsg)->WriteSentinel(2402224786);
    WriteIPDLParam(aMsg, aActor, (aVar).disabledSet());
    // Sentinel = 'disabledSet'
    (aMsg)->WriteSentinel(444204133);
    WriteIPDLParam(aMsg, aActor, (aVar).disabled());
    // Sentinel = 'disabled'
    (aMsg)->WriteSentinel(244843321);
    WriteIPDLParam(aMsg, aActor, (aVar).droppedDown());
    // Sentinel = 'droppedDown'
    (aMsg)->WriteSentinel(458032263);
    (aMsg)->WriteBytes((&((aVar).resolution())), 4);
    // Sentinel = 'resolution'
    (aMsg)->WriteSentinel(399770709);
}

auto IPDLParamTraits<mozilla::PresState>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->contentData())))))) {
        aActor->FatalError("Error deserializing 'contentData' (PresContentData) member of 'PresState'");
        return false;
    }
    // Sentinel = 'contentData'
    if ((!((aMsg)->ReadSentinel(aIter, 456590454)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'contentData' (PresContentData) member of 'PresState'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->scrollState())))))) {
        aActor->FatalError("Error deserializing 'scrollState' (nsPoint) member of 'PresState'");
        return false;
    }
    // Sentinel = 'scrollState'
    if ((!((aMsg)->ReadSentinel(aIter, 464454801)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'scrollState' (nsPoint) member of 'PresState'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->allowScrollOriginDowngrade())))))) {
        aActor->FatalError("Error deserializing 'allowScrollOriginDowngrade' (bool) member of 'PresState'");
        return false;
    }
    // Sentinel = 'allowScrollOriginDowngrade'
    if ((!((aMsg)->ReadSentinel(aIter, 2402224786)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'allowScrollOriginDowngrade' (bool) member of 'PresState'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->disabledSet())))))) {
        aActor->FatalError("Error deserializing 'disabledSet' (bool) member of 'PresState'");
        return false;
    }
    // Sentinel = 'disabledSet'
    if ((!((aMsg)->ReadSentinel(aIter, 444204133)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'disabledSet' (bool) member of 'PresState'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->disabled())))))) {
        aActor->FatalError("Error deserializing 'disabled' (bool) member of 'PresState'");
        return false;
    }
    // Sentinel = 'disabled'
    if ((!((aMsg)->ReadSentinel(aIter, 244843321)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'disabled' (bool) member of 'PresState'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->droppedDown())))))) {
        aActor->FatalError("Error deserializing 'droppedDown' (bool) member of 'PresState'");
        return false;
    }
    // Sentinel = 'droppedDown'
    if ((!((aMsg)->ReadSentinel(aIter, 458032263)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'droppedDown' (bool) member of 'PresState'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->resolution())), 4)))) {
        aActor->FatalError("Error bulk reading fields from float");
        return false;
    }
    // Sentinel = 'resolution'
    if ((!((aMsg)->ReadSentinel(aIter, 399770709)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from float");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla
