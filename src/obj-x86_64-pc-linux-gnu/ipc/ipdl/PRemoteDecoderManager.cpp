//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/MediaIPCUtils.h"
#include "mozilla/layers/LayersMessageUtils.h"
#include "mozilla/layers/PTextureParent.h"
#include "mozilla/layers/PTextureChild.h"
#include "mozilla/PRemoteDecoderParent.h"
#include "mozilla/PRemoteDecoderChild.h"
#include "mozilla/PRemoteDecoderManager.h"
#include "mozilla/PRemoteDecoderManagerParent.h"
#include "mozilla/PRemoteDecoderManagerChild.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace PRemoteDecoderManager {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::PRemoteDecoderManagerParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::PRemoteDecoderManagerChild>* aChild)
{
    return mozilla::ipc::CreateEndpoints(
        mozilla::ipc::PrivateIPDLInterface(),
        aParentDestPid, aChildDestPid,
        aParent, aChild);
}
IPC::Message*
Msg_PRemoteDecoderConstructor(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_PRemoteDecoderConstructor__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply_PRemoteDecoderConstructor(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply_PRemoteDecoderConstructor__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg_Readback(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Readback__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply_Readback(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply_Readback__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg_DeallocateSurfaceDescriptorGPUVideo(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_DeallocateSurfaceDescriptorGPUVideo__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}

} // namespace PRemoteDecoderManager
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct VideoDecoderInfoIPDL|
//
namespace mozilla {
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::VideoDecoderInfoIPDL>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).videoInfo());
    // Sentinel = 'videoInfo'
    (aMsg)->WriteSentinel(308609956);
    (aMsg)->WriteBytes((&((aVar).framerate())), 4);
    // Sentinel = 'framerate'
    (aMsg)->WriteSentinel(311755704);
}

auto IPDLParamTraits<mozilla::VideoDecoderInfoIPDL>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->videoInfo())))))) {
        aActor->FatalError("Error deserializing 'videoInfo' (VideoInfo) member of 'VideoDecoderInfoIPDL'");
        return false;
    }
    // Sentinel = 'videoInfo'
    if ((!((aMsg)->ReadSentinel(aIter, 308609956)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'videoInfo' (VideoInfo) member of 'VideoDecoderInfoIPDL'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->framerate())), 4)))) {
        aActor->FatalError("Error bulk reading fields from float");
        return false;
    }
    // Sentinel = 'framerate'
    if ((!((aMsg)->ReadSentinel(aIter, 311755704)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from float");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union RemoteDecoderInfoIPDL|
//
namespace mozilla {
auto RemoteDecoderInfoIPDL::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TAudioInfo:
        {
            (ptr_AudioInfo())->~AudioInfo__tdef();
            break;
        }
    case TVideoDecoderInfoIPDL:
        {
            (ptr_VideoDecoderInfoIPDL())->~VideoDecoderInfoIPDL__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT RemoteDecoderInfoIPDL::RemoteDecoderInfoIPDL(const AudioInfo& aOther)
{
    new (mozilla::KnownNotNull, ptr_AudioInfo()) AudioInfo(aOther);
    mType = TAudioInfo;
}

MOZ_IMPLICIT RemoteDecoderInfoIPDL::RemoteDecoderInfoIPDL(AudioInfo&& aOther)
{
    new (mozilla::KnownNotNull, ptr_AudioInfo()) AudioInfo(std::move(aOther));
    mType = TAudioInfo;
}

MOZ_IMPLICIT RemoteDecoderInfoIPDL::RemoteDecoderInfoIPDL(const VideoDecoderInfoIPDL& aOther)
{
    new (mozilla::KnownNotNull, ptr_VideoDecoderInfoIPDL()) VideoDecoderInfoIPDL(aOther);
    mType = TVideoDecoderInfoIPDL;
}

MOZ_IMPLICIT RemoteDecoderInfoIPDL::RemoteDecoderInfoIPDL(VideoDecoderInfoIPDL&& aOther)
{
    new (mozilla::KnownNotNull, ptr_VideoDecoderInfoIPDL()) VideoDecoderInfoIPDL(std::move(aOther));
    mType = TVideoDecoderInfoIPDL;
}

MOZ_IMPLICIT RemoteDecoderInfoIPDL::RemoteDecoderInfoIPDL(const RemoteDecoderInfoIPDL& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TAudioInfo:
        {
            new (mozilla::KnownNotNull, ptr_AudioInfo()) AudioInfo((aOther).get_AudioInfo());
            break;
        }
    case TVideoDecoderInfoIPDL:
        {
            new (mozilla::KnownNotNull, ptr_VideoDecoderInfoIPDL()) VideoDecoderInfoIPDL((aOther).get_VideoDecoderInfoIPDL());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT RemoteDecoderInfoIPDL::RemoteDecoderInfoIPDL(RemoteDecoderInfoIPDL&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TAudioInfo:
        {
            new (mozilla::KnownNotNull, ptr_AudioInfo()) AudioInfo(std::move((aOther).get_AudioInfo()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TVideoDecoderInfoIPDL:
        {
            new (mozilla::KnownNotNull, ptr_VideoDecoderInfoIPDL()) VideoDecoderInfoIPDL(std::move((aOther).get_VideoDecoderInfoIPDL()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

RemoteDecoderInfoIPDL::~RemoteDecoderInfoIPDL()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto RemoteDecoderInfoIPDL::operator=(const AudioInfo& aRhs) -> RemoteDecoderInfoIPDL&
{
    if (MaybeDestroy(TAudioInfo)) {
        new (mozilla::KnownNotNull, ptr_AudioInfo()) AudioInfo;
    }
    (*(ptr_AudioInfo())) = aRhs;
    mType = TAudioInfo;
    return (*(this));
}

auto RemoteDecoderInfoIPDL::operator=(AudioInfo&& aRhs) -> RemoteDecoderInfoIPDL&
{
    if (MaybeDestroy(TAudioInfo)) {
        new (mozilla::KnownNotNull, ptr_AudioInfo()) AudioInfo;
    }
    (*(ptr_AudioInfo())) = std::move(aRhs);
    mType = TAudioInfo;
    return (*(this));
}

auto RemoteDecoderInfoIPDL::operator=(const VideoDecoderInfoIPDL& aRhs) -> RemoteDecoderInfoIPDL&
{
    if (MaybeDestroy(TVideoDecoderInfoIPDL)) {
        new (mozilla::KnownNotNull, ptr_VideoDecoderInfoIPDL()) VideoDecoderInfoIPDL;
    }
    (*(ptr_VideoDecoderInfoIPDL())) = aRhs;
    mType = TVideoDecoderInfoIPDL;
    return (*(this));
}

auto RemoteDecoderInfoIPDL::operator=(VideoDecoderInfoIPDL&& aRhs) -> RemoteDecoderInfoIPDL&
{
    if (MaybeDestroy(TVideoDecoderInfoIPDL)) {
        new (mozilla::KnownNotNull, ptr_VideoDecoderInfoIPDL()) VideoDecoderInfoIPDL;
    }
    (*(ptr_VideoDecoderInfoIPDL())) = std::move(aRhs);
    mType = TVideoDecoderInfoIPDL;
    return (*(this));
}

auto RemoteDecoderInfoIPDL::operator=(const RemoteDecoderInfoIPDL& aRhs) -> RemoteDecoderInfoIPDL&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TAudioInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_AudioInfo()) AudioInfo;
            }
            (*(ptr_AudioInfo())) = (aRhs).get_AudioInfo();
            break;
        }
    case TVideoDecoderInfoIPDL:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_VideoDecoderInfoIPDL()) VideoDecoderInfoIPDL;
            }
            (*(ptr_VideoDecoderInfoIPDL())) = (aRhs).get_VideoDecoderInfoIPDL();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto RemoteDecoderInfoIPDL::operator=(RemoteDecoderInfoIPDL&& aRhs) -> RemoteDecoderInfoIPDL&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TAudioInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_AudioInfo()) AudioInfo;
            }
            (*(ptr_AudioInfo())) = std::move((aRhs).get_AudioInfo());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TVideoDecoderInfoIPDL:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_VideoDecoderInfoIPDL()) VideoDecoderInfoIPDL;
            }
            (*(ptr_VideoDecoderInfoIPDL())) = std::move((aRhs).get_VideoDecoderInfoIPDL());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::RemoteDecoderInfoIPDL>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::RemoteDecoderInfoIPDL union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'RemoteDecoderInfoIPDL'
    (aMsg)->WriteSentinel(1499072472);

    switch (type) {
    case union__::TAudioInfo:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_AudioInfo());
            // Sentinel = 'TAudioInfo'
            (aMsg)->WriteSentinel(340329427);
            return;
        }
    case union__::TVideoDecoderInfoIPDL:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_VideoDecoderInfoIPDL());
            // Sentinel = 'TVideoDecoderInfoIPDL'
            (aMsg)->WriteSentinel(1457981367);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::RemoteDecoderInfoIPDL>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::RemoteDecoderInfoIPDL union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union RemoteDecoderInfoIPDL");
        return false;
    }
    // Sentinel = 'RemoteDecoderInfoIPDL'
    if ((!((aMsg)->ReadSentinel(aIter, 1499072472)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union RemoteDecoderInfoIPDL");
        return false;
    }

    switch (type) {
    case union__::TAudioInfo:
        {
            AudioInfo tmp = AudioInfo();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_AudioInfo())))))) {
                aActor->FatalError("Error deserializing variant TAudioInfo of union RemoteDecoderInfoIPDL");
                return false;
            }
            // Sentinel = 'TAudioInfo'
            if ((!((aMsg)->ReadSentinel(aIter, 340329427)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TAudioInfo of union RemoteDecoderInfoIPDL");
                return false;
            }
            return true;
        }
    case union__::TVideoDecoderInfoIPDL:
        {
            mozilla::VideoDecoderInfoIPDL tmp = mozilla::VideoDecoderInfoIPDL();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_VideoDecoderInfoIPDL())))))) {
                aActor->FatalError("Error deserializing variant TVideoDecoderInfoIPDL of union RemoteDecoderInfoIPDL");
                return false;
            }
            // Sentinel = 'TVideoDecoderInfoIPDL'
            if ((!((aMsg)->ReadSentinel(aIter, 1457981367)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TVideoDecoderInfoIPDL of union RemoteDecoderInfoIPDL");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla
