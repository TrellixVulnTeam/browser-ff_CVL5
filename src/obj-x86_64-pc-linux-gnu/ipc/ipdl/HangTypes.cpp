//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/HangTypes.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"


//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct HangEntryBufOffset|
//
namespace mozilla {
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::HangEntryBufOffset>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    (aMsg)->WriteBytes((&((aVar).index())), 4);
    // Sentinel = 'index'
    (aMsg)->WriteSentinel(104333849);
}

auto IPDLParamTraits<mozilla::HangEntryBufOffset>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->index())), 4)))) {
        aActor->FatalError("Error bulk reading fields from uint32_t");
        return false;
    }
    // Sentinel = 'index'
    if ((!((aMsg)->ReadSentinel(aIter, 104333849)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint32_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct HangEntryModOffset|
//
namespace mozilla {
auto HangEntryModOffset::StaticAssertions() const -> void
{
    static_assert(
        (offsetof(HangEntryModOffset, offset_) - offsetof(HangEntryModOffset, module_)) == 4,
        "Bad assumptions about field layout!");
}

} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::HangEntryModOffset>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    (aMsg)->WriteBytes((&((aVar).module())), 8);
    // Sentinel = 'module | offset'
    (aMsg)->WriteSentinel(777061834);
}

auto IPDLParamTraits<mozilla::HangEntryModOffset>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->module())), 8)))) {
        aActor->FatalError("Error bulk reading fields from uint32_t");
        return false;
    }
    // Sentinel = 'module | offset'
    if ((!((aMsg)->ReadSentinel(aIter, 777061834)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint32_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct HangEntryProgCounter|
//
namespace mozilla {
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::HangEntryProgCounter>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).pc());
    // Sentinel = 'pc'
    (aMsg)->WriteSentinel(21299412);
}

auto IPDLParamTraits<mozilla::HangEntryProgCounter>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->pc())))))) {
        aActor->FatalError("Error deserializing 'pc' (uintptr_t) member of 'HangEntryProgCounter'");
        return false;
    }
    // Sentinel = 'pc'
    if ((!((aMsg)->ReadSentinel(aIter, 21299412)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'pc' (uintptr_t) member of 'HangEntryProgCounter'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct HangEntryContent|
//
namespace mozilla {
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::HangEntryContent>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
}

auto IPDLParamTraits<mozilla::HangEntryContent>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct HangEntryJit|
//
namespace mozilla {
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::HangEntryJit>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
}

auto IPDLParamTraits<mozilla::HangEntryJit>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct HangEntryWasm|
//
namespace mozilla {
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::HangEntryWasm>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
}

auto IPDLParamTraits<mozilla::HangEntryWasm>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct HangEntryChromeScript|
//
namespace mozilla {
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::HangEntryChromeScript>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
}

auto IPDLParamTraits<mozilla::HangEntryChromeScript>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct HangEntrySuppressed|
//
namespace mozilla {
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::HangEntrySuppressed>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
}

auto IPDLParamTraits<mozilla::HangEntrySuppressed>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union HangEntry|
//
namespace mozilla {
auto HangEntry::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TnsCString:
        {
            (ptr_nsCString())->~nsCString__tdef();
            break;
        }
    case THangEntryBufOffset:
        {
            (ptr_HangEntryBufOffset())->~HangEntryBufOffset__tdef();
            break;
        }
    case THangEntryModOffset:
        {
            (ptr_HangEntryModOffset())->~HangEntryModOffset__tdef();
            break;
        }
    case THangEntryProgCounter:
        {
            (ptr_HangEntryProgCounter())->~HangEntryProgCounter__tdef();
            break;
        }
    case THangEntryContent:
        {
            (ptr_HangEntryContent())->~HangEntryContent__tdef();
            break;
        }
    case THangEntryJit:
        {
            (ptr_HangEntryJit())->~HangEntryJit__tdef();
            break;
        }
    case THangEntryWasm:
        {
            (ptr_HangEntryWasm())->~HangEntryWasm__tdef();
            break;
        }
    case THangEntryChromeScript:
        {
            (ptr_HangEntryChromeScript())->~HangEntryChromeScript__tdef();
            break;
        }
    case THangEntrySuppressed:
        {
            (ptr_HangEntrySuppressed())->~HangEntrySuppressed__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT HangEntry::HangEntry(const nsCString& aOther)
{
    new (mozilla::KnownNotNull, ptr_nsCString()) nsCString(aOther);
    mType = TnsCString;
}

MOZ_IMPLICIT HangEntry::HangEntry(nsCString&& aOther)
{
    new (mozilla::KnownNotNull, ptr_nsCString()) nsCString(std::move(aOther));
    mType = TnsCString;
}

MOZ_IMPLICIT HangEntry::HangEntry(const HangEntryBufOffset& aOther)
{
    new (mozilla::KnownNotNull, ptr_HangEntryBufOffset()) HangEntryBufOffset(aOther);
    mType = THangEntryBufOffset;
}

MOZ_IMPLICIT HangEntry::HangEntry(HangEntryBufOffset&& aOther)
{
    new (mozilla::KnownNotNull, ptr_HangEntryBufOffset()) HangEntryBufOffset(std::move(aOther));
    mType = THangEntryBufOffset;
}

MOZ_IMPLICIT HangEntry::HangEntry(const HangEntryModOffset& aOther)
{
    new (mozilla::KnownNotNull, ptr_HangEntryModOffset()) HangEntryModOffset(aOther);
    mType = THangEntryModOffset;
}

MOZ_IMPLICIT HangEntry::HangEntry(HangEntryModOffset&& aOther)
{
    new (mozilla::KnownNotNull, ptr_HangEntryModOffset()) HangEntryModOffset(std::move(aOther));
    mType = THangEntryModOffset;
}

MOZ_IMPLICIT HangEntry::HangEntry(const HangEntryProgCounter& aOther)
{
    new (mozilla::KnownNotNull, ptr_HangEntryProgCounter()) HangEntryProgCounter(aOther);
    mType = THangEntryProgCounter;
}

MOZ_IMPLICIT HangEntry::HangEntry(HangEntryProgCounter&& aOther)
{
    new (mozilla::KnownNotNull, ptr_HangEntryProgCounter()) HangEntryProgCounter(std::move(aOther));
    mType = THangEntryProgCounter;
}

MOZ_IMPLICIT HangEntry::HangEntry(const HangEntryContent& aOther)
{
    new (mozilla::KnownNotNull, ptr_HangEntryContent()) HangEntryContent(aOther);
    mType = THangEntryContent;
}

MOZ_IMPLICIT HangEntry::HangEntry(HangEntryContent&& aOther)
{
    new (mozilla::KnownNotNull, ptr_HangEntryContent()) HangEntryContent(std::move(aOther));
    mType = THangEntryContent;
}

MOZ_IMPLICIT HangEntry::HangEntry(const HangEntryJit& aOther)
{
    new (mozilla::KnownNotNull, ptr_HangEntryJit()) HangEntryJit(aOther);
    mType = THangEntryJit;
}

MOZ_IMPLICIT HangEntry::HangEntry(HangEntryJit&& aOther)
{
    new (mozilla::KnownNotNull, ptr_HangEntryJit()) HangEntryJit(std::move(aOther));
    mType = THangEntryJit;
}

MOZ_IMPLICIT HangEntry::HangEntry(const HangEntryWasm& aOther)
{
    new (mozilla::KnownNotNull, ptr_HangEntryWasm()) HangEntryWasm(aOther);
    mType = THangEntryWasm;
}

MOZ_IMPLICIT HangEntry::HangEntry(HangEntryWasm&& aOther)
{
    new (mozilla::KnownNotNull, ptr_HangEntryWasm()) HangEntryWasm(std::move(aOther));
    mType = THangEntryWasm;
}

MOZ_IMPLICIT HangEntry::HangEntry(const HangEntryChromeScript& aOther)
{
    new (mozilla::KnownNotNull, ptr_HangEntryChromeScript()) HangEntryChromeScript(aOther);
    mType = THangEntryChromeScript;
}

MOZ_IMPLICIT HangEntry::HangEntry(HangEntryChromeScript&& aOther)
{
    new (mozilla::KnownNotNull, ptr_HangEntryChromeScript()) HangEntryChromeScript(std::move(aOther));
    mType = THangEntryChromeScript;
}

MOZ_IMPLICIT HangEntry::HangEntry(const HangEntrySuppressed& aOther)
{
    new (mozilla::KnownNotNull, ptr_HangEntrySuppressed()) HangEntrySuppressed(aOther);
    mType = THangEntrySuppressed;
}

MOZ_IMPLICIT HangEntry::HangEntry(HangEntrySuppressed&& aOther)
{
    new (mozilla::KnownNotNull, ptr_HangEntrySuppressed()) HangEntrySuppressed(std::move(aOther));
    mType = THangEntrySuppressed;
}

MOZ_IMPLICIT HangEntry::HangEntry(const HangEntry& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TnsCString:
        {
            new (mozilla::KnownNotNull, ptr_nsCString()) nsCString((aOther).get_nsCString());
            break;
        }
    case THangEntryBufOffset:
        {
            new (mozilla::KnownNotNull, ptr_HangEntryBufOffset()) HangEntryBufOffset((aOther).get_HangEntryBufOffset());
            break;
        }
    case THangEntryModOffset:
        {
            new (mozilla::KnownNotNull, ptr_HangEntryModOffset()) HangEntryModOffset((aOther).get_HangEntryModOffset());
            break;
        }
    case THangEntryProgCounter:
        {
            new (mozilla::KnownNotNull, ptr_HangEntryProgCounter()) HangEntryProgCounter((aOther).get_HangEntryProgCounter());
            break;
        }
    case THangEntryContent:
        {
            new (mozilla::KnownNotNull, ptr_HangEntryContent()) HangEntryContent((aOther).get_HangEntryContent());
            break;
        }
    case THangEntryJit:
        {
            new (mozilla::KnownNotNull, ptr_HangEntryJit()) HangEntryJit((aOther).get_HangEntryJit());
            break;
        }
    case THangEntryWasm:
        {
            new (mozilla::KnownNotNull, ptr_HangEntryWasm()) HangEntryWasm((aOther).get_HangEntryWasm());
            break;
        }
    case THangEntryChromeScript:
        {
            new (mozilla::KnownNotNull, ptr_HangEntryChromeScript()) HangEntryChromeScript((aOther).get_HangEntryChromeScript());
            break;
        }
    case THangEntrySuppressed:
        {
            new (mozilla::KnownNotNull, ptr_HangEntrySuppressed()) HangEntrySuppressed((aOther).get_HangEntrySuppressed());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT HangEntry::HangEntry(HangEntry&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TnsCString:
        {
            new (mozilla::KnownNotNull, ptr_nsCString()) nsCString(std::move((aOther).get_nsCString()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case THangEntryBufOffset:
        {
            new (mozilla::KnownNotNull, ptr_HangEntryBufOffset()) HangEntryBufOffset(std::move((aOther).get_HangEntryBufOffset()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case THangEntryModOffset:
        {
            new (mozilla::KnownNotNull, ptr_HangEntryModOffset()) HangEntryModOffset(std::move((aOther).get_HangEntryModOffset()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case THangEntryProgCounter:
        {
            new (mozilla::KnownNotNull, ptr_HangEntryProgCounter()) HangEntryProgCounter(std::move((aOther).get_HangEntryProgCounter()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case THangEntryContent:
        {
            new (mozilla::KnownNotNull, ptr_HangEntryContent()) HangEntryContent(std::move((aOther).get_HangEntryContent()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case THangEntryJit:
        {
            new (mozilla::KnownNotNull, ptr_HangEntryJit()) HangEntryJit(std::move((aOther).get_HangEntryJit()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case THangEntryWasm:
        {
            new (mozilla::KnownNotNull, ptr_HangEntryWasm()) HangEntryWasm(std::move((aOther).get_HangEntryWasm()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case THangEntryChromeScript:
        {
            new (mozilla::KnownNotNull, ptr_HangEntryChromeScript()) HangEntryChromeScript(std::move((aOther).get_HangEntryChromeScript()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case THangEntrySuppressed:
        {
            new (mozilla::KnownNotNull, ptr_HangEntrySuppressed()) HangEntrySuppressed(std::move((aOther).get_HangEntrySuppressed()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

HangEntry::~HangEntry()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto HangEntry::operator=(const nsCString& aRhs) -> HangEntry&
{
    if (MaybeDestroy(TnsCString)) {
        new (mozilla::KnownNotNull, ptr_nsCString()) nsCString;
    }
    (*(ptr_nsCString())) = aRhs;
    mType = TnsCString;
    return (*(this));
}

auto HangEntry::operator=(nsCString&& aRhs) -> HangEntry&
{
    if (MaybeDestroy(TnsCString)) {
        new (mozilla::KnownNotNull, ptr_nsCString()) nsCString;
    }
    (*(ptr_nsCString())) = std::move(aRhs);
    mType = TnsCString;
    return (*(this));
}

auto HangEntry::operator=(const HangEntryBufOffset& aRhs) -> HangEntry&
{
    if (MaybeDestroy(THangEntryBufOffset)) {
        new (mozilla::KnownNotNull, ptr_HangEntryBufOffset()) HangEntryBufOffset;
    }
    (*(ptr_HangEntryBufOffset())) = aRhs;
    mType = THangEntryBufOffset;
    return (*(this));
}

auto HangEntry::operator=(HangEntryBufOffset&& aRhs) -> HangEntry&
{
    if (MaybeDestroy(THangEntryBufOffset)) {
        new (mozilla::KnownNotNull, ptr_HangEntryBufOffset()) HangEntryBufOffset;
    }
    (*(ptr_HangEntryBufOffset())) = std::move(aRhs);
    mType = THangEntryBufOffset;
    return (*(this));
}

auto HangEntry::operator=(const HangEntryModOffset& aRhs) -> HangEntry&
{
    if (MaybeDestroy(THangEntryModOffset)) {
        new (mozilla::KnownNotNull, ptr_HangEntryModOffset()) HangEntryModOffset;
    }
    (*(ptr_HangEntryModOffset())) = aRhs;
    mType = THangEntryModOffset;
    return (*(this));
}

auto HangEntry::operator=(HangEntryModOffset&& aRhs) -> HangEntry&
{
    if (MaybeDestroy(THangEntryModOffset)) {
        new (mozilla::KnownNotNull, ptr_HangEntryModOffset()) HangEntryModOffset;
    }
    (*(ptr_HangEntryModOffset())) = std::move(aRhs);
    mType = THangEntryModOffset;
    return (*(this));
}

auto HangEntry::operator=(const HangEntryProgCounter& aRhs) -> HangEntry&
{
    if (MaybeDestroy(THangEntryProgCounter)) {
        new (mozilla::KnownNotNull, ptr_HangEntryProgCounter()) HangEntryProgCounter;
    }
    (*(ptr_HangEntryProgCounter())) = aRhs;
    mType = THangEntryProgCounter;
    return (*(this));
}

auto HangEntry::operator=(HangEntryProgCounter&& aRhs) -> HangEntry&
{
    if (MaybeDestroy(THangEntryProgCounter)) {
        new (mozilla::KnownNotNull, ptr_HangEntryProgCounter()) HangEntryProgCounter;
    }
    (*(ptr_HangEntryProgCounter())) = std::move(aRhs);
    mType = THangEntryProgCounter;
    return (*(this));
}

auto HangEntry::operator=(const HangEntryContent& aRhs) -> HangEntry&
{
    if (MaybeDestroy(THangEntryContent)) {
        new (mozilla::KnownNotNull, ptr_HangEntryContent()) HangEntryContent;
    }
    (*(ptr_HangEntryContent())) = aRhs;
    mType = THangEntryContent;
    return (*(this));
}

auto HangEntry::operator=(HangEntryContent&& aRhs) -> HangEntry&
{
    if (MaybeDestroy(THangEntryContent)) {
        new (mozilla::KnownNotNull, ptr_HangEntryContent()) HangEntryContent;
    }
    (*(ptr_HangEntryContent())) = std::move(aRhs);
    mType = THangEntryContent;
    return (*(this));
}

auto HangEntry::operator=(const HangEntryJit& aRhs) -> HangEntry&
{
    if (MaybeDestroy(THangEntryJit)) {
        new (mozilla::KnownNotNull, ptr_HangEntryJit()) HangEntryJit;
    }
    (*(ptr_HangEntryJit())) = aRhs;
    mType = THangEntryJit;
    return (*(this));
}

auto HangEntry::operator=(HangEntryJit&& aRhs) -> HangEntry&
{
    if (MaybeDestroy(THangEntryJit)) {
        new (mozilla::KnownNotNull, ptr_HangEntryJit()) HangEntryJit;
    }
    (*(ptr_HangEntryJit())) = std::move(aRhs);
    mType = THangEntryJit;
    return (*(this));
}

auto HangEntry::operator=(const HangEntryWasm& aRhs) -> HangEntry&
{
    if (MaybeDestroy(THangEntryWasm)) {
        new (mozilla::KnownNotNull, ptr_HangEntryWasm()) HangEntryWasm;
    }
    (*(ptr_HangEntryWasm())) = aRhs;
    mType = THangEntryWasm;
    return (*(this));
}

auto HangEntry::operator=(HangEntryWasm&& aRhs) -> HangEntry&
{
    if (MaybeDestroy(THangEntryWasm)) {
        new (mozilla::KnownNotNull, ptr_HangEntryWasm()) HangEntryWasm;
    }
    (*(ptr_HangEntryWasm())) = std::move(aRhs);
    mType = THangEntryWasm;
    return (*(this));
}

auto HangEntry::operator=(const HangEntryChromeScript& aRhs) -> HangEntry&
{
    if (MaybeDestroy(THangEntryChromeScript)) {
        new (mozilla::KnownNotNull, ptr_HangEntryChromeScript()) HangEntryChromeScript;
    }
    (*(ptr_HangEntryChromeScript())) = aRhs;
    mType = THangEntryChromeScript;
    return (*(this));
}

auto HangEntry::operator=(HangEntryChromeScript&& aRhs) -> HangEntry&
{
    if (MaybeDestroy(THangEntryChromeScript)) {
        new (mozilla::KnownNotNull, ptr_HangEntryChromeScript()) HangEntryChromeScript;
    }
    (*(ptr_HangEntryChromeScript())) = std::move(aRhs);
    mType = THangEntryChromeScript;
    return (*(this));
}

auto HangEntry::operator=(const HangEntrySuppressed& aRhs) -> HangEntry&
{
    if (MaybeDestroy(THangEntrySuppressed)) {
        new (mozilla::KnownNotNull, ptr_HangEntrySuppressed()) HangEntrySuppressed;
    }
    (*(ptr_HangEntrySuppressed())) = aRhs;
    mType = THangEntrySuppressed;
    return (*(this));
}

auto HangEntry::operator=(HangEntrySuppressed&& aRhs) -> HangEntry&
{
    if (MaybeDestroy(THangEntrySuppressed)) {
        new (mozilla::KnownNotNull, ptr_HangEntrySuppressed()) HangEntrySuppressed;
    }
    (*(ptr_HangEntrySuppressed())) = std::move(aRhs);
    mType = THangEntrySuppressed;
    return (*(this));
}

auto HangEntry::operator=(const HangEntry& aRhs) -> HangEntry&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TnsCString:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_nsCString()) nsCString;
            }
            (*(ptr_nsCString())) = (aRhs).get_nsCString();
            break;
        }
    case THangEntryBufOffset:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_HangEntryBufOffset()) HangEntryBufOffset;
            }
            (*(ptr_HangEntryBufOffset())) = (aRhs).get_HangEntryBufOffset();
            break;
        }
    case THangEntryModOffset:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_HangEntryModOffset()) HangEntryModOffset;
            }
            (*(ptr_HangEntryModOffset())) = (aRhs).get_HangEntryModOffset();
            break;
        }
    case THangEntryProgCounter:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_HangEntryProgCounter()) HangEntryProgCounter;
            }
            (*(ptr_HangEntryProgCounter())) = (aRhs).get_HangEntryProgCounter();
            break;
        }
    case THangEntryContent:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_HangEntryContent()) HangEntryContent;
            }
            (*(ptr_HangEntryContent())) = (aRhs).get_HangEntryContent();
            break;
        }
    case THangEntryJit:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_HangEntryJit()) HangEntryJit;
            }
            (*(ptr_HangEntryJit())) = (aRhs).get_HangEntryJit();
            break;
        }
    case THangEntryWasm:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_HangEntryWasm()) HangEntryWasm;
            }
            (*(ptr_HangEntryWasm())) = (aRhs).get_HangEntryWasm();
            break;
        }
    case THangEntryChromeScript:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_HangEntryChromeScript()) HangEntryChromeScript;
            }
            (*(ptr_HangEntryChromeScript())) = (aRhs).get_HangEntryChromeScript();
            break;
        }
    case THangEntrySuppressed:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_HangEntrySuppressed()) HangEntrySuppressed;
            }
            (*(ptr_HangEntrySuppressed())) = (aRhs).get_HangEntrySuppressed();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto HangEntry::operator=(HangEntry&& aRhs) -> HangEntry&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TnsCString:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_nsCString()) nsCString;
            }
            (*(ptr_nsCString())) = std::move((aRhs).get_nsCString());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case THangEntryBufOffset:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_HangEntryBufOffset()) HangEntryBufOffset;
            }
            (*(ptr_HangEntryBufOffset())) = std::move((aRhs).get_HangEntryBufOffset());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case THangEntryModOffset:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_HangEntryModOffset()) HangEntryModOffset;
            }
            (*(ptr_HangEntryModOffset())) = std::move((aRhs).get_HangEntryModOffset());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case THangEntryProgCounter:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_HangEntryProgCounter()) HangEntryProgCounter;
            }
            (*(ptr_HangEntryProgCounter())) = std::move((aRhs).get_HangEntryProgCounter());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case THangEntryContent:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_HangEntryContent()) HangEntryContent;
            }
            (*(ptr_HangEntryContent())) = std::move((aRhs).get_HangEntryContent());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case THangEntryJit:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_HangEntryJit()) HangEntryJit;
            }
            (*(ptr_HangEntryJit())) = std::move((aRhs).get_HangEntryJit());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case THangEntryWasm:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_HangEntryWasm()) HangEntryWasm;
            }
            (*(ptr_HangEntryWasm())) = std::move((aRhs).get_HangEntryWasm());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case THangEntryChromeScript:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_HangEntryChromeScript()) HangEntryChromeScript;
            }
            (*(ptr_HangEntryChromeScript())) = std::move((aRhs).get_HangEntryChromeScript());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case THangEntrySuppressed:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_HangEntrySuppressed()) HangEntrySuppressed;
            }
            (*(ptr_HangEntrySuppressed())) = std::move((aRhs).get_HangEntrySuppressed());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::HangEntry>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::HangEntry union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'HangEntry'
    (aMsg)->WriteSentinel(282002321);

    switch (type) {
    case union__::TnsCString:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_nsCString());
            // Sentinel = 'TnsCString'
            (aMsg)->WriteSentinel(353960944);
            return;
        }
    case union__::THangEntryBufOffset:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_HangEntryBufOffset());
            // Sentinel = 'THangEntryBufOffset'
            (aMsg)->WriteSentinel(1206912873);
            return;
        }
    case union__::THangEntryModOffset:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_HangEntryModOffset());
            // Sentinel = 'THangEntryModOffset'
            (aMsg)->WriteSentinel(1209337708);
            return;
        }
    case union__::THangEntryProgCounter:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_HangEntryProgCounter());
            // Sentinel = 'THangEntryProgCounter'
            (aMsg)->WriteSentinel(1492781149);
            return;
        }
    case union__::THangEntryContent:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_HangEntryContent());
            // Sentinel = 'THangEntryContent'
            (aMsg)->WriteSentinel(977209024);
            return;
        }
    case union__::THangEntryJit:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_HangEntryJit());
            // Sentinel = 'THangEntryJit'
            (aMsg)->WriteSentinel(569050380);
            return;
        }
    case union__::THangEntryWasm:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_HangEntryWasm());
            // Sentinel = 'THangEntryWasm'
            (aMsg)->WriteSentinel(662570365);
            return;
        }
    case union__::THangEntryChromeScript:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_HangEntryChromeScript());
            // Sentinel = 'THangEntryChromeScript'
            (aMsg)->WriteSentinel(1630406840);
            return;
        }
    case union__::THangEntrySuppressed:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_HangEntrySuppressed());
            // Sentinel = 'THangEntrySuppressed'
            (aMsg)->WriteSentinel(1374488595);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::HangEntry>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::HangEntry union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union HangEntry");
        return false;
    }
    // Sentinel = 'HangEntry'
    if ((!((aMsg)->ReadSentinel(aIter, 282002321)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union HangEntry");
        return false;
    }

    switch (type) {
    case union__::TnsCString:
        {
            nsCString tmp = nsCString();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_nsCString())))))) {
                aActor->FatalError("Error deserializing variant TnsCString of union HangEntry");
                return false;
            }
            // Sentinel = 'TnsCString'
            if ((!((aMsg)->ReadSentinel(aIter, 353960944)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TnsCString of union HangEntry");
                return false;
            }
            return true;
        }
    case union__::THangEntryBufOffset:
        {
            mozilla::HangEntryBufOffset tmp = mozilla::HangEntryBufOffset();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_HangEntryBufOffset())))))) {
                aActor->FatalError("Error deserializing variant THangEntryBufOffset of union HangEntry");
                return false;
            }
            // Sentinel = 'THangEntryBufOffset'
            if ((!((aMsg)->ReadSentinel(aIter, 1206912873)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant THangEntryBufOffset of union HangEntry");
                return false;
            }
            return true;
        }
    case union__::THangEntryModOffset:
        {
            mozilla::HangEntryModOffset tmp = mozilla::HangEntryModOffset();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_HangEntryModOffset())))))) {
                aActor->FatalError("Error deserializing variant THangEntryModOffset of union HangEntry");
                return false;
            }
            // Sentinel = 'THangEntryModOffset'
            if ((!((aMsg)->ReadSentinel(aIter, 1209337708)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant THangEntryModOffset of union HangEntry");
                return false;
            }
            return true;
        }
    case union__::THangEntryProgCounter:
        {
            mozilla::HangEntryProgCounter tmp = mozilla::HangEntryProgCounter();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_HangEntryProgCounter())))))) {
                aActor->FatalError("Error deserializing variant THangEntryProgCounter of union HangEntry");
                return false;
            }
            // Sentinel = 'THangEntryProgCounter'
            if ((!((aMsg)->ReadSentinel(aIter, 1492781149)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant THangEntryProgCounter of union HangEntry");
                return false;
            }
            return true;
        }
    case union__::THangEntryContent:
        {
            mozilla::HangEntryContent tmp = mozilla::HangEntryContent();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_HangEntryContent())))))) {
                aActor->FatalError("Error deserializing variant THangEntryContent of union HangEntry");
                return false;
            }
            // Sentinel = 'THangEntryContent'
            if ((!((aMsg)->ReadSentinel(aIter, 977209024)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant THangEntryContent of union HangEntry");
                return false;
            }
            return true;
        }
    case union__::THangEntryJit:
        {
            mozilla::HangEntryJit tmp = mozilla::HangEntryJit();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_HangEntryJit())))))) {
                aActor->FatalError("Error deserializing variant THangEntryJit of union HangEntry");
                return false;
            }
            // Sentinel = 'THangEntryJit'
            if ((!((aMsg)->ReadSentinel(aIter, 569050380)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant THangEntryJit of union HangEntry");
                return false;
            }
            return true;
        }
    case union__::THangEntryWasm:
        {
            mozilla::HangEntryWasm tmp = mozilla::HangEntryWasm();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_HangEntryWasm())))))) {
                aActor->FatalError("Error deserializing variant THangEntryWasm of union HangEntry");
                return false;
            }
            // Sentinel = 'THangEntryWasm'
            if ((!((aMsg)->ReadSentinel(aIter, 662570365)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant THangEntryWasm of union HangEntry");
                return false;
            }
            return true;
        }
    case union__::THangEntryChromeScript:
        {
            mozilla::HangEntryChromeScript tmp = mozilla::HangEntryChromeScript();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_HangEntryChromeScript())))))) {
                aActor->FatalError("Error deserializing variant THangEntryChromeScript of union HangEntry");
                return false;
            }
            // Sentinel = 'THangEntryChromeScript'
            if ((!((aMsg)->ReadSentinel(aIter, 1630406840)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant THangEntryChromeScript of union HangEntry");
                return false;
            }
            return true;
        }
    case union__::THangEntrySuppressed:
        {
            mozilla::HangEntrySuppressed tmp = mozilla::HangEntrySuppressed();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_HangEntrySuppressed())))))) {
                aActor->FatalError("Error deserializing variant THangEntrySuppressed of union HangEntry");
                return false;
            }
            // Sentinel = 'THangEntrySuppressed'
            if ((!((aMsg)->ReadSentinel(aIter, 1374488595)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant THangEntrySuppressed of union HangEntry");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct HangModule|
//
namespace mozilla {
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::HangModule>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).name());
    // Sentinel = 'name'
    (aMsg)->WriteSentinel(69075362);
    WriteIPDLParam(aMsg, aActor, (aVar).breakpadId());
    // Sentinel = 'breakpadId'
    (aMsg)->WriteSentinel(369558504);
}

auto IPDLParamTraits<mozilla::HangModule>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->name())))))) {
        aActor->FatalError("Error deserializing 'name' (nsString) member of 'HangModule'");
        return false;
    }
    // Sentinel = 'name'
    if ((!((aMsg)->ReadSentinel(aIter, 69075362)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'name' (nsString) member of 'HangModule'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->breakpadId())))))) {
        aActor->FatalError("Error deserializing 'breakpadId' (nsCString) member of 'HangModule'");
        return false;
    }
    // Sentinel = 'breakpadId'
    if ((!((aMsg)->ReadSentinel(aIter, 369558504)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'breakpadId' (nsCString) member of 'HangModule'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct HangStack|
//
namespace mozilla {
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::HangStack>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).stack());
    // Sentinel = 'stack'
    (aMsg)->WriteSentinel(107479575);
    WriteIPDLParam(aMsg, aActor, (aVar).strbuffer());
    // Sentinel = 'strbuffer'
    (aMsg)->WriteSentinel(325911508);
    WriteIPDLParam(aMsg, aActor, (aVar).modules());
    // Sentinel = 'modules'
    (aMsg)->WriteSentinel(199557882);
}

auto IPDLParamTraits<mozilla::HangStack>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->stack())))))) {
        aActor->FatalError("Error deserializing 'stack' (HangEntry[]) member of 'HangStack'");
        return false;
    }
    // Sentinel = 'stack'
    if ((!((aMsg)->ReadSentinel(aIter, 107479575)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'stack' (HangEntry[]) member of 'HangStack'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->strbuffer())))))) {
        aActor->FatalError("Error deserializing 'strbuffer' (int8_t[]) member of 'HangStack'");
        return false;
    }
    // Sentinel = 'strbuffer'
    if ((!((aMsg)->ReadSentinel(aIter, 325911508)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'strbuffer' (int8_t[]) member of 'HangStack'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->modules())))))) {
        aActor->FatalError("Error deserializing 'modules' (HangModule[]) member of 'HangStack'");
        return false;
    }
    // Sentinel = 'modules'
    if ((!((aMsg)->ReadSentinel(aIter, 199557882)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'modules' (HangModule[]) member of 'HangStack'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct HangAnnotation|
//
namespace mozilla {
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::HangAnnotation>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).name());
    // Sentinel = 'name'
    (aMsg)->WriteSentinel(69075362);
    WriteIPDLParam(aMsg, aActor, (aVar).value());
    // Sentinel = 'value'
    (aMsg)->WriteSentinel(107610654);
}

auto IPDLParamTraits<mozilla::HangAnnotation>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->name())))))) {
        aActor->FatalError("Error deserializing 'name' (nsString) member of 'HangAnnotation'");
        return false;
    }
    // Sentinel = 'name'
    if ((!((aMsg)->ReadSentinel(aIter, 69075362)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'name' (nsString) member of 'HangAnnotation'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->value())))))) {
        aActor->FatalError("Error deserializing 'value' (nsString) member of 'HangAnnotation'");
        return false;
    }
    // Sentinel = 'value'
    if ((!((aMsg)->ReadSentinel(aIter, 107610654)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'value' (nsString) member of 'HangAnnotation'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct HangDetails|
//
namespace mozilla {
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::HangDetails>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).duration());
    // Sentinel = 'duration'
    (aMsg)->WriteSentinel(256050023);
    WriteIPDLParam(aMsg, aActor, (aVar).process());
    // Sentinel = 'process'
    (aMsg)->WriteSentinel(201458432);
    WriteIPDLParam(aMsg, aActor, (aVar).remoteType());
    // Sentinel = 'remoteType'
    (aMsg)->WriteSentinel(388826159);
    WriteIPDLParam(aMsg, aActor, (aVar).threadName());
    // Sentinel = 'threadName'
    (aMsg)->WriteSentinel(375456762);
    WriteIPDLParam(aMsg, aActor, (aVar).runnableName());
    // Sentinel = 'runnableName'
    (aMsg)->WriteSentinel(543556825);
    WriteIPDLParam(aMsg, aActor, (aVar).stack());
    // Sentinel = 'stack'
    (aMsg)->WriteSentinel(107479575);
    WriteIPDLParam(aMsg, aActor, (aVar).annotations());
    // Sentinel = 'annotations'
    (aMsg)->WriteSentinel(466486447);
}

auto IPDLParamTraits<mozilla::HangDetails>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->duration())))))) {
        aActor->FatalError("Error deserializing 'duration' (TimeDuration) member of 'HangDetails'");
        return false;
    }
    // Sentinel = 'duration'
    if ((!((aMsg)->ReadSentinel(aIter, 256050023)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'duration' (TimeDuration) member of 'HangDetails'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->process())))))) {
        aActor->FatalError("Error deserializing 'process' (nsCString) member of 'HangDetails'");
        return false;
    }
    // Sentinel = 'process'
    if ((!((aMsg)->ReadSentinel(aIter, 201458432)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'process' (nsCString) member of 'HangDetails'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->remoteType())))))) {
        aActor->FatalError("Error deserializing 'remoteType' (nsCString) member of 'HangDetails'");
        return false;
    }
    // Sentinel = 'remoteType'
    if ((!((aMsg)->ReadSentinel(aIter, 388826159)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'remoteType' (nsCString) member of 'HangDetails'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->threadName())))))) {
        aActor->FatalError("Error deserializing 'threadName' (nsCString) member of 'HangDetails'");
        return false;
    }
    // Sentinel = 'threadName'
    if ((!((aMsg)->ReadSentinel(aIter, 375456762)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'threadName' (nsCString) member of 'HangDetails'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->runnableName())))))) {
        aActor->FatalError("Error deserializing 'runnableName' (nsCString) member of 'HangDetails'");
        return false;
    }
    // Sentinel = 'runnableName'
    if ((!((aMsg)->ReadSentinel(aIter, 543556825)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'runnableName' (nsCString) member of 'HangDetails'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->stack())))))) {
        aActor->FatalError("Error deserializing 'stack' (HangStack) member of 'HangDetails'");
        return false;
    }
    // Sentinel = 'stack'
    if ((!((aMsg)->ReadSentinel(aIter, 107479575)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'stack' (HangStack) member of 'HangDetails'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->annotations())))))) {
        aActor->FatalError("Error deserializing 'annotations' (HangAnnotation[]) member of 'HangDetails'");
        return false;
    }
    // Sentinel = 'annotations'
    if ((!((aMsg)->ReadSentinel(aIter, 466486447)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'annotations' (HangAnnotation[]) member of 'HangDetails'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla
