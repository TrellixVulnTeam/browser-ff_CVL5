//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/net/PNeckoChild.h"
#include "SerializedLoadContext.h"
#include "mozilla/ProfilerLabels.h"
#include "mozilla/dom/PermissionMessageUtils.h"
#include "mozilla/ipc/IPCStreamUtils.h"
#include "mozilla/ipc/URIUtils.h"
#include "mozilla/net/NeckoChild.h"
#include "nsIPrincipal.h"

#include "mozilla/dom/PContentChild.h"
#include "mozilla/net/PHttpChannelChild.h"
#include "mozilla/net/PCookieServiceChild.h"
#include "mozilla/dom/PBrowserChild.h"
#include "mozilla/net/PFTPChannelChild.h"
#include "mozilla/net/PGIOChannelChild.h"
#include "mozilla/net/PWebSocketChild.h"
#include "mozilla/net/PWebSocketEventListenerChild.h"
#include "mozilla/net/PTCPSocketChild.h"
#include "mozilla/net/PTCPServerSocketChild.h"
#include "mozilla/net/PUDPSocketChild.h"
#include "mozilla/net/PDNSRequestChild.h"
#include "mozilla/ipc/PFileDescriptorSetChild.h"
#include "mozilla/net/PDataChannelChild.h"
#include "mozilla/net/PSimpleChannelChild.h"
#include "mozilla/net/PTransportProviderChild.h"
#include "mozilla/ipc/PChildToParentStreamChild.h"
#include "mozilla/ipc/PParentToChildStreamChild.h"
#include "mozilla/net/PStunAddrsRequestChild.h"
#include "mozilla/net/PFileChannelChild.h"
#include "mozilla/net/PClassifierDummyChannelChild.h"
#include "mozilla/net/PWebrtcTCPSocketChild.h"
#include "mozilla/net/PSocketProcessBridgeChild.h"
#include "mozilla/net/PDocumentChannelChild.h"
#include "mozilla/net/PAltDataOutputStreamChild.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace net {


auto PNeckoChild::RecvPTransportProviderConstructor(PTransportProviderChild* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PNeckoChild::RecvPTCPSocketConstructor(
        PTCPSocketChild* actor,
        const nsString& host,
        const uint16_t& port) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

MOZ_IMPLICIT PNeckoChild::PNeckoChild() :
    mozilla::ipc::IProtocol(PNeckoMsgStart, mozilla::ipc::ChildSide)
{
    MOZ_COUNT_CTOR(PNeckoChild);
}

PNeckoChild::~PNeckoChild()
{
    MOZ_COUNT_DTOR(PNeckoChild);
}

auto PNeckoChild::Manager() const -> PContentChild*
{
    return static_cast<PContentChild*>(IProtocol::Manager());
}

auto PNeckoChild::ManagedPHttpChannelChild(nsTArray<PHttpChannelChild*>& aArr) const -> void
{
    mManagedPHttpChannelChild.ToArray(aArr);
}

auto PNeckoChild::ManagedPHttpChannelChild() const -> const ManagedContainer<PHttpChannelChild>&
{
    return mManagedPHttpChannelChild;
}

auto PNeckoChild::ManagedPCookieServiceChild(nsTArray<PCookieServiceChild*>& aArr) const -> void
{
    mManagedPCookieServiceChild.ToArray(aArr);
}

auto PNeckoChild::ManagedPCookieServiceChild() const -> const ManagedContainer<PCookieServiceChild>&
{
    return mManagedPCookieServiceChild;
}

auto PNeckoChild::ManagedPFTPChannelChild(nsTArray<PFTPChannelChild*>& aArr) const -> void
{
    mManagedPFTPChannelChild.ToArray(aArr);
}

auto PNeckoChild::ManagedPFTPChannelChild() const -> const ManagedContainer<PFTPChannelChild>&
{
    return mManagedPFTPChannelChild;
}

auto PNeckoChild::ManagedPWebSocketChild(nsTArray<PWebSocketChild*>& aArr) const -> void
{
    mManagedPWebSocketChild.ToArray(aArr);
}

auto PNeckoChild::ManagedPWebSocketChild() const -> const ManagedContainer<PWebSocketChild>&
{
    return mManagedPWebSocketChild;
}

auto PNeckoChild::ManagedPWebSocketEventListenerChild(nsTArray<PWebSocketEventListenerChild*>& aArr) const -> void
{
    mManagedPWebSocketEventListenerChild.ToArray(aArr);
}

auto PNeckoChild::ManagedPWebSocketEventListenerChild() const -> const ManagedContainer<PWebSocketEventListenerChild>&
{
    return mManagedPWebSocketEventListenerChild;
}

auto PNeckoChild::ManagedPTCPSocketChild(nsTArray<PTCPSocketChild*>& aArr) const -> void
{
    mManagedPTCPSocketChild.ToArray(aArr);
}

auto PNeckoChild::ManagedPTCPSocketChild() const -> const ManagedContainer<PTCPSocketChild>&
{
    return mManagedPTCPSocketChild;
}

auto PNeckoChild::ManagedPTCPServerSocketChild(nsTArray<PTCPServerSocketChild*>& aArr) const -> void
{
    mManagedPTCPServerSocketChild.ToArray(aArr);
}

auto PNeckoChild::ManagedPTCPServerSocketChild() const -> const ManagedContainer<PTCPServerSocketChild>&
{
    return mManagedPTCPServerSocketChild;
}

auto PNeckoChild::ManagedPUDPSocketChild(nsTArray<PUDPSocketChild*>& aArr) const -> void
{
    mManagedPUDPSocketChild.ToArray(aArr);
}

auto PNeckoChild::ManagedPUDPSocketChild() const -> const ManagedContainer<PUDPSocketChild>&
{
    return mManagedPUDPSocketChild;
}

auto PNeckoChild::ManagedPDNSRequestChild(nsTArray<PDNSRequestChild*>& aArr) const -> void
{
    mManagedPDNSRequestChild.ToArray(aArr);
}

auto PNeckoChild::ManagedPDNSRequestChild() const -> const ManagedContainer<PDNSRequestChild>&
{
    return mManagedPDNSRequestChild;
}

auto PNeckoChild::ManagedPDataChannelChild(nsTArray<PDataChannelChild*>& aArr) const -> void
{
    mManagedPDataChannelChild.ToArray(aArr);
}

auto PNeckoChild::ManagedPDataChannelChild() const -> const ManagedContainer<PDataChannelChild>&
{
    return mManagedPDataChannelChild;
}

auto PNeckoChild::ManagedPGIOChannelChild(nsTArray<PGIOChannelChild*>& aArr) const -> void
{
    mManagedPGIOChannelChild.ToArray(aArr);
}

auto PNeckoChild::ManagedPGIOChannelChild() const -> const ManagedContainer<PGIOChannelChild>&
{
    return mManagedPGIOChannelChild;
}

auto PNeckoChild::ManagedPSimpleChannelChild(nsTArray<PSimpleChannelChild*>& aArr) const -> void
{
    mManagedPSimpleChannelChild.ToArray(aArr);
}

auto PNeckoChild::ManagedPSimpleChannelChild() const -> const ManagedContainer<PSimpleChannelChild>&
{
    return mManagedPSimpleChannelChild;
}

auto PNeckoChild::ManagedPFileChannelChild(nsTArray<PFileChannelChild*>& aArr) const -> void
{
    mManagedPFileChannelChild.ToArray(aArr);
}

auto PNeckoChild::ManagedPFileChannelChild() const -> const ManagedContainer<PFileChannelChild>&
{
    return mManagedPFileChannelChild;
}

auto PNeckoChild::ManagedPTransportProviderChild(nsTArray<PTransportProviderChild*>& aArr) const -> void
{
    mManagedPTransportProviderChild.ToArray(aArr);
}

auto PNeckoChild::ManagedPTransportProviderChild() const -> const ManagedContainer<PTransportProviderChild>&
{
    return mManagedPTransportProviderChild;
}

auto PNeckoChild::ManagedPAltDataOutputStreamChild(nsTArray<PAltDataOutputStreamChild*>& aArr) const -> void
{
    mManagedPAltDataOutputStreamChild.ToArray(aArr);
}

auto PNeckoChild::ManagedPAltDataOutputStreamChild() const -> const ManagedContainer<PAltDataOutputStreamChild>&
{
    return mManagedPAltDataOutputStreamChild;
}

auto PNeckoChild::ManagedPStunAddrsRequestChild(nsTArray<PStunAddrsRequestChild*>& aArr) const -> void
{
    mManagedPStunAddrsRequestChild.ToArray(aArr);
}

auto PNeckoChild::ManagedPStunAddrsRequestChild() const -> const ManagedContainer<PStunAddrsRequestChild>&
{
    return mManagedPStunAddrsRequestChild;
}

auto PNeckoChild::ManagedPClassifierDummyChannelChild(nsTArray<PClassifierDummyChannelChild*>& aArr) const -> void
{
    mManagedPClassifierDummyChannelChild.ToArray(aArr);
}

auto PNeckoChild::ManagedPClassifierDummyChannelChild() const -> const ManagedContainer<PClassifierDummyChannelChild>&
{
    return mManagedPClassifierDummyChannelChild;
}

auto PNeckoChild::ManagedPWebrtcTCPSocketChild(nsTArray<PWebrtcTCPSocketChild*>& aArr) const -> void
{
    mManagedPWebrtcTCPSocketChild.ToArray(aArr);
}

auto PNeckoChild::ManagedPWebrtcTCPSocketChild() const -> const ManagedContainer<PWebrtcTCPSocketChild>&
{
    return mManagedPWebrtcTCPSocketChild;
}

auto PNeckoChild::ManagedPDocumentChannelChild(nsTArray<PDocumentChannelChild*>& aArr) const -> void
{
    mManagedPDocumentChannelChild.ToArray(aArr);
}

auto PNeckoChild::ManagedPDocumentChannelChild() const -> const ManagedContainer<PDocumentChannelChild>&
{
    return mManagedPDocumentChannelChild;
}

auto PNeckoChild::AllManagedActors(nsTArray<RefPtr<mozilla::ipc::ActorLifecycleProxy>>& arr__) const -> void
{
    uint32_t total = 0;
    total += mManagedPHttpChannelChild.Count();
    total += mManagedPCookieServiceChild.Count();
    total += mManagedPFTPChannelChild.Count();
    total += mManagedPWebSocketChild.Count();
    total += mManagedPWebSocketEventListenerChild.Count();
    total += mManagedPTCPSocketChild.Count();
    total += mManagedPTCPServerSocketChild.Count();
    total += mManagedPUDPSocketChild.Count();
    total += mManagedPDNSRequestChild.Count();
    total += mManagedPDataChannelChild.Count();
    total += mManagedPGIOChannelChild.Count();
    total += mManagedPSimpleChannelChild.Count();
    total += mManagedPFileChannelChild.Count();
    total += mManagedPTransportProviderChild.Count();
    total += mManagedPAltDataOutputStreamChild.Count();
    total += mManagedPStunAddrsRequestChild.Count();
    total += mManagedPClassifierDummyChannelChild.Count();
    total += mManagedPWebrtcTCPSocketChild.Count();
    total += mManagedPDocumentChannelChild.Count();
    arr__.SetCapacity(total);

    for (auto it = mManagedPHttpChannelChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPCookieServiceChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPFTPChannelChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPWebSocketChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPWebSocketEventListenerChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPTCPSocketChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPTCPServerSocketChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPUDPSocketChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPDNSRequestChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPDataChannelChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPGIOChannelChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPSimpleChannelChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPFileChannelChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPTransportProviderChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPAltDataOutputStreamChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPStunAddrsRequestChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPClassifierDummyChannelChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPWebrtcTCPSocketChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPDocumentChannelChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

}

auto PNeckoChild::OpenPHttpChannelEndpoint(PHttpChannelChild* aActor) -> ManagedEndpoint<PHttpChannelParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PHttpChannelChild actor");
        return ManagedEndpoint<PHttpChannelParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPHttpChannelChild.PutEntry(aActor);

    return ManagedEndpoint<PHttpChannelParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoChild::BindPHttpChannelEndpoint(
        ManagedEndpoint<PHttpChannelChild> aEndpoint,
        PHttpChannelChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PHttpChannelChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPHttpChannelChild.PutEntry(aActor);

    return true;
}

auto PNeckoChild::OpenPCookieServiceEndpoint(PCookieServiceChild* aActor) -> ManagedEndpoint<PCookieServiceParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PCookieServiceChild actor");
        return ManagedEndpoint<PCookieServiceParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPCookieServiceChild.PutEntry(aActor);

    return ManagedEndpoint<PCookieServiceParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoChild::BindPCookieServiceEndpoint(
        ManagedEndpoint<PCookieServiceChild> aEndpoint,
        PCookieServiceChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PCookieServiceChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPCookieServiceChild.PutEntry(aActor);

    return true;
}

auto PNeckoChild::OpenPFTPChannelEndpoint(PFTPChannelChild* aActor) -> ManagedEndpoint<PFTPChannelParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PFTPChannelChild actor");
        return ManagedEndpoint<PFTPChannelParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPFTPChannelChild.PutEntry(aActor);

    return ManagedEndpoint<PFTPChannelParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoChild::BindPFTPChannelEndpoint(
        ManagedEndpoint<PFTPChannelChild> aEndpoint,
        PFTPChannelChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PFTPChannelChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPFTPChannelChild.PutEntry(aActor);

    return true;
}

auto PNeckoChild::OpenPWebSocketEndpoint(PWebSocketChild* aActor) -> ManagedEndpoint<PWebSocketParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebSocketChild actor");
        return ManagedEndpoint<PWebSocketParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPWebSocketChild.PutEntry(aActor);

    return ManagedEndpoint<PWebSocketParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoChild::BindPWebSocketEndpoint(
        ManagedEndpoint<PWebSocketChild> aEndpoint,
        PWebSocketChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebSocketChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPWebSocketChild.PutEntry(aActor);

    return true;
}

auto PNeckoChild::OpenPWebSocketEventListenerEndpoint(PWebSocketEventListenerChild* aActor) -> ManagedEndpoint<PWebSocketEventListenerParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebSocketEventListenerChild actor");
        return ManagedEndpoint<PWebSocketEventListenerParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPWebSocketEventListenerChild.PutEntry(aActor);

    return ManagedEndpoint<PWebSocketEventListenerParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoChild::BindPWebSocketEventListenerEndpoint(
        ManagedEndpoint<PWebSocketEventListenerChild> aEndpoint,
        PWebSocketEventListenerChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebSocketEventListenerChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPWebSocketEventListenerChild.PutEntry(aActor);

    return true;
}

auto PNeckoChild::OpenPTCPSocketEndpoint(PTCPSocketChild* aActor) -> ManagedEndpoint<PTCPSocketParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PTCPSocketChild actor");
        return ManagedEndpoint<PTCPSocketParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPTCPSocketChild.PutEntry(aActor);

    return ManagedEndpoint<PTCPSocketParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoChild::BindPTCPSocketEndpoint(
        ManagedEndpoint<PTCPSocketChild> aEndpoint,
        PTCPSocketChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PTCPSocketChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPTCPSocketChild.PutEntry(aActor);

    return true;
}

auto PNeckoChild::OpenPTCPServerSocketEndpoint(PTCPServerSocketChild* aActor) -> ManagedEndpoint<PTCPServerSocketParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PTCPServerSocketChild actor");
        return ManagedEndpoint<PTCPServerSocketParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPTCPServerSocketChild.PutEntry(aActor);

    return ManagedEndpoint<PTCPServerSocketParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoChild::BindPTCPServerSocketEndpoint(
        ManagedEndpoint<PTCPServerSocketChild> aEndpoint,
        PTCPServerSocketChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PTCPServerSocketChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPTCPServerSocketChild.PutEntry(aActor);

    return true;
}

auto PNeckoChild::OpenPUDPSocketEndpoint(PUDPSocketChild* aActor) -> ManagedEndpoint<PUDPSocketParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PUDPSocketChild actor");
        return ManagedEndpoint<PUDPSocketParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPUDPSocketChild.PutEntry(aActor);

    return ManagedEndpoint<PUDPSocketParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoChild::BindPUDPSocketEndpoint(
        ManagedEndpoint<PUDPSocketChild> aEndpoint,
        PUDPSocketChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PUDPSocketChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPUDPSocketChild.PutEntry(aActor);

    return true;
}

auto PNeckoChild::OpenPDNSRequestEndpoint(PDNSRequestChild* aActor) -> ManagedEndpoint<PDNSRequestParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PDNSRequestChild actor");
        return ManagedEndpoint<PDNSRequestParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPDNSRequestChild.PutEntry(aActor);

    return ManagedEndpoint<PDNSRequestParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoChild::BindPDNSRequestEndpoint(
        ManagedEndpoint<PDNSRequestChild> aEndpoint,
        PDNSRequestChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PDNSRequestChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPDNSRequestChild.PutEntry(aActor);

    return true;
}

auto PNeckoChild::OpenPDataChannelEndpoint(PDataChannelChild* aActor) -> ManagedEndpoint<PDataChannelParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PDataChannelChild actor");
        return ManagedEndpoint<PDataChannelParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPDataChannelChild.PutEntry(aActor);

    return ManagedEndpoint<PDataChannelParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoChild::BindPDataChannelEndpoint(
        ManagedEndpoint<PDataChannelChild> aEndpoint,
        PDataChannelChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PDataChannelChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPDataChannelChild.PutEntry(aActor);

    return true;
}

auto PNeckoChild::OpenPGIOChannelEndpoint(PGIOChannelChild* aActor) -> ManagedEndpoint<PGIOChannelParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PGIOChannelChild actor");
        return ManagedEndpoint<PGIOChannelParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPGIOChannelChild.PutEntry(aActor);

    return ManagedEndpoint<PGIOChannelParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoChild::BindPGIOChannelEndpoint(
        ManagedEndpoint<PGIOChannelChild> aEndpoint,
        PGIOChannelChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PGIOChannelChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPGIOChannelChild.PutEntry(aActor);

    return true;
}

auto PNeckoChild::OpenPSimpleChannelEndpoint(PSimpleChannelChild* aActor) -> ManagedEndpoint<PSimpleChannelParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PSimpleChannelChild actor");
        return ManagedEndpoint<PSimpleChannelParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPSimpleChannelChild.PutEntry(aActor);

    return ManagedEndpoint<PSimpleChannelParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoChild::BindPSimpleChannelEndpoint(
        ManagedEndpoint<PSimpleChannelChild> aEndpoint,
        PSimpleChannelChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PSimpleChannelChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPSimpleChannelChild.PutEntry(aActor);

    return true;
}

auto PNeckoChild::OpenPFileChannelEndpoint(PFileChannelChild* aActor) -> ManagedEndpoint<PFileChannelParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PFileChannelChild actor");
        return ManagedEndpoint<PFileChannelParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPFileChannelChild.PutEntry(aActor);

    return ManagedEndpoint<PFileChannelParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoChild::BindPFileChannelEndpoint(
        ManagedEndpoint<PFileChannelChild> aEndpoint,
        PFileChannelChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PFileChannelChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPFileChannelChild.PutEntry(aActor);

    return true;
}

auto PNeckoChild::OpenPTransportProviderEndpoint(PTransportProviderChild* aActor) -> ManagedEndpoint<PTransportProviderParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PTransportProviderChild actor");
        return ManagedEndpoint<PTransportProviderParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPTransportProviderChild.PutEntry(aActor);

    return ManagedEndpoint<PTransportProviderParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoChild::BindPTransportProviderEndpoint(
        ManagedEndpoint<PTransportProviderChild> aEndpoint,
        PTransportProviderChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PTransportProviderChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPTransportProviderChild.PutEntry(aActor);

    return true;
}

auto PNeckoChild::OpenPAltDataOutputStreamEndpoint(PAltDataOutputStreamChild* aActor) -> ManagedEndpoint<PAltDataOutputStreamParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PAltDataOutputStreamChild actor");
        return ManagedEndpoint<PAltDataOutputStreamParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPAltDataOutputStreamChild.PutEntry(aActor);

    return ManagedEndpoint<PAltDataOutputStreamParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoChild::BindPAltDataOutputStreamEndpoint(
        ManagedEndpoint<PAltDataOutputStreamChild> aEndpoint,
        PAltDataOutputStreamChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PAltDataOutputStreamChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPAltDataOutputStreamChild.PutEntry(aActor);

    return true;
}

auto PNeckoChild::OpenPStunAddrsRequestEndpoint(PStunAddrsRequestChild* aActor) -> ManagedEndpoint<PStunAddrsRequestParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PStunAddrsRequestChild actor");
        return ManagedEndpoint<PStunAddrsRequestParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPStunAddrsRequestChild.PutEntry(aActor);

    return ManagedEndpoint<PStunAddrsRequestParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoChild::BindPStunAddrsRequestEndpoint(
        ManagedEndpoint<PStunAddrsRequestChild> aEndpoint,
        PStunAddrsRequestChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PStunAddrsRequestChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPStunAddrsRequestChild.PutEntry(aActor);

    return true;
}

auto PNeckoChild::OpenPClassifierDummyChannelEndpoint(PClassifierDummyChannelChild* aActor) -> ManagedEndpoint<PClassifierDummyChannelParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PClassifierDummyChannelChild actor");
        return ManagedEndpoint<PClassifierDummyChannelParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPClassifierDummyChannelChild.PutEntry(aActor);

    return ManagedEndpoint<PClassifierDummyChannelParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoChild::BindPClassifierDummyChannelEndpoint(
        ManagedEndpoint<PClassifierDummyChannelChild> aEndpoint,
        PClassifierDummyChannelChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PClassifierDummyChannelChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPClassifierDummyChannelChild.PutEntry(aActor);

    return true;
}

auto PNeckoChild::OpenPWebrtcTCPSocketEndpoint(PWebrtcTCPSocketChild* aActor) -> ManagedEndpoint<PWebrtcTCPSocketParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebrtcTCPSocketChild actor");
        return ManagedEndpoint<PWebrtcTCPSocketParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPWebrtcTCPSocketChild.PutEntry(aActor);

    return ManagedEndpoint<PWebrtcTCPSocketParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoChild::BindPWebrtcTCPSocketEndpoint(
        ManagedEndpoint<PWebrtcTCPSocketChild> aEndpoint,
        PWebrtcTCPSocketChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebrtcTCPSocketChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPWebrtcTCPSocketChild.PutEntry(aActor);

    return true;
}

auto PNeckoChild::OpenPDocumentChannelEndpoint(PDocumentChannelChild* aActor) -> ManagedEndpoint<PDocumentChannelParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PDocumentChannelChild actor");
        return ManagedEndpoint<PDocumentChannelParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPDocumentChannelChild.PutEntry(aActor);

    return ManagedEndpoint<PDocumentChannelParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoChild::BindPDocumentChannelEndpoint(
        ManagedEndpoint<PDocumentChannelChild> aEndpoint,
        PDocumentChannelChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PDocumentChannelChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPDocumentChannelChild.PutEntry(aActor);

    return true;
}

auto PNeckoChild::Send__delete__(PNeckoChild* actor) -> bool
{
    if (!actor || !actor->CanSend()) {
        NS_WARNING("Attempt to __delete__ missing or closed actor");
        return false;
    }
    IPC::Message* msg__ = PNecko::Msg___delete__((actor)->Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, actor, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);



    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            (actor)->OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg___delete__", OTHER);

    bool sendok__ = (actor)->ChannelSend(msg__);

    IProtocol* mgr = actor->Manager();
    actor->DestroySubtree(Deletion);
    actor->ClearSubtree();
    mgr->RemoveManagee(PNeckoMsgStart, actor);
    return sendok__;
}

auto PNeckoChild::SendPCookieServiceConstructor() -> PCookieServiceChild*
{
    PCookieServiceChild* actor = (static_cast<NeckoChild*>(this))->AllocPCookieServiceChild();
    return SendPCookieServiceConstructor(actor);
}

auto PNeckoChild::SendPCookieServiceConstructor(PCookieServiceChild* actor) -> PCookieServiceChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PCookieServiceChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPCookieServiceChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PNecko::Msg_PCookieServiceConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PCookieServiceConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PCookieServiceChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PCookieServiceMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PNeckoChild::SendPHttpChannelConstructor(
        PHttpChannelChild* actor,
        PBrowserChild* browser,
        const SerializedLoadContext& loadContext,
        const HttpChannelCreationArgs& args) -> PHttpChannelChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PHttpChannelChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPHttpChannelChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PNecko::Msg_PHttpChannelConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, browser);
    // Sentinel = 'browser'
    (msg__)->WriteSentinel(201130757);
    WriteIPDLParam(msg__, this, loadContext);
    // Sentinel = 'loadContext'
    (msg__)->WriteSentinel(444990598);
    WriteIPDLParam(msg__, this, args);
    // Sentinel = 'args'
    (msg__)->WriteSentinel(69140910);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PHttpChannelConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PHttpChannelChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PHttpChannelMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PNeckoChild::SendPFTPChannelConstructor(
        PBrowserChild* browser,
        const SerializedLoadContext& loadContext,
        const FTPChannelCreationArgs& args) -> PFTPChannelChild*
{
    PFTPChannelChild* actor = (static_cast<NeckoChild*>(this))->AllocPFTPChannelChild(browser, loadContext, args);
    return SendPFTPChannelConstructor(actor, browser, loadContext, args);
}

auto PNeckoChild::SendPFTPChannelConstructor(
        PFTPChannelChild* actor,
        PBrowserChild* browser,
        const SerializedLoadContext& loadContext,
        const FTPChannelCreationArgs& args) -> PFTPChannelChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PFTPChannelChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPFTPChannelChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PNecko::Msg_PFTPChannelConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, browser);
    // Sentinel = 'browser'
    (msg__)->WriteSentinel(201130757);
    WriteIPDLParam(msg__, this, loadContext);
    // Sentinel = 'loadContext'
    (msg__)->WriteSentinel(444990598);
    WriteIPDLParam(msg__, this, args);
    // Sentinel = 'args'
    (msg__)->WriteSentinel(69140910);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PFTPChannelConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PFTPChannelChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PFTPChannelMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PNeckoChild::SendPWebSocketConstructor(
        PBrowserChild* browser,
        const SerializedLoadContext& loadContext,
        const uint32_t& aSerialID) -> PWebSocketChild*
{
    PWebSocketChild* actor = (static_cast<NeckoChild*>(this))->AllocPWebSocketChild(browser, loadContext, aSerialID);
    return SendPWebSocketConstructor(actor, browser, loadContext, aSerialID);
}

auto PNeckoChild::SendPWebSocketConstructor(
        PWebSocketChild* actor,
        PBrowserChild* browser,
        const SerializedLoadContext& loadContext,
        const uint32_t& aSerialID) -> PWebSocketChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PWebSocketChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPWebSocketChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PNecko::Msg_PWebSocketConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, browser);
    // Sentinel = 'browser'
    (msg__)->WriteSentinel(201130757);
    WriteIPDLParam(msg__, this, loadContext);
    // Sentinel = 'loadContext'
    (msg__)->WriteSentinel(444990598);
    WriteIPDLParam(msg__, this, aSerialID);
    // Sentinel = 'aSerialID'
    (msg__)->WriteSentinel(287572815);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PWebSocketConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PWebSocketChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PWebSocketMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PNeckoChild::SendPTCPServerSocketConstructor(
        const uint16_t& localPort,
        const uint16_t& backlog,
        const bool& useArrayBuffers) -> PTCPServerSocketChild*
{
    PTCPServerSocketChild* actor = (static_cast<NeckoChild*>(this))->AllocPTCPServerSocketChild(localPort, backlog, useArrayBuffers);
    return SendPTCPServerSocketConstructor(actor, localPort, backlog, useArrayBuffers);
}

auto PNeckoChild::SendPTCPServerSocketConstructor(
        PTCPServerSocketChild* actor,
        const uint16_t& localPort,
        const uint16_t& backlog,
        const bool& useArrayBuffers) -> PTCPServerSocketChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PTCPServerSocketChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPTCPServerSocketChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PNecko::Msg_PTCPServerSocketConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, localPort);
    // Sentinel = 'localPort'
    (msg__)->WriteSentinel(306774961);
    WriteIPDLParam(msg__, this, backlog);
    // Sentinel = 'backlog'
    (msg__)->WriteSentinel(186581716);
    WriteIPDLParam(msg__, this, useArrayBuffers);
    // Sentinel = 'useArrayBuffers'
    (msg__)->WriteSentinel(815007258);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PTCPServerSocketConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PTCPServerSocketChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PTCPServerSocketMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PNeckoChild::SendPUDPSocketConstructor(
        nsIPrincipal* principal,
        const nsCString& filter) -> PUDPSocketChild*
{
    PUDPSocketChild* actor = (static_cast<NeckoChild*>(this))->AllocPUDPSocketChild(principal, filter);
    return SendPUDPSocketConstructor(actor, principal, filter);
}

auto PNeckoChild::SendPUDPSocketConstructor(
        PUDPSocketChild* actor,
        nsIPrincipal* principal,
        const nsCString& filter) -> PUDPSocketChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PUDPSocketChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPUDPSocketChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PNecko::Msg_PUDPSocketConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, principal);
    // Sentinel = 'principal'
    (msg__)->WriteSentinel(319620035);
    WriteIPDLParam(msg__, this, filter);
    // Sentinel = 'filter'
    (msg__)->WriteSentinel(146735751);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PUDPSocketConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PUDPSocketChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PUDPSocketMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PNeckoChild::SendPDNSRequestConstructor(
        PDNSRequestChild* actor,
        const nsCString& hostName,
        const nsCString& trrServer,
        const uint16_t& type,
        const OriginAttributes& originAttributes,
        const uint32_t& flags) -> PDNSRequestChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PDNSRequestChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPDNSRequestChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PNecko::Msg_PDNSRequestConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, hostName);
    // Sentinel = 'hostName'
    (msg__)->WriteSentinel(249627456);
    WriteIPDLParam(msg__, this, trrServer);
    // Sentinel = 'trrServer'
    (msg__)->WriteSentinel(320603088);
    WriteIPDLParam(msg__, this, type);
    // Sentinel = 'type'
    (msg__)->WriteSentinel(75760067);
    WriteIPDLParam(msg__, this, originAttributes);
    // Sentinel = 'originAttributes'
    (msg__)->WriteSentinel(947259056);
    WriteIPDLParam(msg__, this, flags);
    // Sentinel = 'flags'
    (msg__)->WriteSentinel(102171150);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PDNSRequestConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PDNSRequestChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PDNSRequestMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PNeckoChild::SendPDocumentChannelConstructor(
        PDocumentChannelChild* actor,
        const MaybeDiscardedBrowsingContext& browsingContext,
        const DocumentChannelCreationArgs& args) -> PDocumentChannelChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PDocumentChannelChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPDocumentChannelChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PNecko::Msg_PDocumentChannelConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, browsingContext);
    // Sentinel = 'browsingContext'
    (msg__)->WriteSentinel(844695121);
    WriteIPDLParam(msg__, this, args);
    // Sentinel = 'args'
    (msg__)->WriteSentinel(69140910);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PDocumentChannelConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PDocumentChannelChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PDocumentChannelMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PNeckoChild::SendPWebSocketEventListenerConstructor(const uint64_t& aInnerWindowID) -> PWebSocketEventListenerChild*
{
    PWebSocketEventListenerChild* actor = (static_cast<NeckoChild*>(this))->AllocPWebSocketEventListenerChild(aInnerWindowID);
    return SendPWebSocketEventListenerConstructor(actor, aInnerWindowID);
}

auto PNeckoChild::SendPWebSocketEventListenerConstructor(
        PWebSocketEventListenerChild* actor,
        const uint64_t& aInnerWindowID) -> PWebSocketEventListenerChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PWebSocketEventListenerChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPWebSocketEventListenerChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PNecko::Msg_PWebSocketEventListenerConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, aInnerWindowID);
    // Sentinel = 'aInnerWindowID'
    (msg__)->WriteSentinel(687670627);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PWebSocketEventListenerConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PWebSocketEventListenerChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PWebSocketEventListenerMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PNeckoChild::SendPredPredict(
        nsIURI* targetURI,
        nsIURI* sourceURI,
        const uint32_t& reason,
        const OriginAttributes& originAttributes,
        const bool& hasVerifier) -> bool
{
    IPC::Message* msg__ = PNecko::Msg_PredPredict(Id());

    WriteIPDLParam(msg__, this, targetURI);
    // Sentinel = 'targetURI'
    (msg__)->WriteSentinel(308413304);
    WriteIPDLParam(msg__, this, sourceURI);
    // Sentinel = 'sourceURI'
    (msg__)->WriteSentinel(316277634);
    WriteIPDLParam(msg__, this, reason);
    // Sentinel = 'reason'
    (msg__)->WriteSentinel(148112009);
    WriteIPDLParam(msg__, this, originAttributes);
    // Sentinel = 'originAttributes'
    (msg__)->WriteSentinel(947259056);
    WriteIPDLParam(msg__, this, hasVerifier);
    // Sentinel = 'hasVerifier'
    (msg__)->WriteSentinel(445842553);




    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PredPredict", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PNeckoChild::SendPredLearn(
        nsIURI* targetURI,
        nsIURI* sourceURI,
        const uint32_t& reason,
        const OriginAttributes& originAttributes) -> bool
{
    IPC::Message* msg__ = PNecko::Msg_PredLearn(Id());

    WriteIPDLParam(msg__, this, targetURI);
    // Sentinel = 'targetURI'
    (msg__)->WriteSentinel(308413304);
    WriteIPDLParam(msg__, this, sourceURI);
    // Sentinel = 'sourceURI'
    (msg__)->WriteSentinel(316277634);
    WriteIPDLParam(msg__, this, reason);
    // Sentinel = 'reason'
    (msg__)->WriteSentinel(148112009);
    WriteIPDLParam(msg__, this, originAttributes);
    // Sentinel = 'originAttributes'
    (msg__)->WriteSentinel(947259056);




    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PredLearn", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PNeckoChild::SendPredReset() -> bool
{
    IPC::Message* msg__ = PNecko::Msg_PredReset(Id());





    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PredReset", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PNeckoChild::SendSpeculativeConnect(
        nsIURI* uri,
        nsIPrincipal* principal,
        const bool& anonymous) -> bool
{
    IPC::Message* msg__ = PNecko::Msg_SpeculativeConnect(Id());

    WriteIPDLParam(msg__, this, uri);
    // Sentinel = 'uri'
    (msg__)->WriteSentinel(45023569);
    WriteIPDLParam(msg__, this, principal);
    // Sentinel = 'principal'
    (msg__)->WriteSentinel(319620035);
    WriteIPDLParam(msg__, this, anonymous);
    // Sentinel = 'anonymous'
    (msg__)->WriteSentinel(322569194);




    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_SpeculativeConnect", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PNeckoChild::SendHTMLDNSPrefetch(
        const nsString& hostname,
        const bool& isHttps,
        const OriginAttributes& originAttributes,
        const uint32_t& flags) -> bool
{
    IPC::Message* msg__ = PNecko::Msg_HTMLDNSPrefetch(Id());

    WriteIPDLParam(msg__, this, hostname);
    // Sentinel = 'hostname'
    (msg__)->WriteSentinel(258016096);
    WriteIPDLParam(msg__, this, isHttps);
    // Sentinel = 'isHttps'
    (msg__)->WriteSentinel(192873200);
    WriteIPDLParam(msg__, this, originAttributes);
    // Sentinel = 'originAttributes'
    (msg__)->WriteSentinel(947259056);
    WriteIPDLParam(msg__, this, flags);
    // Sentinel = 'flags'
    (msg__)->WriteSentinel(102171150);




    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_HTMLDNSPrefetch", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PNeckoChild::SendCancelHTMLDNSPrefetch(
        const nsString& hostname,
        const bool& isHttps,
        const OriginAttributes& originAttributes,
        const uint32_t& flags,
        const nsresult& reason) -> bool
{
    IPC::Message* msg__ = PNecko::Msg_CancelHTMLDNSPrefetch(Id());

    WriteIPDLParam(msg__, this, hostname);
    // Sentinel = 'hostname'
    (msg__)->WriteSentinel(258016096);
    WriteIPDLParam(msg__, this, isHttps);
    // Sentinel = 'isHttps'
    (msg__)->WriteSentinel(192873200);
    WriteIPDLParam(msg__, this, originAttributes);
    // Sentinel = 'originAttributes'
    (msg__)->WriteSentinel(947259056);
    WriteIPDLParam(msg__, this, flags);
    // Sentinel = 'flags'
    (msg__)->WriteSentinel(102171150);
    WriteIPDLParam(msg__, this, reason);
    // Sentinel = 'reason'
    (msg__)->WriteSentinel(148112009);




    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_CancelHTMLDNSPrefetch", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PNeckoChild::SendPDataChannelConstructor(
        PDataChannelChild* actor,
        const uint32_t& channelId) -> PDataChannelChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PDataChannelChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPDataChannelChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PNecko::Msg_PDataChannelConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, channelId);
    // Sentinel = 'channelId'
    (msg__)->WriteSentinel(301138823);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PDataChannelConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PDataChannelChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PDataChannelMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PNeckoChild::SendPGIOChannelConstructor(
        PBrowserChild* browser,
        const SerializedLoadContext& loadContext,
        const GIOChannelCreationArgs& args) -> PGIOChannelChild*
{
    PGIOChannelChild* actor = (static_cast<NeckoChild*>(this))->AllocPGIOChannelChild(browser, loadContext, args);
    return SendPGIOChannelConstructor(actor, browser, loadContext, args);
}

auto PNeckoChild::SendPGIOChannelConstructor(
        PGIOChannelChild* actor,
        PBrowserChild* browser,
        const SerializedLoadContext& loadContext,
        const GIOChannelCreationArgs& args) -> PGIOChannelChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PGIOChannelChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPGIOChannelChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PNecko::Msg_PGIOChannelConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, browser);
    // Sentinel = 'browser'
    (msg__)->WriteSentinel(201130757);
    WriteIPDLParam(msg__, this, loadContext);
    // Sentinel = 'loadContext'
    (msg__)->WriteSentinel(444990598);
    WriteIPDLParam(msg__, this, args);
    // Sentinel = 'args'
    (msg__)->WriteSentinel(69140910);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PGIOChannelConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PGIOChannelChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PGIOChannelMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PNeckoChild::SendPSimpleChannelConstructor(const uint32_t& channelId) -> PSimpleChannelChild*
{
    PSimpleChannelChild* actor = (static_cast<NeckoChild*>(this))->AllocPSimpleChannelChild(channelId);
    return SendPSimpleChannelConstructor(actor, channelId);
}

auto PNeckoChild::SendPSimpleChannelConstructor(
        PSimpleChannelChild* actor,
        const uint32_t& channelId) -> PSimpleChannelChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PSimpleChannelChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPSimpleChannelChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PNecko::Msg_PSimpleChannelConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, channelId);
    // Sentinel = 'channelId'
    (msg__)->WriteSentinel(301138823);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PSimpleChannelConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PSimpleChannelChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PSimpleChannelMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PNeckoChild::SendPFileChannelConstructor(
        PFileChannelChild* actor,
        const uint32_t& channelId) -> PFileChannelChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PFileChannelChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPFileChannelChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PNecko::Msg_PFileChannelConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, channelId);
    // Sentinel = 'channelId'
    (msg__)->WriteSentinel(301138823);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PFileChannelConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PFileChannelChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PFileChannelMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PNeckoChild::SendPClassifierDummyChannelConstructor(
        nsIURI* uri,
        nsIURI* aTopWindowURI,
        const nsresult& aTopWindowURIResult,
        const mozilla::Maybe<LoadInfoArgs>& loadInfo) -> PClassifierDummyChannelChild*
{
    PClassifierDummyChannelChild* actor = (static_cast<NeckoChild*>(this))->AllocPClassifierDummyChannelChild(uri, aTopWindowURI, aTopWindowURIResult, loadInfo);
    return SendPClassifierDummyChannelConstructor(actor, uri, aTopWindowURI, aTopWindowURIResult, loadInfo);
}

auto PNeckoChild::SendPClassifierDummyChannelConstructor(
        PClassifierDummyChannelChild* actor,
        nsIURI* uri,
        nsIURI* aTopWindowURI,
        const nsresult& aTopWindowURIResult,
        const mozilla::Maybe<LoadInfoArgs>& loadInfo) -> PClassifierDummyChannelChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PClassifierDummyChannelChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPClassifierDummyChannelChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PNecko::Msg_PClassifierDummyChannelConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, uri);
    // Sentinel = 'uri'
    (msg__)->WriteSentinel(45023569);
    WriteIPDLParam(msg__, this, aTopWindowURI);
    // Sentinel = 'aTopWindowURI'
    (msg__)->WriteSentinel(598934781);
    WriteIPDLParam(msg__, this, aTopWindowURIResult);
    // Sentinel = 'aTopWindowURIResult'
    (msg__)->WriteSentinel(1241319292);
    WriteIPDLParam(msg__, this, loadInfo);
    // Sentinel = 'loadInfo'
    (msg__)->WriteSentinel(240386861);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PClassifierDummyChannelConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PClassifierDummyChannelChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PClassifierDummyChannelMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PNeckoChild::SendOnAuthAvailable(
        const uint64_t& callbackId,
        const nsString& user,
        const nsString& password,
        const nsString& domain) -> bool
{
    IPC::Message* msg__ = PNecko::Msg_OnAuthAvailable(Id());

    WriteIPDLParam(msg__, this, callbackId);
    // Sentinel = 'callbackId'
    (msg__)->WriteSentinel(362349531);
    WriteIPDLParam(msg__, this, user);
    // Sentinel = 'user'
    (msg__)->WriteSentinel(74252736);
    WriteIPDLParam(msg__, this, password);
    // Sentinel = 'password'
    (msg__)->WriteSentinel(261161844);
    WriteIPDLParam(msg__, this, domain);
    // Sentinel = 'domain'
    (msg__)->WriteSentinel(144704121);




    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_OnAuthAvailable", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PNeckoChild::SendOnAuthCancelled(
        const uint64_t& callbackId,
        const bool& userCancel) -> bool
{
    IPC::Message* msg__ = PNecko::Msg_OnAuthCancelled(Id());

    WriteIPDLParam(msg__, this, callbackId);
    // Sentinel = 'callbackId'
    (msg__)->WriteSentinel(362349531);
    WriteIPDLParam(msg__, this, userCancel);
    // Sentinel = 'userCancel'
    (msg__)->WriteSentinel(377160710);




    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_OnAuthCancelled", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PNeckoChild::SendRequestContextLoadBegin(const uint64_t& rcid) -> bool
{
    IPC::Message* msg__ = PNecko::Msg_RequestContextLoadBegin(Id());

    WriteIPDLParam(msg__, this, rcid);
    // Sentinel = 'rcid'
    (msg__)->WriteSentinel(69927331);




    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_RequestContextLoadBegin", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PNeckoChild::SendRequestContextAfterDOMContentLoaded(const uint64_t& rcid) -> bool
{
    IPC::Message* msg__ = PNecko::Msg_RequestContextAfterDOMContentLoaded(Id());

    WriteIPDLParam(msg__, this, rcid);
    // Sentinel = 'rcid'
    (msg__)->WriteSentinel(69927331);




    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_RequestContextAfterDOMContentLoaded", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PNeckoChild::SendRemoveRequestContext(const uint64_t& rcid) -> bool
{
    IPC::Message* msg__ = PNecko::Msg_RemoveRequestContext(Id());

    WriteIPDLParam(msg__, this, rcid);
    // Sentinel = 'rcid'
    (msg__)->WriteSentinel(69927331);




    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_RemoveRequestContext", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PNeckoChild::SendPAltDataOutputStreamConstructor(
        const nsCString& type,
        const int64_t& predictedSize,
        PHttpChannelChild* channel) -> PAltDataOutputStreamChild*
{
    PAltDataOutputStreamChild* actor = (static_cast<NeckoChild*>(this))->AllocPAltDataOutputStreamChild(type, predictedSize, channel);
    return SendPAltDataOutputStreamConstructor(actor, type, predictedSize, channel);
}

auto PNeckoChild::SendPAltDataOutputStreamConstructor(
        PAltDataOutputStreamChild* actor,
        const nsCString& type,
        const int64_t& predictedSize,
        PHttpChannelChild* channel) -> PAltDataOutputStreamChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PAltDataOutputStreamChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPAltDataOutputStreamChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PNecko::Msg_PAltDataOutputStreamConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, type);
    // Sentinel = 'type'
    (msg__)->WriteSentinel(75760067);
    WriteIPDLParam(msg__, this, predictedSize);
    // Sentinel = 'predictedSize'
    (msg__)->WriteSentinel(628819280);
    MOZ_RELEASE_ASSERT(channel, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, channel);
    // Sentinel = 'channel'
    (msg__)->WriteSentinel(189334234);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PAltDataOutputStreamConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PAltDataOutputStreamChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PAltDataOutputStreamMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PNeckoChild::SendPStunAddrsRequestConstructor() -> PStunAddrsRequestChild*
{
    PStunAddrsRequestChild* actor = (static_cast<NeckoChild*>(this))->AllocPStunAddrsRequestChild();
    return SendPStunAddrsRequestConstructor(actor);
}

auto PNeckoChild::SendPStunAddrsRequestConstructor(PStunAddrsRequestChild* actor) -> PStunAddrsRequestChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PStunAddrsRequestChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPStunAddrsRequestChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PNecko::Msg_PStunAddrsRequestConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PStunAddrsRequestConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PStunAddrsRequestChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PStunAddrsRequestMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PNeckoChild::SendPWebrtcTCPSocketConstructor(const mozilla::Maybe<TabId>& tabId) -> PWebrtcTCPSocketChild*
{
    PWebrtcTCPSocketChild* actor = (static_cast<NeckoChild*>(this))->AllocPWebrtcTCPSocketChild(tabId);
    return SendPWebrtcTCPSocketConstructor(actor, tabId);
}

auto PNeckoChild::SendPWebrtcTCPSocketConstructor(
        PWebrtcTCPSocketChild* actor,
        const mozilla::Maybe<TabId>& tabId) -> PWebrtcTCPSocketChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PWebrtcTCPSocketChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPWebrtcTCPSocketChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PNecko::Msg_PWebrtcTCPSocketConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, tabId);
    // Sentinel = 'tabId'
    (msg__)->WriteSentinel(99156453);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PWebrtcTCPSocketConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PWebrtcTCPSocketChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PWebrtcTCPSocketMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PNeckoChild::SendGetExtensionStream(
        nsIURI* uri,
        mozilla::ipc::ResolveCallback<RefPtr<nsIInputStream>>&& aResolve,
        mozilla::ipc::RejectCallback&& aReject) -> void
{
    IPC::Message* msg__ = PNecko::Msg_GetExtensionStream(Id());

    WriteIPDLParam(msg__, this, uri);
    // Sentinel = 'uri'
    (msg__)->WriteSentinel(45023569);




    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_GetExtensionStream", OTHER);

    ChannelSend(msg__, std::move(aResolve), std::move(aReject));
    return;
}

auto PNeckoChild::SendGetExtensionStream(nsIURI* uri) -> RefPtr<GetExtensionStreamPromise>
{
    RefPtr<MozPromise<RefPtr<nsIInputStream>, ResponseRejectReason, true>::Private> promise__ = new MozPromise<RefPtr<nsIInputStream>, ResponseRejectReason, true>::Private(__func__);
    promise__->UseDirectTaskDispatch(__func__);
    SendGetExtensionStream(std::move(uri), [promise__](RefPtr<nsIInputStream>&& aValue) {
        promise__->Resolve(std::move(aValue), __func__);
    }, [promise__](ResponseRejectReason&& aReason) {
        promise__->Reject(std::move(aReason), __func__);
    });
    return promise__;
}

auto PNeckoChild::SendGetExtensionFD(
        nsIURI* uri,
        mozilla::ipc::ResolveCallback<FileDescriptor>&& aResolve,
        mozilla::ipc::RejectCallback&& aReject) -> void
{
    IPC::Message* msg__ = PNecko::Msg_GetExtensionFD(Id());

    WriteIPDLParam(msg__, this, uri);
    // Sentinel = 'uri'
    (msg__)->WriteSentinel(45023569);




    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_GetExtensionFD", OTHER);

    ChannelSend(msg__, std::move(aResolve), std::move(aReject));
    return;
}

auto PNeckoChild::SendGetExtensionFD(nsIURI* uri) -> RefPtr<GetExtensionFDPromise>
{
    RefPtr<MozPromise<FileDescriptor, ResponseRejectReason, true>::Private> promise__ = new MozPromise<FileDescriptor, ResponseRejectReason, true>::Private(__func__);
    promise__->UseDirectTaskDispatch(__func__);
    SendGetExtensionFD(std::move(uri), [promise__](FileDescriptor&& aValue) {
        promise__->Resolve(std::move(aValue), __func__);
    }, [promise__](ResponseRejectReason&& aReason) {
        promise__->Reject(std::move(aReason), __func__);
    });
    return promise__;
}

auto PNeckoChild::SendInitSocketProcessBridge(
        mozilla::ipc::ResolveCallback<Endpoint<mozilla::net::PSocketProcessBridgeChild>>&& aResolve,
        mozilla::ipc::RejectCallback&& aReject) -> void
{
    IPC::Message* msg__ = PNecko::Msg_InitSocketProcessBridge(Id());





    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_InitSocketProcessBridge", OTHER);

    ChannelSend(msg__, std::move(aResolve), std::move(aReject));
    return;
}

auto PNeckoChild::SendInitSocketProcessBridge() -> RefPtr<InitSocketProcessBridgePromise>
{
    RefPtr<MozPromise<Endpoint<mozilla::net::PSocketProcessBridgeChild>, ResponseRejectReason, true>::Private> promise__ = new MozPromise<Endpoint<mozilla::net::PSocketProcessBridgeChild>, ResponseRejectReason, true>::Private(__func__);
    promise__->UseDirectTaskDispatch(__func__);
    SendInitSocketProcessBridge([promise__](Endpoint<mozilla::net::PSocketProcessBridgeChild>&& aValue) {
        promise__->Resolve(std::move(aValue), __func__);
    }, [promise__](ResponseRejectReason&& aReason) {
        promise__->Reject(std::move(aReason), __func__);
    });
    return promise__;
}

auto PNeckoChild::SendResetSocketProcessBridge() -> bool
{
    IPC::Message* msg__ = PNecko::Msg_ResetSocketProcessBridge(Id());





    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_ResetSocketProcessBridge", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PNeckoChild::SendEnsureHSTSData(
        mozilla::ipc::ResolveCallback<bool>&& aResolve,
        mozilla::ipc::RejectCallback&& aReject) -> void
{
    IPC::Message* msg__ = PNecko::Msg_EnsureHSTSData(Id());





    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_EnsureHSTSData", OTHER);

    ChannelSend(msg__, std::move(aResolve), std::move(aReject));
    return;
}

auto PNeckoChild::SendEnsureHSTSData() -> RefPtr<EnsureHSTSDataPromise>
{
    RefPtr<MozPromise<bool, ResponseRejectReason, true>::Private> promise__ = new MozPromise<bool, ResponseRejectReason, true>::Private(__func__);
    promise__->UseDirectTaskDispatch(__func__);
    SendEnsureHSTSData([promise__](bool&& aValue) {
        promise__->Resolve(std::move(aValue), __func__);
    }, [promise__](ResponseRejectReason&& aReason) {
        promise__->Reject(std::move(aReason), __func__);
    });
    return promise__;
}

auto PNeckoChild::SendGetPageThumbStream(
        nsIURI* uri,
        mozilla::ipc::ResolveCallback<RefPtr<nsIInputStream>>&& aResolve,
        mozilla::ipc::RejectCallback&& aReject) -> void
{
    IPC::Message* msg__ = PNecko::Msg_GetPageThumbStream(Id());

    WriteIPDLParam(msg__, this, uri);
    // Sentinel = 'uri'
    (msg__)->WriteSentinel(45023569);




    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_GetPageThumbStream", OTHER);

    ChannelSend(msg__, std::move(aResolve), std::move(aReject));
    return;
}

auto PNeckoChild::SendGetPageThumbStream(nsIURI* uri) -> RefPtr<GetPageThumbStreamPromise>
{
    RefPtr<MozPromise<RefPtr<nsIInputStream>, ResponseRejectReason, true>::Private> promise__ = new MozPromise<RefPtr<nsIInputStream>, ResponseRejectReason, true>::Private(__func__);
    promise__->UseDirectTaskDispatch(__func__);
    SendGetPageThumbStream(std::move(uri), [promise__](RefPtr<nsIInputStream>&& aValue) {
        promise__->Resolve(std::move(aValue), __func__);
    }, [promise__](ResponseRejectReason&& aReason) {
        promise__->Reject(std::move(aReason), __func__);
    });
    return promise__;
}

auto PNeckoChild::SendPTCPSocketConstructor(
        const nsString& host,
        const uint16_t& port) -> PTCPSocketChild*
{
    PTCPSocketChild* actor = (static_cast<NeckoChild*>(this))->AllocPTCPSocketChild(host, port);
    return SendPTCPSocketConstructor(actor, host, port);
}

auto PNeckoChild::SendPTCPSocketConstructor(
        PTCPSocketChild* actor,
        const nsString& host,
        const uint16_t& port) -> PTCPSocketChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PTCPSocketChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPTCPSocketChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PNecko::Msg_PTCPSocketConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, host);
    // Sentinel = 'host'
    (msg__)->WriteSentinel(72024511);
    WriteIPDLParam(msg__, this, port);
    // Sentinel = 'port'
    (msg__)->WriteSentinel(73990598);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PTCPSocketConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PTCPSocketChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PTCPSocketMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PNeckoChild::RemoveManagee(
        int32_t aProtocolId,
        IProtocol* aListener) -> void
{
    switch (aProtocolId) {
    case PHttpChannelMsgStart:
{
            PHttpChannelChild* actor = static_cast<PHttpChannelChild*>(aListener);
            auto& container = mManagedPHttpChannelChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PCookieServiceMsgStart:
{
            PCookieServiceChild* actor = static_cast<PCookieServiceChild*>(aListener);
            auto& container = mManagedPCookieServiceChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PFTPChannelMsgStart:
{
            PFTPChannelChild* actor = static_cast<PFTPChannelChild*>(aListener);
            auto& container = mManagedPFTPChannelChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PWebSocketMsgStart:
{
            PWebSocketChild* actor = static_cast<PWebSocketChild*>(aListener);
            auto& container = mManagedPWebSocketChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PWebSocketEventListenerMsgStart:
{
            PWebSocketEventListenerChild* actor = static_cast<PWebSocketEventListenerChild*>(aListener);
            auto& container = mManagedPWebSocketEventListenerChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PTCPSocketMsgStart:
{
            PTCPSocketChild* actor = static_cast<PTCPSocketChild*>(aListener);
            auto& container = mManagedPTCPSocketChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PTCPServerSocketMsgStart:
{
            PTCPServerSocketChild* actor = static_cast<PTCPServerSocketChild*>(aListener);
            auto& container = mManagedPTCPServerSocketChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PUDPSocketMsgStart:
{
            PUDPSocketChild* actor = static_cast<PUDPSocketChild*>(aListener);
            auto& container = mManagedPUDPSocketChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PDNSRequestMsgStart:
{
            PDNSRequestChild* actor = static_cast<PDNSRequestChild*>(aListener);
            auto& container = mManagedPDNSRequestChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PDataChannelMsgStart:
{
            PDataChannelChild* actor = static_cast<PDataChannelChild*>(aListener);
            auto& container = mManagedPDataChannelChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PGIOChannelMsgStart:
{
            PGIOChannelChild* actor = static_cast<PGIOChannelChild*>(aListener);
            auto& container = mManagedPGIOChannelChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PSimpleChannelMsgStart:
{
            PSimpleChannelChild* actor = static_cast<PSimpleChannelChild*>(aListener);
            auto& container = mManagedPSimpleChannelChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PFileChannelMsgStart:
{
            PFileChannelChild* actor = static_cast<PFileChannelChild*>(aListener);
            auto& container = mManagedPFileChannelChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PTransportProviderMsgStart:
{
            PTransportProviderChild* actor = static_cast<PTransportProviderChild*>(aListener);
            auto& container = mManagedPTransportProviderChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PAltDataOutputStreamMsgStart:
{
            PAltDataOutputStreamChild* actor = static_cast<PAltDataOutputStreamChild*>(aListener);
            auto& container = mManagedPAltDataOutputStreamChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PStunAddrsRequestMsgStart:
{
            PStunAddrsRequestChild* actor = static_cast<PStunAddrsRequestChild*>(aListener);
            auto& container = mManagedPStunAddrsRequestChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PClassifierDummyChannelMsgStart:
{
            PClassifierDummyChannelChild* actor = static_cast<PClassifierDummyChannelChild*>(aListener);
            auto& container = mManagedPClassifierDummyChannelChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PWebrtcTCPSocketMsgStart:
{
            PWebrtcTCPSocketChild* actor = static_cast<PWebrtcTCPSocketChild*>(aListener);
            auto& container = mManagedPWebrtcTCPSocketChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PDocumentChannelMsgStart:
{
            PDocumentChannelChild* actor = static_cast<PDocumentChannelChild*>(aListener);
            auto& container = mManagedPDocumentChannelChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    default:
FatalError("unreached");
        return;    }
}

auto PNeckoChild::DeallocManagee(
        int32_t aProtocolId,
        IProtocol* aListener) -> void
{
    switch (aProtocolId) {
    case PCookieServiceMsgStart:
        static_cast<NeckoChild*>(this)->DeallocPCookieServiceChild(static_cast<PCookieServiceChild*>(aListener));
        return;
    case PFTPChannelMsgStart:
        static_cast<NeckoChild*>(this)->DeallocPFTPChannelChild(static_cast<PFTPChannelChild*>(aListener));
        return;
    case PWebSocketMsgStart:
        static_cast<NeckoChild*>(this)->DeallocPWebSocketChild(static_cast<PWebSocketChild*>(aListener));
        return;
    case PWebSocketEventListenerMsgStart:
        static_cast<NeckoChild*>(this)->DeallocPWebSocketEventListenerChild(static_cast<PWebSocketEventListenerChild*>(aListener));
        return;
    case PTCPSocketMsgStart:
        static_cast<NeckoChild*>(this)->DeallocPTCPSocketChild(static_cast<PTCPSocketChild*>(aListener));
        return;
    case PTCPServerSocketMsgStart:
        static_cast<NeckoChild*>(this)->DeallocPTCPServerSocketChild(static_cast<PTCPServerSocketChild*>(aListener));
        return;
    case PUDPSocketMsgStart:
        static_cast<NeckoChild*>(this)->DeallocPUDPSocketChild(static_cast<PUDPSocketChild*>(aListener));
        return;
    case PGIOChannelMsgStart:
        static_cast<NeckoChild*>(this)->DeallocPGIOChannelChild(static_cast<PGIOChannelChild*>(aListener));
        return;
    case PSimpleChannelMsgStart:
        static_cast<NeckoChild*>(this)->DeallocPSimpleChannelChild(static_cast<PSimpleChannelChild*>(aListener));
        return;
    case PTransportProviderMsgStart:
        static_cast<NeckoChild*>(this)->DeallocPTransportProviderChild(static_cast<PTransportProviderChild*>(aListener));
        return;
    case PAltDataOutputStreamMsgStart:
        static_cast<NeckoChild*>(this)->DeallocPAltDataOutputStreamChild(static_cast<PAltDataOutputStreamChild*>(aListener));
        return;
    case PStunAddrsRequestMsgStart:
        static_cast<NeckoChild*>(this)->DeallocPStunAddrsRequestChild(static_cast<PStunAddrsRequestChild*>(aListener));
        return;
    case PClassifierDummyChannelMsgStart:
        static_cast<NeckoChild*>(this)->DeallocPClassifierDummyChannelChild(static_cast<PClassifierDummyChannelChild*>(aListener));
        return;
    case PWebrtcTCPSocketMsgStart:
        static_cast<NeckoChild*>(this)->DeallocPWebrtcTCPSocketChild(static_cast<PWebrtcTCPSocketChild*>(aListener));
        return;
    default:
        FatalError("unreached");
        return;
    }
}

auto PNeckoChild::OnMessageReceived(const Message& msg__) -> PNeckoChild::Result
{
    switch (msg__.type()) {
    case PNecko::Reply___delete____ID:
        {
            return MsgProcessed;
        }
    case PNecko::Reply_PCookieServiceConstructor__ID:
        {
            return MsgProcessed;
        }
    case PNecko::Reply_PHttpChannelConstructor__ID:
        {
            return MsgProcessed;
        }
    case PNecko::Reply_PFTPChannelConstructor__ID:
        {
            return MsgProcessed;
        }
    case PNecko::Reply_PWebSocketConstructor__ID:
        {
            return MsgProcessed;
        }
    case PNecko::Reply_PTCPServerSocketConstructor__ID:
        {
            return MsgProcessed;
        }
    case PNecko::Reply_PUDPSocketConstructor__ID:
        {
            return MsgProcessed;
        }
    case PNecko::Reply_PDNSRequestConstructor__ID:
        {
            return MsgProcessed;
        }
    case PNecko::Reply_PDocumentChannelConstructor__ID:
        {
            return MsgProcessed;
        }
    case PNecko::Reply_PWebSocketEventListenerConstructor__ID:
        {
            return MsgProcessed;
        }
    case PNecko::Reply_PDataChannelConstructor__ID:
        {
            return MsgProcessed;
        }
    case PNecko::Reply_PGIOChannelConstructor__ID:
        {
            return MsgProcessed;
        }
    case PNecko::Reply_PSimpleChannelConstructor__ID:
        {
            return MsgProcessed;
        }
    case PNecko::Reply_PFileChannelConstructor__ID:
        {
            return MsgProcessed;
        }
    case PNecko::Reply_PClassifierDummyChannelConstructor__ID:
        {
            return MsgProcessed;
        }
    case PNecko::Reply_PAltDataOutputStreamConstructor__ID:
        {
            return MsgProcessed;
        }
    case PNecko::Reply_PStunAddrsRequestConstructor__ID:
        {
            return MsgProcessed;
        }
    case PNecko::Reply_PWebrtcTCPSocketConstructor__ID:
        {
            return MsgProcessed;
        }
    case PNecko::Reply_GetExtensionStream__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_GetExtensionStream", OTHER);

            PickleIterator iter__{msg__};
            bool resolve__ = false;
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(resolve__)))))) {
                FatalError("Error deserializing 'resolve__'");
                return MsgValueError;
            }
            // Sentinel = 'resolve__'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 322044863)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'resolve__'");
                return MsgValueError;
            }


            UniquePtr<MessageChannel::UntypedCallbackHolder> untypedCallback =
                GetIPCChannel()->PopCallback(msg__);

            typedef MessageChannel::CallbackHolder<RefPtr<nsIInputStream>> CallbackHolder;
            auto* callback = static_cast<CallbackHolder*>(untypedCallback.get());
            if (!callback) {
                FatalError("Error unknown callback");
                return MsgProcessingError;
            }

            if (resolve__) {
                RefPtr<nsIInputStream> stream{};

                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(stream)))))) {
                    FatalError("Error deserializing 'nsIInputStream'");
                    return MsgValueError;
                }
                // Sentinel = 'stream'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 153223821)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'nsIInputStream'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Resolve(std::move(stream));
            } else {
                ResponseRejectReason reason__{};
                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(reason__)))))) {
                    FatalError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                // Sentinel = 'reason__'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 251855687)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Reject(std::move(reason__));
            }
            return MsgProcessed;
        }
    case PNecko::Reply_GetExtensionFD__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_GetExtensionFD", OTHER);

            PickleIterator iter__{msg__};
            bool resolve__ = false;
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(resolve__)))))) {
                FatalError("Error deserializing 'resolve__'");
                return MsgValueError;
            }
            // Sentinel = 'resolve__'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 322044863)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'resolve__'");
                return MsgValueError;
            }


            UniquePtr<MessageChannel::UntypedCallbackHolder> untypedCallback =
                GetIPCChannel()->PopCallback(msg__);

            typedef MessageChannel::CallbackHolder<FileDescriptor> CallbackHolder;
            auto* callback = static_cast<CallbackHolder*>(untypedCallback.get());
            if (!callback) {
                FatalError("Error unknown callback");
                return MsgProcessingError;
            }

            if (resolve__) {
                FileDescriptor fd{};

                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(fd)))))) {
                    FatalError("Error deserializing 'FileDescriptor'");
                    return MsgValueError;
                }
                // Sentinel = 'fd'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 20054219)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'FileDescriptor'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Resolve(std::move(fd));
            } else {
                ResponseRejectReason reason__{};
                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(reason__)))))) {
                    FatalError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                // Sentinel = 'reason__'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 251855687)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Reject(std::move(reason__));
            }
            return MsgProcessed;
        }
    case PNecko::Reply_InitSocketProcessBridge__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_InitSocketProcessBridge", OTHER);

            PickleIterator iter__{msg__};
            bool resolve__ = false;
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(resolve__)))))) {
                FatalError("Error deserializing 'resolve__'");
                return MsgValueError;
            }
            // Sentinel = 'resolve__'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 322044863)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'resolve__'");
                return MsgValueError;
            }


            UniquePtr<MessageChannel::UntypedCallbackHolder> untypedCallback =
                GetIPCChannel()->PopCallback(msg__);

            typedef MessageChannel::CallbackHolder<Endpoint<mozilla::net::PSocketProcessBridgeChild>> CallbackHolder;
            auto* callback = static_cast<CallbackHolder*>(untypedCallback.get());
            if (!callback) {
                FatalError("Error unknown callback");
                return MsgProcessingError;
            }

            if (resolve__) {
                Endpoint<mozilla::net::PSocketProcessBridgeChild> endpoint{};

                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(endpoint)))))) {
                    FatalError("Error deserializing 'Endpoint<mozilla::net::PSocketProcessBridgeChild>'");
                    return MsgValueError;
                }
                // Sentinel = 'endpoint'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 251724642)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'Endpoint<mozilla::net::PSocketProcessBridgeChild>'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Resolve(std::move(endpoint));
            } else {
                ResponseRejectReason reason__{};
                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(reason__)))))) {
                    FatalError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                // Sentinel = 'reason__'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 251855687)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Reject(std::move(reason__));
            }
            return MsgProcessed;
        }
    case PNecko::Reply_EnsureHSTSData__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_EnsureHSTSData", OTHER);

            PickleIterator iter__{msg__};
            bool resolve__ = false;
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(resolve__)))))) {
                FatalError("Error deserializing 'resolve__'");
                return MsgValueError;
            }
            // Sentinel = 'resolve__'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 322044863)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'resolve__'");
                return MsgValueError;
            }


            UniquePtr<MessageChannel::UntypedCallbackHolder> untypedCallback =
                GetIPCChannel()->PopCallback(msg__);

            typedef MessageChannel::CallbackHolder<bool> CallbackHolder;
            auto* callback = static_cast<CallbackHolder*>(untypedCallback.get());
            if (!callback) {
                FatalError("Error unknown callback");
                return MsgProcessingError;
            }

            if (resolve__) {
                bool result{};

                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(result)))))) {
                    FatalError("Error deserializing 'bool'");
                    return MsgValueError;
                }
                // Sentinel = 'result'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 153223840)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Resolve(std::move(result));
            } else {
                ResponseRejectReason reason__{};
                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(reason__)))))) {
                    FatalError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                // Sentinel = 'reason__'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 251855687)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Reject(std::move(reason__));
            }
            return MsgProcessed;
        }
    case PNecko::Reply_GetPageThumbStream__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_GetPageThumbStream", OTHER);

            PickleIterator iter__{msg__};
            bool resolve__ = false;
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(resolve__)))))) {
                FatalError("Error deserializing 'resolve__'");
                return MsgValueError;
            }
            // Sentinel = 'resolve__'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 322044863)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'resolve__'");
                return MsgValueError;
            }


            UniquePtr<MessageChannel::UntypedCallbackHolder> untypedCallback =
                GetIPCChannel()->PopCallback(msg__);

            typedef MessageChannel::CallbackHolder<RefPtr<nsIInputStream>> CallbackHolder;
            auto* callback = static_cast<CallbackHolder*>(untypedCallback.get());
            if (!callback) {
                FatalError("Error unknown callback");
                return MsgProcessingError;
            }

            if (resolve__) {
                RefPtr<nsIInputStream> stream{};

                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(stream)))))) {
                    FatalError("Error deserializing 'nsIInputStream'");
                    return MsgValueError;
                }
                // Sentinel = 'stream'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 153223821)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'nsIInputStream'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Resolve(std::move(stream));
            } else {
                ResponseRejectReason reason__{};
                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(reason__)))))) {
                    FatalError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                // Sentinel = 'reason__'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 251855687)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Reject(std::move(reason__));
            }
            return MsgProcessed;
        }
    case PNecko::Msg_AsyncAuthPromptForNestedFrame__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_AsyncAuthPromptForNestedFrame", OTHER);

            PickleIterator iter__{msg__};
            TabId nestedFrameId{};
            nsCString uri{};
            nsString realm{};
            uint64_t callbackId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(nestedFrameId)))))) {
                FatalError("Error deserializing 'TabId'");
                return MsgValueError;
            }
            // Sentinel = 'nestedFrameId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 618202396)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'TabId'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(uri)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'uri'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 45023569)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(realm)))))) {
                FatalError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            // Sentinel = 'realm'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 104530450)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(callbackId)))))) {
                FatalError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            // Sentinel = 'callbackId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 362349531)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<NeckoChild*>(this))->RecvAsyncAuthPromptForNestedFrame(std::move(nestedFrameId), std::move(uri), std::move(realm), std::move(callbackId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PredOnPredictPrefetch__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PredOnPredictPrefetch", OTHER);

            PickleIterator iter__{msg__};
            RefPtr<nsIURI> uri{};
            uint32_t httpStatus{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(uri)))))) {
                FatalError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            // Sentinel = 'uri'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 45023569)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(httpStatus)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'httpStatus'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 391185477)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<NeckoChild*>(this))->RecvPredOnPredictPrefetch(uri, std::move(httpStatus))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PredOnPredictPreconnect__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PredOnPredictPreconnect", OTHER);

            PickleIterator iter__{msg__};
            RefPtr<nsIURI> uri{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(uri)))))) {
                FatalError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            // Sentinel = 'uri'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 45023569)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<NeckoChild*>(this))->RecvPredOnPredictPreconnect(uri)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PredOnPredictDNS__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PredOnPredictDNS", OTHER);

            PickleIterator iter__{msg__};
            RefPtr<nsIURI> uri{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(uri)))))) {
                FatalError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            // Sentinel = 'uri'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 45023569)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<NeckoChild*>(this))->RecvPredOnPredictDNS(uri)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_SpeculativeConnectRequest__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_SpeculativeConnectRequest", OTHER);

            if ((!((static_cast<NeckoChild*>(this))->RecvSpeculativeConnectRequest()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_NetworkChangeNotification__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_NetworkChangeNotification", OTHER);

            PickleIterator iter__{msg__};
            nsCString type{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(type)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'type'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 75760067)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<NeckoChild*>(this))->RecvNetworkChangeNotification(std::move(type))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PTransportProviderConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PTransportProviderConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PTransportProviderChild* actor = (static_cast<NeckoChild*>(this))->AllocPTransportProviderChild();
            if (!actor) {
                NS_WARNING("Cannot bind null PTransportProviderChild actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPTransportProviderChild.PutEntry(actor);

            if ((!((static_cast<NeckoChild*>(this))->RecvPTransportProviderConstructor(std::move(actor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Reply_PTCPSocketConstructor__ID:
        {
            return MsgProcessed;
        }
    case PNecko::Msg_PTCPSocketConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PTCPSocketConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            nsString host{};
            uint16_t port{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(host)))))) {
                FatalError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            // Sentinel = 'host'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 72024511)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(port)))))) {
                FatalError("Error deserializing 'uint16_t'");
                return MsgValueError;
            }
            // Sentinel = 'port'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 73990598)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint16_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PTCPSocketChild* actor = (static_cast<NeckoChild*>(this))->AllocPTCPSocketChild(host, port);
            if (!actor) {
                NS_WARNING("Cannot bind null PTCPSocketChild actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPTCPSocketChild.PutEntry(actor);

            if ((!((static_cast<NeckoChild*>(this))->RecvPTCPSocketConstructor(std::move(actor), std::move(host), std::move(port))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    default:
        return MsgNotKnown;
    }
}

auto PNeckoChild::OnMessageReceived(
        const Message& msg__,
        Message*& reply__) -> PNeckoChild::Result
{
    return MsgNotKnown;
}

auto PNeckoChild::OnCallReceived(
        const Message& msg__,
        Message*& reply__) -> PNeckoChild::Result
{
    MOZ_ASSERT_UNREACHABLE("message protocol not supported");
    return MsgNotKnown;
}

auto PNeckoChild::ClearSubtree() -> void
{
    for (auto it = mManagedPHttpChannelChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPHttpChannelChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPHttpChannelChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPHttpChannelChild.Clear();

    for (auto it = mManagedPCookieServiceChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPCookieServiceChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPCookieServiceChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPCookieServiceChild.Clear();

    for (auto it = mManagedPFTPChannelChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPFTPChannelChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPFTPChannelChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPFTPChannelChild.Clear();

    for (auto it = mManagedPWebSocketChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPWebSocketChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPWebSocketChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPWebSocketChild.Clear();

    for (auto it = mManagedPWebSocketEventListenerChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPWebSocketEventListenerChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPWebSocketEventListenerChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPWebSocketEventListenerChild.Clear();

    for (auto it = mManagedPTCPSocketChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPTCPSocketChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPTCPSocketChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPTCPSocketChild.Clear();

    for (auto it = mManagedPTCPServerSocketChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPTCPServerSocketChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPTCPServerSocketChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPTCPServerSocketChild.Clear();

    for (auto it = mManagedPUDPSocketChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPUDPSocketChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPUDPSocketChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPUDPSocketChild.Clear();

    for (auto it = mManagedPDNSRequestChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPDNSRequestChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPDNSRequestChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPDNSRequestChild.Clear();

    for (auto it = mManagedPDataChannelChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPDataChannelChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPDataChannelChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPDataChannelChild.Clear();

    for (auto it = mManagedPGIOChannelChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPGIOChannelChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPGIOChannelChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPGIOChannelChild.Clear();

    for (auto it = mManagedPSimpleChannelChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPSimpleChannelChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPSimpleChannelChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPSimpleChannelChild.Clear();

    for (auto it = mManagedPFileChannelChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPFileChannelChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPFileChannelChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPFileChannelChild.Clear();

    for (auto it = mManagedPTransportProviderChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPTransportProviderChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPTransportProviderChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPTransportProviderChild.Clear();

    for (auto it = mManagedPAltDataOutputStreamChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPAltDataOutputStreamChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPAltDataOutputStreamChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPAltDataOutputStreamChild.Clear();

    for (auto it = mManagedPStunAddrsRequestChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPStunAddrsRequestChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPStunAddrsRequestChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPStunAddrsRequestChild.Clear();

    for (auto it = mManagedPClassifierDummyChannelChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPClassifierDummyChannelChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPClassifierDummyChannelChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPClassifierDummyChannelChild.Clear();

    for (auto it = mManagedPWebrtcTCPSocketChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPWebrtcTCPSocketChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPWebrtcTCPSocketChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPWebrtcTCPSocketChild.Clear();

    for (auto it = mManagedPDocumentChannelChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPDocumentChannelChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPDocumentChannelChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPDocumentChannelChild.Clear();

}



} // namespace net
} // namespace mozilla
namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::net::PNeckoChild*>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    int32_t id;
    if (!aVar) {
        id = 0;  // kNullActorId
    } else {
        id = aVar->Id();
        if (id == 1) {  // kFreedActorId
            aVar->FatalError("Actor has been |delete|d");
        }
        MOZ_RELEASE_ASSERT(
            aActor->GetIPCChannel() == aVar->GetIPCChannel(),
            "Actor must be from the same channel as the"
            " actor it's being sent over");
        MOZ_RELEASE_ASSERT(
            aVar->CanSend(),
            "Actor must still be open when sending");
    }

    WriteIPDLParam(aMsg, aActor, id);
}

auto IPDLParamTraits<mozilla::net::PNeckoChild*>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    mozilla::Maybe<mozilla::ipc::IProtocol*> actor =
        aActor->ReadActor(aMsg, aIter, true, "PNecko", PNeckoMsgStart);
    if (actor.isNothing()) {
        return false;
    }

    *aVar = static_cast<mozilla::net::PNeckoChild*>(actor.value());
    return true;
}

} // namespace ipc
} // namespace mozilla
