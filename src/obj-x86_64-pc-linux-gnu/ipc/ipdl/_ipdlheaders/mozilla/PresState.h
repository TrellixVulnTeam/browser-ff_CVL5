//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PresState_h
#define PresState_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "mozilla/dom/BlobImpl.h"
#include "mozilla/ipc/IPCCore.h"
#include "nsPoint.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SelectContentData|
//
namespace mozilla {
class SelectContentData final
{
private:

public:
    MOZ_IMPLICIT SelectContentData() :
        indices_(),
        values_()
    {
    }

    MOZ_IMPLICIT SelectContentData(
            const nsTArray<uint32_t>& _indices,
            const nsTArray<nsString>& _values) :
        indices_(_indices),
        values_(_values)
    {
    }

    nsTArray<uint32_t>&
    indices()
    {
        return indices_;
    }
    const nsTArray<uint32_t>&
    indices() const
    {
        return indices_;
    }

    nsTArray<nsString>&
    values()
    {
        return values_;
    }
    const nsTArray<nsString>&
    values() const
    {
        return values_;
    }

private:
    CopyableTArray<uint32_t> indices_;
    CopyableTArray<nsString> values_;
};
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::SelectContentData>
{
    typedef mozilla::SelectContentData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CheckedContentData|
//
namespace mozilla {
class CheckedContentData final
{
private:

public:
    MOZ_IMPLICIT CheckedContentData() :
        checked_()
    {
    }

    MOZ_IMPLICIT CheckedContentData(const bool& _checked) :
        checked_(_checked)
    {
    }

    bool&
    checked()
    {
        return checked_;
    }
    const bool&
    checked() const
    {
        return checked_;
    }

private:
    bool checked_;
};
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::CheckedContentData>
{
    typedef mozilla::CheckedContentData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union FileContentData|
//
namespace mozilla {
class FileContentData final
{
public:
    enum Type {
        T__None,
        TBlobImpl = 1,
        TnsString,
        T__Last = TnsString
    };

private:
    typedef mozilla::dom::BlobImpl BlobImpl;
    typedef RefPtr<BlobImpl> BlobImpl__tdef;
    typedef nsString nsString__tdef;

    union Value {
        mozilla::AlignedStorage2<RefPtr<BlobImpl>> VBlobImpl;
        mozilla::AlignedStorage2<nsString> VnsString;
    };

    RefPtr<BlobImpl>*
    ptr_BlobImpl()
    {
        return ((mValue).VBlobImpl).addr();
    }
    const RefPtr<BlobImpl>*
    constptr_BlobImpl() const
    {
        return ((mValue).VBlobImpl).addr();
    }
    nsString*
    ptr_nsString()
    {
        return ((mValue).VnsString).addr();
    }
    const nsString*
    constptr_nsString() const
    {
        return ((mValue).VnsString).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT FileContentData() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT FileContentData(BlobImpl* aOther);

    MOZ_IMPLICIT FileContentData(RefPtr<BlobImpl>&& aOther);

    MOZ_IMPLICIT FileContentData(const nsString& aOther);

    MOZ_IMPLICIT FileContentData(nsString&& aOther);

    MOZ_IMPLICIT FileContentData(const FileContentData& aOther);

    MOZ_IMPLICIT FileContentData(FileContentData&& aOther);

    ~FileContentData();

    Type
    type() const
    {
        return mType;
    }

    FileContentData&
    operator=(BlobImpl* aRhs);

    FileContentData&
    operator=(RefPtr<BlobImpl>&& aRhs);

    FileContentData&
    operator=(const nsString& aRhs);

    FileContentData&
    operator=(nsString&& aRhs);

    FileContentData&
    operator=(const FileContentData& aRhs);

    FileContentData&
    operator=(FileContentData&& aRhs);

    RefPtr<BlobImpl>&
    get_BlobImpl()
    {
        AssertSanity(TBlobImpl);
        return (*(ptr_BlobImpl()));
    }
    BlobImpl*
    get_BlobImpl() const
    {
        AssertSanity(TBlobImpl);
        return (*(constptr_BlobImpl()));
    }
    operator RefPtr<BlobImpl>&()
    {
        return get_BlobImpl();
    }
    operator BlobImpl*() const
    {
        return get_BlobImpl();
    }

    nsString&
    get_nsString()
    {
        AssertSanity(TnsString);
        return (*(ptr_nsString()));
    }
    const nsString&
    get_nsString() const
    {
        AssertSanity(TnsString);
        return (*(constptr_nsString()));
    }
    operator nsString&()
    {
        return get_nsString();
    }
    operator const nsString&() const
    {
        return get_nsString();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::FileContentData>
{
    typedef mozilla::FileContentData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct TextContentData|
//
namespace mozilla {
class TextContentData final
{
private:

public:
    MOZ_IMPLICIT TextContentData() :
        value_(),
        lastValueChangeWasInteractive_()
    {
    }

    MOZ_IMPLICIT TextContentData(
            const nsString& _value,
            const bool& _lastValueChangeWasInteractive) :
        value_(_value),
        lastValueChangeWasInteractive_(_lastValueChangeWasInteractive)
    {
    }

    nsString&
    value()
    {
        return value_;
    }
    const nsString&
    value() const
    {
        return value_;
    }

    bool&
    lastValueChangeWasInteractive()
    {
        return lastValueChangeWasInteractive_;
    }
    const bool&
    lastValueChangeWasInteractive() const
    {
        return lastValueChangeWasInteractive_;
    }

private:
    nsString value_;
    bool lastValueChangeWasInteractive_;
};
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::TextContentData>
{
    typedef mozilla::TextContentData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union PresContentData|
//
namespace mozilla {
class PresContentData final
{
public:
    enum Type {
        T__None,
        Tvoid_t = 1,
        TTextContentData,
        TSelectContentData,
        TCheckedContentData,
        TArrayOfFileContentData,
        T__Last = TArrayOfFileContentData
    };

private:
    typedef mozilla::void_t void_t;
    typedef mozilla::TextContentData TextContentData;
    typedef mozilla::SelectContentData SelectContentData;
    typedef mozilla::CheckedContentData CheckedContentData;
    typedef mozilla::FileContentData FileContentData;
    typedef void_t void_t__tdef;
    typedef TextContentData TextContentData__tdef;
    typedef SelectContentData SelectContentData__tdef;
    typedef CheckedContentData CheckedContentData__tdef;
    typedef nsTArray<FileContentData> ArrayOfFileContentData__tdef;

    union Value {
        mozilla::AlignedStorage2<void_t> Vvoid_t;
        mozilla::AlignedStorage2<TextContentData> VTextContentData;
        mozilla::AlignedStorage2<SelectContentData> VSelectContentData;
        mozilla::AlignedStorage2<CheckedContentData> VCheckedContentData;
        mozilla::AlignedStorage2<nsTArray<FileContentData>> VArrayOfFileContentData;
    };

    void_t*
    ptr_void_t()
    {
        return ((mValue).Vvoid_t).addr();
    }
    const void_t*
    constptr_void_t() const
    {
        return ((mValue).Vvoid_t).addr();
    }
    TextContentData*
    ptr_TextContentData()
    {
        return ((mValue).VTextContentData).addr();
    }
    const TextContentData*
    constptr_TextContentData() const
    {
        return ((mValue).VTextContentData).addr();
    }
    SelectContentData*
    ptr_SelectContentData()
    {
        return ((mValue).VSelectContentData).addr();
    }
    const SelectContentData*
    constptr_SelectContentData() const
    {
        return ((mValue).VSelectContentData).addr();
    }
    CheckedContentData*
    ptr_CheckedContentData()
    {
        return ((mValue).VCheckedContentData).addr();
    }
    const CheckedContentData*
    constptr_CheckedContentData() const
    {
        return ((mValue).VCheckedContentData).addr();
    }
    nsTArray<FileContentData>*
    ptr_ArrayOfFileContentData()
    {
        return ((mValue).VArrayOfFileContentData).addr();
    }
    const nsTArray<FileContentData>*
    constptr_ArrayOfFileContentData() const
    {
        return ((mValue).VArrayOfFileContentData).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT PresContentData() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT PresContentData(const void_t& aOther);

    MOZ_IMPLICIT PresContentData(void_t&& aOther);

    MOZ_IMPLICIT PresContentData(const TextContentData& aOther);

    MOZ_IMPLICIT PresContentData(TextContentData&& aOther);

    MOZ_IMPLICIT PresContentData(const SelectContentData& aOther);

    MOZ_IMPLICIT PresContentData(SelectContentData&& aOther);

    MOZ_IMPLICIT PresContentData(const CheckedContentData& aOther);

    MOZ_IMPLICIT PresContentData(CheckedContentData&& aOther);

    MOZ_IMPLICIT PresContentData(const nsTArray<FileContentData>& aOther);

    MOZ_IMPLICIT PresContentData(nsTArray<FileContentData>&& aOther);

    MOZ_IMPLICIT PresContentData(const PresContentData& aOther);

    MOZ_IMPLICIT PresContentData(PresContentData&& aOther);

    ~PresContentData();

    Type
    type() const
    {
        return mType;
    }

    PresContentData&
    operator=(const void_t& aRhs);

    PresContentData&
    operator=(void_t&& aRhs);

    PresContentData&
    operator=(const TextContentData& aRhs);

    PresContentData&
    operator=(TextContentData&& aRhs);

    PresContentData&
    operator=(const SelectContentData& aRhs);

    PresContentData&
    operator=(SelectContentData&& aRhs);

    PresContentData&
    operator=(const CheckedContentData& aRhs);

    PresContentData&
    operator=(CheckedContentData&& aRhs);

    PresContentData&
    operator=(const nsTArray<FileContentData>& aRhs);

    PresContentData&
    operator=(nsTArray<FileContentData>&& aRhs);

    PresContentData&
    operator=(const PresContentData& aRhs);

    PresContentData&
    operator=(PresContentData&& aRhs);

    void_t&
    get_void_t()
    {
        AssertSanity(Tvoid_t);
        return (*(ptr_void_t()));
    }
    const void_t&
    get_void_t() const
    {
        AssertSanity(Tvoid_t);
        return (*(constptr_void_t()));
    }
    operator void_t&()
    {
        return get_void_t();
    }
    operator const void_t&() const
    {
        return get_void_t();
    }

    TextContentData&
    get_TextContentData()
    {
        AssertSanity(TTextContentData);
        return (*(ptr_TextContentData()));
    }
    const TextContentData&
    get_TextContentData() const
    {
        AssertSanity(TTextContentData);
        return (*(constptr_TextContentData()));
    }
    operator TextContentData&()
    {
        return get_TextContentData();
    }
    operator const TextContentData&() const
    {
        return get_TextContentData();
    }

    SelectContentData&
    get_SelectContentData()
    {
        AssertSanity(TSelectContentData);
        return (*(ptr_SelectContentData()));
    }
    const SelectContentData&
    get_SelectContentData() const
    {
        AssertSanity(TSelectContentData);
        return (*(constptr_SelectContentData()));
    }
    operator SelectContentData&()
    {
        return get_SelectContentData();
    }
    operator const SelectContentData&() const
    {
        return get_SelectContentData();
    }

    CheckedContentData&
    get_CheckedContentData()
    {
        AssertSanity(TCheckedContentData);
        return (*(ptr_CheckedContentData()));
    }
    const CheckedContentData&
    get_CheckedContentData() const
    {
        AssertSanity(TCheckedContentData);
        return (*(constptr_CheckedContentData()));
    }
    operator CheckedContentData&()
    {
        return get_CheckedContentData();
    }
    operator const CheckedContentData&() const
    {
        return get_CheckedContentData();
    }

    nsTArray<FileContentData>&
    get_ArrayOfFileContentData()
    {
        AssertSanity(TArrayOfFileContentData);
        return (*(ptr_ArrayOfFileContentData()));
    }
    const nsTArray<FileContentData>&
    get_ArrayOfFileContentData() const
    {
        AssertSanity(TArrayOfFileContentData);
        return (*(constptr_ArrayOfFileContentData()));
    }
    operator nsTArray<FileContentData>&()
    {
        return get_ArrayOfFileContentData();
    }
    operator const nsTArray<FileContentData>&() const
    {
        return get_ArrayOfFileContentData();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::PresContentData>
{
    typedef mozilla::PresContentData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct PresState|
//
namespace mozilla {
class PresState final
{
private:
    typedef mozilla::PresContentData PresContentData;

public:
    MOZ_IMPLICIT PresState() :
        contentData_(),
        scrollState_(),
        allowScrollOriginDowngrade_(),
        disabledSet_(),
        disabled_(),
        droppedDown_(),
        resolution_()
    {
    }

    MOZ_IMPLICIT PresState(
            const PresContentData& _contentData,
            const nsPoint& _scrollState,
            const bool& _allowScrollOriginDowngrade,
            const float& _resolution,
            const bool& _disabledSet,
            const bool& _disabled,
            const bool& _droppedDown) :
        contentData_(_contentData),
        scrollState_(_scrollState),
        allowScrollOriginDowngrade_(_allowScrollOriginDowngrade),
        disabledSet_(_disabledSet),
        disabled_(_disabled),
        droppedDown_(_droppedDown),
        resolution_(_resolution)
    {
    }

    PresContentData&
    contentData()
    {
        return contentData_;
    }
    const PresContentData&
    contentData() const
    {
        return contentData_;
    }

    nsPoint&
    scrollState()
    {
        return scrollState_;
    }
    const nsPoint&
    scrollState() const
    {
        return scrollState_;
    }

    bool&
    allowScrollOriginDowngrade()
    {
        return allowScrollOriginDowngrade_;
    }
    const bool&
    allowScrollOriginDowngrade() const
    {
        return allowScrollOriginDowngrade_;
    }

    float&
    resolution()
    {
        return resolution_;
    }
    const float&
    resolution() const
    {
        return resolution_;
    }

    bool&
    disabledSet()
    {
        return disabledSet_;
    }
    const bool&
    disabledSet() const
    {
        return disabledSet_;
    }

    bool&
    disabled()
    {
        return disabled_;
    }
    const bool&
    disabled() const
    {
        return disabled_;
    }

    bool&
    droppedDown()
    {
        return droppedDown_;
    }
    const bool&
    droppedDown() const
    {
        return droppedDown_;
    }

private:
    PresContentData contentData_;
    nsPoint scrollState_;
    bool allowScrollOriginDowngrade_;
    bool disabledSet_;
    bool disabled_;
    bool droppedDown_;
    float resolution_;
};
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::PresState>
{
    typedef mozilla::PresState paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

#endif // ifndef PresState_h
