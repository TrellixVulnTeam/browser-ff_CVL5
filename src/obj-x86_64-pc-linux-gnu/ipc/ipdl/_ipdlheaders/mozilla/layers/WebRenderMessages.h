//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef WebRenderMessages_h
#define WebRenderMessages_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "MediaInfo.h"
#include "Units.h"
#include "mozilla/layers/LayersTypes.h"
#include "mozilla/webrender/WebRenderTypes.h"
#include "mozilla/webrender/webrender_ffi.h"
#include "mozilla/layers/LayersSurfaces.h"
#include "mozilla/layers/LayersMessages.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct RefCountedShmem|
//
namespace mozilla {
namespace layers {
class RefCountedShmem final
{
private:
    typedef mozilla::ipc::Shmem Shmem;

public:
    MOZ_IMPLICIT RefCountedShmem() :
        buffer_()
    {
    }

    MOZ_IMPLICIT RefCountedShmem(Shmem&& _buffer) :
        buffer_(_buffer)
    {
    }

    Shmem&
    buffer()
    {
        return buffer_;
    }
    Shmem&
    buffer() const
    {
        return const_cast<Shmem&>(buffer_);
    }

private:
    Shmem buffer_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::RefCountedShmem>
{
    typedef mozilla::layers::RefCountedShmem paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpAddPrivateExternalImage|
//
namespace mozilla {
namespace layers {
class OpAddPrivateExternalImage final
{
private:
    typedef mozilla::wr::ExternalImageId ExternalImageId;
    typedef mozilla::wr::ImageKey ImageKey;
    typedef mozilla::wr::ImageDescriptor ImageDescriptor;

public:
    MOZ_IMPLICIT OpAddPrivateExternalImage() :
        externalImageId_(),
        key_(),
        descriptor_()
    {
    }

    MOZ_IMPLICIT OpAddPrivateExternalImage(
            const ExternalImageId& _externalImageId,
            const ImageKey& _key,
            const ImageDescriptor& _descriptor) :
        externalImageId_(_externalImageId),
        key_(_key),
        descriptor_(_descriptor)
    {
    }

    ExternalImageId&
    externalImageId()
    {
        return externalImageId_;
    }
    const ExternalImageId&
    externalImageId() const
    {
        return externalImageId_;
    }

    ImageKey&
    key()
    {
        return key_;
    }
    const ImageKey&
    key() const
    {
        return key_;
    }

    ImageDescriptor&
    descriptor()
    {
        return descriptor_;
    }
    const ImageDescriptor&
    descriptor() const
    {
        return descriptor_;
    }

private:
    ExternalImageId externalImageId_;
    ImageKey key_;
    ImageDescriptor descriptor_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpAddPrivateExternalImage>
{
    typedef mozilla::layers::OpAddPrivateExternalImage paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpAddSharedExternalImage|
//
namespace mozilla {
namespace layers {
class OpAddSharedExternalImage final
{
private:
    typedef mozilla::wr::ExternalImageId ExternalImageId;
    typedef mozilla::wr::ImageKey ImageKey;

public:
    MOZ_IMPLICIT OpAddSharedExternalImage() :
        externalImageId_(),
        key_()
    {
    }

    MOZ_IMPLICIT OpAddSharedExternalImage(
            const ExternalImageId& _externalImageId,
            const ImageKey& _key) :
        externalImageId_(_externalImageId),
        key_(_key)
    {
    }

    ExternalImageId&
    externalImageId()
    {
        return externalImageId_;
    }
    const ExternalImageId&
    externalImageId() const
    {
        return externalImageId_;
    }

    ImageKey&
    key()
    {
        return key_;
    }
    const ImageKey&
    key() const
    {
        return key_;
    }

private:
    ExternalImageId externalImageId_;
    ImageKey key_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpAddSharedExternalImage>
{
    typedef mozilla::layers::OpAddSharedExternalImage paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace layers {
class PTextureParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PTextureChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpPushExternalImageForTexture|
//
namespace mozilla {
namespace layers {
class OpPushExternalImageForTexture final
{
private:
    typedef mozilla::wr::ExternalImageId ExternalImageId;
    typedef mozilla::wr::ImageKey ImageKey;
    typedef mozilla::layers::PTextureParent PTextureParent;
    typedef mozilla::layers::PTextureChild PTextureChild;

public:
    MOZ_IMPLICIT OpPushExternalImageForTexture() :
        externalImageId_(),
        key_(),
        textureParent_(),
        textureChild_(),
        isUpdate_()
    {
    }

    MOZ_IMPLICIT OpPushExternalImageForTexture(
            const ExternalImageId& _externalImageId,
            const ImageKey& _key,
            PTextureParent* _textureParent,
            PTextureChild* _textureChild,
            const bool& _isUpdate) :
        externalImageId_(_externalImageId),
        key_(_key),
        textureParent_(_textureParent),
        textureChild_(_textureChild),
        isUpdate_(_isUpdate)
    {
    }

    ExternalImageId&
    externalImageId()
    {
        return externalImageId_;
    }
    const ExternalImageId&
    externalImageId() const
    {
        return externalImageId_;
    }

    ImageKey&
    key()
    {
        return key_;
    }
    const ImageKey&
    key() const
    {
        return key_;
    }

    PTextureParent*&
    textureParent()
    {
        return textureParent_;
    }
    PTextureParent*
    textureParent() const
    {
        return textureParent_;
    }

    PTextureChild*&
    textureChild()
    {
        return textureChild_;
    }
    PTextureChild*
    textureChild() const
    {
        return textureChild_;
    }

    bool&
    isUpdate()
    {
        return isUpdate_;
    }
    const bool&
    isUpdate() const
    {
        return isUpdate_;
    }

private:
    ExternalImageId externalImageId_;
    ImageKey key_;
    PTextureParent* textureParent_;
    PTextureChild* textureChild_;
    bool isUpdate_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpPushExternalImageForTexture>
{
    typedef mozilla::layers::OpPushExternalImageForTexture paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpAddCompositorAnimations|
//
namespace mozilla {
namespace layers {
class OpAddCompositorAnimations final
{
private:
    typedef mozilla::layers::CompositorAnimations CompositorAnimations;

public:
    MOZ_IMPLICIT OpAddCompositorAnimations() :
        data_()
    {
    }

    MOZ_IMPLICIT OpAddCompositorAnimations(const CompositorAnimations& _data) :
        data_(_data)
    {
    }

    CompositorAnimations&
    data()
    {
        return data_;
    }
    const CompositorAnimations&
    data() const
    {
        return data_;
    }

private:
    CompositorAnimations data_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpAddCompositorAnimations>
{
    typedef mozilla::layers::OpAddCompositorAnimations paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpAddPipelineIdForCompositable|
//
namespace mozilla {
namespace layers {
class OpAddPipelineIdForCompositable final
{
private:
    typedef mozilla::wr::PipelineId PipelineId;
    typedef mozilla::layers::CompositableHandle CompositableHandle;

public:
    MOZ_IMPLICIT OpAddPipelineIdForCompositable() :
        pipelineId_(),
        handle_(),
        isAsync_()
    {
    }

    MOZ_IMPLICIT OpAddPipelineIdForCompositable(
            const PipelineId& _pipelineId,
            const CompositableHandle& _handle,
            const bool& _isAsync) :
        pipelineId_(_pipelineId),
        handle_(_handle),
        isAsync_(_isAsync)
    {
    }

    PipelineId&
    pipelineId()
    {
        return pipelineId_;
    }
    const PipelineId&
    pipelineId() const
    {
        return pipelineId_;
    }

    CompositableHandle&
    handle()
    {
        return handle_;
    }
    const CompositableHandle&
    handle() const
    {
        return handle_;
    }

    bool&
    isAsync()
    {
        return isAsync_;
    }
    const bool&
    isAsync() const
    {
        return isAsync_;
    }

private:
    PipelineId pipelineId_;
    CompositableHandle handle_;
    bool isAsync_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpAddPipelineIdForCompositable>
{
    typedef mozilla::layers::OpAddPipelineIdForCompositable paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpRemovePipelineIdForCompositable|
//
namespace mozilla {
namespace layers {
class OpRemovePipelineIdForCompositable final
{
private:
    typedef mozilla::wr::PipelineId PipelineId;

public:
    MOZ_IMPLICIT OpRemovePipelineIdForCompositable() :
        pipelineId_()
    {
    }

    MOZ_IMPLICIT OpRemovePipelineIdForCompositable(const PipelineId& _pipelineId) :
        pipelineId_(_pipelineId)
    {
    }

    PipelineId&
    pipelineId()
    {
        return pipelineId_;
    }
    const PipelineId&
    pipelineId() const
    {
        return pipelineId_;
    }

private:
    PipelineId pipelineId_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpRemovePipelineIdForCompositable>
{
    typedef mozilla::layers::OpRemovePipelineIdForCompositable paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpReleaseTextureOfImage|
//
namespace mozilla {
namespace layers {
class OpReleaseTextureOfImage final
{
private:
    typedef mozilla::wr::ImageKey ImageKey;

public:
    MOZ_IMPLICIT OpReleaseTextureOfImage() :
        key_()
    {
    }

    MOZ_IMPLICIT OpReleaseTextureOfImage(const ImageKey& _key) :
        key_(_key)
    {
    }

    ImageKey&
    key()
    {
        return key_;
    }
    const ImageKey&
    key() const
    {
        return key_;
    }

private:
    ImageKey key_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpReleaseTextureOfImage>
{
    typedef mozilla::layers::OpReleaseTextureOfImage paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpUpdateAsyncImagePipeline|
//
namespace mozilla {
namespace layers {
class OpUpdateAsyncImagePipeline final
{
private:
    typedef mozilla::wr::PipelineId PipelineId;
    typedef mozilla::LayoutDeviceRect LayoutDeviceRect;
    typedef mozilla::VideoInfo::Rotation Rotation;
    typedef mozilla::wr::ImageRendering ImageRendering;
    typedef mozilla::wr::MixBlendMode MixBlendMode;

public:
    MOZ_IMPLICIT OpUpdateAsyncImagePipeline() :
        pipelineId_(),
        scBounds_(),
        rotation_(),
        filter_(),
        mixBlendMode_()
    {
    }

    MOZ_IMPLICIT OpUpdateAsyncImagePipeline(
            const PipelineId& _pipelineId,
            const LayoutDeviceRect& _scBounds,
            const Rotation& _rotation,
            const ImageRendering& _filter,
            const MixBlendMode& _mixBlendMode) :
        pipelineId_(_pipelineId),
        scBounds_(_scBounds),
        rotation_(_rotation),
        filter_(_filter),
        mixBlendMode_(_mixBlendMode)
    {
    }

    PipelineId&
    pipelineId()
    {
        return pipelineId_;
    }
    const PipelineId&
    pipelineId() const
    {
        return pipelineId_;
    }

    LayoutDeviceRect&
    scBounds()
    {
        return scBounds_;
    }
    const LayoutDeviceRect&
    scBounds() const
    {
        return scBounds_;
    }

    Rotation&
    rotation()
    {
        return rotation_;
    }
    const Rotation&
    rotation() const
    {
        return rotation_;
    }

    ImageRendering&
    filter()
    {
        return filter_;
    }
    const ImageRendering&
    filter() const
    {
        return filter_;
    }

    MixBlendMode&
    mixBlendMode()
    {
        return mixBlendMode_;
    }
    const MixBlendMode&
    mixBlendMode() const
    {
        return mixBlendMode_;
    }

private:
    PipelineId pipelineId_;
    LayoutDeviceRect scBounds_;
    Rotation rotation_;
    ImageRendering filter_;
    MixBlendMode mixBlendMode_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpUpdateAsyncImagePipeline>
{
    typedef mozilla::layers::OpUpdateAsyncImagePipeline paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpUpdatedAsyncImagePipeline|
//
namespace mozilla {
namespace layers {
class OpUpdatedAsyncImagePipeline final
{
private:
    typedef mozilla::wr::PipelineId PipelineId;

public:
    MOZ_IMPLICIT OpUpdatedAsyncImagePipeline() :
        pipelineId_()
    {
    }

    MOZ_IMPLICIT OpUpdatedAsyncImagePipeline(const PipelineId& _pipelineId) :
        pipelineId_(_pipelineId)
    {
    }

    PipelineId&
    pipelineId()
    {
        return pipelineId_;
    }
    const PipelineId&
    pipelineId() const
    {
        return pipelineId_;
    }

private:
    PipelineId pipelineId_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpUpdatedAsyncImagePipeline>
{
    typedef mozilla::layers::OpUpdatedAsyncImagePipeline paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union WebRenderParentCommand|
//
namespace mozilla {
namespace layers {
class WebRenderParentCommand final
{
public:
    enum Type {
        T__None,
        TOpAddPipelineIdForCompositable = 1,
        TOpRemovePipelineIdForCompositable,
        TOpReleaseTextureOfImage,
        TOpUpdateAsyncImagePipeline,
        TOpUpdatedAsyncImagePipeline,
        TCompositableOperation,
        TOpAddCompositorAnimations,
        T__Last = TOpAddCompositorAnimations
    };

private:
    typedef mozilla::layers::OpAddPipelineIdForCompositable OpAddPipelineIdForCompositable;
    typedef mozilla::layers::OpRemovePipelineIdForCompositable OpRemovePipelineIdForCompositable;
    typedef mozilla::layers::OpReleaseTextureOfImage OpReleaseTextureOfImage;
    typedef mozilla::layers::OpUpdateAsyncImagePipeline OpUpdateAsyncImagePipeline;
    typedef mozilla::layers::OpUpdatedAsyncImagePipeline OpUpdatedAsyncImagePipeline;
    typedef mozilla::layers::CompositableOperation CompositableOperation;
    typedef mozilla::layers::OpAddCompositorAnimations OpAddCompositorAnimations;
    typedef OpAddPipelineIdForCompositable OpAddPipelineIdForCompositable__tdef;
    typedef OpRemovePipelineIdForCompositable OpRemovePipelineIdForCompositable__tdef;
    typedef OpReleaseTextureOfImage OpReleaseTextureOfImage__tdef;
    typedef OpUpdateAsyncImagePipeline OpUpdateAsyncImagePipeline__tdef;
    typedef OpUpdatedAsyncImagePipeline OpUpdatedAsyncImagePipeline__tdef;
    typedef CompositableOperation CompositableOperation__tdef;
    typedef OpAddCompositorAnimations OpAddCompositorAnimations__tdef;

    union Value {
        mozilla::AlignedStorage2<OpAddPipelineIdForCompositable> VOpAddPipelineIdForCompositable;
        mozilla::AlignedStorage2<OpRemovePipelineIdForCompositable> VOpRemovePipelineIdForCompositable;
        mozilla::AlignedStorage2<OpReleaseTextureOfImage> VOpReleaseTextureOfImage;
        mozilla::AlignedStorage2<OpUpdateAsyncImagePipeline> VOpUpdateAsyncImagePipeline;
        mozilla::AlignedStorage2<OpUpdatedAsyncImagePipeline> VOpUpdatedAsyncImagePipeline;
        mozilla::AlignedStorage2<CompositableOperation> VCompositableOperation;
        mozilla::AlignedStorage2<OpAddCompositorAnimations> VOpAddCompositorAnimations;
    };

    OpAddPipelineIdForCompositable*
    ptr_OpAddPipelineIdForCompositable()
    {
        return ((mValue).VOpAddPipelineIdForCompositable).addr();
    }
    const OpAddPipelineIdForCompositable*
    constptr_OpAddPipelineIdForCompositable() const
    {
        return ((mValue).VOpAddPipelineIdForCompositable).addr();
    }
    OpRemovePipelineIdForCompositable*
    ptr_OpRemovePipelineIdForCompositable()
    {
        return ((mValue).VOpRemovePipelineIdForCompositable).addr();
    }
    const OpRemovePipelineIdForCompositable*
    constptr_OpRemovePipelineIdForCompositable() const
    {
        return ((mValue).VOpRemovePipelineIdForCompositable).addr();
    }
    OpReleaseTextureOfImage*
    ptr_OpReleaseTextureOfImage()
    {
        return ((mValue).VOpReleaseTextureOfImage).addr();
    }
    const OpReleaseTextureOfImage*
    constptr_OpReleaseTextureOfImage() const
    {
        return ((mValue).VOpReleaseTextureOfImage).addr();
    }
    OpUpdateAsyncImagePipeline*
    ptr_OpUpdateAsyncImagePipeline()
    {
        return ((mValue).VOpUpdateAsyncImagePipeline).addr();
    }
    const OpUpdateAsyncImagePipeline*
    constptr_OpUpdateAsyncImagePipeline() const
    {
        return ((mValue).VOpUpdateAsyncImagePipeline).addr();
    }
    OpUpdatedAsyncImagePipeline*
    ptr_OpUpdatedAsyncImagePipeline()
    {
        return ((mValue).VOpUpdatedAsyncImagePipeline).addr();
    }
    const OpUpdatedAsyncImagePipeline*
    constptr_OpUpdatedAsyncImagePipeline() const
    {
        return ((mValue).VOpUpdatedAsyncImagePipeline).addr();
    }
    CompositableOperation*
    ptr_CompositableOperation()
    {
        return ((mValue).VCompositableOperation).addr();
    }
    const CompositableOperation*
    constptr_CompositableOperation() const
    {
        return ((mValue).VCompositableOperation).addr();
    }
    OpAddCompositorAnimations*
    ptr_OpAddCompositorAnimations()
    {
        return ((mValue).VOpAddCompositorAnimations).addr();
    }
    const OpAddCompositorAnimations*
    constptr_OpAddCompositorAnimations() const
    {
        return ((mValue).VOpAddCompositorAnimations).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT WebRenderParentCommand() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT WebRenderParentCommand(const OpAddPipelineIdForCompositable& aOther);

    MOZ_IMPLICIT WebRenderParentCommand(OpAddPipelineIdForCompositable&& aOther);

    MOZ_IMPLICIT WebRenderParentCommand(const OpRemovePipelineIdForCompositable& aOther);

    MOZ_IMPLICIT WebRenderParentCommand(OpRemovePipelineIdForCompositable&& aOther);

    MOZ_IMPLICIT WebRenderParentCommand(const OpReleaseTextureOfImage& aOther);

    MOZ_IMPLICIT WebRenderParentCommand(OpReleaseTextureOfImage&& aOther);

    MOZ_IMPLICIT WebRenderParentCommand(const OpUpdateAsyncImagePipeline& aOther);

    MOZ_IMPLICIT WebRenderParentCommand(OpUpdateAsyncImagePipeline&& aOther);

    MOZ_IMPLICIT WebRenderParentCommand(const OpUpdatedAsyncImagePipeline& aOther);

    MOZ_IMPLICIT WebRenderParentCommand(OpUpdatedAsyncImagePipeline&& aOther);

    MOZ_IMPLICIT WebRenderParentCommand(const CompositableOperation& aOther);

    MOZ_IMPLICIT WebRenderParentCommand(CompositableOperation&& aOther);

    MOZ_IMPLICIT WebRenderParentCommand(const OpAddCompositorAnimations& aOther);

    MOZ_IMPLICIT WebRenderParentCommand(OpAddCompositorAnimations&& aOther);

    MOZ_IMPLICIT WebRenderParentCommand(const WebRenderParentCommand& aOther);

    MOZ_IMPLICIT WebRenderParentCommand(WebRenderParentCommand&& aOther);

    ~WebRenderParentCommand();

    Type
    type() const
    {
        return mType;
    }

    WebRenderParentCommand&
    operator=(const OpAddPipelineIdForCompositable& aRhs);

    WebRenderParentCommand&
    operator=(OpAddPipelineIdForCompositable&& aRhs);

    WebRenderParentCommand&
    operator=(const OpRemovePipelineIdForCompositable& aRhs);

    WebRenderParentCommand&
    operator=(OpRemovePipelineIdForCompositable&& aRhs);

    WebRenderParentCommand&
    operator=(const OpReleaseTextureOfImage& aRhs);

    WebRenderParentCommand&
    operator=(OpReleaseTextureOfImage&& aRhs);

    WebRenderParentCommand&
    operator=(const OpUpdateAsyncImagePipeline& aRhs);

    WebRenderParentCommand&
    operator=(OpUpdateAsyncImagePipeline&& aRhs);

    WebRenderParentCommand&
    operator=(const OpUpdatedAsyncImagePipeline& aRhs);

    WebRenderParentCommand&
    operator=(OpUpdatedAsyncImagePipeline&& aRhs);

    WebRenderParentCommand&
    operator=(const CompositableOperation& aRhs);

    WebRenderParentCommand&
    operator=(CompositableOperation&& aRhs);

    WebRenderParentCommand&
    operator=(const OpAddCompositorAnimations& aRhs);

    WebRenderParentCommand&
    operator=(OpAddCompositorAnimations&& aRhs);

    WebRenderParentCommand&
    operator=(const WebRenderParentCommand& aRhs);

    WebRenderParentCommand&
    operator=(WebRenderParentCommand&& aRhs);

    OpAddPipelineIdForCompositable&
    get_OpAddPipelineIdForCompositable()
    {
        AssertSanity(TOpAddPipelineIdForCompositable);
        return (*(ptr_OpAddPipelineIdForCompositable()));
    }
    const OpAddPipelineIdForCompositable&
    get_OpAddPipelineIdForCompositable() const
    {
        AssertSanity(TOpAddPipelineIdForCompositable);
        return (*(constptr_OpAddPipelineIdForCompositable()));
    }
    operator OpAddPipelineIdForCompositable&()
    {
        return get_OpAddPipelineIdForCompositable();
    }
    operator const OpAddPipelineIdForCompositable&() const
    {
        return get_OpAddPipelineIdForCompositable();
    }

    OpRemovePipelineIdForCompositable&
    get_OpRemovePipelineIdForCompositable()
    {
        AssertSanity(TOpRemovePipelineIdForCompositable);
        return (*(ptr_OpRemovePipelineIdForCompositable()));
    }
    const OpRemovePipelineIdForCompositable&
    get_OpRemovePipelineIdForCompositable() const
    {
        AssertSanity(TOpRemovePipelineIdForCompositable);
        return (*(constptr_OpRemovePipelineIdForCompositable()));
    }
    operator OpRemovePipelineIdForCompositable&()
    {
        return get_OpRemovePipelineIdForCompositable();
    }
    operator const OpRemovePipelineIdForCompositable&() const
    {
        return get_OpRemovePipelineIdForCompositable();
    }

    OpReleaseTextureOfImage&
    get_OpReleaseTextureOfImage()
    {
        AssertSanity(TOpReleaseTextureOfImage);
        return (*(ptr_OpReleaseTextureOfImage()));
    }
    const OpReleaseTextureOfImage&
    get_OpReleaseTextureOfImage() const
    {
        AssertSanity(TOpReleaseTextureOfImage);
        return (*(constptr_OpReleaseTextureOfImage()));
    }
    operator OpReleaseTextureOfImage&()
    {
        return get_OpReleaseTextureOfImage();
    }
    operator const OpReleaseTextureOfImage&() const
    {
        return get_OpReleaseTextureOfImage();
    }

    OpUpdateAsyncImagePipeline&
    get_OpUpdateAsyncImagePipeline()
    {
        AssertSanity(TOpUpdateAsyncImagePipeline);
        return (*(ptr_OpUpdateAsyncImagePipeline()));
    }
    const OpUpdateAsyncImagePipeline&
    get_OpUpdateAsyncImagePipeline() const
    {
        AssertSanity(TOpUpdateAsyncImagePipeline);
        return (*(constptr_OpUpdateAsyncImagePipeline()));
    }
    operator OpUpdateAsyncImagePipeline&()
    {
        return get_OpUpdateAsyncImagePipeline();
    }
    operator const OpUpdateAsyncImagePipeline&() const
    {
        return get_OpUpdateAsyncImagePipeline();
    }

    OpUpdatedAsyncImagePipeline&
    get_OpUpdatedAsyncImagePipeline()
    {
        AssertSanity(TOpUpdatedAsyncImagePipeline);
        return (*(ptr_OpUpdatedAsyncImagePipeline()));
    }
    const OpUpdatedAsyncImagePipeline&
    get_OpUpdatedAsyncImagePipeline() const
    {
        AssertSanity(TOpUpdatedAsyncImagePipeline);
        return (*(constptr_OpUpdatedAsyncImagePipeline()));
    }
    operator OpUpdatedAsyncImagePipeline&()
    {
        return get_OpUpdatedAsyncImagePipeline();
    }
    operator const OpUpdatedAsyncImagePipeline&() const
    {
        return get_OpUpdatedAsyncImagePipeline();
    }

    CompositableOperation&
    get_CompositableOperation()
    {
        AssertSanity(TCompositableOperation);
        return (*(ptr_CompositableOperation()));
    }
    const CompositableOperation&
    get_CompositableOperation() const
    {
        AssertSanity(TCompositableOperation);
        return (*(constptr_CompositableOperation()));
    }
    operator CompositableOperation&()
    {
        return get_CompositableOperation();
    }
    operator const CompositableOperation&() const
    {
        return get_CompositableOperation();
    }

    OpAddCompositorAnimations&
    get_OpAddCompositorAnimations()
    {
        AssertSanity(TOpAddCompositorAnimations);
        return (*(ptr_OpAddCompositorAnimations()));
    }
    const OpAddCompositorAnimations&
    get_OpAddCompositorAnimations() const
    {
        AssertSanity(TOpAddCompositorAnimations);
        return (*(constptr_OpAddCompositorAnimations()));
    }
    operator OpAddCompositorAnimations&()
    {
        return get_OpAddCompositorAnimations();
    }
    operator const OpAddCompositorAnimations&() const
    {
        return get_OpAddCompositorAnimations();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::WebRenderParentCommand>
{
    typedef mozilla::layers::WebRenderParentCommand paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OffsetRange|
//
namespace mozilla {
namespace layers {
class OffsetRange final
{
private:

public:
    MOZ_IMPLICIT OffsetRange() :
        source_(),
        start_(),
        length_()
    {
    }

    MOZ_IMPLICIT OffsetRange(
            const uint32_t& _source,
            const uint32_t& _start,
            const uint32_t& _length) :
        source_(_source),
        start_(_start),
        length_(_length)
    {
    }

    uint32_t&
    source()
    {
        return source_;
    }
    const uint32_t&
    source() const
    {
        return source_;
    }

    uint32_t&
    start()
    {
        return start_;
    }
    const uint32_t&
    start() const
    {
        return start_;
    }

    uint32_t&
    length()
    {
        return length_;
    }
    const uint32_t&
    length() const
    {
        return length_;
    }

private:
    void
    StaticAssertions() const;
    uint32_t source_;
    uint32_t start_;
    uint32_t length_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OffsetRange>
{
    typedef mozilla::layers::OffsetRange paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpAddImage|
//
namespace mozilla {
namespace layers {
class OpAddImage final
{
private:
    typedef mozilla::wr::ImageDescriptor ImageDescriptor;
    typedef mozilla::layers::OffsetRange OffsetRange;
    typedef mozilla::wr::ImageKey ImageKey;

public:
    MOZ_IMPLICIT OpAddImage() :
        descriptor_(),
        bytes_(),
        key_(),
        tiling_()
    {
    }

    MOZ_IMPLICIT OpAddImage(
            const ImageDescriptor& _descriptor,
            const OffsetRange& _bytes,
            const uint16_t& _tiling,
            const ImageKey& _key) :
        descriptor_(_descriptor),
        bytes_(_bytes),
        key_(_key),
        tiling_(_tiling)
    {
    }

    ImageDescriptor&
    descriptor()
    {
        return descriptor_;
    }
    const ImageDescriptor&
    descriptor() const
    {
        return descriptor_;
    }

    OffsetRange&
    bytes()
    {
        return bytes_;
    }
    const OffsetRange&
    bytes() const
    {
        return bytes_;
    }

    uint16_t&
    tiling()
    {
        return tiling_;
    }
    const uint16_t&
    tiling() const
    {
        return tiling_;
    }

    ImageKey&
    key()
    {
        return key_;
    }
    const ImageKey&
    key() const
    {
        return key_;
    }

private:
    ImageDescriptor descriptor_;
    OffsetRange bytes_;
    ImageKey key_;
    uint16_t tiling_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpAddImage>
{
    typedef mozilla::layers::OpAddImage paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpAddBlobImage|
//
namespace mozilla {
namespace layers {
class OpAddBlobImage final
{
private:
    typedef mozilla::wr::ImageDescriptor ImageDescriptor;
    typedef mozilla::layers::OffsetRange OffsetRange;
    typedef mozilla::ImageIntRect ImageIntRect;
    typedef mozilla::wr::BlobImageKey BlobImageKey;

public:
    MOZ_IMPLICIT OpAddBlobImage() :
        descriptor_(),
        bytes_(),
        visibleRect_(),
        key_(),
        tiling_()
    {
    }

    MOZ_IMPLICIT OpAddBlobImage(
            const ImageDescriptor& _descriptor,
            const OffsetRange& _bytes,
            const ImageIntRect& _visibleRect,
            const uint16_t& _tiling,
            const BlobImageKey& _key) :
        descriptor_(_descriptor),
        bytes_(_bytes),
        visibleRect_(_visibleRect),
        key_(_key),
        tiling_(_tiling)
    {
    }

    ImageDescriptor&
    descriptor()
    {
        return descriptor_;
    }
    const ImageDescriptor&
    descriptor() const
    {
        return descriptor_;
    }

    OffsetRange&
    bytes()
    {
        return bytes_;
    }
    const OffsetRange&
    bytes() const
    {
        return bytes_;
    }

    ImageIntRect&
    visibleRect()
    {
        return visibleRect_;
    }
    const ImageIntRect&
    visibleRect() const
    {
        return visibleRect_;
    }

    uint16_t&
    tiling()
    {
        return tiling_;
    }
    const uint16_t&
    tiling() const
    {
        return tiling_;
    }

    BlobImageKey&
    key()
    {
        return key_;
    }
    const BlobImageKey&
    key() const
    {
        return key_;
    }

private:
    ImageDescriptor descriptor_;
    OffsetRange bytes_;
    ImageIntRect visibleRect_;
    BlobImageKey key_;
    uint16_t tiling_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpAddBlobImage>
{
    typedef mozilla::layers::OpAddBlobImage paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpUpdateImage|
//
namespace mozilla {
namespace layers {
class OpUpdateImage final
{
private:
    typedef mozilla::wr::ImageDescriptor ImageDescriptor;
    typedef mozilla::layers::OffsetRange OffsetRange;
    typedef mozilla::wr::ImageKey ImageKey;

public:
    MOZ_IMPLICIT OpUpdateImage() :
        descriptor_(),
        bytes_(),
        key_()
    {
    }

    MOZ_IMPLICIT OpUpdateImage(
            const ImageDescriptor& _descriptor,
            const OffsetRange& _bytes,
            const ImageKey& _key) :
        descriptor_(_descriptor),
        bytes_(_bytes),
        key_(_key)
    {
    }

    ImageDescriptor&
    descriptor()
    {
        return descriptor_;
    }
    const ImageDescriptor&
    descriptor() const
    {
        return descriptor_;
    }

    OffsetRange&
    bytes()
    {
        return bytes_;
    }
    const OffsetRange&
    bytes() const
    {
        return bytes_;
    }

    ImageKey&
    key()
    {
        return key_;
    }
    const ImageKey&
    key() const
    {
        return key_;
    }

private:
    ImageDescriptor descriptor_;
    OffsetRange bytes_;
    ImageKey key_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpUpdateImage>
{
    typedef mozilla::layers::OpUpdateImage paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpUpdateBlobImage|
//
namespace mozilla {
namespace layers {
class OpUpdateBlobImage final
{
private:
    typedef mozilla::wr::ImageDescriptor ImageDescriptor;
    typedef mozilla::layers::OffsetRange OffsetRange;
    typedef mozilla::wr::BlobImageKey BlobImageKey;
    typedef mozilla::ImageIntRect ImageIntRect;

public:
    MOZ_IMPLICIT OpUpdateBlobImage() :
        descriptor_(),
        bytes_(),
        key_(),
        visibleRect_(),
        dirtyRect_()
    {
    }

    MOZ_IMPLICIT OpUpdateBlobImage(
            const ImageDescriptor& _descriptor,
            const OffsetRange& _bytes,
            const BlobImageKey& _key,
            const ImageIntRect& _visibleRect,
            const ImageIntRect& _dirtyRect) :
        descriptor_(_descriptor),
        bytes_(_bytes),
        key_(_key),
        visibleRect_(_visibleRect),
        dirtyRect_(_dirtyRect)
    {
    }

    ImageDescriptor&
    descriptor()
    {
        return descriptor_;
    }
    const ImageDescriptor&
    descriptor() const
    {
        return descriptor_;
    }

    OffsetRange&
    bytes()
    {
        return bytes_;
    }
    const OffsetRange&
    bytes() const
    {
        return bytes_;
    }

    BlobImageKey&
    key()
    {
        return key_;
    }
    const BlobImageKey&
    key() const
    {
        return key_;
    }

    ImageIntRect&
    visibleRect()
    {
        return visibleRect_;
    }
    const ImageIntRect&
    visibleRect() const
    {
        return visibleRect_;
    }

    ImageIntRect&
    dirtyRect()
    {
        return dirtyRect_;
    }
    const ImageIntRect&
    dirtyRect() const
    {
        return dirtyRect_;
    }

private:
    ImageDescriptor descriptor_;
    OffsetRange bytes_;
    BlobImageKey key_;
    ImageIntRect visibleRect_;
    ImageIntRect dirtyRect_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpUpdateBlobImage>
{
    typedef mozilla::layers::OpUpdateBlobImage paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpSetBlobImageVisibleArea|
//
namespace mozilla {
namespace layers {
class OpSetBlobImageVisibleArea final
{
private:
    typedef mozilla::ImageIntRect ImageIntRect;
    typedef mozilla::wr::BlobImageKey BlobImageKey;

public:
    MOZ_IMPLICIT OpSetBlobImageVisibleArea() :
        area_(),
        key_()
    {
    }

    MOZ_IMPLICIT OpSetBlobImageVisibleArea(
            const ImageIntRect& _area,
            const BlobImageKey& _key) :
        area_(_area),
        key_(_key)
    {
    }

    ImageIntRect&
    area()
    {
        return area_;
    }
    const ImageIntRect&
    area() const
    {
        return area_;
    }

    BlobImageKey&
    key()
    {
        return key_;
    }
    const BlobImageKey&
    key() const
    {
        return key_;
    }

private:
    ImageIntRect area_;
    BlobImageKey key_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpSetBlobImageVisibleArea>
{
    typedef mozilla::layers::OpSetBlobImageVisibleArea paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpUpdatePrivateExternalImage|
//
namespace mozilla {
namespace layers {
class OpUpdatePrivateExternalImage final
{
private:
    typedef mozilla::wr::ExternalImageId ExternalImageId;
    typedef mozilla::wr::ImageKey ImageKey;
    typedef mozilla::wr::ImageDescriptor ImageDescriptor;
    typedef mozilla::ImageIntRect ImageIntRect;

public:
    MOZ_IMPLICIT OpUpdatePrivateExternalImage() :
        externalImageId_(),
        key_(),
        descriptor_(),
        dirtyRect_()
    {
    }

    MOZ_IMPLICIT OpUpdatePrivateExternalImage(
            const ExternalImageId& _externalImageId,
            const ImageKey& _key,
            const ImageDescriptor& _descriptor,
            const ImageIntRect& _dirtyRect) :
        externalImageId_(_externalImageId),
        key_(_key),
        descriptor_(_descriptor),
        dirtyRect_(_dirtyRect)
    {
    }

    ExternalImageId&
    externalImageId()
    {
        return externalImageId_;
    }
    const ExternalImageId&
    externalImageId() const
    {
        return externalImageId_;
    }

    ImageKey&
    key()
    {
        return key_;
    }
    const ImageKey&
    key() const
    {
        return key_;
    }

    ImageDescriptor&
    descriptor()
    {
        return descriptor_;
    }
    const ImageDescriptor&
    descriptor() const
    {
        return descriptor_;
    }

    ImageIntRect&
    dirtyRect()
    {
        return dirtyRect_;
    }
    const ImageIntRect&
    dirtyRect() const
    {
        return dirtyRect_;
    }

private:
    ExternalImageId externalImageId_;
    ImageKey key_;
    ImageDescriptor descriptor_;
    ImageIntRect dirtyRect_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpUpdatePrivateExternalImage>
{
    typedef mozilla::layers::OpUpdatePrivateExternalImage paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpUpdateSharedExternalImage|
//
namespace mozilla {
namespace layers {
class OpUpdateSharedExternalImage final
{
private:
    typedef mozilla::wr::ExternalImageId ExternalImageId;
    typedef mozilla::wr::ImageKey ImageKey;
    typedef mozilla::ImageIntRect ImageIntRect;

public:
    MOZ_IMPLICIT OpUpdateSharedExternalImage() :
        externalImageId_(),
        key_(),
        dirtyRect_()
    {
    }

    MOZ_IMPLICIT OpUpdateSharedExternalImage(
            const ExternalImageId& _externalImageId,
            const ImageKey& _key,
            const ImageIntRect& _dirtyRect) :
        externalImageId_(_externalImageId),
        key_(_key),
        dirtyRect_(_dirtyRect)
    {
    }

    ExternalImageId&
    externalImageId()
    {
        return externalImageId_;
    }
    const ExternalImageId&
    externalImageId() const
    {
        return externalImageId_;
    }

    ImageKey&
    key()
    {
        return key_;
    }
    const ImageKey&
    key() const
    {
        return key_;
    }

    ImageIntRect&
    dirtyRect()
    {
        return dirtyRect_;
    }
    const ImageIntRect&
    dirtyRect() const
    {
        return dirtyRect_;
    }

private:
    ExternalImageId externalImageId_;
    ImageKey key_;
    ImageIntRect dirtyRect_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpUpdateSharedExternalImage>
{
    typedef mozilla::layers::OpUpdateSharedExternalImage paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpDeleteImage|
//
namespace mozilla {
namespace layers {
class OpDeleteImage final
{
private:
    typedef mozilla::wr::ImageKey ImageKey;

public:
    MOZ_IMPLICIT OpDeleteImage() :
        key_()
    {
    }

    MOZ_IMPLICIT OpDeleteImage(const ImageKey& _key) :
        key_(_key)
    {
    }

    ImageKey&
    key()
    {
        return key_;
    }
    const ImageKey&
    key() const
    {
        return key_;
    }

private:
    ImageKey key_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpDeleteImage>
{
    typedef mozilla::layers::OpDeleteImage paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpDeleteBlobImage|
//
namespace mozilla {
namespace layers {
class OpDeleteBlobImage final
{
private:
    typedef mozilla::wr::BlobImageKey BlobImageKey;

public:
    MOZ_IMPLICIT OpDeleteBlobImage() :
        key_()
    {
    }

    MOZ_IMPLICIT OpDeleteBlobImage(const BlobImageKey& _key) :
        key_(_key)
    {
    }

    BlobImageKey&
    key()
    {
        return key_;
    }
    const BlobImageKey&
    key() const
    {
        return key_;
    }

private:
    BlobImageKey key_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpDeleteBlobImage>
{
    typedef mozilla::layers::OpDeleteBlobImage paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpAddRawFont|
//
namespace mozilla {
namespace layers {
class OpAddRawFont final
{
private:
    typedef mozilla::layers::OffsetRange OffsetRange;
    typedef mozilla::wr::FontKey FontKey;

public:
    MOZ_IMPLICIT OpAddRawFont() :
        bytes_(),
        key_(),
        fontIndex_()
    {
    }

    MOZ_IMPLICIT OpAddRawFont(
            const OffsetRange& _bytes,
            const uint32_t& _fontIndex,
            const FontKey& _key) :
        bytes_(_bytes),
        key_(_key),
        fontIndex_(_fontIndex)
    {
    }

    OffsetRange&
    bytes()
    {
        return bytes_;
    }
    const OffsetRange&
    bytes() const
    {
        return bytes_;
    }

    uint32_t&
    fontIndex()
    {
        return fontIndex_;
    }
    const uint32_t&
    fontIndex() const
    {
        return fontIndex_;
    }

    FontKey&
    key()
    {
        return key_;
    }
    const FontKey&
    key() const
    {
        return key_;
    }

private:
    OffsetRange bytes_;
    FontKey key_;
    uint32_t fontIndex_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpAddRawFont>
{
    typedef mozilla::layers::OpAddRawFont paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpAddFontDescriptor|
//
namespace mozilla {
namespace layers {
class OpAddFontDescriptor final
{
private:
    typedef mozilla::layers::OffsetRange OffsetRange;
    typedef mozilla::wr::FontKey FontKey;

public:
    MOZ_IMPLICIT OpAddFontDescriptor() :
        bytes_(),
        key_(),
        fontIndex_()
    {
    }

    MOZ_IMPLICIT OpAddFontDescriptor(
            const OffsetRange& _bytes,
            const uint32_t& _fontIndex,
            const FontKey& _key) :
        bytes_(_bytes),
        key_(_key),
        fontIndex_(_fontIndex)
    {
    }

    OffsetRange&
    bytes()
    {
        return bytes_;
    }
    const OffsetRange&
    bytes() const
    {
        return bytes_;
    }

    uint32_t&
    fontIndex()
    {
        return fontIndex_;
    }
    const uint32_t&
    fontIndex() const
    {
        return fontIndex_;
    }

    FontKey&
    key()
    {
        return key_;
    }
    const FontKey&
    key() const
    {
        return key_;
    }

private:
    OffsetRange bytes_;
    FontKey key_;
    uint32_t fontIndex_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpAddFontDescriptor>
{
    typedef mozilla::layers::OpAddFontDescriptor paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpDeleteFont|
//
namespace mozilla {
namespace layers {
class OpDeleteFont final
{
private:
    typedef mozilla::wr::FontKey FontKey;

public:
    MOZ_IMPLICIT OpDeleteFont() :
        key_()
    {
    }

    MOZ_IMPLICIT OpDeleteFont(const FontKey& _key) :
        key_(_key)
    {
    }

    FontKey&
    key()
    {
        return key_;
    }
    const FontKey&
    key() const
    {
        return key_;
    }

private:
    FontKey key_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpDeleteFont>
{
    typedef mozilla::layers::OpDeleteFont paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpAddFontInstance|
//
namespace mozilla {
namespace layers {
class OpAddFontInstance final
{
private:
    typedef mozilla::wr::MaybeFontInstanceOptions MaybeFontInstanceOptions;
    typedef mozilla::wr::MaybeFontInstancePlatformOptions MaybeFontInstancePlatformOptions;
    typedef mozilla::layers::OffsetRange OffsetRange;
    typedef mozilla::wr::FontInstanceKey FontInstanceKey;
    typedef mozilla::wr::FontKey FontKey;

public:
    MOZ_IMPLICIT OpAddFontInstance() :
        options_(),
        platformOptions_(),
        variations_(),
        instanceKey_(),
        fontKey_(),
        glyphSize_()
    {
    }

    MOZ_IMPLICIT OpAddFontInstance(
            const MaybeFontInstanceOptions& _options,
            const MaybeFontInstancePlatformOptions& _platformOptions,
            const OffsetRange& _variations,
            const FontInstanceKey& _instanceKey,
            const FontKey& _fontKey,
            const float& _glyphSize) :
        options_(_options),
        platformOptions_(_platformOptions),
        variations_(_variations),
        instanceKey_(_instanceKey),
        fontKey_(_fontKey),
        glyphSize_(_glyphSize)
    {
    }

    MaybeFontInstanceOptions&
    options()
    {
        return options_;
    }
    const MaybeFontInstanceOptions&
    options() const
    {
        return options_;
    }

    MaybeFontInstancePlatformOptions&
    platformOptions()
    {
        return platformOptions_;
    }
    const MaybeFontInstancePlatformOptions&
    platformOptions() const
    {
        return platformOptions_;
    }

    OffsetRange&
    variations()
    {
        return variations_;
    }
    const OffsetRange&
    variations() const
    {
        return variations_;
    }

    FontInstanceKey&
    instanceKey()
    {
        return instanceKey_;
    }
    const FontInstanceKey&
    instanceKey() const
    {
        return instanceKey_;
    }

    FontKey&
    fontKey()
    {
        return fontKey_;
    }
    const FontKey&
    fontKey() const
    {
        return fontKey_;
    }

    float&
    glyphSize()
    {
        return glyphSize_;
    }
    const float&
    glyphSize() const
    {
        return glyphSize_;
    }

private:
    MaybeFontInstanceOptions options_;
    MaybeFontInstancePlatformOptions platformOptions_;
    OffsetRange variations_;
    FontInstanceKey instanceKey_;
    FontKey fontKey_;
    float glyphSize_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpAddFontInstance>
{
    typedef mozilla::layers::OpAddFontInstance paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpDeleteFontInstance|
//
namespace mozilla {
namespace layers {
class OpDeleteFontInstance final
{
private:
    typedef mozilla::wr::FontInstanceKey FontInstanceKey;

public:
    MOZ_IMPLICIT OpDeleteFontInstance() :
        key_()
    {
    }

    MOZ_IMPLICIT OpDeleteFontInstance(const FontInstanceKey& _key) :
        key_(_key)
    {
    }

    FontInstanceKey&
    key()
    {
        return key_;
    }
    const FontInstanceKey&
    key() const
    {
        return key_;
    }

private:
    FontInstanceKey key_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpDeleteFontInstance>
{
    typedef mozilla::layers::OpDeleteFontInstance paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union OpUpdateResource|
//
namespace mozilla {
namespace layers {
class OpUpdateResource final
{
public:
    enum Type {
        T__None,
        TOpAddImage = 1,
        TOpAddBlobImage,
        TOpUpdateImage,
        TOpUpdateBlobImage,
        TOpSetBlobImageVisibleArea,
        TOpDeleteImage,
        TOpDeleteBlobImage,
        TOpAddRawFont,
        TOpAddFontDescriptor,
        TOpDeleteFont,
        TOpAddFontInstance,
        TOpDeleteFontInstance,
        TOpAddPrivateExternalImage,
        TOpAddSharedExternalImage,
        TOpPushExternalImageForTexture,
        TOpUpdatePrivateExternalImage,
        TOpUpdateSharedExternalImage,
        T__Last = TOpUpdateSharedExternalImage
    };

private:
    typedef mozilla::layers::OpAddImage OpAddImage;
    typedef mozilla::layers::OpAddBlobImage OpAddBlobImage;
    typedef mozilla::layers::OpUpdateImage OpUpdateImage;
    typedef mozilla::layers::OpUpdateBlobImage OpUpdateBlobImage;
    typedef mozilla::layers::OpSetBlobImageVisibleArea OpSetBlobImageVisibleArea;
    typedef mozilla::layers::OpDeleteImage OpDeleteImage;
    typedef mozilla::layers::OpDeleteBlobImage OpDeleteBlobImage;
    typedef mozilla::layers::OpAddRawFont OpAddRawFont;
    typedef mozilla::layers::OpAddFontDescriptor OpAddFontDescriptor;
    typedef mozilla::layers::OpDeleteFont OpDeleteFont;
    typedef mozilla::layers::OpAddFontInstance OpAddFontInstance;
    typedef mozilla::layers::OpDeleteFontInstance OpDeleteFontInstance;
    typedef mozilla::layers::OpAddPrivateExternalImage OpAddPrivateExternalImage;
    typedef mozilla::layers::OpAddSharedExternalImage OpAddSharedExternalImage;
    typedef mozilla::layers::OpPushExternalImageForTexture OpPushExternalImageForTexture;
    typedef mozilla::layers::OpUpdatePrivateExternalImage OpUpdatePrivateExternalImage;
    typedef mozilla::layers::OpUpdateSharedExternalImage OpUpdateSharedExternalImage;
    typedef OpAddImage OpAddImage__tdef;
    typedef OpAddBlobImage OpAddBlobImage__tdef;
    typedef OpUpdateImage OpUpdateImage__tdef;
    typedef OpUpdateBlobImage OpUpdateBlobImage__tdef;
    typedef OpSetBlobImageVisibleArea OpSetBlobImageVisibleArea__tdef;
    typedef OpDeleteImage OpDeleteImage__tdef;
    typedef OpDeleteBlobImage OpDeleteBlobImage__tdef;
    typedef OpAddRawFont OpAddRawFont__tdef;
    typedef OpAddFontDescriptor OpAddFontDescriptor__tdef;
    typedef OpDeleteFont OpDeleteFont__tdef;
    typedef OpAddFontInstance OpAddFontInstance__tdef;
    typedef OpDeleteFontInstance OpDeleteFontInstance__tdef;
    typedef OpAddPrivateExternalImage OpAddPrivateExternalImage__tdef;
    typedef OpAddSharedExternalImage OpAddSharedExternalImage__tdef;
    typedef OpPushExternalImageForTexture OpPushExternalImageForTexture__tdef;
    typedef OpUpdatePrivateExternalImage OpUpdatePrivateExternalImage__tdef;
    typedef OpUpdateSharedExternalImage OpUpdateSharedExternalImage__tdef;

    union Value {
        mozilla::AlignedStorage2<OpAddImage> VOpAddImage;
        mozilla::AlignedStorage2<OpAddBlobImage> VOpAddBlobImage;
        mozilla::AlignedStorage2<OpUpdateImage> VOpUpdateImage;
        mozilla::AlignedStorage2<OpUpdateBlobImage> VOpUpdateBlobImage;
        mozilla::AlignedStorage2<OpSetBlobImageVisibleArea> VOpSetBlobImageVisibleArea;
        mozilla::AlignedStorage2<OpDeleteImage> VOpDeleteImage;
        mozilla::AlignedStorage2<OpDeleteBlobImage> VOpDeleteBlobImage;
        mozilla::AlignedStorage2<OpAddRawFont> VOpAddRawFont;
        mozilla::AlignedStorage2<OpAddFontDescriptor> VOpAddFontDescriptor;
        mozilla::AlignedStorage2<OpDeleteFont> VOpDeleteFont;
        mozilla::AlignedStorage2<OpAddFontInstance> VOpAddFontInstance;
        mozilla::AlignedStorage2<OpDeleteFontInstance> VOpDeleteFontInstance;
        mozilla::AlignedStorage2<OpAddPrivateExternalImage> VOpAddPrivateExternalImage;
        mozilla::AlignedStorage2<OpAddSharedExternalImage> VOpAddSharedExternalImage;
        mozilla::AlignedStorage2<OpPushExternalImageForTexture> VOpPushExternalImageForTexture;
        mozilla::AlignedStorage2<OpUpdatePrivateExternalImage> VOpUpdatePrivateExternalImage;
        mozilla::AlignedStorage2<OpUpdateSharedExternalImage> VOpUpdateSharedExternalImage;
    };

    OpAddImage*
    ptr_OpAddImage()
    {
        return ((mValue).VOpAddImage).addr();
    }
    const OpAddImage*
    constptr_OpAddImage() const
    {
        return ((mValue).VOpAddImage).addr();
    }
    OpAddBlobImage*
    ptr_OpAddBlobImage()
    {
        return ((mValue).VOpAddBlobImage).addr();
    }
    const OpAddBlobImage*
    constptr_OpAddBlobImage() const
    {
        return ((mValue).VOpAddBlobImage).addr();
    }
    OpUpdateImage*
    ptr_OpUpdateImage()
    {
        return ((mValue).VOpUpdateImage).addr();
    }
    const OpUpdateImage*
    constptr_OpUpdateImage() const
    {
        return ((mValue).VOpUpdateImage).addr();
    }
    OpUpdateBlobImage*
    ptr_OpUpdateBlobImage()
    {
        return ((mValue).VOpUpdateBlobImage).addr();
    }
    const OpUpdateBlobImage*
    constptr_OpUpdateBlobImage() const
    {
        return ((mValue).VOpUpdateBlobImage).addr();
    }
    OpSetBlobImageVisibleArea*
    ptr_OpSetBlobImageVisibleArea()
    {
        return ((mValue).VOpSetBlobImageVisibleArea).addr();
    }
    const OpSetBlobImageVisibleArea*
    constptr_OpSetBlobImageVisibleArea() const
    {
        return ((mValue).VOpSetBlobImageVisibleArea).addr();
    }
    OpDeleteImage*
    ptr_OpDeleteImage()
    {
        return ((mValue).VOpDeleteImage).addr();
    }
    const OpDeleteImage*
    constptr_OpDeleteImage() const
    {
        return ((mValue).VOpDeleteImage).addr();
    }
    OpDeleteBlobImage*
    ptr_OpDeleteBlobImage()
    {
        return ((mValue).VOpDeleteBlobImage).addr();
    }
    const OpDeleteBlobImage*
    constptr_OpDeleteBlobImage() const
    {
        return ((mValue).VOpDeleteBlobImage).addr();
    }
    OpAddRawFont*
    ptr_OpAddRawFont()
    {
        return ((mValue).VOpAddRawFont).addr();
    }
    const OpAddRawFont*
    constptr_OpAddRawFont() const
    {
        return ((mValue).VOpAddRawFont).addr();
    }
    OpAddFontDescriptor*
    ptr_OpAddFontDescriptor()
    {
        return ((mValue).VOpAddFontDescriptor).addr();
    }
    const OpAddFontDescriptor*
    constptr_OpAddFontDescriptor() const
    {
        return ((mValue).VOpAddFontDescriptor).addr();
    }
    OpDeleteFont*
    ptr_OpDeleteFont()
    {
        return ((mValue).VOpDeleteFont).addr();
    }
    const OpDeleteFont*
    constptr_OpDeleteFont() const
    {
        return ((mValue).VOpDeleteFont).addr();
    }
    OpAddFontInstance*
    ptr_OpAddFontInstance()
    {
        return ((mValue).VOpAddFontInstance).addr();
    }
    const OpAddFontInstance*
    constptr_OpAddFontInstance() const
    {
        return ((mValue).VOpAddFontInstance).addr();
    }
    OpDeleteFontInstance*
    ptr_OpDeleteFontInstance()
    {
        return ((mValue).VOpDeleteFontInstance).addr();
    }
    const OpDeleteFontInstance*
    constptr_OpDeleteFontInstance() const
    {
        return ((mValue).VOpDeleteFontInstance).addr();
    }
    OpAddPrivateExternalImage*
    ptr_OpAddPrivateExternalImage()
    {
        return ((mValue).VOpAddPrivateExternalImage).addr();
    }
    const OpAddPrivateExternalImage*
    constptr_OpAddPrivateExternalImage() const
    {
        return ((mValue).VOpAddPrivateExternalImage).addr();
    }
    OpAddSharedExternalImage*
    ptr_OpAddSharedExternalImage()
    {
        return ((mValue).VOpAddSharedExternalImage).addr();
    }
    const OpAddSharedExternalImage*
    constptr_OpAddSharedExternalImage() const
    {
        return ((mValue).VOpAddSharedExternalImage).addr();
    }
    OpPushExternalImageForTexture*
    ptr_OpPushExternalImageForTexture()
    {
        return ((mValue).VOpPushExternalImageForTexture).addr();
    }
    const OpPushExternalImageForTexture*
    constptr_OpPushExternalImageForTexture() const
    {
        return ((mValue).VOpPushExternalImageForTexture).addr();
    }
    OpUpdatePrivateExternalImage*
    ptr_OpUpdatePrivateExternalImage()
    {
        return ((mValue).VOpUpdatePrivateExternalImage).addr();
    }
    const OpUpdatePrivateExternalImage*
    constptr_OpUpdatePrivateExternalImage() const
    {
        return ((mValue).VOpUpdatePrivateExternalImage).addr();
    }
    OpUpdateSharedExternalImage*
    ptr_OpUpdateSharedExternalImage()
    {
        return ((mValue).VOpUpdateSharedExternalImage).addr();
    }
    const OpUpdateSharedExternalImage*
    constptr_OpUpdateSharedExternalImage() const
    {
        return ((mValue).VOpUpdateSharedExternalImage).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT OpUpdateResource() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT OpUpdateResource(const OpAddImage& aOther);

    MOZ_IMPLICIT OpUpdateResource(OpAddImage&& aOther);

    MOZ_IMPLICIT OpUpdateResource(const OpAddBlobImage& aOther);

    MOZ_IMPLICIT OpUpdateResource(OpAddBlobImage&& aOther);

    MOZ_IMPLICIT OpUpdateResource(const OpUpdateImage& aOther);

    MOZ_IMPLICIT OpUpdateResource(OpUpdateImage&& aOther);

    MOZ_IMPLICIT OpUpdateResource(const OpUpdateBlobImage& aOther);

    MOZ_IMPLICIT OpUpdateResource(OpUpdateBlobImage&& aOther);

    MOZ_IMPLICIT OpUpdateResource(const OpSetBlobImageVisibleArea& aOther);

    MOZ_IMPLICIT OpUpdateResource(OpSetBlobImageVisibleArea&& aOther);

    MOZ_IMPLICIT OpUpdateResource(const OpDeleteImage& aOther);

    MOZ_IMPLICIT OpUpdateResource(OpDeleteImage&& aOther);

    MOZ_IMPLICIT OpUpdateResource(const OpDeleteBlobImage& aOther);

    MOZ_IMPLICIT OpUpdateResource(OpDeleteBlobImage&& aOther);

    MOZ_IMPLICIT OpUpdateResource(const OpAddRawFont& aOther);

    MOZ_IMPLICIT OpUpdateResource(OpAddRawFont&& aOther);

    MOZ_IMPLICIT OpUpdateResource(const OpAddFontDescriptor& aOther);

    MOZ_IMPLICIT OpUpdateResource(OpAddFontDescriptor&& aOther);

    MOZ_IMPLICIT OpUpdateResource(const OpDeleteFont& aOther);

    MOZ_IMPLICIT OpUpdateResource(OpDeleteFont&& aOther);

    MOZ_IMPLICIT OpUpdateResource(const OpAddFontInstance& aOther);

    MOZ_IMPLICIT OpUpdateResource(OpAddFontInstance&& aOther);

    MOZ_IMPLICIT OpUpdateResource(const OpDeleteFontInstance& aOther);

    MOZ_IMPLICIT OpUpdateResource(OpDeleteFontInstance&& aOther);

    MOZ_IMPLICIT OpUpdateResource(const OpAddPrivateExternalImage& aOther);

    MOZ_IMPLICIT OpUpdateResource(OpAddPrivateExternalImage&& aOther);

    MOZ_IMPLICIT OpUpdateResource(const OpAddSharedExternalImage& aOther);

    MOZ_IMPLICIT OpUpdateResource(OpAddSharedExternalImage&& aOther);

    MOZ_IMPLICIT OpUpdateResource(const OpPushExternalImageForTexture& aOther);

    MOZ_IMPLICIT OpUpdateResource(OpPushExternalImageForTexture&& aOther);

    MOZ_IMPLICIT OpUpdateResource(const OpUpdatePrivateExternalImage& aOther);

    MOZ_IMPLICIT OpUpdateResource(OpUpdatePrivateExternalImage&& aOther);

    MOZ_IMPLICIT OpUpdateResource(const OpUpdateSharedExternalImage& aOther);

    MOZ_IMPLICIT OpUpdateResource(OpUpdateSharedExternalImage&& aOther);

    MOZ_IMPLICIT OpUpdateResource(const OpUpdateResource& aOther);

    MOZ_IMPLICIT OpUpdateResource(OpUpdateResource&& aOther);

    ~OpUpdateResource();

    Type
    type() const
    {
        return mType;
    }

    OpUpdateResource&
    operator=(const OpAddImage& aRhs);

    OpUpdateResource&
    operator=(OpAddImage&& aRhs);

    OpUpdateResource&
    operator=(const OpAddBlobImage& aRhs);

    OpUpdateResource&
    operator=(OpAddBlobImage&& aRhs);

    OpUpdateResource&
    operator=(const OpUpdateImage& aRhs);

    OpUpdateResource&
    operator=(OpUpdateImage&& aRhs);

    OpUpdateResource&
    operator=(const OpUpdateBlobImage& aRhs);

    OpUpdateResource&
    operator=(OpUpdateBlobImage&& aRhs);

    OpUpdateResource&
    operator=(const OpSetBlobImageVisibleArea& aRhs);

    OpUpdateResource&
    operator=(OpSetBlobImageVisibleArea&& aRhs);

    OpUpdateResource&
    operator=(const OpDeleteImage& aRhs);

    OpUpdateResource&
    operator=(OpDeleteImage&& aRhs);

    OpUpdateResource&
    operator=(const OpDeleteBlobImage& aRhs);

    OpUpdateResource&
    operator=(OpDeleteBlobImage&& aRhs);

    OpUpdateResource&
    operator=(const OpAddRawFont& aRhs);

    OpUpdateResource&
    operator=(OpAddRawFont&& aRhs);

    OpUpdateResource&
    operator=(const OpAddFontDescriptor& aRhs);

    OpUpdateResource&
    operator=(OpAddFontDescriptor&& aRhs);

    OpUpdateResource&
    operator=(const OpDeleteFont& aRhs);

    OpUpdateResource&
    operator=(OpDeleteFont&& aRhs);

    OpUpdateResource&
    operator=(const OpAddFontInstance& aRhs);

    OpUpdateResource&
    operator=(OpAddFontInstance&& aRhs);

    OpUpdateResource&
    operator=(const OpDeleteFontInstance& aRhs);

    OpUpdateResource&
    operator=(OpDeleteFontInstance&& aRhs);

    OpUpdateResource&
    operator=(const OpAddPrivateExternalImage& aRhs);

    OpUpdateResource&
    operator=(OpAddPrivateExternalImage&& aRhs);

    OpUpdateResource&
    operator=(const OpAddSharedExternalImage& aRhs);

    OpUpdateResource&
    operator=(OpAddSharedExternalImage&& aRhs);

    OpUpdateResource&
    operator=(const OpPushExternalImageForTexture& aRhs);

    OpUpdateResource&
    operator=(OpPushExternalImageForTexture&& aRhs);

    OpUpdateResource&
    operator=(const OpUpdatePrivateExternalImage& aRhs);

    OpUpdateResource&
    operator=(OpUpdatePrivateExternalImage&& aRhs);

    OpUpdateResource&
    operator=(const OpUpdateSharedExternalImage& aRhs);

    OpUpdateResource&
    operator=(OpUpdateSharedExternalImage&& aRhs);

    OpUpdateResource&
    operator=(const OpUpdateResource& aRhs);

    OpUpdateResource&
    operator=(OpUpdateResource&& aRhs);

    OpAddImage&
    get_OpAddImage()
    {
        AssertSanity(TOpAddImage);
        return (*(ptr_OpAddImage()));
    }
    const OpAddImage&
    get_OpAddImage() const
    {
        AssertSanity(TOpAddImage);
        return (*(constptr_OpAddImage()));
    }
    operator OpAddImage&()
    {
        return get_OpAddImage();
    }
    operator const OpAddImage&() const
    {
        return get_OpAddImage();
    }

    OpAddBlobImage&
    get_OpAddBlobImage()
    {
        AssertSanity(TOpAddBlobImage);
        return (*(ptr_OpAddBlobImage()));
    }
    const OpAddBlobImage&
    get_OpAddBlobImage() const
    {
        AssertSanity(TOpAddBlobImage);
        return (*(constptr_OpAddBlobImage()));
    }
    operator OpAddBlobImage&()
    {
        return get_OpAddBlobImage();
    }
    operator const OpAddBlobImage&() const
    {
        return get_OpAddBlobImage();
    }

    OpUpdateImage&
    get_OpUpdateImage()
    {
        AssertSanity(TOpUpdateImage);
        return (*(ptr_OpUpdateImage()));
    }
    const OpUpdateImage&
    get_OpUpdateImage() const
    {
        AssertSanity(TOpUpdateImage);
        return (*(constptr_OpUpdateImage()));
    }
    operator OpUpdateImage&()
    {
        return get_OpUpdateImage();
    }
    operator const OpUpdateImage&() const
    {
        return get_OpUpdateImage();
    }

    OpUpdateBlobImage&
    get_OpUpdateBlobImage()
    {
        AssertSanity(TOpUpdateBlobImage);
        return (*(ptr_OpUpdateBlobImage()));
    }
    const OpUpdateBlobImage&
    get_OpUpdateBlobImage() const
    {
        AssertSanity(TOpUpdateBlobImage);
        return (*(constptr_OpUpdateBlobImage()));
    }
    operator OpUpdateBlobImage&()
    {
        return get_OpUpdateBlobImage();
    }
    operator const OpUpdateBlobImage&() const
    {
        return get_OpUpdateBlobImage();
    }

    OpSetBlobImageVisibleArea&
    get_OpSetBlobImageVisibleArea()
    {
        AssertSanity(TOpSetBlobImageVisibleArea);
        return (*(ptr_OpSetBlobImageVisibleArea()));
    }
    const OpSetBlobImageVisibleArea&
    get_OpSetBlobImageVisibleArea() const
    {
        AssertSanity(TOpSetBlobImageVisibleArea);
        return (*(constptr_OpSetBlobImageVisibleArea()));
    }
    operator OpSetBlobImageVisibleArea&()
    {
        return get_OpSetBlobImageVisibleArea();
    }
    operator const OpSetBlobImageVisibleArea&() const
    {
        return get_OpSetBlobImageVisibleArea();
    }

    OpDeleteImage&
    get_OpDeleteImage()
    {
        AssertSanity(TOpDeleteImage);
        return (*(ptr_OpDeleteImage()));
    }
    const OpDeleteImage&
    get_OpDeleteImage() const
    {
        AssertSanity(TOpDeleteImage);
        return (*(constptr_OpDeleteImage()));
    }
    operator OpDeleteImage&()
    {
        return get_OpDeleteImage();
    }
    operator const OpDeleteImage&() const
    {
        return get_OpDeleteImage();
    }

    OpDeleteBlobImage&
    get_OpDeleteBlobImage()
    {
        AssertSanity(TOpDeleteBlobImage);
        return (*(ptr_OpDeleteBlobImage()));
    }
    const OpDeleteBlobImage&
    get_OpDeleteBlobImage() const
    {
        AssertSanity(TOpDeleteBlobImage);
        return (*(constptr_OpDeleteBlobImage()));
    }
    operator OpDeleteBlobImage&()
    {
        return get_OpDeleteBlobImage();
    }
    operator const OpDeleteBlobImage&() const
    {
        return get_OpDeleteBlobImage();
    }

    OpAddRawFont&
    get_OpAddRawFont()
    {
        AssertSanity(TOpAddRawFont);
        return (*(ptr_OpAddRawFont()));
    }
    const OpAddRawFont&
    get_OpAddRawFont() const
    {
        AssertSanity(TOpAddRawFont);
        return (*(constptr_OpAddRawFont()));
    }
    operator OpAddRawFont&()
    {
        return get_OpAddRawFont();
    }
    operator const OpAddRawFont&() const
    {
        return get_OpAddRawFont();
    }

    OpAddFontDescriptor&
    get_OpAddFontDescriptor()
    {
        AssertSanity(TOpAddFontDescriptor);
        return (*(ptr_OpAddFontDescriptor()));
    }
    const OpAddFontDescriptor&
    get_OpAddFontDescriptor() const
    {
        AssertSanity(TOpAddFontDescriptor);
        return (*(constptr_OpAddFontDescriptor()));
    }
    operator OpAddFontDescriptor&()
    {
        return get_OpAddFontDescriptor();
    }
    operator const OpAddFontDescriptor&() const
    {
        return get_OpAddFontDescriptor();
    }

    OpDeleteFont&
    get_OpDeleteFont()
    {
        AssertSanity(TOpDeleteFont);
        return (*(ptr_OpDeleteFont()));
    }
    const OpDeleteFont&
    get_OpDeleteFont() const
    {
        AssertSanity(TOpDeleteFont);
        return (*(constptr_OpDeleteFont()));
    }
    operator OpDeleteFont&()
    {
        return get_OpDeleteFont();
    }
    operator const OpDeleteFont&() const
    {
        return get_OpDeleteFont();
    }

    OpAddFontInstance&
    get_OpAddFontInstance()
    {
        AssertSanity(TOpAddFontInstance);
        return (*(ptr_OpAddFontInstance()));
    }
    const OpAddFontInstance&
    get_OpAddFontInstance() const
    {
        AssertSanity(TOpAddFontInstance);
        return (*(constptr_OpAddFontInstance()));
    }
    operator OpAddFontInstance&()
    {
        return get_OpAddFontInstance();
    }
    operator const OpAddFontInstance&() const
    {
        return get_OpAddFontInstance();
    }

    OpDeleteFontInstance&
    get_OpDeleteFontInstance()
    {
        AssertSanity(TOpDeleteFontInstance);
        return (*(ptr_OpDeleteFontInstance()));
    }
    const OpDeleteFontInstance&
    get_OpDeleteFontInstance() const
    {
        AssertSanity(TOpDeleteFontInstance);
        return (*(constptr_OpDeleteFontInstance()));
    }
    operator OpDeleteFontInstance&()
    {
        return get_OpDeleteFontInstance();
    }
    operator const OpDeleteFontInstance&() const
    {
        return get_OpDeleteFontInstance();
    }

    OpAddPrivateExternalImage&
    get_OpAddPrivateExternalImage()
    {
        AssertSanity(TOpAddPrivateExternalImage);
        return (*(ptr_OpAddPrivateExternalImage()));
    }
    const OpAddPrivateExternalImage&
    get_OpAddPrivateExternalImage() const
    {
        AssertSanity(TOpAddPrivateExternalImage);
        return (*(constptr_OpAddPrivateExternalImage()));
    }
    operator OpAddPrivateExternalImage&()
    {
        return get_OpAddPrivateExternalImage();
    }
    operator const OpAddPrivateExternalImage&() const
    {
        return get_OpAddPrivateExternalImage();
    }

    OpAddSharedExternalImage&
    get_OpAddSharedExternalImage()
    {
        AssertSanity(TOpAddSharedExternalImage);
        return (*(ptr_OpAddSharedExternalImage()));
    }
    const OpAddSharedExternalImage&
    get_OpAddSharedExternalImage() const
    {
        AssertSanity(TOpAddSharedExternalImage);
        return (*(constptr_OpAddSharedExternalImage()));
    }
    operator OpAddSharedExternalImage&()
    {
        return get_OpAddSharedExternalImage();
    }
    operator const OpAddSharedExternalImage&() const
    {
        return get_OpAddSharedExternalImage();
    }

    OpPushExternalImageForTexture&
    get_OpPushExternalImageForTexture()
    {
        AssertSanity(TOpPushExternalImageForTexture);
        return (*(ptr_OpPushExternalImageForTexture()));
    }
    const OpPushExternalImageForTexture&
    get_OpPushExternalImageForTexture() const
    {
        AssertSanity(TOpPushExternalImageForTexture);
        return (*(constptr_OpPushExternalImageForTexture()));
    }
    operator OpPushExternalImageForTexture&()
    {
        return get_OpPushExternalImageForTexture();
    }
    operator const OpPushExternalImageForTexture&() const
    {
        return get_OpPushExternalImageForTexture();
    }

    OpUpdatePrivateExternalImage&
    get_OpUpdatePrivateExternalImage()
    {
        AssertSanity(TOpUpdatePrivateExternalImage);
        return (*(ptr_OpUpdatePrivateExternalImage()));
    }
    const OpUpdatePrivateExternalImage&
    get_OpUpdatePrivateExternalImage() const
    {
        AssertSanity(TOpUpdatePrivateExternalImage);
        return (*(constptr_OpUpdatePrivateExternalImage()));
    }
    operator OpUpdatePrivateExternalImage&()
    {
        return get_OpUpdatePrivateExternalImage();
    }
    operator const OpUpdatePrivateExternalImage&() const
    {
        return get_OpUpdatePrivateExternalImage();
    }

    OpUpdateSharedExternalImage&
    get_OpUpdateSharedExternalImage()
    {
        AssertSanity(TOpUpdateSharedExternalImage);
        return (*(ptr_OpUpdateSharedExternalImage()));
    }
    const OpUpdateSharedExternalImage&
    get_OpUpdateSharedExternalImage() const
    {
        AssertSanity(TOpUpdateSharedExternalImage);
        return (*(constptr_OpUpdateSharedExternalImage()));
    }
    operator OpUpdateSharedExternalImage&()
    {
        return get_OpUpdateSharedExternalImage();
    }
    operator const OpUpdateSharedExternalImage&() const
    {
        return get_OpUpdateSharedExternalImage();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpUpdateResource>
{
    typedef mozilla::layers::OpUpdateResource paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

#endif // ifndef WebRenderMessages_h
