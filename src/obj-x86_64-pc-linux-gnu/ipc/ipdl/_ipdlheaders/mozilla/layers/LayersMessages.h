//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef LayersMessages_h
#define LayersMessages_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "FrameMetrics.h"
#include "Units.h"
#include "mozilla/HalScreenConfiguration.h"
#include "mozilla/MotionPathUtils.h"
#include "mozilla/ServoStyleConsts.h"
#include "mozilla/TimeStamp.h"
#include "mozilla/VsyncDispatcher.h"
#include "mozilla/WidgetUtils.h"
#include "mozilla/gfx/2D.h"
#include "mozilla/gfx/Matrix.h"
#include "mozilla/gfx/Point.h"
#include "mozilla/gfx/Types.h"
#include "mozilla/ipc/CrossProcessSemaphore.h"
#include "mozilla/layers/CompositorTypes.h"
#include "mozilla/layers/FocusTarget.h"
#include "mozilla/layers/LayerAttributes.h"
#include "mozilla/layers/LayersTypes.h"
#include "mozilla/layers/ScrollableLayerGuid.h"
#include "nsCSSPropertyID.h"
#include "nsColor.h"
#include "nsPoint.h"
#include "nsRect.h"
#include "mozilla/layers/LayersSurfaces.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct TargetConfig|
//
namespace mozilla {
namespace layers {
class TargetConfig final
{
private:
    typedef mozilla::gfx::IntRect IntRect;
    typedef mozilla::ScreenRotation ScreenRotation;
    typedef hal::ScreenOrientation ScreenOrientation;

public:
    MOZ_IMPLICIT TargetConfig() :
        naturalBounds_(),
        rotation_(),
        orientation_(),
        clearRegion_()
    {
    }

    MOZ_IMPLICIT TargetConfig(
            const IntRect& _naturalBounds,
            const ScreenRotation& _rotation,
            const ScreenOrientation& _orientation,
            const nsIntRegion& _clearRegion) :
        naturalBounds_(_naturalBounds),
        rotation_(_rotation),
        orientation_(_orientation),
        clearRegion_(_clearRegion)
    {
    }

    IntRect&
    naturalBounds()
    {
        return naturalBounds_;
    }
    const IntRect&
    naturalBounds() const
    {
        return naturalBounds_;
    }

    ScreenRotation&
    rotation()
    {
        return rotation_;
    }
    const ScreenRotation&
    rotation() const
    {
        return rotation_;
    }

    ScreenOrientation&
    orientation()
    {
        return orientation_;
    }
    const ScreenOrientation&
    orientation() const
    {
        return orientation_;
    }

    nsIntRegion&
    clearRegion()
    {
        return clearRegion_;
    }
    const nsIntRegion&
    clearRegion() const
    {
        return clearRegion_;
    }

private:
    IntRect naturalBounds_;
    ScreenRotation rotation_;
    ScreenOrientation orientation_;
    nsIntRegion clearRegion_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::TargetConfig>
{
    typedef mozilla::layers::TargetConfig paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpCreatePaintedLayer|
//
namespace mozilla {
namespace layers {
class OpCreatePaintedLayer final
{
private:
    typedef mozilla::layers::LayerHandle LayerHandle;

public:
    MOZ_IMPLICIT OpCreatePaintedLayer() :
        layer_()
    {
    }

    MOZ_IMPLICIT OpCreatePaintedLayer(const LayerHandle& _layer) :
        layer_(_layer)
    {
    }

    LayerHandle&
    layer()
    {
        return layer_;
    }
    const LayerHandle&
    layer() const
    {
        return layer_;
    }

private:
    LayerHandle layer_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpCreatePaintedLayer>
{
    typedef mozilla::layers::OpCreatePaintedLayer paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpCreateContainerLayer|
//
namespace mozilla {
namespace layers {
class OpCreateContainerLayer final
{
private:
    typedef mozilla::layers::LayerHandle LayerHandle;

public:
    MOZ_IMPLICIT OpCreateContainerLayer() :
        layer_()
    {
    }

    MOZ_IMPLICIT OpCreateContainerLayer(const LayerHandle& _layer) :
        layer_(_layer)
    {
    }

    LayerHandle&
    layer()
    {
        return layer_;
    }
    const LayerHandle&
    layer() const
    {
        return layer_;
    }

private:
    LayerHandle layer_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpCreateContainerLayer>
{
    typedef mozilla::layers::OpCreateContainerLayer paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpCreateImageLayer|
//
namespace mozilla {
namespace layers {
class OpCreateImageLayer final
{
private:
    typedef mozilla::layers::LayerHandle LayerHandle;

public:
    MOZ_IMPLICIT OpCreateImageLayer() :
        layer_()
    {
    }

    MOZ_IMPLICIT OpCreateImageLayer(const LayerHandle& _layer) :
        layer_(_layer)
    {
    }

    LayerHandle&
    layer()
    {
        return layer_;
    }
    const LayerHandle&
    layer() const
    {
        return layer_;
    }

private:
    LayerHandle layer_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpCreateImageLayer>
{
    typedef mozilla::layers::OpCreateImageLayer paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpCreateColorLayer|
//
namespace mozilla {
namespace layers {
class OpCreateColorLayer final
{
private:
    typedef mozilla::layers::LayerHandle LayerHandle;

public:
    MOZ_IMPLICIT OpCreateColorLayer() :
        layer_()
    {
    }

    MOZ_IMPLICIT OpCreateColorLayer(const LayerHandle& _layer) :
        layer_(_layer)
    {
    }

    LayerHandle&
    layer()
    {
        return layer_;
    }
    const LayerHandle&
    layer() const
    {
        return layer_;
    }

private:
    LayerHandle layer_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpCreateColorLayer>
{
    typedef mozilla::layers::OpCreateColorLayer paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpCreateCanvasLayer|
//
namespace mozilla {
namespace layers {
class OpCreateCanvasLayer final
{
private:
    typedef mozilla::layers::LayerHandle LayerHandle;

public:
    MOZ_IMPLICIT OpCreateCanvasLayer() :
        layer_()
    {
    }

    MOZ_IMPLICIT OpCreateCanvasLayer(const LayerHandle& _layer) :
        layer_(_layer)
    {
    }

    LayerHandle&
    layer()
    {
        return layer_;
    }
    const LayerHandle&
    layer() const
    {
        return layer_;
    }

private:
    LayerHandle layer_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpCreateCanvasLayer>
{
    typedef mozilla::layers::OpCreateCanvasLayer paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpCreateRefLayer|
//
namespace mozilla {
namespace layers {
class OpCreateRefLayer final
{
private:
    typedef mozilla::layers::LayerHandle LayerHandle;

public:
    MOZ_IMPLICIT OpCreateRefLayer() :
        layer_()
    {
    }

    MOZ_IMPLICIT OpCreateRefLayer(const LayerHandle& _layer) :
        layer_(_layer)
    {
    }

    LayerHandle&
    layer()
    {
        return layer_;
    }
    const LayerHandle&
    layer() const
    {
        return layer_;
    }

private:
    LayerHandle layer_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpCreateRefLayer>
{
    typedef mozilla::layers::OpCreateRefLayer paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpAttachCompositable|
//
namespace mozilla {
namespace layers {
class OpAttachCompositable final
{
private:
    typedef mozilla::layers::LayerHandle LayerHandle;
    typedef mozilla::layers::CompositableHandle CompositableHandle;

public:
    MOZ_IMPLICIT OpAttachCompositable() :
        layer_(),
        compositable_()
    {
    }

    MOZ_IMPLICIT OpAttachCompositable(
            const LayerHandle& _layer,
            const CompositableHandle& _compositable) :
        layer_(_layer),
        compositable_(_compositable)
    {
    }

    LayerHandle&
    layer()
    {
        return layer_;
    }
    const LayerHandle&
    layer() const
    {
        return layer_;
    }

    CompositableHandle&
    compositable()
    {
        return compositable_;
    }
    const CompositableHandle&
    compositable() const
    {
        return compositable_;
    }

private:
    LayerHandle layer_;
    CompositableHandle compositable_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpAttachCompositable>
{
    typedef mozilla::layers::OpAttachCompositable paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpAttachAsyncCompositable|
//
namespace mozilla {
namespace layers {
class OpAttachAsyncCompositable final
{
private:
    typedef mozilla::layers::LayerHandle LayerHandle;
    typedef mozilla::layers::CompositableHandle CompositableHandle;

public:
    MOZ_IMPLICIT OpAttachAsyncCompositable() :
        layer_(),
        compositable_()
    {
    }

    MOZ_IMPLICIT OpAttachAsyncCompositable(
            const LayerHandle& _layer,
            const CompositableHandle& _compositable) :
        layer_(_layer),
        compositable_(_compositable)
    {
    }

    LayerHandle&
    layer()
    {
        return layer_;
    }
    const LayerHandle&
    layer() const
    {
        return layer_;
    }

    CompositableHandle&
    compositable()
    {
        return compositable_;
    }
    const CompositableHandle&
    compositable() const
    {
        return compositable_;
    }

private:
    LayerHandle layer_;
    CompositableHandle compositable_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpAttachAsyncCompositable>
{
    typedef mozilla::layers::OpAttachAsyncCompositable paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ThebesBufferData|
//
namespace mozilla {
namespace layers {
class ThebesBufferData final
{
private:
    typedef mozilla::gfx::IntRect IntRect;
    typedef mozilla::gfx::IntPoint IntPoint;

public:
    MOZ_IMPLICIT ThebesBufferData() :
        rect_(),
        rotation_()
    {
    }

    MOZ_IMPLICIT ThebesBufferData(
            const IntRect& _rect,
            const IntPoint& _rotation) :
        rect_(_rect),
        rotation_(_rotation)
    {
    }

    IntRect&
    rect()
    {
        return rect_;
    }
    const IntRect&
    rect() const
    {
        return rect_;
    }

    IntPoint&
    rotation()
    {
        return rotation_;
    }
    const IntPoint&
    rotation() const
    {
        return rotation_;
    }

private:
    IntRect rect_;
    IntPoint rotation_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::ThebesBufferData>
{
    typedef mozilla::layers::ThebesBufferData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CubicBezierFunction|
//
namespace mozilla {
namespace layers {
class CubicBezierFunction final
{
private:

public:
    MOZ_IMPLICIT CubicBezierFunction() :
        x1_(),
        y1_(),
        x2_(),
        y2_()
    {
    }

    MOZ_IMPLICIT CubicBezierFunction(
            const float& _x1,
            const float& _y1,
            const float& _x2,
            const float& _y2) :
        x1_(_x1),
        y1_(_y1),
        x2_(_x2),
        y2_(_y2)
    {
    }

    float&
    x1()
    {
        return x1_;
    }
    const float&
    x1() const
    {
        return x1_;
    }

    float&
    y1()
    {
        return y1_;
    }
    const float&
    y1() const
    {
        return y1_;
    }

    float&
    x2()
    {
        return x2_;
    }
    const float&
    x2() const
    {
        return x2_;
    }

    float&
    y2()
    {
        return y2_;
    }
    const float&
    y2() const
    {
        return y2_;
    }

private:
    void
    StaticAssertions() const;
    float x1_;
    float y1_;
    float x2_;
    float y2_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::CubicBezierFunction>
{
    typedef mozilla::layers::CubicBezierFunction paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct StepFunction|
//
namespace mozilla {
namespace layers {
class StepFunction final
{
private:

public:
    MOZ_IMPLICIT StepFunction() :
        steps_(),
        type_()
    {
    }

    MOZ_IMPLICIT StepFunction(
            const int& _steps,
            const uint8_t& _type) :
        steps_(_steps),
        type_(_type)
    {
    }

    int&
    steps()
    {
        return steps_;
    }
    const int&
    steps() const
    {
        return steps_;
    }

    uint8_t&
    type()
    {
        return type_;
    }
    const uint8_t&
    type() const
    {
        return type_;
    }

private:
    int steps_;
    uint8_t type_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::StepFunction>
{
    typedef mozilla::layers::StepFunction paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union TimingFunction|
//
namespace mozilla {
namespace layers {
class TimingFunction final
{
public:
    enum Type {
        T__None,
        Tnull_t = 1,
        TCubicBezierFunction,
        TStepFunction,
        T__Last = TStepFunction
    };

private:
    typedef mozilla::null_t null_t;
    typedef mozilla::layers::CubicBezierFunction CubicBezierFunction;
    typedef mozilla::layers::StepFunction StepFunction;
    typedef null_t null_t__tdef;
    typedef CubicBezierFunction CubicBezierFunction__tdef;
    typedef StepFunction StepFunction__tdef;

    union Value {
        mozilla::AlignedStorage2<null_t> Vnull_t;
        mozilla::AlignedStorage2<CubicBezierFunction> VCubicBezierFunction;
        mozilla::AlignedStorage2<StepFunction> VStepFunction;
    };

    null_t*
    ptr_null_t()
    {
        return ((mValue).Vnull_t).addr();
    }
    const null_t*
    constptr_null_t() const
    {
        return ((mValue).Vnull_t).addr();
    }
    CubicBezierFunction*
    ptr_CubicBezierFunction()
    {
        return ((mValue).VCubicBezierFunction).addr();
    }
    const CubicBezierFunction*
    constptr_CubicBezierFunction() const
    {
        return ((mValue).VCubicBezierFunction).addr();
    }
    StepFunction*
    ptr_StepFunction()
    {
        return ((mValue).VStepFunction).addr();
    }
    const StepFunction*
    constptr_StepFunction() const
    {
        return ((mValue).VStepFunction).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT TimingFunction() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT TimingFunction(const null_t& aOther);

    MOZ_IMPLICIT TimingFunction(null_t&& aOther);

    MOZ_IMPLICIT TimingFunction(const CubicBezierFunction& aOther);

    MOZ_IMPLICIT TimingFunction(CubicBezierFunction&& aOther);

    MOZ_IMPLICIT TimingFunction(const StepFunction& aOther);

    MOZ_IMPLICIT TimingFunction(StepFunction&& aOther);

    MOZ_IMPLICIT TimingFunction(const TimingFunction& aOther);

    MOZ_IMPLICIT TimingFunction(TimingFunction&& aOther);

    ~TimingFunction();

    Type
    type() const
    {
        return mType;
    }

    TimingFunction&
    operator=(const null_t& aRhs);

    TimingFunction&
    operator=(null_t&& aRhs);

    TimingFunction&
    operator=(const CubicBezierFunction& aRhs);

    TimingFunction&
    operator=(CubicBezierFunction&& aRhs);

    TimingFunction&
    operator=(const StepFunction& aRhs);

    TimingFunction&
    operator=(StepFunction&& aRhs);

    TimingFunction&
    operator=(const TimingFunction& aRhs);

    TimingFunction&
    operator=(TimingFunction&& aRhs);

    null_t&
    get_null_t()
    {
        AssertSanity(Tnull_t);
        return (*(ptr_null_t()));
    }
    const null_t&
    get_null_t() const
    {
        AssertSanity(Tnull_t);
        return (*(constptr_null_t()));
    }
    operator null_t&()
    {
        return get_null_t();
    }
    operator const null_t&() const
    {
        return get_null_t();
    }

    CubicBezierFunction&
    get_CubicBezierFunction()
    {
        AssertSanity(TCubicBezierFunction);
        return (*(ptr_CubicBezierFunction()));
    }
    const CubicBezierFunction&
    get_CubicBezierFunction() const
    {
        AssertSanity(TCubicBezierFunction);
        return (*(constptr_CubicBezierFunction()));
    }
    operator CubicBezierFunction&()
    {
        return get_CubicBezierFunction();
    }
    operator const CubicBezierFunction&() const
    {
        return get_CubicBezierFunction();
    }

    StepFunction&
    get_StepFunction()
    {
        AssertSanity(TStepFunction);
        return (*(ptr_StepFunction()));
    }
    const StepFunction&
    get_StepFunction() const
    {
        AssertSanity(TStepFunction);
        return (*(constptr_StepFunction()));
    }
    operator StepFunction&()
    {
        return get_StepFunction();
    }
    operator const StepFunction&() const
    {
        return get_StepFunction();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::TimingFunction>
{
    typedef mozilla::layers::TimingFunction paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct LayerColor|
//
namespace mozilla {
namespace layers {
class LayerColor final
{
private:
    typedef mozilla::gfx::DeviceColor DeviceColor;

public:
    MOZ_IMPLICIT LayerColor() :
        value_()
    {
    }

    MOZ_IMPLICIT LayerColor(const DeviceColor& _value) :
        value_(_value)
    {
    }

    DeviceColor&
    value()
    {
        return value_;
    }
    const DeviceColor&
    value() const
    {
        return value_;
    }

private:
    DeviceColor value_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::LayerColor>
{
    typedef mozilla::layers::LayerColor paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union Animatable|
//
namespace mozilla {
namespace layers {
class Animatable final
{
public:
    enum Type {
        T__None,
        Tnull_t = 1,
        Tfloat,
        Tnscolor,
        TStyleRotate,
        TStyleScale,
        TStyleTranslate,
        TStyleTransform,
        TStyleOffsetPath,
        TLengthPercentage,
        TStyleOffsetRotate,
        TStylePositionOrAuto,
        T__Last = TStylePositionOrAuto
    };

private:
    typedef mozilla::null_t null_t;
    typedef mozilla::StyleRotate StyleRotate;
    typedef mozilla::StyleScale StyleScale;
    typedef mozilla::StyleTranslate StyleTranslate;
    typedef mozilla::StyleTransform StyleTransform;
    typedef mozilla::StyleOffsetPath StyleOffsetPath;
    typedef mozilla::LengthPercentage LengthPercentage;
    typedef mozilla::StyleOffsetRotate StyleOffsetRotate;
    typedef mozilla::StylePositionOrAuto StylePositionOrAuto;
    typedef null_t null_t__tdef;
    typedef float float__tdef;
    typedef nscolor nscolor__tdef;
    typedef StyleRotate StyleRotate__tdef;
    typedef StyleScale StyleScale__tdef;
    typedef StyleTranslate StyleTranslate__tdef;
    typedef StyleTransform StyleTransform__tdef;
    typedef StyleOffsetPath StyleOffsetPath__tdef;
    typedef LengthPercentage LengthPercentage__tdef;
    typedef StyleOffsetRotate StyleOffsetRotate__tdef;
    typedef StylePositionOrAuto StylePositionOrAuto__tdef;

    union Value {
        mozilla::AlignedStorage2<null_t> Vnull_t;
        mozilla::AlignedStorage2<float> Vfloat;
        mozilla::AlignedStorage2<nscolor> Vnscolor;
        mozilla::AlignedStorage2<StyleRotate> VStyleRotate;
        mozilla::AlignedStorage2<StyleScale> VStyleScale;
        mozilla::AlignedStorage2<StyleTranslate> VStyleTranslate;
        mozilla::AlignedStorage2<StyleTransform> VStyleTransform;
        mozilla::AlignedStorage2<StyleOffsetPath> VStyleOffsetPath;
        mozilla::AlignedStorage2<LengthPercentage> VLengthPercentage;
        mozilla::AlignedStorage2<StyleOffsetRotate> VStyleOffsetRotate;
        mozilla::AlignedStorage2<StylePositionOrAuto> VStylePositionOrAuto;
    };

    null_t*
    ptr_null_t()
    {
        return ((mValue).Vnull_t).addr();
    }
    const null_t*
    constptr_null_t() const
    {
        return ((mValue).Vnull_t).addr();
    }
    float*
    ptr_float()
    {
        return ((mValue).Vfloat).addr();
    }
    const float*
    constptr_float() const
    {
        return ((mValue).Vfloat).addr();
    }
    nscolor*
    ptr_nscolor()
    {
        return ((mValue).Vnscolor).addr();
    }
    const nscolor*
    constptr_nscolor() const
    {
        return ((mValue).Vnscolor).addr();
    }
    StyleRotate*
    ptr_StyleRotate()
    {
        return ((mValue).VStyleRotate).addr();
    }
    const StyleRotate*
    constptr_StyleRotate() const
    {
        return ((mValue).VStyleRotate).addr();
    }
    StyleScale*
    ptr_StyleScale()
    {
        return ((mValue).VStyleScale).addr();
    }
    const StyleScale*
    constptr_StyleScale() const
    {
        return ((mValue).VStyleScale).addr();
    }
    StyleTranslate*
    ptr_StyleTranslate()
    {
        return ((mValue).VStyleTranslate).addr();
    }
    const StyleTranslate*
    constptr_StyleTranslate() const
    {
        return ((mValue).VStyleTranslate).addr();
    }
    StyleTransform*
    ptr_StyleTransform()
    {
        return ((mValue).VStyleTransform).addr();
    }
    const StyleTransform*
    constptr_StyleTransform() const
    {
        return ((mValue).VStyleTransform).addr();
    }
    StyleOffsetPath*
    ptr_StyleOffsetPath()
    {
        return ((mValue).VStyleOffsetPath).addr();
    }
    const StyleOffsetPath*
    constptr_StyleOffsetPath() const
    {
        return ((mValue).VStyleOffsetPath).addr();
    }
    LengthPercentage*
    ptr_LengthPercentage()
    {
        return ((mValue).VLengthPercentage).addr();
    }
    const LengthPercentage*
    constptr_LengthPercentage() const
    {
        return ((mValue).VLengthPercentage).addr();
    }
    StyleOffsetRotate*
    ptr_StyleOffsetRotate()
    {
        return ((mValue).VStyleOffsetRotate).addr();
    }
    const StyleOffsetRotate*
    constptr_StyleOffsetRotate() const
    {
        return ((mValue).VStyleOffsetRotate).addr();
    }
    StylePositionOrAuto*
    ptr_StylePositionOrAuto()
    {
        return ((mValue).VStylePositionOrAuto).addr();
    }
    const StylePositionOrAuto*
    constptr_StylePositionOrAuto() const
    {
        return ((mValue).VStylePositionOrAuto).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT Animatable() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT Animatable(const null_t& aOther);

    MOZ_IMPLICIT Animatable(null_t&& aOther);

    MOZ_IMPLICIT Animatable(const float& aOther);

    MOZ_IMPLICIT Animatable(float&& aOther);

    MOZ_IMPLICIT Animatable(const nscolor& aOther);

    MOZ_IMPLICIT Animatable(nscolor&& aOther);

    MOZ_IMPLICIT Animatable(const StyleRotate& aOther);

    MOZ_IMPLICIT Animatable(StyleRotate&& aOther);

    MOZ_IMPLICIT Animatable(const StyleScale& aOther);

    MOZ_IMPLICIT Animatable(StyleScale&& aOther);

    MOZ_IMPLICIT Animatable(const StyleTranslate& aOther);

    MOZ_IMPLICIT Animatable(StyleTranslate&& aOther);

    MOZ_IMPLICIT Animatable(const StyleTransform& aOther);

    MOZ_IMPLICIT Animatable(StyleTransform&& aOther);

    MOZ_IMPLICIT Animatable(const StyleOffsetPath& aOther);

    MOZ_IMPLICIT Animatable(StyleOffsetPath&& aOther);

    MOZ_IMPLICIT Animatable(const LengthPercentage& aOther);

    MOZ_IMPLICIT Animatable(LengthPercentage&& aOther);

    MOZ_IMPLICIT Animatable(const StyleOffsetRotate& aOther);

    MOZ_IMPLICIT Animatable(StyleOffsetRotate&& aOther);

    MOZ_IMPLICIT Animatable(const StylePositionOrAuto& aOther);

    MOZ_IMPLICIT Animatable(StylePositionOrAuto&& aOther);

    MOZ_IMPLICIT Animatable(const Animatable& aOther);

    MOZ_IMPLICIT Animatable(Animatable&& aOther);

    ~Animatable();

    Type
    type() const
    {
        return mType;
    }

    Animatable&
    operator=(const null_t& aRhs);

    Animatable&
    operator=(null_t&& aRhs);

    Animatable&
    operator=(const float& aRhs);

    Animatable&
    operator=(float&& aRhs);

    Animatable&
    operator=(const nscolor& aRhs);

    Animatable&
    operator=(nscolor&& aRhs);

    Animatable&
    operator=(const StyleRotate& aRhs);

    Animatable&
    operator=(StyleRotate&& aRhs);

    Animatable&
    operator=(const StyleScale& aRhs);

    Animatable&
    operator=(StyleScale&& aRhs);

    Animatable&
    operator=(const StyleTranslate& aRhs);

    Animatable&
    operator=(StyleTranslate&& aRhs);

    Animatable&
    operator=(const StyleTransform& aRhs);

    Animatable&
    operator=(StyleTransform&& aRhs);

    Animatable&
    operator=(const StyleOffsetPath& aRhs);

    Animatable&
    operator=(StyleOffsetPath&& aRhs);

    Animatable&
    operator=(const LengthPercentage& aRhs);

    Animatable&
    operator=(LengthPercentage&& aRhs);

    Animatable&
    operator=(const StyleOffsetRotate& aRhs);

    Animatable&
    operator=(StyleOffsetRotate&& aRhs);

    Animatable&
    operator=(const StylePositionOrAuto& aRhs);

    Animatable&
    operator=(StylePositionOrAuto&& aRhs);

    Animatable&
    operator=(const Animatable& aRhs);

    Animatable&
    operator=(Animatable&& aRhs);

    bool
    operator==(const null_t& aRhs) const;

    bool
    operator==(const float& aRhs) const;

    bool
    operator==(const nscolor& aRhs) const;

    bool
    operator==(const StyleRotate& aRhs) const;

    bool
    operator==(const StyleScale& aRhs) const;

    bool
    operator==(const StyleTranslate& aRhs) const;

    bool
    operator==(const StyleTransform& aRhs) const;

    bool
    operator==(const StyleOffsetPath& aRhs) const;

    bool
    operator==(const LengthPercentage& aRhs) const;

    bool
    operator==(const StyleOffsetRotate& aRhs) const;

    bool
    operator==(const StylePositionOrAuto& aRhs) const;

    bool
    operator==(const Animatable& aRhs) const;

    null_t&
    get_null_t()
    {
        AssertSanity(Tnull_t);
        return (*(ptr_null_t()));
    }
    const null_t&
    get_null_t() const
    {
        AssertSanity(Tnull_t);
        return (*(constptr_null_t()));
    }
    operator null_t&()
    {
        return get_null_t();
    }
    operator const null_t&() const
    {
        return get_null_t();
    }

    float&
    get_float()
    {
        AssertSanity(Tfloat);
        return (*(ptr_float()));
    }
    const float&
    get_float() const
    {
        AssertSanity(Tfloat);
        return (*(constptr_float()));
    }
    operator float&()
    {
        return get_float();
    }
    operator const float&() const
    {
        return get_float();
    }

    nscolor&
    get_nscolor()
    {
        AssertSanity(Tnscolor);
        return (*(ptr_nscolor()));
    }
    const nscolor&
    get_nscolor() const
    {
        AssertSanity(Tnscolor);
        return (*(constptr_nscolor()));
    }
    operator nscolor&()
    {
        return get_nscolor();
    }
    operator const nscolor&() const
    {
        return get_nscolor();
    }

    StyleRotate&
    get_StyleRotate()
    {
        AssertSanity(TStyleRotate);
        return (*(ptr_StyleRotate()));
    }
    const StyleRotate&
    get_StyleRotate() const
    {
        AssertSanity(TStyleRotate);
        return (*(constptr_StyleRotate()));
    }
    operator StyleRotate&()
    {
        return get_StyleRotate();
    }
    operator const StyleRotate&() const
    {
        return get_StyleRotate();
    }

    StyleScale&
    get_StyleScale()
    {
        AssertSanity(TStyleScale);
        return (*(ptr_StyleScale()));
    }
    const StyleScale&
    get_StyleScale() const
    {
        AssertSanity(TStyleScale);
        return (*(constptr_StyleScale()));
    }
    operator StyleScale&()
    {
        return get_StyleScale();
    }
    operator const StyleScale&() const
    {
        return get_StyleScale();
    }

    StyleTranslate&
    get_StyleTranslate()
    {
        AssertSanity(TStyleTranslate);
        return (*(ptr_StyleTranslate()));
    }
    const StyleTranslate&
    get_StyleTranslate() const
    {
        AssertSanity(TStyleTranslate);
        return (*(constptr_StyleTranslate()));
    }
    operator StyleTranslate&()
    {
        return get_StyleTranslate();
    }
    operator const StyleTranslate&() const
    {
        return get_StyleTranslate();
    }

    StyleTransform&
    get_StyleTransform()
    {
        AssertSanity(TStyleTransform);
        return (*(ptr_StyleTransform()));
    }
    const StyleTransform&
    get_StyleTransform() const
    {
        AssertSanity(TStyleTransform);
        return (*(constptr_StyleTransform()));
    }
    operator StyleTransform&()
    {
        return get_StyleTransform();
    }
    operator const StyleTransform&() const
    {
        return get_StyleTransform();
    }

    StyleOffsetPath&
    get_StyleOffsetPath()
    {
        AssertSanity(TStyleOffsetPath);
        return (*(ptr_StyleOffsetPath()));
    }
    const StyleOffsetPath&
    get_StyleOffsetPath() const
    {
        AssertSanity(TStyleOffsetPath);
        return (*(constptr_StyleOffsetPath()));
    }
    operator StyleOffsetPath&()
    {
        return get_StyleOffsetPath();
    }
    operator const StyleOffsetPath&() const
    {
        return get_StyleOffsetPath();
    }

    LengthPercentage&
    get_LengthPercentage()
    {
        AssertSanity(TLengthPercentage);
        return (*(ptr_LengthPercentage()));
    }
    const LengthPercentage&
    get_LengthPercentage() const
    {
        AssertSanity(TLengthPercentage);
        return (*(constptr_LengthPercentage()));
    }
    operator LengthPercentage&()
    {
        return get_LengthPercentage();
    }
    operator const LengthPercentage&() const
    {
        return get_LengthPercentage();
    }

    StyleOffsetRotate&
    get_StyleOffsetRotate()
    {
        AssertSanity(TStyleOffsetRotate);
        return (*(ptr_StyleOffsetRotate()));
    }
    const StyleOffsetRotate&
    get_StyleOffsetRotate() const
    {
        AssertSanity(TStyleOffsetRotate);
        return (*(constptr_StyleOffsetRotate()));
    }
    operator StyleOffsetRotate&()
    {
        return get_StyleOffsetRotate();
    }
    operator const StyleOffsetRotate&() const
    {
        return get_StyleOffsetRotate();
    }

    StylePositionOrAuto&
    get_StylePositionOrAuto()
    {
        AssertSanity(TStylePositionOrAuto);
        return (*(ptr_StylePositionOrAuto()));
    }
    const StylePositionOrAuto&
    get_StylePositionOrAuto() const
    {
        AssertSanity(TStylePositionOrAuto);
        return (*(constptr_StylePositionOrAuto()));
    }
    operator StylePositionOrAuto&()
    {
        return get_StylePositionOrAuto();
    }
    operator const StylePositionOrAuto&() const
    {
        return get_StylePositionOrAuto();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::Animatable>
{
    typedef mozilla::layers::Animatable paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct AnimationSegment|
//
namespace mozilla {
namespace layers {
class AnimationSegment final
{
private:
    typedef mozilla::layers::Animatable Animatable;
    typedef mozilla::layers::TimingFunction TimingFunction;

public:
    MOZ_IMPLICIT AnimationSegment() :
        startState_(),
        endState_(),
        sampleFn_(),
        startPortion_(),
        endPortion_(),
        startComposite_(),
        endComposite_()
    {
    }

    MOZ_IMPLICIT AnimationSegment(
            const Animatable& _startState,
            const Animatable& _endState,
            const float& _startPortion,
            const float& _endPortion,
            const uint8_t& _startComposite,
            const uint8_t& _endComposite,
            const TimingFunction& _sampleFn) :
        startState_(_startState),
        endState_(_endState),
        sampleFn_(_sampleFn),
        startPortion_(_startPortion),
        endPortion_(_endPortion),
        startComposite_(_startComposite),
        endComposite_(_endComposite)
    {
    }

    Animatable&
    startState()
    {
        return startState_;
    }
    const Animatable&
    startState() const
    {
        return startState_;
    }

    Animatable&
    endState()
    {
        return endState_;
    }
    const Animatable&
    endState() const
    {
        return endState_;
    }

    float&
    startPortion()
    {
        return startPortion_;
    }
    const float&
    startPortion() const
    {
        return startPortion_;
    }

    float&
    endPortion()
    {
        return endPortion_;
    }
    const float&
    endPortion() const
    {
        return endPortion_;
    }

    uint8_t&
    startComposite()
    {
        return startComposite_;
    }
    const uint8_t&
    startComposite() const
    {
        return startComposite_;
    }

    uint8_t&
    endComposite()
    {
        return endComposite_;
    }
    const uint8_t&
    endComposite() const
    {
        return endComposite_;
    }

    TimingFunction&
    sampleFn()
    {
        return sampleFn_;
    }
    const TimingFunction&
    sampleFn() const
    {
        return sampleFn_;
    }

private:
    void
    StaticAssertions() const;
    Animatable startState_;
    Animatable endState_;
    TimingFunction sampleFn_;
    float startPortion_;
    float endPortion_;
    uint8_t startComposite_;
    uint8_t endComposite_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::AnimationSegment>
{
    typedef mozilla::layers::AnimationSegment paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct MotionPathData|
//
namespace mozilla {
namespace layers {
class MotionPathData final
{
private:
    typedef mozilla::CSSPoint CSSPoint;
    typedef mozilla::RayReferenceData RayReferenceData;

public:
    MOZ_IMPLICIT MotionPathData() :
        origin_(),
        anchorAdjustment_(),
        rayReferenceData_()
    {
    }

    MOZ_IMPLICIT MotionPathData(
            const CSSPoint& _origin,
            const CSSPoint& _anchorAdjustment,
            const RayReferenceData& _rayReferenceData) :
        origin_(_origin),
        anchorAdjustment_(_anchorAdjustment),
        rayReferenceData_(_rayReferenceData)
    {
    }

    bool
    operator==(const MotionPathData& _o) const;

    bool
    operator!=(const MotionPathData& _o) const;

    CSSPoint&
    origin()
    {
        return origin_;
    }
    const CSSPoint&
    origin() const
    {
        return origin_;
    }

    CSSPoint&
    anchorAdjustment()
    {
        return anchorAdjustment_;
    }
    const CSSPoint&
    anchorAdjustment() const
    {
        return anchorAdjustment_;
    }

    RayReferenceData&
    rayReferenceData()
    {
        return rayReferenceData_;
    }
    const RayReferenceData&
    rayReferenceData() const
    {
        return rayReferenceData_;
    }

private:
    CSSPoint origin_;
    CSSPoint anchorAdjustment_;
    RayReferenceData rayReferenceData_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::MotionPathData>
{
    typedef mozilla::layers::MotionPathData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct PartialPrerenderData|
//
namespace mozilla {
namespace layers {
class PartialPrerenderData final
{
private:
    typedef mozilla::LayoutDeviceRect LayoutDeviceRect;
    typedef mozilla::SideBits SideBits;
    typedef mozilla::layers::ScrollableLayerGuid::ViewID ViewID;
    typedef mozilla::ParentLayerRect ParentLayerRect;
    typedef mozilla::gfx::Matrix4x4 Matrix4x4;
    typedef mozilla::LayoutDevicePoint LayoutDevicePoint;

public:
    MOZ_IMPLICIT PartialPrerenderData() :
        rect_(),
        overflowedSides_(),
        scrollId_(),
        clipRect_(),
        transformInClip_(),
        position_()
    {
    }

    MOZ_IMPLICIT PartialPrerenderData(
            const LayoutDeviceRect& _rect,
            const SideBits& _overflowedSides,
            const ViewID& _scrollId,
            const ParentLayerRect& _clipRect,
            const Matrix4x4& _transformInClip,
            const LayoutDevicePoint& _position) :
        rect_(_rect),
        overflowedSides_(_overflowedSides),
        scrollId_(_scrollId),
        clipRect_(_clipRect),
        transformInClip_(_transformInClip),
        position_(_position)
    {
    }

    bool
    operator==(const PartialPrerenderData& _o) const;

    bool
    operator!=(const PartialPrerenderData& _o) const;

    LayoutDeviceRect&
    rect()
    {
        return rect_;
    }
    const LayoutDeviceRect&
    rect() const
    {
        return rect_;
    }

    SideBits&
    overflowedSides()
    {
        return overflowedSides_;
    }
    const SideBits&
    overflowedSides() const
    {
        return overflowedSides_;
    }

    ViewID&
    scrollId()
    {
        return scrollId_;
    }
    const ViewID&
    scrollId() const
    {
        return scrollId_;
    }

    ParentLayerRect&
    clipRect()
    {
        return clipRect_;
    }
    const ParentLayerRect&
    clipRect() const
    {
        return clipRect_;
    }

    Matrix4x4&
    transformInClip()
    {
        return transformInClip_;
    }
    const Matrix4x4&
    transformInClip() const
    {
        return transformInClip_;
    }

    LayoutDevicePoint&
    position()
    {
        return position_;
    }
    const LayoutDevicePoint&
    position() const
    {
        return position_;
    }

private:
    LayoutDeviceRect rect_;
    SideBits overflowedSides_;
    ViewID scrollId_;
    ParentLayerRect clipRect_;
    Matrix4x4 transformInClip_;
    LayoutDevicePoint position_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::PartialPrerenderData>
{
    typedef mozilla::layers::PartialPrerenderData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct TransformData|
//
namespace mozilla {
namespace layers {
class TransformData final
{
private:
    typedef mozilla::gfx::Point3D Point3D;
    typedef mozilla::layers::MotionPathData MotionPathData;
    typedef mozilla::layers::PartialPrerenderData PartialPrerenderData;

public:
    MOZ_IMPLICIT TransformData() :
        origin_(),
        transformOrigin_(),
        bounds_(),
        motionPathData_(),
        partialPrerenderData_(),
        appUnitsPerDevPixel_()
    {
    }

    MOZ_IMPLICIT TransformData(
            const nsPoint& _origin,
            const Point3D& _transformOrigin,
            const nsRect& _bounds,
            const int32_t& _appUnitsPerDevPixel,
            const mozilla::Maybe<MotionPathData>& _motionPathData,
            const mozilla::Maybe<PartialPrerenderData>& _partialPrerenderData) :
        origin_(_origin),
        transformOrigin_(_transformOrigin),
        bounds_(_bounds),
        motionPathData_(_motionPathData),
        partialPrerenderData_(_partialPrerenderData),
        appUnitsPerDevPixel_(_appUnitsPerDevPixel)
    {
    }

    bool
    operator==(const TransformData& _o) const;

    bool
    operator!=(const TransformData& _o) const;

    nsPoint&
    origin()
    {
        return origin_;
    }
    const nsPoint&
    origin() const
    {
        return origin_;
    }

    Point3D&
    transformOrigin()
    {
        return transformOrigin_;
    }
    const Point3D&
    transformOrigin() const
    {
        return transformOrigin_;
    }

    nsRect&
    bounds()
    {
        return bounds_;
    }
    const nsRect&
    bounds() const
    {
        return bounds_;
    }

    int32_t&
    appUnitsPerDevPixel()
    {
        return appUnitsPerDevPixel_;
    }
    const int32_t&
    appUnitsPerDevPixel() const
    {
        return appUnitsPerDevPixel_;
    }

    mozilla::Maybe<MotionPathData>&
    motionPathData()
    {
        return motionPathData_;
    }
    const mozilla::Maybe<MotionPathData>&
    motionPathData() const
    {
        return motionPathData_;
    }

    mozilla::Maybe<PartialPrerenderData>&
    partialPrerenderData()
    {
        return partialPrerenderData_;
    }
    const mozilla::Maybe<PartialPrerenderData>&
    partialPrerenderData() const
    {
        return partialPrerenderData_;
    }

private:
    nsPoint origin_;
    Point3D transformOrigin_;
    nsRect bounds_;
    mozilla::Maybe<MotionPathData> motionPathData_;
    mozilla::Maybe<PartialPrerenderData> partialPrerenderData_;
    int32_t appUnitsPerDevPixel_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::TransformData>
{
    typedef mozilla::layers::TransformData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct Animation|
//
namespace mozilla {
namespace layers {
class Animation final
{
private:
    typedef mozilla::TimeStamp TimeStamp;
    typedef mozilla::TimeDuration TimeDuration;
    typedef mozilla::layers::AnimationSegment AnimationSegment;
    typedef mozilla::layers::TimingFunction TimingFunction;
    typedef mozilla::layers::Animatable Animatable;
    typedef mozilla::layers::TransformData TransformData;

public:
    MOZ_IMPLICIT Animation() :
        originTime_(),
        startTime_(),
        delay_(),
        endDelay_(),
        holdTime_(),
        duration_(),
        segments_(),
        property_(),
        easingFunction_(),
        isNotPlaying_(),
        isNotAnimating_(),
        baseStyle_(),
        transformData_(),
        iterations_(),
        iterationStart_(),
        playbackRate_(),
        previousPlaybackRate_(),
        direction_(),
        fillMode_(),
        iterationComposite_()
    {
    }

    MOZ_IMPLICIT Animation(
            const TimeStamp& _originTime,
            const mozilla::Maybe<TimeDuration>& _startTime,
            const TimeDuration& _delay,
            const TimeDuration& _endDelay,
            const TimeDuration& _holdTime,
            const TimeDuration& _duration,
            const nsTArray<AnimationSegment>& _segments,
            const float& _iterations,
            const float& _iterationStart,
            const uint8_t& _direction,
            const uint8_t& _fillMode,
            const nsCSSPropertyID& _property,
            const float& _playbackRate,
            const float& _previousPlaybackRate,
            const TimingFunction& _easingFunction,
            const uint8_t& _iterationComposite,
            const bool& _isNotPlaying,
            const bool& _isNotAnimating,
            const Animatable& _baseStyle,
            const mozilla::Maybe<TransformData>& _transformData) :
        originTime_(_originTime),
        startTime_(_startTime),
        delay_(_delay),
        endDelay_(_endDelay),
        holdTime_(_holdTime),
        duration_(_duration),
        segments_(_segments),
        property_(_property),
        easingFunction_(_easingFunction),
        isNotPlaying_(_isNotPlaying),
        isNotAnimating_(_isNotAnimating),
        baseStyle_(_baseStyle),
        transformData_(_transformData),
        iterations_(_iterations),
        iterationStart_(_iterationStart),
        playbackRate_(_playbackRate),
        previousPlaybackRate_(_previousPlaybackRate),
        direction_(_direction),
        fillMode_(_fillMode),
        iterationComposite_(_iterationComposite)
    {
    }

    TimeStamp&
    originTime()
    {
        return originTime_;
    }
    const TimeStamp&
    originTime() const
    {
        return originTime_;
    }

    mozilla::Maybe<TimeDuration>&
    startTime()
    {
        return startTime_;
    }
    const mozilla::Maybe<TimeDuration>&
    startTime() const
    {
        return startTime_;
    }

    TimeDuration&
    delay()
    {
        return delay_;
    }
    const TimeDuration&
    delay() const
    {
        return delay_;
    }

    TimeDuration&
    endDelay()
    {
        return endDelay_;
    }
    const TimeDuration&
    endDelay() const
    {
        return endDelay_;
    }

    TimeDuration&
    holdTime()
    {
        return holdTime_;
    }
    const TimeDuration&
    holdTime() const
    {
        return holdTime_;
    }

    TimeDuration&
    duration()
    {
        return duration_;
    }
    const TimeDuration&
    duration() const
    {
        return duration_;
    }

    nsTArray<AnimationSegment>&
    segments()
    {
        return segments_;
    }
    const nsTArray<AnimationSegment>&
    segments() const
    {
        return segments_;
    }

    float&
    iterations()
    {
        return iterations_;
    }
    const float&
    iterations() const
    {
        return iterations_;
    }

    float&
    iterationStart()
    {
        return iterationStart_;
    }
    const float&
    iterationStart() const
    {
        return iterationStart_;
    }

    uint8_t&
    direction()
    {
        return direction_;
    }
    const uint8_t&
    direction() const
    {
        return direction_;
    }

    uint8_t&
    fillMode()
    {
        return fillMode_;
    }
    const uint8_t&
    fillMode() const
    {
        return fillMode_;
    }

    nsCSSPropertyID&
    property()
    {
        return property_;
    }
    const nsCSSPropertyID&
    property() const
    {
        return property_;
    }

    float&
    playbackRate()
    {
        return playbackRate_;
    }
    const float&
    playbackRate() const
    {
        return playbackRate_;
    }

    float&
    previousPlaybackRate()
    {
        return previousPlaybackRate_;
    }
    const float&
    previousPlaybackRate() const
    {
        return previousPlaybackRate_;
    }

    TimingFunction&
    easingFunction()
    {
        return easingFunction_;
    }
    const TimingFunction&
    easingFunction() const
    {
        return easingFunction_;
    }

    uint8_t&
    iterationComposite()
    {
        return iterationComposite_;
    }
    const uint8_t&
    iterationComposite() const
    {
        return iterationComposite_;
    }

    bool&
    isNotPlaying()
    {
        return isNotPlaying_;
    }
    const bool&
    isNotPlaying() const
    {
        return isNotPlaying_;
    }

    bool&
    isNotAnimating()
    {
        return isNotAnimating_;
    }
    const bool&
    isNotAnimating() const
    {
        return isNotAnimating_;
    }

    Animatable&
    baseStyle()
    {
        return baseStyle_;
    }
    const Animatable&
    baseStyle() const
    {
        return baseStyle_;
    }

    mozilla::Maybe<TransformData>&
    transformData()
    {
        return transformData_;
    }
    const mozilla::Maybe<TransformData>&
    transformData() const
    {
        return transformData_;
    }

private:
    void
    StaticAssertions() const;
    TimeStamp originTime_;
    mozilla::Maybe<TimeDuration> startTime_;
    TimeDuration delay_;
    TimeDuration endDelay_;
    TimeDuration holdTime_;
    TimeDuration duration_;
    CopyableTArray<AnimationSegment> segments_;
    nsCSSPropertyID property_;
    TimingFunction easingFunction_;
    bool isNotPlaying_;
    bool isNotAnimating_;
    Animatable baseStyle_;
    mozilla::Maybe<TransformData> transformData_;
    float iterations_;
    float iterationStart_;
    float playbackRate_;
    float previousPlaybackRate_;
    uint8_t direction_;
    uint8_t fillMode_;
    uint8_t iterationComposite_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::Animation>
{
    typedef mozilla::layers::Animation paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CompositorAnimations|
//
namespace mozilla {
namespace layers {
class CompositorAnimations final
{
private:
    typedef mozilla::layers::Animation Animation;

public:
    MOZ_IMPLICIT CompositorAnimations() :
        animations_(),
        id_()
    {
    }

    MOZ_IMPLICIT CompositorAnimations(
            const nsTArray<Animation>& _animations,
            const uint64_t& _id) :
        animations_(_animations),
        id_(_id)
    {
    }

    nsTArray<Animation>&
    animations()
    {
        return animations_;
    }
    const nsTArray<Animation>&
    animations() const
    {
        return animations_;
    }

    uint64_t&
    id()
    {
        return id_;
    }
    const uint64_t&
    id() const
    {
        return id_;
    }

private:
    CopyableTArray<Animation> animations_;
    uint64_t id_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::CompositorAnimations>
{
    typedef mozilla::layers::CompositorAnimations paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CommonLayerAttributes|
//
namespace mozilla {
namespace layers {
class CommonLayerAttributes final
{
private:
    typedef mozilla::LayerIntRegion LayerIntRegion;
    typedef mozilla::layers::EventRegions EventRegions;
    typedef mozilla::ParentLayerIntRect ParentLayerIntRect;
    typedef mozilla::layers::LayerHandle LayerHandle;
    typedef mozilla::layers::CompositorAnimations CompositorAnimations;
    typedef mozilla::layers::ScrollMetadata ScrollMetadata;

public:
    MOZ_IMPLICIT CommonLayerAttributes() :
        visibleRegion_(),
        eventRegions_(),
        useClipRect_(),
        clipRect_(),
        maskLayer_(),
        ancestorMaskLayers_(),
        compositorAnimations_(),
        invalidRegion_(),
        scrollMetadata_(),
        displayListLog_()
    {
    }

    MOZ_IMPLICIT CommonLayerAttributes(
            const LayerIntRegion& _visibleRegion,
            const EventRegions& _eventRegions,
            const bool& _useClipRect,
            const ParentLayerIntRect& _clipRect,
            const LayerHandle& _maskLayer,
            const nsTArray<LayerHandle>& _ancestorMaskLayers,
            const CompositorAnimations& _compositorAnimations,
            const nsIntRegion& _invalidRegion,
            const nsTArray<ScrollMetadata>& _scrollMetadata,
            const nsCString& _displayListLog) :
        visibleRegion_(_visibleRegion),
        eventRegions_(_eventRegions),
        useClipRect_(_useClipRect),
        clipRect_(_clipRect),
        maskLayer_(_maskLayer),
        ancestorMaskLayers_(_ancestorMaskLayers),
        compositorAnimations_(_compositorAnimations),
        invalidRegion_(_invalidRegion),
        scrollMetadata_(_scrollMetadata),
        displayListLog_(_displayListLog)
    {
    }

    LayerIntRegion&
    visibleRegion()
    {
        return visibleRegion_;
    }
    const LayerIntRegion&
    visibleRegion() const
    {
        return visibleRegion_;
    }

    EventRegions&
    eventRegions()
    {
        return eventRegions_;
    }
    const EventRegions&
    eventRegions() const
    {
        return eventRegions_;
    }

    bool&
    useClipRect()
    {
        return useClipRect_;
    }
    const bool&
    useClipRect() const
    {
        return useClipRect_;
    }

    ParentLayerIntRect&
    clipRect()
    {
        return clipRect_;
    }
    const ParentLayerIntRect&
    clipRect() const
    {
        return clipRect_;
    }

    LayerHandle&
    maskLayer()
    {
        return maskLayer_;
    }
    const LayerHandle&
    maskLayer() const
    {
        return maskLayer_;
    }

    nsTArray<LayerHandle>&
    ancestorMaskLayers()
    {
        return ancestorMaskLayers_;
    }
    const nsTArray<LayerHandle>&
    ancestorMaskLayers() const
    {
        return ancestorMaskLayers_;
    }

    CompositorAnimations&
    compositorAnimations()
    {
        return compositorAnimations_;
    }
    const CompositorAnimations&
    compositorAnimations() const
    {
        return compositorAnimations_;
    }

    nsIntRegion&
    invalidRegion()
    {
        return invalidRegion_;
    }
    const nsIntRegion&
    invalidRegion() const
    {
        return invalidRegion_;
    }

    nsTArray<ScrollMetadata>&
    scrollMetadata()
    {
        return scrollMetadata_;
    }
    const nsTArray<ScrollMetadata>&
    scrollMetadata() const
    {
        return scrollMetadata_;
    }

    nsCString&
    displayListLog()
    {
        return displayListLog_;
    }
    const nsCString&
    displayListLog() const
    {
        return displayListLog_;
    }

private:
    LayerIntRegion visibleRegion_;
    EventRegions eventRegions_;
    bool useClipRect_;
    ParentLayerIntRect clipRect_;
    LayerHandle maskLayer_;
    CopyableTArray<LayerHandle> ancestorMaskLayers_;
    CompositorAnimations compositorAnimations_;
    nsIntRegion invalidRegion_;
    CopyableTArray<ScrollMetadata> scrollMetadata_;
    nsCString displayListLog_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::CommonLayerAttributes>
{
    typedef mozilla::layers::CommonLayerAttributes paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct PaintedLayerAttributes|
//
namespace mozilla {
namespace layers {
class PaintedLayerAttributes final
{
private:

public:
    MOZ_IMPLICIT PaintedLayerAttributes() :
        validRegion_()
    {
    }

    MOZ_IMPLICIT PaintedLayerAttributes(const nsIntRegion& _validRegion) :
        validRegion_(_validRegion)
    {
    }

    nsIntRegion&
    validRegion()
    {
        return validRegion_;
    }
    const nsIntRegion&
    validRegion() const
    {
        return validRegion_;
    }

private:
    nsIntRegion validRegion_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::PaintedLayerAttributes>
{
    typedef mozilla::layers::PaintedLayerAttributes paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ContainerLayerAttributes|
//
namespace mozilla {
namespace layers {
class ContainerLayerAttributes final
{
private:

public:
    MOZ_IMPLICIT ContainerLayerAttributes() :
        preXScale_(),
        preYScale_(),
        inheritedXScale_(),
        inheritedYScale_(),
        presShellResolution_()
    {
    }

    MOZ_IMPLICIT ContainerLayerAttributes(
            const float& _preXScale,
            const float& _preYScale,
            const float& _inheritedXScale,
            const float& _inheritedYScale,
            const float& _presShellResolution) :
        preXScale_(_preXScale),
        preYScale_(_preYScale),
        inheritedXScale_(_inheritedXScale),
        inheritedYScale_(_inheritedYScale),
        presShellResolution_(_presShellResolution)
    {
    }

    float&
    preXScale()
    {
        return preXScale_;
    }
    const float&
    preXScale() const
    {
        return preXScale_;
    }

    float&
    preYScale()
    {
        return preYScale_;
    }
    const float&
    preYScale() const
    {
        return preYScale_;
    }

    float&
    inheritedXScale()
    {
        return inheritedXScale_;
    }
    const float&
    inheritedXScale() const
    {
        return inheritedXScale_;
    }

    float&
    inheritedYScale()
    {
        return inheritedYScale_;
    }
    const float&
    inheritedYScale() const
    {
        return inheritedYScale_;
    }

    float&
    presShellResolution()
    {
        return presShellResolution_;
    }
    const float&
    presShellResolution() const
    {
        return presShellResolution_;
    }

private:
    void
    StaticAssertions() const;
    float preXScale_;
    float preYScale_;
    float inheritedXScale_;
    float inheritedYScale_;
    float presShellResolution_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::ContainerLayerAttributes>
{
    typedef mozilla::layers::ContainerLayerAttributes paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ColorLayerAttributes|
//
namespace mozilla {
namespace layers {
class ColorLayerAttributes final
{
private:
    typedef mozilla::layers::LayerColor LayerColor;
    typedef mozilla::gfx::IntRect IntRect;

public:
    MOZ_IMPLICIT ColorLayerAttributes() :
        color_(),
        bounds_()
    {
    }

    MOZ_IMPLICIT ColorLayerAttributes(
            const LayerColor& _color,
            const IntRect& _bounds) :
        color_(_color),
        bounds_(_bounds)
    {
    }

    LayerColor&
    color()
    {
        return color_;
    }
    const LayerColor&
    color() const
    {
        return color_;
    }

    IntRect&
    bounds()
    {
        return bounds_;
    }
    const IntRect&
    bounds() const
    {
        return bounds_;
    }

private:
    LayerColor color_;
    IntRect bounds_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::ColorLayerAttributes>
{
    typedef mozilla::layers::ColorLayerAttributes paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CanvasLayerAttributes|
//
namespace mozilla {
namespace layers {
class CanvasLayerAttributes final
{
private:
    typedef mozilla::gfx::SamplingFilter SamplingFilter;
    typedef mozilla::gfx::IntRect IntRect;

public:
    MOZ_IMPLICIT CanvasLayerAttributes() :
        samplingFilter_(),
        bounds_()
    {
    }

    MOZ_IMPLICIT CanvasLayerAttributes(
            const SamplingFilter& _samplingFilter,
            const IntRect& _bounds) :
        samplingFilter_(_samplingFilter),
        bounds_(_bounds)
    {
    }

    SamplingFilter&
    samplingFilter()
    {
        return samplingFilter_;
    }
    const SamplingFilter&
    samplingFilter() const
    {
        return samplingFilter_;
    }

    IntRect&
    bounds()
    {
        return bounds_;
    }
    const IntRect&
    bounds() const
    {
        return bounds_;
    }

private:
    SamplingFilter samplingFilter_;
    IntRect bounds_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::CanvasLayerAttributes>
{
    typedef mozilla::layers::CanvasLayerAttributes paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct RefLayerAttributes|
//
namespace mozilla {
namespace layers {
class RefLayerAttributes final
{
private:
    typedef mozilla::layers::LayersId LayersId;
    typedef mozilla::layers::EventRegionsOverride EventRegionsOverride;
    typedef mozilla::LayerIntSize LayerIntSize;

public:
    MOZ_IMPLICIT RefLayerAttributes() :
        id_(),
        eventRegionsOverride_(),
        remoteDocumentSize_()
    {
    }

    MOZ_IMPLICIT RefLayerAttributes(
            const LayersId& _id,
            const EventRegionsOverride& _eventRegionsOverride,
            const LayerIntSize& _remoteDocumentSize) :
        id_(_id),
        eventRegionsOverride_(_eventRegionsOverride),
        remoteDocumentSize_(_remoteDocumentSize)
    {
    }

    LayersId&
    id()
    {
        return id_;
    }
    const LayersId&
    id() const
    {
        return id_;
    }

    EventRegionsOverride&
    eventRegionsOverride()
    {
        return eventRegionsOverride_;
    }
    const EventRegionsOverride&
    eventRegionsOverride() const
    {
        return eventRegionsOverride_;
    }

    LayerIntSize&
    remoteDocumentSize()
    {
        return remoteDocumentSize_;
    }
    const LayerIntSize&
    remoteDocumentSize() const
    {
        return remoteDocumentSize_;
    }

private:
    LayersId id_;
    EventRegionsOverride eventRegionsOverride_;
    LayerIntSize remoteDocumentSize_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::RefLayerAttributes>
{
    typedef mozilla::layers::RefLayerAttributes paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ImageLayerAttributes|
//
namespace mozilla {
namespace layers {
class ImageLayerAttributes final
{
private:
    typedef mozilla::gfx::SamplingFilter SamplingFilter;
    typedef mozilla::gfx::IntSize IntSize;
    typedef mozilla::layers::ScaleMode ScaleMode;

public:
    MOZ_IMPLICIT ImageLayerAttributes() :
        samplingFilter_(),
        scaleToSize_(),
        scaleMode_()
    {
    }

    MOZ_IMPLICIT ImageLayerAttributes(
            const SamplingFilter& _samplingFilter,
            const IntSize& _scaleToSize,
            const ScaleMode& _scaleMode) :
        samplingFilter_(_samplingFilter),
        scaleToSize_(_scaleToSize),
        scaleMode_(_scaleMode)
    {
    }

    SamplingFilter&
    samplingFilter()
    {
        return samplingFilter_;
    }
    const SamplingFilter&
    samplingFilter() const
    {
        return samplingFilter_;
    }

    IntSize&
    scaleToSize()
    {
        return scaleToSize_;
    }
    const IntSize&
    scaleToSize() const
    {
        return scaleToSize_;
    }

    ScaleMode&
    scaleMode()
    {
        return scaleMode_;
    }
    const ScaleMode&
    scaleMode() const
    {
        return scaleMode_;
    }

private:
    SamplingFilter samplingFilter_;
    IntSize scaleToSize_;
    ScaleMode scaleMode_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::ImageLayerAttributes>
{
    typedef mozilla::layers::ImageLayerAttributes paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union SpecificLayerAttributes|
//
namespace mozilla {
namespace layers {
class SpecificLayerAttributes final
{
public:
    enum Type {
        T__None,
        Tnull_t = 1,
        TPaintedLayerAttributes,
        TContainerLayerAttributes,
        TColorLayerAttributes,
        TCanvasLayerAttributes,
        TRefLayerAttributes,
        TImageLayerAttributes,
        T__Last = TImageLayerAttributes
    };

private:
    typedef mozilla::null_t null_t;
    typedef mozilla::layers::PaintedLayerAttributes PaintedLayerAttributes;
    typedef mozilla::layers::ContainerLayerAttributes ContainerLayerAttributes;
    typedef mozilla::layers::ColorLayerAttributes ColorLayerAttributes;
    typedef mozilla::layers::CanvasLayerAttributes CanvasLayerAttributes;
    typedef mozilla::layers::RefLayerAttributes RefLayerAttributes;
    typedef mozilla::layers::ImageLayerAttributes ImageLayerAttributes;
    typedef null_t null_t__tdef;
    typedef PaintedLayerAttributes PaintedLayerAttributes__tdef;
    typedef ContainerLayerAttributes ContainerLayerAttributes__tdef;
    typedef ColorLayerAttributes ColorLayerAttributes__tdef;
    typedef CanvasLayerAttributes CanvasLayerAttributes__tdef;
    typedef RefLayerAttributes RefLayerAttributes__tdef;
    typedef ImageLayerAttributes ImageLayerAttributes__tdef;

    union Value {
        mozilla::AlignedStorage2<null_t> Vnull_t;
        mozilla::AlignedStorage2<PaintedLayerAttributes> VPaintedLayerAttributes;
        mozilla::AlignedStorage2<ContainerLayerAttributes> VContainerLayerAttributes;
        mozilla::AlignedStorage2<ColorLayerAttributes> VColorLayerAttributes;
        mozilla::AlignedStorage2<CanvasLayerAttributes> VCanvasLayerAttributes;
        mozilla::AlignedStorage2<RefLayerAttributes> VRefLayerAttributes;
        mozilla::AlignedStorage2<ImageLayerAttributes> VImageLayerAttributes;
    };

    null_t*
    ptr_null_t()
    {
        return ((mValue).Vnull_t).addr();
    }
    const null_t*
    constptr_null_t() const
    {
        return ((mValue).Vnull_t).addr();
    }
    PaintedLayerAttributes*
    ptr_PaintedLayerAttributes()
    {
        return ((mValue).VPaintedLayerAttributes).addr();
    }
    const PaintedLayerAttributes*
    constptr_PaintedLayerAttributes() const
    {
        return ((mValue).VPaintedLayerAttributes).addr();
    }
    ContainerLayerAttributes*
    ptr_ContainerLayerAttributes()
    {
        return ((mValue).VContainerLayerAttributes).addr();
    }
    const ContainerLayerAttributes*
    constptr_ContainerLayerAttributes() const
    {
        return ((mValue).VContainerLayerAttributes).addr();
    }
    ColorLayerAttributes*
    ptr_ColorLayerAttributes()
    {
        return ((mValue).VColorLayerAttributes).addr();
    }
    const ColorLayerAttributes*
    constptr_ColorLayerAttributes() const
    {
        return ((mValue).VColorLayerAttributes).addr();
    }
    CanvasLayerAttributes*
    ptr_CanvasLayerAttributes()
    {
        return ((mValue).VCanvasLayerAttributes).addr();
    }
    const CanvasLayerAttributes*
    constptr_CanvasLayerAttributes() const
    {
        return ((mValue).VCanvasLayerAttributes).addr();
    }
    RefLayerAttributes*
    ptr_RefLayerAttributes()
    {
        return ((mValue).VRefLayerAttributes).addr();
    }
    const RefLayerAttributes*
    constptr_RefLayerAttributes() const
    {
        return ((mValue).VRefLayerAttributes).addr();
    }
    ImageLayerAttributes*
    ptr_ImageLayerAttributes()
    {
        return ((mValue).VImageLayerAttributes).addr();
    }
    const ImageLayerAttributes*
    constptr_ImageLayerAttributes() const
    {
        return ((mValue).VImageLayerAttributes).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT SpecificLayerAttributes() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT SpecificLayerAttributes(const null_t& aOther);

    MOZ_IMPLICIT SpecificLayerAttributes(null_t&& aOther);

    MOZ_IMPLICIT SpecificLayerAttributes(const PaintedLayerAttributes& aOther);

    MOZ_IMPLICIT SpecificLayerAttributes(PaintedLayerAttributes&& aOther);

    MOZ_IMPLICIT SpecificLayerAttributes(const ContainerLayerAttributes& aOther);

    MOZ_IMPLICIT SpecificLayerAttributes(ContainerLayerAttributes&& aOther);

    MOZ_IMPLICIT SpecificLayerAttributes(const ColorLayerAttributes& aOther);

    MOZ_IMPLICIT SpecificLayerAttributes(ColorLayerAttributes&& aOther);

    MOZ_IMPLICIT SpecificLayerAttributes(const CanvasLayerAttributes& aOther);

    MOZ_IMPLICIT SpecificLayerAttributes(CanvasLayerAttributes&& aOther);

    MOZ_IMPLICIT SpecificLayerAttributes(const RefLayerAttributes& aOther);

    MOZ_IMPLICIT SpecificLayerAttributes(RefLayerAttributes&& aOther);

    MOZ_IMPLICIT SpecificLayerAttributes(const ImageLayerAttributes& aOther);

    MOZ_IMPLICIT SpecificLayerAttributes(ImageLayerAttributes&& aOther);

    MOZ_IMPLICIT SpecificLayerAttributes(const SpecificLayerAttributes& aOther);

    MOZ_IMPLICIT SpecificLayerAttributes(SpecificLayerAttributes&& aOther);

    ~SpecificLayerAttributes();

    Type
    type() const
    {
        return mType;
    }

    SpecificLayerAttributes&
    operator=(const null_t& aRhs);

    SpecificLayerAttributes&
    operator=(null_t&& aRhs);

    SpecificLayerAttributes&
    operator=(const PaintedLayerAttributes& aRhs);

    SpecificLayerAttributes&
    operator=(PaintedLayerAttributes&& aRhs);

    SpecificLayerAttributes&
    operator=(const ContainerLayerAttributes& aRhs);

    SpecificLayerAttributes&
    operator=(ContainerLayerAttributes&& aRhs);

    SpecificLayerAttributes&
    operator=(const ColorLayerAttributes& aRhs);

    SpecificLayerAttributes&
    operator=(ColorLayerAttributes&& aRhs);

    SpecificLayerAttributes&
    operator=(const CanvasLayerAttributes& aRhs);

    SpecificLayerAttributes&
    operator=(CanvasLayerAttributes&& aRhs);

    SpecificLayerAttributes&
    operator=(const RefLayerAttributes& aRhs);

    SpecificLayerAttributes&
    operator=(RefLayerAttributes&& aRhs);

    SpecificLayerAttributes&
    operator=(const ImageLayerAttributes& aRhs);

    SpecificLayerAttributes&
    operator=(ImageLayerAttributes&& aRhs);

    SpecificLayerAttributes&
    operator=(const SpecificLayerAttributes& aRhs);

    SpecificLayerAttributes&
    operator=(SpecificLayerAttributes&& aRhs);

    null_t&
    get_null_t()
    {
        AssertSanity(Tnull_t);
        return (*(ptr_null_t()));
    }
    const null_t&
    get_null_t() const
    {
        AssertSanity(Tnull_t);
        return (*(constptr_null_t()));
    }
    operator null_t&()
    {
        return get_null_t();
    }
    operator const null_t&() const
    {
        return get_null_t();
    }

    PaintedLayerAttributes&
    get_PaintedLayerAttributes()
    {
        AssertSanity(TPaintedLayerAttributes);
        return (*(ptr_PaintedLayerAttributes()));
    }
    const PaintedLayerAttributes&
    get_PaintedLayerAttributes() const
    {
        AssertSanity(TPaintedLayerAttributes);
        return (*(constptr_PaintedLayerAttributes()));
    }
    operator PaintedLayerAttributes&()
    {
        return get_PaintedLayerAttributes();
    }
    operator const PaintedLayerAttributes&() const
    {
        return get_PaintedLayerAttributes();
    }

    ContainerLayerAttributes&
    get_ContainerLayerAttributes()
    {
        AssertSanity(TContainerLayerAttributes);
        return (*(ptr_ContainerLayerAttributes()));
    }
    const ContainerLayerAttributes&
    get_ContainerLayerAttributes() const
    {
        AssertSanity(TContainerLayerAttributes);
        return (*(constptr_ContainerLayerAttributes()));
    }
    operator ContainerLayerAttributes&()
    {
        return get_ContainerLayerAttributes();
    }
    operator const ContainerLayerAttributes&() const
    {
        return get_ContainerLayerAttributes();
    }

    ColorLayerAttributes&
    get_ColorLayerAttributes()
    {
        AssertSanity(TColorLayerAttributes);
        return (*(ptr_ColorLayerAttributes()));
    }
    const ColorLayerAttributes&
    get_ColorLayerAttributes() const
    {
        AssertSanity(TColorLayerAttributes);
        return (*(constptr_ColorLayerAttributes()));
    }
    operator ColorLayerAttributes&()
    {
        return get_ColorLayerAttributes();
    }
    operator const ColorLayerAttributes&() const
    {
        return get_ColorLayerAttributes();
    }

    CanvasLayerAttributes&
    get_CanvasLayerAttributes()
    {
        AssertSanity(TCanvasLayerAttributes);
        return (*(ptr_CanvasLayerAttributes()));
    }
    const CanvasLayerAttributes&
    get_CanvasLayerAttributes() const
    {
        AssertSanity(TCanvasLayerAttributes);
        return (*(constptr_CanvasLayerAttributes()));
    }
    operator CanvasLayerAttributes&()
    {
        return get_CanvasLayerAttributes();
    }
    operator const CanvasLayerAttributes&() const
    {
        return get_CanvasLayerAttributes();
    }

    RefLayerAttributes&
    get_RefLayerAttributes()
    {
        AssertSanity(TRefLayerAttributes);
        return (*(ptr_RefLayerAttributes()));
    }
    const RefLayerAttributes&
    get_RefLayerAttributes() const
    {
        AssertSanity(TRefLayerAttributes);
        return (*(constptr_RefLayerAttributes()));
    }
    operator RefLayerAttributes&()
    {
        return get_RefLayerAttributes();
    }
    operator const RefLayerAttributes&() const
    {
        return get_RefLayerAttributes();
    }

    ImageLayerAttributes&
    get_ImageLayerAttributes()
    {
        AssertSanity(TImageLayerAttributes);
        return (*(ptr_ImageLayerAttributes()));
    }
    const ImageLayerAttributes&
    get_ImageLayerAttributes() const
    {
        AssertSanity(TImageLayerAttributes);
        return (*(constptr_ImageLayerAttributes()));
    }
    operator ImageLayerAttributes&()
    {
        return get_ImageLayerAttributes();
    }
    operator const ImageLayerAttributes&() const
    {
        return get_ImageLayerAttributes();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::SpecificLayerAttributes>
{
    typedef mozilla::layers::SpecificLayerAttributes paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct LayerAttributes|
//
namespace mozilla {
namespace layers {
class LayerAttributes final
{
private:
    typedef mozilla::layers::CommonLayerAttributes CommonLayerAttributes;
    typedef mozilla::layers::SpecificLayerAttributes SpecificLayerAttributes;

public:
    MOZ_IMPLICIT LayerAttributes() :
        common_(),
        specific_()
    {
    }

    MOZ_IMPLICIT LayerAttributes(
            const CommonLayerAttributes& _common,
            const SpecificLayerAttributes& _specific) :
        common_(_common),
        specific_(_specific)
    {
    }

    CommonLayerAttributes&
    common()
    {
        return common_;
    }
    const CommonLayerAttributes&
    common() const
    {
        return common_;
    }

    SpecificLayerAttributes&
    specific()
    {
        return specific_;
    }
    const SpecificLayerAttributes&
    specific() const
    {
        return specific_;
    }

private:
    CommonLayerAttributes common_;
    SpecificLayerAttributes specific_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::LayerAttributes>
{
    typedef mozilla::layers::LayerAttributes paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct PluginWindowData|
//
namespace mozilla {
namespace layers {
class PluginWindowData final
{
private:
    typedef mozilla::LayoutDeviceIntRect LayoutDeviceIntRect;

public:
    MOZ_IMPLICIT PluginWindowData() :
        windowId_(),
        clip_(),
        bounds_(),
        visible_()
    {
    }

    MOZ_IMPLICIT PluginWindowData(
            const uintptr_t& _windowId,
            const nsTArray<LayoutDeviceIntRect>& _clip,
            const LayoutDeviceIntRect& _bounds,
            const bool& _visible) :
        windowId_(_windowId),
        clip_(_clip),
        bounds_(_bounds),
        visible_(_visible)
    {
    }

    bool
    operator==(const PluginWindowData& _o) const;

    bool
    operator!=(const PluginWindowData& _o) const;

    uintptr_t&
    windowId()
    {
        return windowId_;
    }
    const uintptr_t&
    windowId() const
    {
        return windowId_;
    }

    nsTArray<LayoutDeviceIntRect>&
    clip()
    {
        return clip_;
    }
    const nsTArray<LayoutDeviceIntRect>&
    clip() const
    {
        return clip_;
    }

    LayoutDeviceIntRect&
    bounds()
    {
        return bounds_;
    }
    const LayoutDeviceIntRect&
    bounds() const
    {
        return bounds_;
    }

    bool&
    visible()
    {
        return visible_;
    }
    const bool&
    visible() const
    {
        return visible_;
    }

private:
    uintptr_t windowId_;
    CopyableTArray<LayoutDeviceIntRect> clip_;
    LayoutDeviceIntRect bounds_;
    bool visible_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::PluginWindowData>
{
    typedef mozilla::layers::PluginWindowData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpSetSimpleLayerAttributes|
//
namespace mozilla {
namespace layers {
class OpSetSimpleLayerAttributes final
{
private:
    typedef mozilla::layers::LayerHandle LayerHandle;
    typedef mozilla::layers::SimpleLayerAttributes SimpleLayerAttributes;

public:
    MOZ_IMPLICIT OpSetSimpleLayerAttributes() :
        layer_(),
        attrs_()
    {
    }

    MOZ_IMPLICIT OpSetSimpleLayerAttributes(
            const LayerHandle& _layer,
            const SimpleLayerAttributes& _attrs) :
        layer_(_layer),
        attrs_(_attrs)
    {
    }

    LayerHandle&
    layer()
    {
        return layer_;
    }
    const LayerHandle&
    layer() const
    {
        return layer_;
    }

    SimpleLayerAttributes&
    attrs()
    {
        return attrs_;
    }
    const SimpleLayerAttributes&
    attrs() const
    {
        return attrs_;
    }

private:
    LayerHandle layer_;
    SimpleLayerAttributes attrs_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpSetSimpleLayerAttributes>
{
    typedef mozilla::layers::OpSetSimpleLayerAttributes paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpSetLayerAttributes|
//
namespace mozilla {
namespace layers {
class OpSetLayerAttributes final
{
private:
    typedef mozilla::layers::LayerHandle LayerHandle;
    typedef mozilla::layers::LayerAttributes LayerAttributes;

public:
    MOZ_IMPLICIT OpSetLayerAttributes() :
        layer_(),
        attrs_()
    {
    }

    MOZ_IMPLICIT OpSetLayerAttributes(
            const LayerHandle& _layer,
            const LayerAttributes& _attrs) :
        layer_(_layer),
        attrs_(_attrs)
    {
    }

    LayerHandle&
    layer()
    {
        return layer_;
    }
    const LayerHandle&
    layer() const
    {
        return layer_;
    }

    LayerAttributes&
    attrs()
    {
        return attrs_;
    }
    const LayerAttributes&
    attrs() const
    {
        return attrs_;
    }

private:
    LayerHandle layer_;
    LayerAttributes attrs_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpSetLayerAttributes>
{
    typedef mozilla::layers::OpSetLayerAttributes paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpSetRoot|
//
namespace mozilla {
namespace layers {
class OpSetRoot final
{
private:
    typedef mozilla::layers::LayerHandle LayerHandle;

public:
    MOZ_IMPLICIT OpSetRoot() :
        root_()
    {
    }

    MOZ_IMPLICIT OpSetRoot(const LayerHandle& _root) :
        root_(_root)
    {
    }

    LayerHandle&
    root()
    {
        return root_;
    }
    const LayerHandle&
    root() const
    {
        return root_;
    }

private:
    LayerHandle root_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpSetRoot>
{
    typedef mozilla::layers::OpSetRoot paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpInsertAfter|
//
namespace mozilla {
namespace layers {
class OpInsertAfter final
{
private:
    typedef mozilla::layers::LayerHandle LayerHandle;

public:
    MOZ_IMPLICIT OpInsertAfter() :
        container_(),
        childLayer_(),
        after_()
    {
    }

    MOZ_IMPLICIT OpInsertAfter(
            const LayerHandle& _container,
            const LayerHandle& _childLayer,
            const LayerHandle& _after) :
        container_(_container),
        childLayer_(_childLayer),
        after_(_after)
    {
    }

    LayerHandle&
    container()
    {
        return container_;
    }
    const LayerHandle&
    container() const
    {
        return container_;
    }

    LayerHandle&
    childLayer()
    {
        return childLayer_;
    }
    const LayerHandle&
    childLayer() const
    {
        return childLayer_;
    }

    LayerHandle&
    after()
    {
        return after_;
    }
    const LayerHandle&
    after() const
    {
        return after_;
    }

private:
    LayerHandle container_;
    LayerHandle childLayer_;
    LayerHandle after_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpInsertAfter>
{
    typedef mozilla::layers::OpInsertAfter paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpPrependChild|
//
namespace mozilla {
namespace layers {
class OpPrependChild final
{
private:
    typedef mozilla::layers::LayerHandle LayerHandle;

public:
    MOZ_IMPLICIT OpPrependChild() :
        container_(),
        childLayer_()
    {
    }

    MOZ_IMPLICIT OpPrependChild(
            const LayerHandle& _container,
            const LayerHandle& _childLayer) :
        container_(_container),
        childLayer_(_childLayer)
    {
    }

    LayerHandle&
    container()
    {
        return container_;
    }
    const LayerHandle&
    container() const
    {
        return container_;
    }

    LayerHandle&
    childLayer()
    {
        return childLayer_;
    }
    const LayerHandle&
    childLayer() const
    {
        return childLayer_;
    }

private:
    LayerHandle container_;
    LayerHandle childLayer_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpPrependChild>
{
    typedef mozilla::layers::OpPrependChild paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpRemoveChild|
//
namespace mozilla {
namespace layers {
class OpRemoveChild final
{
private:
    typedef mozilla::layers::LayerHandle LayerHandle;

public:
    MOZ_IMPLICIT OpRemoveChild() :
        container_(),
        childLayer_()
    {
    }

    MOZ_IMPLICIT OpRemoveChild(
            const LayerHandle& _container,
            const LayerHandle& _childLayer) :
        container_(_container),
        childLayer_(_childLayer)
    {
    }

    LayerHandle&
    container()
    {
        return container_;
    }
    const LayerHandle&
    container() const
    {
        return container_;
    }

    LayerHandle&
    childLayer()
    {
        return childLayer_;
    }
    const LayerHandle&
    childLayer() const
    {
        return childLayer_;
    }

private:
    LayerHandle container_;
    LayerHandle childLayer_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpRemoveChild>
{
    typedef mozilla::layers::OpRemoveChild paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpRepositionChild|
//
namespace mozilla {
namespace layers {
class OpRepositionChild final
{
private:
    typedef mozilla::layers::LayerHandle LayerHandle;

public:
    MOZ_IMPLICIT OpRepositionChild() :
        container_(),
        childLayer_(),
        after_()
    {
    }

    MOZ_IMPLICIT OpRepositionChild(
            const LayerHandle& _container,
            const LayerHandle& _childLayer,
            const LayerHandle& _after) :
        container_(_container),
        childLayer_(_childLayer),
        after_(_after)
    {
    }

    LayerHandle&
    container()
    {
        return container_;
    }
    const LayerHandle&
    container() const
    {
        return container_;
    }

    LayerHandle&
    childLayer()
    {
        return childLayer_;
    }
    const LayerHandle&
    childLayer() const
    {
        return childLayer_;
    }

    LayerHandle&
    after()
    {
        return after_;
    }
    const LayerHandle&
    after() const
    {
        return after_;
    }

private:
    LayerHandle container_;
    LayerHandle childLayer_;
    LayerHandle after_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpRepositionChild>
{
    typedef mozilla::layers::OpRepositionChild paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpRaiseToTopChild|
//
namespace mozilla {
namespace layers {
class OpRaiseToTopChild final
{
private:
    typedef mozilla::layers::LayerHandle LayerHandle;

public:
    MOZ_IMPLICIT OpRaiseToTopChild() :
        container_(),
        childLayer_()
    {
    }

    MOZ_IMPLICIT OpRaiseToTopChild(
            const LayerHandle& _container,
            const LayerHandle& _childLayer) :
        container_(_container),
        childLayer_(_childLayer)
    {
    }

    LayerHandle&
    container()
    {
        return container_;
    }
    const LayerHandle&
    container() const
    {
        return container_;
    }

    LayerHandle&
    childLayer()
    {
        return childLayer_;
    }
    const LayerHandle&
    childLayer() const
    {
        return childLayer_;
    }

private:
    LayerHandle container_;
    LayerHandle childLayer_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpRaiseToTopChild>
{
    typedef mozilla::layers::OpRaiseToTopChild paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpSetDiagnosticTypes|
//
namespace mozilla {
namespace layers {
class OpSetDiagnosticTypes final
{
private:
    typedef mozilla::layers::DiagnosticTypes DiagnosticTypes;

public:
    MOZ_IMPLICIT OpSetDiagnosticTypes() :
        diagnostics_()
    {
    }

    MOZ_IMPLICIT OpSetDiagnosticTypes(const DiagnosticTypes& _diagnostics) :
        diagnostics_(_diagnostics)
    {
    }

    DiagnosticTypes&
    diagnostics()
    {
        return diagnostics_;
    }
    const DiagnosticTypes&
    diagnostics() const
    {
        return diagnostics_;
    }

private:
    DiagnosticTypes diagnostics_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpSetDiagnosticTypes>
{
    typedef mozilla::layers::OpSetDiagnosticTypes paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ShmemSection|
//
namespace mozilla {
namespace layers {
class ShmemSection final
{
private:
    typedef mozilla::ipc::Shmem Shmem;

public:
    MOZ_IMPLICIT ShmemSection() :
        shmem_(),
        offset_(),
        size_()
    {
    }

    MOZ_IMPLICIT ShmemSection(
            Shmem&& _shmem,
            const uint32_t& _offset,
            const uint32_t& _size) :
        shmem_(_shmem),
        offset_(_offset),
        size_(_size)
    {
    }

    Shmem&
    shmem()
    {
        return shmem_;
    }
    Shmem&
    shmem() const
    {
        return const_cast<Shmem&>(shmem_);
    }

    uint32_t&
    offset()
    {
        return offset_;
    }
    const uint32_t&
    offset() const
    {
        return offset_;
    }

    uint32_t&
    size()
    {
        return size_;
    }
    const uint32_t&
    size() const
    {
        return size_;
    }

private:
    void
    StaticAssertions() const;
    Shmem shmem_;
    uint32_t offset_;
    uint32_t size_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::ShmemSection>
{
    typedef mozilla::layers::ShmemSection paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CrossProcessSemaphoreDescriptor|
//
namespace mozilla {
namespace layers {
class CrossProcessSemaphoreDescriptor final
{
private:
    typedef mozilla::CrossProcessSemaphoreHandle CrossProcessSemaphoreHandle;

public:
    MOZ_IMPLICIT CrossProcessSemaphoreDescriptor() :
        sem_()
    {
    }

    MOZ_IMPLICIT CrossProcessSemaphoreDescriptor(const CrossProcessSemaphoreHandle& _sem) :
        sem_(_sem)
    {
    }

    CrossProcessSemaphoreHandle&
    sem()
    {
        return sem_;
    }
    const CrossProcessSemaphoreHandle&
    sem() const
    {
        return sem_;
    }

private:
    CrossProcessSemaphoreHandle sem_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::CrossProcessSemaphoreDescriptor>
{
    typedef mozilla::layers::CrossProcessSemaphoreDescriptor paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union ReadLockDescriptor|
//
namespace mozilla {
namespace layers {
class ReadLockDescriptor final
{
public:
    enum Type {
        T__None,
        TShmemSection = 1,
        TCrossProcessSemaphoreDescriptor,
        Tuintptr_t,
        Tnull_t,
        T__Last = Tnull_t
    };

private:
    typedef mozilla::layers::ShmemSection ShmemSection;
    typedef mozilla::layers::CrossProcessSemaphoreDescriptor CrossProcessSemaphoreDescriptor;
    typedef mozilla::null_t null_t;
    typedef ShmemSection ShmemSection__tdef;
    typedef CrossProcessSemaphoreDescriptor CrossProcessSemaphoreDescriptor__tdef;
    typedef uintptr_t uintptr_t__tdef;
    typedef null_t null_t__tdef;

    union Value {
        mozilla::AlignedStorage2<ShmemSection> VShmemSection;
        mozilla::AlignedStorage2<CrossProcessSemaphoreDescriptor> VCrossProcessSemaphoreDescriptor;
        mozilla::AlignedStorage2<uintptr_t> Vuintptr_t;
        mozilla::AlignedStorage2<null_t> Vnull_t;
    };

    ShmemSection*
    ptr_ShmemSection()
    {
        return ((mValue).VShmemSection).addr();
    }
    const ShmemSection*
    constptr_ShmemSection() const
    {
        return ((mValue).VShmemSection).addr();
    }
    CrossProcessSemaphoreDescriptor*
    ptr_CrossProcessSemaphoreDescriptor()
    {
        return ((mValue).VCrossProcessSemaphoreDescriptor).addr();
    }
    const CrossProcessSemaphoreDescriptor*
    constptr_CrossProcessSemaphoreDescriptor() const
    {
        return ((mValue).VCrossProcessSemaphoreDescriptor).addr();
    }
    uintptr_t*
    ptr_uintptr_t()
    {
        return ((mValue).Vuintptr_t).addr();
    }
    const uintptr_t*
    constptr_uintptr_t() const
    {
        return ((mValue).Vuintptr_t).addr();
    }
    null_t*
    ptr_null_t()
    {
        return ((mValue).Vnull_t).addr();
    }
    const null_t*
    constptr_null_t() const
    {
        return ((mValue).Vnull_t).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT ReadLockDescriptor() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT ReadLockDescriptor(const ShmemSection& aOther);

    MOZ_IMPLICIT ReadLockDescriptor(ShmemSection&& aOther);

    MOZ_IMPLICIT ReadLockDescriptor(const CrossProcessSemaphoreDescriptor& aOther);

    MOZ_IMPLICIT ReadLockDescriptor(CrossProcessSemaphoreDescriptor&& aOther);

    MOZ_IMPLICIT ReadLockDescriptor(const uintptr_t& aOther);

    MOZ_IMPLICIT ReadLockDescriptor(uintptr_t&& aOther);

    MOZ_IMPLICIT ReadLockDescriptor(const null_t& aOther);

    MOZ_IMPLICIT ReadLockDescriptor(null_t&& aOther);

    MOZ_IMPLICIT ReadLockDescriptor(const ReadLockDescriptor& aOther);

    MOZ_IMPLICIT ReadLockDescriptor(ReadLockDescriptor&& aOther);

    ~ReadLockDescriptor();

    Type
    type() const
    {
        return mType;
    }

    ReadLockDescriptor&
    operator=(const ShmemSection& aRhs);

    ReadLockDescriptor&
    operator=(ShmemSection&& aRhs);

    ReadLockDescriptor&
    operator=(const CrossProcessSemaphoreDescriptor& aRhs);

    ReadLockDescriptor&
    operator=(CrossProcessSemaphoreDescriptor&& aRhs);

    ReadLockDescriptor&
    operator=(const uintptr_t& aRhs);

    ReadLockDescriptor&
    operator=(uintptr_t&& aRhs);

    ReadLockDescriptor&
    operator=(const null_t& aRhs);

    ReadLockDescriptor&
    operator=(null_t&& aRhs);

    ReadLockDescriptor&
    operator=(const ReadLockDescriptor& aRhs);

    ReadLockDescriptor&
    operator=(ReadLockDescriptor&& aRhs);

    ShmemSection&
    get_ShmemSection()
    {
        AssertSanity(TShmemSection);
        return (*(ptr_ShmemSection()));
    }
    const ShmemSection&
    get_ShmemSection() const
    {
        AssertSanity(TShmemSection);
        return (*(constptr_ShmemSection()));
    }
    operator ShmemSection&()
    {
        return get_ShmemSection();
    }
    operator const ShmemSection&() const
    {
        return get_ShmemSection();
    }

    CrossProcessSemaphoreDescriptor&
    get_CrossProcessSemaphoreDescriptor()
    {
        AssertSanity(TCrossProcessSemaphoreDescriptor);
        return (*(ptr_CrossProcessSemaphoreDescriptor()));
    }
    const CrossProcessSemaphoreDescriptor&
    get_CrossProcessSemaphoreDescriptor() const
    {
        AssertSanity(TCrossProcessSemaphoreDescriptor);
        return (*(constptr_CrossProcessSemaphoreDescriptor()));
    }
    operator CrossProcessSemaphoreDescriptor&()
    {
        return get_CrossProcessSemaphoreDescriptor();
    }
    operator const CrossProcessSemaphoreDescriptor&() const
    {
        return get_CrossProcessSemaphoreDescriptor();
    }

    uintptr_t&
    get_uintptr_t()
    {
        AssertSanity(Tuintptr_t);
        return (*(ptr_uintptr_t()));
    }
    const uintptr_t&
    get_uintptr_t() const
    {
        AssertSanity(Tuintptr_t);
        return (*(constptr_uintptr_t()));
    }
    operator uintptr_t&()
    {
        return get_uintptr_t();
    }
    operator const uintptr_t&() const
    {
        return get_uintptr_t();
    }

    null_t&
    get_null_t()
    {
        AssertSanity(Tnull_t);
        return (*(ptr_null_t()));
    }
    const null_t&
    get_null_t() const
    {
        AssertSanity(Tnull_t);
        return (*(constptr_null_t()));
    }
    operator null_t&()
    {
        return get_null_t();
    }
    operator const null_t&() const
    {
        return get_null_t();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::ReadLockDescriptor>
{
    typedef mozilla::layers::ReadLockDescriptor paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace layers {
class PTextureParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PTextureChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct TexturedTileDescriptor|
//
namespace mozilla {
namespace layers {
class TexturedTileDescriptor final
{
private:
    typedef mozilla::layers::PTextureParent PTextureParent;
    typedef mozilla::layers::PTextureChild PTextureChild;
    typedef mozilla::gfx::IntRect IntRect;

public:
    MOZ_IMPLICIT TexturedTileDescriptor() :
        textureParent_(),
        textureChild_(),
        textureOnWhiteParent_(),
        textureOnWhiteChild_(),
        updateRect_(),
        readLocked_(),
        readLockedOnWhite_(),
        wasPlaceholder_()
    {
    }

    MOZ_IMPLICIT TexturedTileDescriptor(
            PTextureParent* _textureParent,
            PTextureChild* _textureChild,
            const mozilla::Maybe<PTextureParent*>& _textureOnWhiteParent,
            const mozilla::Maybe<PTextureChild*>& _textureOnWhiteChild,
            const IntRect& _updateRect,
            const bool& _readLocked,
            const bool& _readLockedOnWhite,
            const bool& _wasPlaceholder) :
        textureParent_(_textureParent),
        textureChild_(_textureChild),
        textureOnWhiteParent_(_textureOnWhiteParent),
        textureOnWhiteChild_(_textureOnWhiteChild),
        updateRect_(_updateRect),
        readLocked_(_readLocked),
        readLockedOnWhite_(_readLockedOnWhite),
        wasPlaceholder_(_wasPlaceholder)
    {
    }

    PTextureParent*&
    textureParent()
    {
        return textureParent_;
    }
    PTextureParent*
    textureParent() const
    {
        return textureParent_;
    }

    PTextureChild*&
    textureChild()
    {
        return textureChild_;
    }
    PTextureChild*
    textureChild() const
    {
        return textureChild_;
    }

    mozilla::Maybe<PTextureParent*>&
    textureOnWhiteParent()
    {
        return textureOnWhiteParent_;
    }
    const mozilla::Maybe<PTextureParent*>&
    textureOnWhiteParent() const
    {
        return textureOnWhiteParent_;
    }

    mozilla::Maybe<PTextureChild*>&
    textureOnWhiteChild()
    {
        return textureOnWhiteChild_;
    }
    const mozilla::Maybe<PTextureChild*>&
    textureOnWhiteChild() const
    {
        return textureOnWhiteChild_;
    }

    IntRect&
    updateRect()
    {
        return updateRect_;
    }
    const IntRect&
    updateRect() const
    {
        return updateRect_;
    }

    bool&
    readLocked()
    {
        return readLocked_;
    }
    const bool&
    readLocked() const
    {
        return readLocked_;
    }

    bool&
    readLockedOnWhite()
    {
        return readLockedOnWhite_;
    }
    const bool&
    readLockedOnWhite() const
    {
        return readLockedOnWhite_;
    }

    bool&
    wasPlaceholder()
    {
        return wasPlaceholder_;
    }
    const bool&
    wasPlaceholder() const
    {
        return wasPlaceholder_;
    }

private:
    PTextureParent* textureParent_;
    PTextureChild* textureChild_;
    mozilla::Maybe<PTextureParent*> textureOnWhiteParent_;
    mozilla::Maybe<PTextureChild*> textureOnWhiteChild_;
    IntRect updateRect_;
    bool readLocked_;
    bool readLockedOnWhite_;
    bool wasPlaceholder_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::TexturedTileDescriptor>
{
    typedef mozilla::layers::TexturedTileDescriptor paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct PlaceholderTileDescriptor|
//
namespace mozilla {
namespace layers {
class PlaceholderTileDescriptor final
{
private:

public:
    MOZ_IMPLICIT PlaceholderTileDescriptor()
    {
    }

private:
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::PlaceholderTileDescriptor>
{
    typedef mozilla::layers::PlaceholderTileDescriptor paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union TileDescriptor|
//
namespace mozilla {
namespace layers {
class TileDescriptor final
{
public:
    enum Type {
        T__None,
        TTexturedTileDescriptor = 1,
        TPlaceholderTileDescriptor,
        T__Last = TPlaceholderTileDescriptor
    };

private:
    typedef mozilla::layers::TexturedTileDescriptor TexturedTileDescriptor;
    typedef mozilla::layers::PlaceholderTileDescriptor PlaceholderTileDescriptor;
    typedef TexturedTileDescriptor TexturedTileDescriptor__tdef;
    typedef PlaceholderTileDescriptor PlaceholderTileDescriptor__tdef;

    union Value {
        mozilla::AlignedStorage2<TexturedTileDescriptor> VTexturedTileDescriptor;
        mozilla::AlignedStorage2<PlaceholderTileDescriptor> VPlaceholderTileDescriptor;
    };

    TexturedTileDescriptor*
    ptr_TexturedTileDescriptor()
    {
        return ((mValue).VTexturedTileDescriptor).addr();
    }
    const TexturedTileDescriptor*
    constptr_TexturedTileDescriptor() const
    {
        return ((mValue).VTexturedTileDescriptor).addr();
    }
    PlaceholderTileDescriptor*
    ptr_PlaceholderTileDescriptor()
    {
        return ((mValue).VPlaceholderTileDescriptor).addr();
    }
    const PlaceholderTileDescriptor*
    constptr_PlaceholderTileDescriptor() const
    {
        return ((mValue).VPlaceholderTileDescriptor).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT TileDescriptor() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT TileDescriptor(const TexturedTileDescriptor& aOther);

    MOZ_IMPLICIT TileDescriptor(TexturedTileDescriptor&& aOther);

    MOZ_IMPLICIT TileDescriptor(const PlaceholderTileDescriptor& aOther);

    MOZ_IMPLICIT TileDescriptor(PlaceholderTileDescriptor&& aOther);

    MOZ_IMPLICIT TileDescriptor(const TileDescriptor& aOther);

    MOZ_IMPLICIT TileDescriptor(TileDescriptor&& aOther);

    ~TileDescriptor();

    Type
    type() const
    {
        return mType;
    }

    TileDescriptor&
    operator=(const TexturedTileDescriptor& aRhs);

    TileDescriptor&
    operator=(TexturedTileDescriptor&& aRhs);

    TileDescriptor&
    operator=(const PlaceholderTileDescriptor& aRhs);

    TileDescriptor&
    operator=(PlaceholderTileDescriptor&& aRhs);

    TileDescriptor&
    operator=(const TileDescriptor& aRhs);

    TileDescriptor&
    operator=(TileDescriptor&& aRhs);

    TexturedTileDescriptor&
    get_TexturedTileDescriptor()
    {
        AssertSanity(TTexturedTileDescriptor);
        return (*(ptr_TexturedTileDescriptor()));
    }
    const TexturedTileDescriptor&
    get_TexturedTileDescriptor() const
    {
        AssertSanity(TTexturedTileDescriptor);
        return (*(constptr_TexturedTileDescriptor()));
    }
    operator TexturedTileDescriptor&()
    {
        return get_TexturedTileDescriptor();
    }
    operator const TexturedTileDescriptor&() const
    {
        return get_TexturedTileDescriptor();
    }

    PlaceholderTileDescriptor&
    get_PlaceholderTileDescriptor()
    {
        AssertSanity(TPlaceholderTileDescriptor);
        return (*(ptr_PlaceholderTileDescriptor()));
    }
    const PlaceholderTileDescriptor&
    get_PlaceholderTileDescriptor() const
    {
        AssertSanity(TPlaceholderTileDescriptor);
        return (*(constptr_PlaceholderTileDescriptor()));
    }
    operator PlaceholderTileDescriptor&()
    {
        return get_PlaceholderTileDescriptor();
    }
    operator const PlaceholderTileDescriptor&() const
    {
        return get_PlaceholderTileDescriptor();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::TileDescriptor>
{
    typedef mozilla::layers::TileDescriptor paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SurfaceDescriptorTiles|
//
namespace mozilla {
namespace layers {
class SurfaceDescriptorTiles final
{
private:
    typedef mozilla::layers::TileDescriptor TileDescriptor;
    typedef mozilla::gfx::IntPoint IntPoint;
    typedef mozilla::gfx::IntSize IntSize;

public:
    MOZ_IMPLICIT SurfaceDescriptorTiles() :
        validRegion_(),
        tiles_(),
        tileOrigin_(),
        tileSize_(),
        firstTileX_(),
        firstTileY_(),
        retainedWidth_(),
        retainedHeight_(),
        isProgressive_(),
        resolution_(),
        frameXResolution_(),
        frameYResolution_()
    {
    }

    MOZ_IMPLICIT SurfaceDescriptorTiles(
            const nsIntRegion& _validRegion,
            const nsTArray<TileDescriptor>& _tiles,
            const IntPoint& _tileOrigin,
            const IntSize& _tileSize,
            const int& _firstTileX,
            const int& _firstTileY,
            const int& _retainedWidth,
            const int& _retainedHeight,
            const float& _resolution,
            const float& _frameXResolution,
            const float& _frameYResolution,
            const bool& _isProgressive) :
        validRegion_(_validRegion),
        tiles_(_tiles),
        tileOrigin_(_tileOrigin),
        tileSize_(_tileSize),
        firstTileX_(_firstTileX),
        firstTileY_(_firstTileY),
        retainedWidth_(_retainedWidth),
        retainedHeight_(_retainedHeight),
        isProgressive_(_isProgressive),
        resolution_(_resolution),
        frameXResolution_(_frameXResolution),
        frameYResolution_(_frameYResolution)
    {
    }

    nsIntRegion&
    validRegion()
    {
        return validRegion_;
    }
    const nsIntRegion&
    validRegion() const
    {
        return validRegion_;
    }

    nsTArray<TileDescriptor>&
    tiles()
    {
        return tiles_;
    }
    const nsTArray<TileDescriptor>&
    tiles() const
    {
        return tiles_;
    }

    IntPoint&
    tileOrigin()
    {
        return tileOrigin_;
    }
    const IntPoint&
    tileOrigin() const
    {
        return tileOrigin_;
    }

    IntSize&
    tileSize()
    {
        return tileSize_;
    }
    const IntSize&
    tileSize() const
    {
        return tileSize_;
    }

    int&
    firstTileX()
    {
        return firstTileX_;
    }
    const int&
    firstTileX() const
    {
        return firstTileX_;
    }

    int&
    firstTileY()
    {
        return firstTileY_;
    }
    const int&
    firstTileY() const
    {
        return firstTileY_;
    }

    int&
    retainedWidth()
    {
        return retainedWidth_;
    }
    const int&
    retainedWidth() const
    {
        return retainedWidth_;
    }

    int&
    retainedHeight()
    {
        return retainedHeight_;
    }
    const int&
    retainedHeight() const
    {
        return retainedHeight_;
    }

    float&
    resolution()
    {
        return resolution_;
    }
    const float&
    resolution() const
    {
        return resolution_;
    }

    float&
    frameXResolution()
    {
        return frameXResolution_;
    }
    const float&
    frameXResolution() const
    {
        return frameXResolution_;
    }

    float&
    frameYResolution()
    {
        return frameYResolution_;
    }
    const float&
    frameYResolution() const
    {
        return frameYResolution_;
    }

    bool&
    isProgressive()
    {
        return isProgressive_;
    }
    const bool&
    isProgressive() const
    {
        return isProgressive_;
    }

private:
    void
    StaticAssertions() const;
    nsIntRegion validRegion_;
    CopyableTArray<TileDescriptor> tiles_;
    IntPoint tileOrigin_;
    IntSize tileSize_;
    int firstTileX_;
    int firstTileY_;
    int retainedWidth_;
    int retainedHeight_;
    bool isProgressive_;
    float resolution_;
    float frameXResolution_;
    float frameYResolution_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::SurfaceDescriptorTiles>
{
    typedef mozilla::layers::SurfaceDescriptorTiles paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpUseTiledLayerBuffer|
//
namespace mozilla {
namespace layers {
class OpUseTiledLayerBuffer final
{
private:
    typedef mozilla::layers::SurfaceDescriptorTiles SurfaceDescriptorTiles;

public:
    MOZ_IMPLICIT OpUseTiledLayerBuffer() :
        tileLayerDescriptor_()
    {
    }

    MOZ_IMPLICIT OpUseTiledLayerBuffer(const SurfaceDescriptorTiles& _tileLayerDescriptor) :
        tileLayerDescriptor_(_tileLayerDescriptor)
    {
    }

    SurfaceDescriptorTiles&
    tileLayerDescriptor()
    {
        return tileLayerDescriptor_;
    }
    const SurfaceDescriptorTiles&
    tileLayerDescriptor() const
    {
        return tileLayerDescriptor_;
    }

private:
    SurfaceDescriptorTiles tileLayerDescriptor_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpUseTiledLayerBuffer>
{
    typedef mozilla::layers::OpUseTiledLayerBuffer paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpPaintTextureRegion|
//
namespace mozilla {
namespace layers {
class OpPaintTextureRegion final
{
private:
    typedef mozilla::layers::ThebesBufferData ThebesBufferData;

public:
    MOZ_IMPLICIT OpPaintTextureRegion() :
        bufferData_(),
        updatedRegion_()
    {
    }

    MOZ_IMPLICIT OpPaintTextureRegion(
            const ThebesBufferData& _bufferData,
            const nsIntRegion& _updatedRegion) :
        bufferData_(_bufferData),
        updatedRegion_(_updatedRegion)
    {
    }

    ThebesBufferData&
    bufferData()
    {
        return bufferData_;
    }
    const ThebesBufferData&
    bufferData() const
    {
        return bufferData_;
    }

    nsIntRegion&
    updatedRegion()
    {
        return updatedRegion_;
    }
    const nsIntRegion&
    updatedRegion() const
    {
        return updatedRegion_;
    }

private:
    ThebesBufferData bufferData_;
    nsIntRegion updatedRegion_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpPaintTextureRegion>
{
    typedef mozilla::layers::OpPaintTextureRegion paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace layers {
class PTextureParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PTextureChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpRemoveTexture|
//
namespace mozilla {
namespace layers {
class OpRemoveTexture final
{
private:
    typedef mozilla::layers::PTextureParent PTextureParent;
    typedef mozilla::layers::PTextureChild PTextureChild;

public:
    MOZ_IMPLICIT OpRemoveTexture() :
        textureParent_(),
        textureChild_()
    {
    }

    MOZ_IMPLICIT OpRemoveTexture(
            PTextureParent* _textureParent,
            PTextureChild* _textureChild) :
        textureParent_(_textureParent),
        textureChild_(_textureChild)
    {
    }

    PTextureParent*&
    textureParent()
    {
        return textureParent_;
    }
    PTextureParent*
    textureParent() const
    {
        return textureParent_;
    }

    PTextureChild*&
    textureChild()
    {
        return textureChild_;
    }
    PTextureChild*
    textureChild() const
    {
        return textureChild_;
    }

private:
    PTextureParent* textureParent_;
    PTextureChild* textureChild_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpRemoveTexture>
{
    typedef mozilla::layers::OpRemoveTexture paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace layers {
class PTextureParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PTextureChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct TimedTexture|
//
namespace mozilla {
namespace layers {
class TimedTexture final
{
private:
    typedef mozilla::layers::PTextureParent PTextureParent;
    typedef mozilla::layers::PTextureChild PTextureChild;
    typedef mozilla::TimeStamp TimeStamp;
    typedef mozilla::gfx::IntRect IntRect;

public:
    MOZ_IMPLICIT TimedTexture() :
        textureParent_(),
        textureChild_(),
        timeStamp_(),
        picture_(),
        readLocked_(),
        frameID_(),
        producerID_()
    {
    }

    MOZ_IMPLICIT TimedTexture(
            PTextureParent* _textureParent,
            PTextureChild* _textureChild,
            const TimeStamp& _timeStamp,
            const IntRect& _picture,
            const uint32_t& _frameID,
            const uint32_t& _producerID,
            const bool& _readLocked) :
        textureParent_(_textureParent),
        textureChild_(_textureChild),
        timeStamp_(_timeStamp),
        picture_(_picture),
        readLocked_(_readLocked),
        frameID_(_frameID),
        producerID_(_producerID)
    {
    }

    PTextureParent*&
    textureParent()
    {
        return textureParent_;
    }
    PTextureParent*
    textureParent() const
    {
        return textureParent_;
    }

    PTextureChild*&
    textureChild()
    {
        return textureChild_;
    }
    PTextureChild*
    textureChild() const
    {
        return textureChild_;
    }

    TimeStamp&
    timeStamp()
    {
        return timeStamp_;
    }
    const TimeStamp&
    timeStamp() const
    {
        return timeStamp_;
    }

    IntRect&
    picture()
    {
        return picture_;
    }
    const IntRect&
    picture() const
    {
        return picture_;
    }

    uint32_t&
    frameID()
    {
        return frameID_;
    }
    const uint32_t&
    frameID() const
    {
        return frameID_;
    }

    uint32_t&
    producerID()
    {
        return producerID_;
    }
    const uint32_t&
    producerID() const
    {
        return producerID_;
    }

    bool&
    readLocked()
    {
        return readLocked_;
    }
    const bool&
    readLocked() const
    {
        return readLocked_;
    }

private:
    void
    StaticAssertions() const;
    PTextureParent* textureParent_;
    PTextureChild* textureChild_;
    TimeStamp timeStamp_;
    IntRect picture_;
    bool readLocked_;
    uint32_t frameID_;
    uint32_t producerID_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::TimedTexture>
{
    typedef mozilla::layers::TimedTexture paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpUseTexture|
//
namespace mozilla {
namespace layers {
class OpUseTexture final
{
private:
    typedef mozilla::layers::TimedTexture TimedTexture;

public:
    MOZ_IMPLICIT OpUseTexture() :
        textures_()
    {
    }

    MOZ_IMPLICIT OpUseTexture(const nsTArray<TimedTexture>& _textures) :
        textures_(_textures)
    {
    }

    nsTArray<TimedTexture>&
    textures()
    {
        return textures_;
    }
    const nsTArray<TimedTexture>&
    textures() const
    {
        return textures_;
    }

private:
    CopyableTArray<TimedTexture> textures_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpUseTexture>
{
    typedef mozilla::layers::OpUseTexture paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace layers {
class PTextureParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PTextureChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpUseComponentAlphaTextures|
//
namespace mozilla {
namespace layers {
class OpUseComponentAlphaTextures final
{
private:
    typedef mozilla::layers::PTextureParent PTextureParent;
    typedef mozilla::layers::PTextureChild PTextureChild;

public:
    MOZ_IMPLICIT OpUseComponentAlphaTextures() :
        textureOnBlackParent_(),
        textureOnBlackChild_(),
        textureOnWhiteParent_(),
        textureOnWhiteChild_(),
        readLockedBlack_(),
        readLockedWhite_()
    {
    }

    MOZ_IMPLICIT OpUseComponentAlphaTextures(
            PTextureParent* _textureOnBlackParent,
            PTextureChild* _textureOnBlackChild,
            PTextureParent* _textureOnWhiteParent,
            PTextureChild* _textureOnWhiteChild,
            const bool& _readLockedBlack,
            const bool& _readLockedWhite) :
        textureOnBlackParent_(_textureOnBlackParent),
        textureOnBlackChild_(_textureOnBlackChild),
        textureOnWhiteParent_(_textureOnWhiteParent),
        textureOnWhiteChild_(_textureOnWhiteChild),
        readLockedBlack_(_readLockedBlack),
        readLockedWhite_(_readLockedWhite)
    {
    }

    PTextureParent*&
    textureOnBlackParent()
    {
        return textureOnBlackParent_;
    }
    PTextureParent*
    textureOnBlackParent() const
    {
        return textureOnBlackParent_;
    }

    PTextureChild*&
    textureOnBlackChild()
    {
        return textureOnBlackChild_;
    }
    PTextureChild*
    textureOnBlackChild() const
    {
        return textureOnBlackChild_;
    }

    PTextureParent*&
    textureOnWhiteParent()
    {
        return textureOnWhiteParent_;
    }
    PTextureParent*
    textureOnWhiteParent() const
    {
        return textureOnWhiteParent_;
    }

    PTextureChild*&
    textureOnWhiteChild()
    {
        return textureOnWhiteChild_;
    }
    PTextureChild*
    textureOnWhiteChild() const
    {
        return textureOnWhiteChild_;
    }

    bool&
    readLockedBlack()
    {
        return readLockedBlack_;
    }
    const bool&
    readLockedBlack() const
    {
        return readLockedBlack_;
    }

    bool&
    readLockedWhite()
    {
        return readLockedWhite_;
    }
    const bool&
    readLockedWhite() const
    {
        return readLockedWhite_;
    }

private:
    PTextureParent* textureOnBlackParent_;
    PTextureChild* textureOnBlackChild_;
    PTextureParent* textureOnWhiteParent_;
    PTextureChild* textureOnWhiteChild_;
    bool readLockedBlack_;
    bool readLockedWhite_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpUseComponentAlphaTextures>
{
    typedef mozilla::layers::OpUseComponentAlphaTextures paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpNotifyNotUsed|
//
namespace mozilla {
namespace layers {
class OpNotifyNotUsed final
{
private:

public:
    MOZ_IMPLICIT OpNotifyNotUsed() :
        TextureId_(),
        fwdTransactionId_()
    {
    }

    MOZ_IMPLICIT OpNotifyNotUsed(
            const uint64_t& _TextureId,
            const uint64_t& _fwdTransactionId) :
        TextureId_(_TextureId),
        fwdTransactionId_(_fwdTransactionId)
    {
    }

    uint64_t&
    TextureId()
    {
        return TextureId_;
    }
    const uint64_t&
    TextureId() const
    {
        return TextureId_;
    }

    uint64_t&
    fwdTransactionId()
    {
        return fwdTransactionId_;
    }
    const uint64_t&
    fwdTransactionId() const
    {
        return fwdTransactionId_;
    }

private:
    void
    StaticAssertions() const;
    uint64_t TextureId_;
    uint64_t fwdTransactionId_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpNotifyNotUsed>
{
    typedef mozilla::layers::OpNotifyNotUsed paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace layers {
class PTextureParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PTextureChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpDeliverAcquireFence|
//
namespace mozilla {
namespace layers {
class OpDeliverAcquireFence final
{
private:
    typedef mozilla::layers::PTextureParent PTextureParent;
    typedef mozilla::layers::PTextureChild PTextureChild;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;

public:
    MOZ_IMPLICIT OpDeliverAcquireFence() :
        textureParent_(),
        textureChild_(),
        fenceFd_()
    {
    }

    MOZ_IMPLICIT OpDeliverAcquireFence(
            PTextureParent* _textureParent,
            PTextureChild* _textureChild,
            const FileDescriptor& _fenceFd) :
        textureParent_(_textureParent),
        textureChild_(_textureChild),
        fenceFd_(_fenceFd)
    {
    }

    PTextureParent*&
    textureParent()
    {
        return textureParent_;
    }
    PTextureParent*
    textureParent() const
    {
        return textureParent_;
    }

    PTextureChild*&
    textureChild()
    {
        return textureChild_;
    }
    PTextureChild*
    textureChild() const
    {
        return textureChild_;
    }

    FileDescriptor&
    fenceFd()
    {
        return fenceFd_;
    }
    const FileDescriptor&
    fenceFd() const
    {
        return const_cast<FileDescriptor&>(fenceFd_);
    }

private:
    PTextureParent* textureParent_;
    PTextureChild* textureChild_;
    FileDescriptor fenceFd_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpDeliverAcquireFence>
{
    typedef mozilla::layers::OpDeliverAcquireFence paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpDeliverReleaseFence|
//
namespace mozilla {
namespace layers {
class OpDeliverReleaseFence final
{
private:
    typedef mozilla::ipc::FileDescriptor FileDescriptor;

public:
    MOZ_IMPLICIT OpDeliverReleaseFence() :
        fenceFd_(),
        usesImageBridge_(),
        bufferId_(),
        fwdTransactionId_()
    {
    }

    MOZ_IMPLICIT OpDeliverReleaseFence(
            const mozilla::Maybe<FileDescriptor>& _fenceFd,
            const uint64_t& _bufferId,
            const uint64_t& _fwdTransactionId,
            const bool& _usesImageBridge) :
        fenceFd_(_fenceFd),
        usesImageBridge_(_usesImageBridge),
        bufferId_(_bufferId),
        fwdTransactionId_(_fwdTransactionId)
    {
    }

    mozilla::Maybe<FileDescriptor>&
    fenceFd()
    {
        return fenceFd_;
    }
    const mozilla::Maybe<FileDescriptor>&
    fenceFd() const
    {
        return fenceFd_;
    }

    uint64_t&
    bufferId()
    {
        return bufferId_;
    }
    const uint64_t&
    bufferId() const
    {
        return bufferId_;
    }

    uint64_t&
    fwdTransactionId()
    {
        return fwdTransactionId_;
    }
    const uint64_t&
    fwdTransactionId() const
    {
        return fwdTransactionId_;
    }

    bool&
    usesImageBridge()
    {
        return usesImageBridge_;
    }
    const bool&
    usesImageBridge() const
    {
        return usesImageBridge_;
    }

private:
    void
    StaticAssertions() const;
    mozilla::Maybe<FileDescriptor> fenceFd_;
    bool usesImageBridge_;
    uint64_t bufferId_;
    uint64_t fwdTransactionId_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpDeliverReleaseFence>
{
    typedef mozilla::layers::OpDeliverReleaseFence paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union CompositableOperationDetail|
//
namespace mozilla {
namespace layers {
class CompositableOperationDetail final
{
public:
    enum Type {
        T__None,
        TOpPaintTextureRegion = 1,
        TOpUseTiledLayerBuffer,
        TOpRemoveTexture,
        TOpUseTexture,
        TOpUseComponentAlphaTextures,
        TOpDeliverAcquireFence,
        T__Last = TOpDeliverAcquireFence
    };

private:
    typedef mozilla::layers::OpPaintTextureRegion OpPaintTextureRegion;
    typedef mozilla::layers::OpUseTiledLayerBuffer OpUseTiledLayerBuffer;
    typedef mozilla::layers::OpRemoveTexture OpRemoveTexture;
    typedef mozilla::layers::OpUseTexture OpUseTexture;
    typedef mozilla::layers::OpUseComponentAlphaTextures OpUseComponentAlphaTextures;
    typedef mozilla::layers::OpDeliverAcquireFence OpDeliverAcquireFence;
    typedef OpPaintTextureRegion OpPaintTextureRegion__tdef;
    typedef OpUseTiledLayerBuffer OpUseTiledLayerBuffer__tdef;
    typedef OpRemoveTexture OpRemoveTexture__tdef;
    typedef OpUseTexture OpUseTexture__tdef;
    typedef OpUseComponentAlphaTextures OpUseComponentAlphaTextures__tdef;
    typedef OpDeliverAcquireFence OpDeliverAcquireFence__tdef;

    union Value {
        mozilla::AlignedStorage2<OpPaintTextureRegion> VOpPaintTextureRegion;
        mozilla::AlignedStorage2<OpUseTiledLayerBuffer> VOpUseTiledLayerBuffer;
        mozilla::AlignedStorage2<OpRemoveTexture> VOpRemoveTexture;
        mozilla::AlignedStorage2<OpUseTexture> VOpUseTexture;
        mozilla::AlignedStorage2<OpUseComponentAlphaTextures> VOpUseComponentAlphaTextures;
        mozilla::AlignedStorage2<OpDeliverAcquireFence> VOpDeliverAcquireFence;
    };

    OpPaintTextureRegion*
    ptr_OpPaintTextureRegion()
    {
        return ((mValue).VOpPaintTextureRegion).addr();
    }
    const OpPaintTextureRegion*
    constptr_OpPaintTextureRegion() const
    {
        return ((mValue).VOpPaintTextureRegion).addr();
    }
    OpUseTiledLayerBuffer*
    ptr_OpUseTiledLayerBuffer()
    {
        return ((mValue).VOpUseTiledLayerBuffer).addr();
    }
    const OpUseTiledLayerBuffer*
    constptr_OpUseTiledLayerBuffer() const
    {
        return ((mValue).VOpUseTiledLayerBuffer).addr();
    }
    OpRemoveTexture*
    ptr_OpRemoveTexture()
    {
        return ((mValue).VOpRemoveTexture).addr();
    }
    const OpRemoveTexture*
    constptr_OpRemoveTexture() const
    {
        return ((mValue).VOpRemoveTexture).addr();
    }
    OpUseTexture*
    ptr_OpUseTexture()
    {
        return ((mValue).VOpUseTexture).addr();
    }
    const OpUseTexture*
    constptr_OpUseTexture() const
    {
        return ((mValue).VOpUseTexture).addr();
    }
    OpUseComponentAlphaTextures*
    ptr_OpUseComponentAlphaTextures()
    {
        return ((mValue).VOpUseComponentAlphaTextures).addr();
    }
    const OpUseComponentAlphaTextures*
    constptr_OpUseComponentAlphaTextures() const
    {
        return ((mValue).VOpUseComponentAlphaTextures).addr();
    }
    OpDeliverAcquireFence*
    ptr_OpDeliverAcquireFence()
    {
        return ((mValue).VOpDeliverAcquireFence).addr();
    }
    const OpDeliverAcquireFence*
    constptr_OpDeliverAcquireFence() const
    {
        return ((mValue).VOpDeliverAcquireFence).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT CompositableOperationDetail() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT CompositableOperationDetail(const OpPaintTextureRegion& aOther);

    MOZ_IMPLICIT CompositableOperationDetail(OpPaintTextureRegion&& aOther);

    MOZ_IMPLICIT CompositableOperationDetail(const OpUseTiledLayerBuffer& aOther);

    MOZ_IMPLICIT CompositableOperationDetail(OpUseTiledLayerBuffer&& aOther);

    MOZ_IMPLICIT CompositableOperationDetail(const OpRemoveTexture& aOther);

    MOZ_IMPLICIT CompositableOperationDetail(OpRemoveTexture&& aOther);

    MOZ_IMPLICIT CompositableOperationDetail(const OpUseTexture& aOther);

    MOZ_IMPLICIT CompositableOperationDetail(OpUseTexture&& aOther);

    MOZ_IMPLICIT CompositableOperationDetail(const OpUseComponentAlphaTextures& aOther);

    MOZ_IMPLICIT CompositableOperationDetail(OpUseComponentAlphaTextures&& aOther);

    MOZ_IMPLICIT CompositableOperationDetail(const OpDeliverAcquireFence& aOther);

    MOZ_IMPLICIT CompositableOperationDetail(OpDeliverAcquireFence&& aOther);

    MOZ_IMPLICIT CompositableOperationDetail(const CompositableOperationDetail& aOther);

    MOZ_IMPLICIT CompositableOperationDetail(CompositableOperationDetail&& aOther);

    ~CompositableOperationDetail();

    Type
    type() const
    {
        return mType;
    }

    CompositableOperationDetail&
    operator=(const OpPaintTextureRegion& aRhs);

    CompositableOperationDetail&
    operator=(OpPaintTextureRegion&& aRhs);

    CompositableOperationDetail&
    operator=(const OpUseTiledLayerBuffer& aRhs);

    CompositableOperationDetail&
    operator=(OpUseTiledLayerBuffer&& aRhs);

    CompositableOperationDetail&
    operator=(const OpRemoveTexture& aRhs);

    CompositableOperationDetail&
    operator=(OpRemoveTexture&& aRhs);

    CompositableOperationDetail&
    operator=(const OpUseTexture& aRhs);

    CompositableOperationDetail&
    operator=(OpUseTexture&& aRhs);

    CompositableOperationDetail&
    operator=(const OpUseComponentAlphaTextures& aRhs);

    CompositableOperationDetail&
    operator=(OpUseComponentAlphaTextures&& aRhs);

    CompositableOperationDetail&
    operator=(const OpDeliverAcquireFence& aRhs);

    CompositableOperationDetail&
    operator=(OpDeliverAcquireFence&& aRhs);

    CompositableOperationDetail&
    operator=(const CompositableOperationDetail& aRhs);

    CompositableOperationDetail&
    operator=(CompositableOperationDetail&& aRhs);

    OpPaintTextureRegion&
    get_OpPaintTextureRegion()
    {
        AssertSanity(TOpPaintTextureRegion);
        return (*(ptr_OpPaintTextureRegion()));
    }
    const OpPaintTextureRegion&
    get_OpPaintTextureRegion() const
    {
        AssertSanity(TOpPaintTextureRegion);
        return (*(constptr_OpPaintTextureRegion()));
    }
    operator OpPaintTextureRegion&()
    {
        return get_OpPaintTextureRegion();
    }
    operator const OpPaintTextureRegion&() const
    {
        return get_OpPaintTextureRegion();
    }

    OpUseTiledLayerBuffer&
    get_OpUseTiledLayerBuffer()
    {
        AssertSanity(TOpUseTiledLayerBuffer);
        return (*(ptr_OpUseTiledLayerBuffer()));
    }
    const OpUseTiledLayerBuffer&
    get_OpUseTiledLayerBuffer() const
    {
        AssertSanity(TOpUseTiledLayerBuffer);
        return (*(constptr_OpUseTiledLayerBuffer()));
    }
    operator OpUseTiledLayerBuffer&()
    {
        return get_OpUseTiledLayerBuffer();
    }
    operator const OpUseTiledLayerBuffer&() const
    {
        return get_OpUseTiledLayerBuffer();
    }

    OpRemoveTexture&
    get_OpRemoveTexture()
    {
        AssertSanity(TOpRemoveTexture);
        return (*(ptr_OpRemoveTexture()));
    }
    const OpRemoveTexture&
    get_OpRemoveTexture() const
    {
        AssertSanity(TOpRemoveTexture);
        return (*(constptr_OpRemoveTexture()));
    }
    operator OpRemoveTexture&()
    {
        return get_OpRemoveTexture();
    }
    operator const OpRemoveTexture&() const
    {
        return get_OpRemoveTexture();
    }

    OpUseTexture&
    get_OpUseTexture()
    {
        AssertSanity(TOpUseTexture);
        return (*(ptr_OpUseTexture()));
    }
    const OpUseTexture&
    get_OpUseTexture() const
    {
        AssertSanity(TOpUseTexture);
        return (*(constptr_OpUseTexture()));
    }
    operator OpUseTexture&()
    {
        return get_OpUseTexture();
    }
    operator const OpUseTexture&() const
    {
        return get_OpUseTexture();
    }

    OpUseComponentAlphaTextures&
    get_OpUseComponentAlphaTextures()
    {
        AssertSanity(TOpUseComponentAlphaTextures);
        return (*(ptr_OpUseComponentAlphaTextures()));
    }
    const OpUseComponentAlphaTextures&
    get_OpUseComponentAlphaTextures() const
    {
        AssertSanity(TOpUseComponentAlphaTextures);
        return (*(constptr_OpUseComponentAlphaTextures()));
    }
    operator OpUseComponentAlphaTextures&()
    {
        return get_OpUseComponentAlphaTextures();
    }
    operator const OpUseComponentAlphaTextures&() const
    {
        return get_OpUseComponentAlphaTextures();
    }

    OpDeliverAcquireFence&
    get_OpDeliverAcquireFence()
    {
        AssertSanity(TOpDeliverAcquireFence);
        return (*(ptr_OpDeliverAcquireFence()));
    }
    const OpDeliverAcquireFence&
    get_OpDeliverAcquireFence() const
    {
        AssertSanity(TOpDeliverAcquireFence);
        return (*(constptr_OpDeliverAcquireFence()));
    }
    operator OpDeliverAcquireFence&()
    {
        return get_OpDeliverAcquireFence();
    }
    operator const OpDeliverAcquireFence&() const
    {
        return get_OpDeliverAcquireFence();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::CompositableOperationDetail>
{
    typedef mozilla::layers::CompositableOperationDetail paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CompositableOperation|
//
namespace mozilla {
namespace layers {
class CompositableOperation final
{
private:
    typedef mozilla::layers::CompositableHandle CompositableHandle;
    typedef mozilla::layers::CompositableOperationDetail CompositableOperationDetail;

public:
    MOZ_IMPLICIT CompositableOperation() :
        compositable_(),
        detail_()
    {
    }

    MOZ_IMPLICIT CompositableOperation(
            const CompositableHandle& _compositable,
            const CompositableOperationDetail& _detail) :
        compositable_(_compositable),
        detail_(_detail)
    {
    }

    CompositableHandle&
    compositable()
    {
        return compositable_;
    }
    const CompositableHandle&
    compositable() const
    {
        return compositable_;
    }

    CompositableOperationDetail&
    detail()
    {
        return detail_;
    }
    const CompositableOperationDetail&
    detail() const
    {
        return detail_;
    }

private:
    CompositableHandle compositable_;
    CompositableOperationDetail detail_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::CompositableOperation>
{
    typedef mozilla::layers::CompositableOperation paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union Edit|
//
namespace mozilla {
namespace layers {
class Edit final
{
public:
    enum Type {
        T__None,
        TOpCreatePaintedLayer = 1,
        TOpCreateContainerLayer,
        TOpCreateImageLayer,
        TOpCreateColorLayer,
        TOpCreateCanvasLayer,
        TOpCreateRefLayer,
        TOpSetDiagnosticTypes,
        TOpSetRoot,
        TOpInsertAfter,
        TOpPrependChild,
        TOpRemoveChild,
        TOpRepositionChild,
        TOpRaiseToTopChild,
        TOpAttachCompositable,
        TOpAttachAsyncCompositable,
        TCompositableOperation,
        T__Last = TCompositableOperation
    };

private:
    typedef mozilla::layers::OpCreatePaintedLayer OpCreatePaintedLayer;
    typedef mozilla::layers::OpCreateContainerLayer OpCreateContainerLayer;
    typedef mozilla::layers::OpCreateImageLayer OpCreateImageLayer;
    typedef mozilla::layers::OpCreateColorLayer OpCreateColorLayer;
    typedef mozilla::layers::OpCreateCanvasLayer OpCreateCanvasLayer;
    typedef mozilla::layers::OpCreateRefLayer OpCreateRefLayer;
    typedef mozilla::layers::OpSetDiagnosticTypes OpSetDiagnosticTypes;
    typedef mozilla::layers::OpSetRoot OpSetRoot;
    typedef mozilla::layers::OpInsertAfter OpInsertAfter;
    typedef mozilla::layers::OpPrependChild OpPrependChild;
    typedef mozilla::layers::OpRemoveChild OpRemoveChild;
    typedef mozilla::layers::OpRepositionChild OpRepositionChild;
    typedef mozilla::layers::OpRaiseToTopChild OpRaiseToTopChild;
    typedef mozilla::layers::OpAttachCompositable OpAttachCompositable;
    typedef mozilla::layers::OpAttachAsyncCompositable OpAttachAsyncCompositable;
    typedef mozilla::layers::CompositableOperation CompositableOperation;
    typedef OpCreatePaintedLayer OpCreatePaintedLayer__tdef;
    typedef OpCreateContainerLayer OpCreateContainerLayer__tdef;
    typedef OpCreateImageLayer OpCreateImageLayer__tdef;
    typedef OpCreateColorLayer OpCreateColorLayer__tdef;
    typedef OpCreateCanvasLayer OpCreateCanvasLayer__tdef;
    typedef OpCreateRefLayer OpCreateRefLayer__tdef;
    typedef OpSetDiagnosticTypes OpSetDiagnosticTypes__tdef;
    typedef OpSetRoot OpSetRoot__tdef;
    typedef OpInsertAfter OpInsertAfter__tdef;
    typedef OpPrependChild OpPrependChild__tdef;
    typedef OpRemoveChild OpRemoveChild__tdef;
    typedef OpRepositionChild OpRepositionChild__tdef;
    typedef OpRaiseToTopChild OpRaiseToTopChild__tdef;
    typedef OpAttachCompositable OpAttachCompositable__tdef;
    typedef OpAttachAsyncCompositable OpAttachAsyncCompositable__tdef;
    typedef CompositableOperation CompositableOperation__tdef;

    union Value {
        mozilla::AlignedStorage2<OpCreatePaintedLayer> VOpCreatePaintedLayer;
        mozilla::AlignedStorage2<OpCreateContainerLayer> VOpCreateContainerLayer;
        mozilla::AlignedStorage2<OpCreateImageLayer> VOpCreateImageLayer;
        mozilla::AlignedStorage2<OpCreateColorLayer> VOpCreateColorLayer;
        mozilla::AlignedStorage2<OpCreateCanvasLayer> VOpCreateCanvasLayer;
        mozilla::AlignedStorage2<OpCreateRefLayer> VOpCreateRefLayer;
        mozilla::AlignedStorage2<OpSetDiagnosticTypes> VOpSetDiagnosticTypes;
        mozilla::AlignedStorage2<OpSetRoot> VOpSetRoot;
        mozilla::AlignedStorage2<OpInsertAfter> VOpInsertAfter;
        mozilla::AlignedStorage2<OpPrependChild> VOpPrependChild;
        mozilla::AlignedStorage2<OpRemoveChild> VOpRemoveChild;
        mozilla::AlignedStorage2<OpRepositionChild> VOpRepositionChild;
        mozilla::AlignedStorage2<OpRaiseToTopChild> VOpRaiseToTopChild;
        mozilla::AlignedStorage2<OpAttachCompositable> VOpAttachCompositable;
        mozilla::AlignedStorage2<OpAttachAsyncCompositable> VOpAttachAsyncCompositable;
        mozilla::AlignedStorage2<CompositableOperation> VCompositableOperation;
    };

    OpCreatePaintedLayer*
    ptr_OpCreatePaintedLayer()
    {
        return ((mValue).VOpCreatePaintedLayer).addr();
    }
    const OpCreatePaintedLayer*
    constptr_OpCreatePaintedLayer() const
    {
        return ((mValue).VOpCreatePaintedLayer).addr();
    }
    OpCreateContainerLayer*
    ptr_OpCreateContainerLayer()
    {
        return ((mValue).VOpCreateContainerLayer).addr();
    }
    const OpCreateContainerLayer*
    constptr_OpCreateContainerLayer() const
    {
        return ((mValue).VOpCreateContainerLayer).addr();
    }
    OpCreateImageLayer*
    ptr_OpCreateImageLayer()
    {
        return ((mValue).VOpCreateImageLayer).addr();
    }
    const OpCreateImageLayer*
    constptr_OpCreateImageLayer() const
    {
        return ((mValue).VOpCreateImageLayer).addr();
    }
    OpCreateColorLayer*
    ptr_OpCreateColorLayer()
    {
        return ((mValue).VOpCreateColorLayer).addr();
    }
    const OpCreateColorLayer*
    constptr_OpCreateColorLayer() const
    {
        return ((mValue).VOpCreateColorLayer).addr();
    }
    OpCreateCanvasLayer*
    ptr_OpCreateCanvasLayer()
    {
        return ((mValue).VOpCreateCanvasLayer).addr();
    }
    const OpCreateCanvasLayer*
    constptr_OpCreateCanvasLayer() const
    {
        return ((mValue).VOpCreateCanvasLayer).addr();
    }
    OpCreateRefLayer*
    ptr_OpCreateRefLayer()
    {
        return ((mValue).VOpCreateRefLayer).addr();
    }
    const OpCreateRefLayer*
    constptr_OpCreateRefLayer() const
    {
        return ((mValue).VOpCreateRefLayer).addr();
    }
    OpSetDiagnosticTypes*
    ptr_OpSetDiagnosticTypes()
    {
        return ((mValue).VOpSetDiagnosticTypes).addr();
    }
    const OpSetDiagnosticTypes*
    constptr_OpSetDiagnosticTypes() const
    {
        return ((mValue).VOpSetDiagnosticTypes).addr();
    }
    OpSetRoot*
    ptr_OpSetRoot()
    {
        return ((mValue).VOpSetRoot).addr();
    }
    const OpSetRoot*
    constptr_OpSetRoot() const
    {
        return ((mValue).VOpSetRoot).addr();
    }
    OpInsertAfter*
    ptr_OpInsertAfter()
    {
        return ((mValue).VOpInsertAfter).addr();
    }
    const OpInsertAfter*
    constptr_OpInsertAfter() const
    {
        return ((mValue).VOpInsertAfter).addr();
    }
    OpPrependChild*
    ptr_OpPrependChild()
    {
        return ((mValue).VOpPrependChild).addr();
    }
    const OpPrependChild*
    constptr_OpPrependChild() const
    {
        return ((mValue).VOpPrependChild).addr();
    }
    OpRemoveChild*
    ptr_OpRemoveChild()
    {
        return ((mValue).VOpRemoveChild).addr();
    }
    const OpRemoveChild*
    constptr_OpRemoveChild() const
    {
        return ((mValue).VOpRemoveChild).addr();
    }
    OpRepositionChild*
    ptr_OpRepositionChild()
    {
        return ((mValue).VOpRepositionChild).addr();
    }
    const OpRepositionChild*
    constptr_OpRepositionChild() const
    {
        return ((mValue).VOpRepositionChild).addr();
    }
    OpRaiseToTopChild*
    ptr_OpRaiseToTopChild()
    {
        return ((mValue).VOpRaiseToTopChild).addr();
    }
    const OpRaiseToTopChild*
    constptr_OpRaiseToTopChild() const
    {
        return ((mValue).VOpRaiseToTopChild).addr();
    }
    OpAttachCompositable*
    ptr_OpAttachCompositable()
    {
        return ((mValue).VOpAttachCompositable).addr();
    }
    const OpAttachCompositable*
    constptr_OpAttachCompositable() const
    {
        return ((mValue).VOpAttachCompositable).addr();
    }
    OpAttachAsyncCompositable*
    ptr_OpAttachAsyncCompositable()
    {
        return ((mValue).VOpAttachAsyncCompositable).addr();
    }
    const OpAttachAsyncCompositable*
    constptr_OpAttachAsyncCompositable() const
    {
        return ((mValue).VOpAttachAsyncCompositable).addr();
    }
    CompositableOperation*
    ptr_CompositableOperation()
    {
        return ((mValue).VCompositableOperation).addr();
    }
    const CompositableOperation*
    constptr_CompositableOperation() const
    {
        return ((mValue).VCompositableOperation).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT Edit() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT Edit(const OpCreatePaintedLayer& aOther);

    MOZ_IMPLICIT Edit(OpCreatePaintedLayer&& aOther);

    MOZ_IMPLICIT Edit(const OpCreateContainerLayer& aOther);

    MOZ_IMPLICIT Edit(OpCreateContainerLayer&& aOther);

    MOZ_IMPLICIT Edit(const OpCreateImageLayer& aOther);

    MOZ_IMPLICIT Edit(OpCreateImageLayer&& aOther);

    MOZ_IMPLICIT Edit(const OpCreateColorLayer& aOther);

    MOZ_IMPLICIT Edit(OpCreateColorLayer&& aOther);

    MOZ_IMPLICIT Edit(const OpCreateCanvasLayer& aOther);

    MOZ_IMPLICIT Edit(OpCreateCanvasLayer&& aOther);

    MOZ_IMPLICIT Edit(const OpCreateRefLayer& aOther);

    MOZ_IMPLICIT Edit(OpCreateRefLayer&& aOther);

    MOZ_IMPLICIT Edit(const OpSetDiagnosticTypes& aOther);

    MOZ_IMPLICIT Edit(OpSetDiagnosticTypes&& aOther);

    MOZ_IMPLICIT Edit(const OpSetRoot& aOther);

    MOZ_IMPLICIT Edit(OpSetRoot&& aOther);

    MOZ_IMPLICIT Edit(const OpInsertAfter& aOther);

    MOZ_IMPLICIT Edit(OpInsertAfter&& aOther);

    MOZ_IMPLICIT Edit(const OpPrependChild& aOther);

    MOZ_IMPLICIT Edit(OpPrependChild&& aOther);

    MOZ_IMPLICIT Edit(const OpRemoveChild& aOther);

    MOZ_IMPLICIT Edit(OpRemoveChild&& aOther);

    MOZ_IMPLICIT Edit(const OpRepositionChild& aOther);

    MOZ_IMPLICIT Edit(OpRepositionChild&& aOther);

    MOZ_IMPLICIT Edit(const OpRaiseToTopChild& aOther);

    MOZ_IMPLICIT Edit(OpRaiseToTopChild&& aOther);

    MOZ_IMPLICIT Edit(const OpAttachCompositable& aOther);

    MOZ_IMPLICIT Edit(OpAttachCompositable&& aOther);

    MOZ_IMPLICIT Edit(const OpAttachAsyncCompositable& aOther);

    MOZ_IMPLICIT Edit(OpAttachAsyncCompositable&& aOther);

    MOZ_IMPLICIT Edit(const CompositableOperation& aOther);

    MOZ_IMPLICIT Edit(CompositableOperation&& aOther);

    MOZ_IMPLICIT Edit(const Edit& aOther);

    MOZ_IMPLICIT Edit(Edit&& aOther);

    ~Edit();

    Type
    type() const
    {
        return mType;
    }

    Edit&
    operator=(const OpCreatePaintedLayer& aRhs);

    Edit&
    operator=(OpCreatePaintedLayer&& aRhs);

    Edit&
    operator=(const OpCreateContainerLayer& aRhs);

    Edit&
    operator=(OpCreateContainerLayer&& aRhs);

    Edit&
    operator=(const OpCreateImageLayer& aRhs);

    Edit&
    operator=(OpCreateImageLayer&& aRhs);

    Edit&
    operator=(const OpCreateColorLayer& aRhs);

    Edit&
    operator=(OpCreateColorLayer&& aRhs);

    Edit&
    operator=(const OpCreateCanvasLayer& aRhs);

    Edit&
    operator=(OpCreateCanvasLayer&& aRhs);

    Edit&
    operator=(const OpCreateRefLayer& aRhs);

    Edit&
    operator=(OpCreateRefLayer&& aRhs);

    Edit&
    operator=(const OpSetDiagnosticTypes& aRhs);

    Edit&
    operator=(OpSetDiagnosticTypes&& aRhs);

    Edit&
    operator=(const OpSetRoot& aRhs);

    Edit&
    operator=(OpSetRoot&& aRhs);

    Edit&
    operator=(const OpInsertAfter& aRhs);

    Edit&
    operator=(OpInsertAfter&& aRhs);

    Edit&
    operator=(const OpPrependChild& aRhs);

    Edit&
    operator=(OpPrependChild&& aRhs);

    Edit&
    operator=(const OpRemoveChild& aRhs);

    Edit&
    operator=(OpRemoveChild&& aRhs);

    Edit&
    operator=(const OpRepositionChild& aRhs);

    Edit&
    operator=(OpRepositionChild&& aRhs);

    Edit&
    operator=(const OpRaiseToTopChild& aRhs);

    Edit&
    operator=(OpRaiseToTopChild&& aRhs);

    Edit&
    operator=(const OpAttachCompositable& aRhs);

    Edit&
    operator=(OpAttachCompositable&& aRhs);

    Edit&
    operator=(const OpAttachAsyncCompositable& aRhs);

    Edit&
    operator=(OpAttachAsyncCompositable&& aRhs);

    Edit&
    operator=(const CompositableOperation& aRhs);

    Edit&
    operator=(CompositableOperation&& aRhs);

    Edit&
    operator=(const Edit& aRhs);

    Edit&
    operator=(Edit&& aRhs);

    OpCreatePaintedLayer&
    get_OpCreatePaintedLayer()
    {
        AssertSanity(TOpCreatePaintedLayer);
        return (*(ptr_OpCreatePaintedLayer()));
    }
    const OpCreatePaintedLayer&
    get_OpCreatePaintedLayer() const
    {
        AssertSanity(TOpCreatePaintedLayer);
        return (*(constptr_OpCreatePaintedLayer()));
    }
    operator OpCreatePaintedLayer&()
    {
        return get_OpCreatePaintedLayer();
    }
    operator const OpCreatePaintedLayer&() const
    {
        return get_OpCreatePaintedLayer();
    }

    OpCreateContainerLayer&
    get_OpCreateContainerLayer()
    {
        AssertSanity(TOpCreateContainerLayer);
        return (*(ptr_OpCreateContainerLayer()));
    }
    const OpCreateContainerLayer&
    get_OpCreateContainerLayer() const
    {
        AssertSanity(TOpCreateContainerLayer);
        return (*(constptr_OpCreateContainerLayer()));
    }
    operator OpCreateContainerLayer&()
    {
        return get_OpCreateContainerLayer();
    }
    operator const OpCreateContainerLayer&() const
    {
        return get_OpCreateContainerLayer();
    }

    OpCreateImageLayer&
    get_OpCreateImageLayer()
    {
        AssertSanity(TOpCreateImageLayer);
        return (*(ptr_OpCreateImageLayer()));
    }
    const OpCreateImageLayer&
    get_OpCreateImageLayer() const
    {
        AssertSanity(TOpCreateImageLayer);
        return (*(constptr_OpCreateImageLayer()));
    }
    operator OpCreateImageLayer&()
    {
        return get_OpCreateImageLayer();
    }
    operator const OpCreateImageLayer&() const
    {
        return get_OpCreateImageLayer();
    }

    OpCreateColorLayer&
    get_OpCreateColorLayer()
    {
        AssertSanity(TOpCreateColorLayer);
        return (*(ptr_OpCreateColorLayer()));
    }
    const OpCreateColorLayer&
    get_OpCreateColorLayer() const
    {
        AssertSanity(TOpCreateColorLayer);
        return (*(constptr_OpCreateColorLayer()));
    }
    operator OpCreateColorLayer&()
    {
        return get_OpCreateColorLayer();
    }
    operator const OpCreateColorLayer&() const
    {
        return get_OpCreateColorLayer();
    }

    OpCreateCanvasLayer&
    get_OpCreateCanvasLayer()
    {
        AssertSanity(TOpCreateCanvasLayer);
        return (*(ptr_OpCreateCanvasLayer()));
    }
    const OpCreateCanvasLayer&
    get_OpCreateCanvasLayer() const
    {
        AssertSanity(TOpCreateCanvasLayer);
        return (*(constptr_OpCreateCanvasLayer()));
    }
    operator OpCreateCanvasLayer&()
    {
        return get_OpCreateCanvasLayer();
    }
    operator const OpCreateCanvasLayer&() const
    {
        return get_OpCreateCanvasLayer();
    }

    OpCreateRefLayer&
    get_OpCreateRefLayer()
    {
        AssertSanity(TOpCreateRefLayer);
        return (*(ptr_OpCreateRefLayer()));
    }
    const OpCreateRefLayer&
    get_OpCreateRefLayer() const
    {
        AssertSanity(TOpCreateRefLayer);
        return (*(constptr_OpCreateRefLayer()));
    }
    operator OpCreateRefLayer&()
    {
        return get_OpCreateRefLayer();
    }
    operator const OpCreateRefLayer&() const
    {
        return get_OpCreateRefLayer();
    }

    OpSetDiagnosticTypes&
    get_OpSetDiagnosticTypes()
    {
        AssertSanity(TOpSetDiagnosticTypes);
        return (*(ptr_OpSetDiagnosticTypes()));
    }
    const OpSetDiagnosticTypes&
    get_OpSetDiagnosticTypes() const
    {
        AssertSanity(TOpSetDiagnosticTypes);
        return (*(constptr_OpSetDiagnosticTypes()));
    }
    operator OpSetDiagnosticTypes&()
    {
        return get_OpSetDiagnosticTypes();
    }
    operator const OpSetDiagnosticTypes&() const
    {
        return get_OpSetDiagnosticTypes();
    }

    OpSetRoot&
    get_OpSetRoot()
    {
        AssertSanity(TOpSetRoot);
        return (*(ptr_OpSetRoot()));
    }
    const OpSetRoot&
    get_OpSetRoot() const
    {
        AssertSanity(TOpSetRoot);
        return (*(constptr_OpSetRoot()));
    }
    operator OpSetRoot&()
    {
        return get_OpSetRoot();
    }
    operator const OpSetRoot&() const
    {
        return get_OpSetRoot();
    }

    OpInsertAfter&
    get_OpInsertAfter()
    {
        AssertSanity(TOpInsertAfter);
        return (*(ptr_OpInsertAfter()));
    }
    const OpInsertAfter&
    get_OpInsertAfter() const
    {
        AssertSanity(TOpInsertAfter);
        return (*(constptr_OpInsertAfter()));
    }
    operator OpInsertAfter&()
    {
        return get_OpInsertAfter();
    }
    operator const OpInsertAfter&() const
    {
        return get_OpInsertAfter();
    }

    OpPrependChild&
    get_OpPrependChild()
    {
        AssertSanity(TOpPrependChild);
        return (*(ptr_OpPrependChild()));
    }
    const OpPrependChild&
    get_OpPrependChild() const
    {
        AssertSanity(TOpPrependChild);
        return (*(constptr_OpPrependChild()));
    }
    operator OpPrependChild&()
    {
        return get_OpPrependChild();
    }
    operator const OpPrependChild&() const
    {
        return get_OpPrependChild();
    }

    OpRemoveChild&
    get_OpRemoveChild()
    {
        AssertSanity(TOpRemoveChild);
        return (*(ptr_OpRemoveChild()));
    }
    const OpRemoveChild&
    get_OpRemoveChild() const
    {
        AssertSanity(TOpRemoveChild);
        return (*(constptr_OpRemoveChild()));
    }
    operator OpRemoveChild&()
    {
        return get_OpRemoveChild();
    }
    operator const OpRemoveChild&() const
    {
        return get_OpRemoveChild();
    }

    OpRepositionChild&
    get_OpRepositionChild()
    {
        AssertSanity(TOpRepositionChild);
        return (*(ptr_OpRepositionChild()));
    }
    const OpRepositionChild&
    get_OpRepositionChild() const
    {
        AssertSanity(TOpRepositionChild);
        return (*(constptr_OpRepositionChild()));
    }
    operator OpRepositionChild&()
    {
        return get_OpRepositionChild();
    }
    operator const OpRepositionChild&() const
    {
        return get_OpRepositionChild();
    }

    OpRaiseToTopChild&
    get_OpRaiseToTopChild()
    {
        AssertSanity(TOpRaiseToTopChild);
        return (*(ptr_OpRaiseToTopChild()));
    }
    const OpRaiseToTopChild&
    get_OpRaiseToTopChild() const
    {
        AssertSanity(TOpRaiseToTopChild);
        return (*(constptr_OpRaiseToTopChild()));
    }
    operator OpRaiseToTopChild&()
    {
        return get_OpRaiseToTopChild();
    }
    operator const OpRaiseToTopChild&() const
    {
        return get_OpRaiseToTopChild();
    }

    OpAttachCompositable&
    get_OpAttachCompositable()
    {
        AssertSanity(TOpAttachCompositable);
        return (*(ptr_OpAttachCompositable()));
    }
    const OpAttachCompositable&
    get_OpAttachCompositable() const
    {
        AssertSanity(TOpAttachCompositable);
        return (*(constptr_OpAttachCompositable()));
    }
    operator OpAttachCompositable&()
    {
        return get_OpAttachCompositable();
    }
    operator const OpAttachCompositable&() const
    {
        return get_OpAttachCompositable();
    }

    OpAttachAsyncCompositable&
    get_OpAttachAsyncCompositable()
    {
        AssertSanity(TOpAttachAsyncCompositable);
        return (*(ptr_OpAttachAsyncCompositable()));
    }
    const OpAttachAsyncCompositable&
    get_OpAttachAsyncCompositable() const
    {
        AssertSanity(TOpAttachAsyncCompositable);
        return (*(constptr_OpAttachAsyncCompositable()));
    }
    operator OpAttachAsyncCompositable&()
    {
        return get_OpAttachAsyncCompositable();
    }
    operator const OpAttachAsyncCompositable&() const
    {
        return get_OpAttachAsyncCompositable();
    }

    CompositableOperation&
    get_CompositableOperation()
    {
        AssertSanity(TCompositableOperation);
        return (*(ptr_CompositableOperation()));
    }
    const CompositableOperation&
    get_CompositableOperation() const
    {
        AssertSanity(TCompositableOperation);
        return (*(constptr_CompositableOperation()));
    }
    operator CompositableOperation&()
    {
        return get_CompositableOperation();
    }
    operator const CompositableOperation&() const
    {
        return get_CompositableOperation();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::Edit>
{
    typedef mozilla::layers::Edit paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace layers {
class PTextureParent;
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace layers {
class PTextureChild;
} // namespace layers
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union OpDestroy|
//
namespace mozilla {
namespace layers {
class OpDestroy final
{
public:
    enum Type {
        T__None,
        TPTextureParent = 1,
        TPTextureChild,
        TCompositableHandle,
        T__Last = TCompositableHandle
    };

private:
    typedef mozilla::layers::PTextureParent PTextureParent;
    typedef mozilla::layers::PTextureChild PTextureChild;
    typedef mozilla::layers::CompositableHandle CompositableHandle;
    typedef PTextureParent* PTextureParent__tdef;
    typedef PTextureChild* PTextureChild__tdef;
    typedef CompositableHandle CompositableHandle__tdef;

    union Value {
        mozilla::AlignedStorage2<PTextureParent*> VPTextureParent;
        mozilla::AlignedStorage2<PTextureChild*> VPTextureChild;
        mozilla::AlignedStorage2<CompositableHandle> VCompositableHandle;
    };

    PTextureParent**
    ptr_PTextureParent()
    {
        return ((mValue).VPTextureParent).addr();
    }
    PTextureParent* const*
    constptr_PTextureParent() const
    {
        return ((mValue).VPTextureParent).addr();
    }
    PTextureChild**
    ptr_PTextureChild()
    {
        return ((mValue).VPTextureChild).addr();
    }
    PTextureChild* const*
    constptr_PTextureChild() const
    {
        return ((mValue).VPTextureChild).addr();
    }
    CompositableHandle*
    ptr_CompositableHandle()
    {
        return ((mValue).VCompositableHandle).addr();
    }
    const CompositableHandle*
    constptr_CompositableHandle() const
    {
        return ((mValue).VCompositableHandle).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT OpDestroy() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT OpDestroy(PTextureParent* aOther);

    MOZ_IMPLICIT OpDestroy(PTextureChild* aOther);

    MOZ_IMPLICIT OpDestroy(const CompositableHandle& aOther);

    MOZ_IMPLICIT OpDestroy(CompositableHandle&& aOther);

    MOZ_IMPLICIT OpDestroy(const OpDestroy& aOther);

    MOZ_IMPLICIT OpDestroy(OpDestroy&& aOther);

    ~OpDestroy();

    Type
    type() const
    {
        return mType;
    }

    OpDestroy&
    operator=(PTextureParent* aRhs);

    OpDestroy&
    operator=(PTextureChild* aRhs);

    OpDestroy&
    operator=(const CompositableHandle& aRhs);

    OpDestroy&
    operator=(CompositableHandle&& aRhs);

    OpDestroy&
    operator=(const OpDestroy& aRhs);

    OpDestroy&
    operator=(OpDestroy&& aRhs);

    PTextureParent*&
    get_PTextureParent()
    {
        AssertSanity(TPTextureParent);
        return (*(ptr_PTextureParent()));
    }
    PTextureParent*
    get_PTextureParent() const
    {
        AssertSanity(TPTextureParent);
        return (*(constptr_PTextureParent()));
    }
    operator PTextureParent*&()
    {
        return get_PTextureParent();
    }
    operator PTextureParent*() const
    {
        return get_PTextureParent();
    }

    PTextureChild*&
    get_PTextureChild()
    {
        AssertSanity(TPTextureChild);
        return (*(ptr_PTextureChild()));
    }
    PTextureChild*
    get_PTextureChild() const
    {
        AssertSanity(TPTextureChild);
        return (*(constptr_PTextureChild()));
    }
    operator PTextureChild*&()
    {
        return get_PTextureChild();
    }
    operator PTextureChild*() const
    {
        return get_PTextureChild();
    }

    CompositableHandle&
    get_CompositableHandle()
    {
        AssertSanity(TCompositableHandle);
        return (*(ptr_CompositableHandle()));
    }
    const CompositableHandle&
    get_CompositableHandle() const
    {
        AssertSanity(TCompositableHandle);
        return (*(constptr_CompositableHandle()));
    }
    operator CompositableHandle&()
    {
        return get_CompositableHandle();
    }
    operator const CompositableHandle&() const
    {
        return get_CompositableHandle();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpDestroy>
{
    typedef mozilla::layers::OpDestroy paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OpContentBufferSwap|
//
namespace mozilla {
namespace layers {
class OpContentBufferSwap final
{
private:
    typedef mozilla::layers::CompositableHandle CompositableHandle;

public:
    MOZ_IMPLICIT OpContentBufferSwap() :
        compositable_(),
        frontUpdatedRegion_()
    {
    }

    MOZ_IMPLICIT OpContentBufferSwap(
            const CompositableHandle& _compositable,
            const nsIntRegion& _frontUpdatedRegion) :
        compositable_(_compositable),
        frontUpdatedRegion_(_frontUpdatedRegion)
    {
    }

    CompositableHandle&
    compositable()
    {
        return compositable_;
    }
    const CompositableHandle&
    compositable() const
    {
        return compositable_;
    }

    nsIntRegion&
    frontUpdatedRegion()
    {
        return frontUpdatedRegion_;
    }
    const nsIntRegion&
    frontUpdatedRegion() const
    {
        return frontUpdatedRegion_;
    }

private:
    CompositableHandle compositable_;
    nsIntRegion frontUpdatedRegion_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OpContentBufferSwap>
{
    typedef mozilla::layers::OpContentBufferSwap paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ImageCompositeNotification|
//
namespace mozilla {
namespace layers {
class ImageCompositeNotification final
{
private:
    typedef mozilla::layers::CompositableHandle CompositableHandle;
    typedef mozilla::TimeStamp TimeStamp;

public:
    MOZ_IMPLICIT ImageCompositeNotification() :
        compositable_(),
        imageTimeStamp_(),
        firstCompositeTimeStamp_(),
        frameID_(),
        producerID_()
    {
    }

    MOZ_IMPLICIT ImageCompositeNotification(
            const CompositableHandle& _compositable,
            const TimeStamp& _imageTimeStamp,
            const TimeStamp& _firstCompositeTimeStamp,
            const uint32_t& _frameID,
            const uint32_t& _producerID) :
        compositable_(_compositable),
        imageTimeStamp_(_imageTimeStamp),
        firstCompositeTimeStamp_(_firstCompositeTimeStamp),
        frameID_(_frameID),
        producerID_(_producerID)
    {
    }

    CompositableHandle&
    compositable()
    {
        return compositable_;
    }
    const CompositableHandle&
    compositable() const
    {
        return compositable_;
    }

    TimeStamp&
    imageTimeStamp()
    {
        return imageTimeStamp_;
    }
    const TimeStamp&
    imageTimeStamp() const
    {
        return imageTimeStamp_;
    }

    TimeStamp&
    firstCompositeTimeStamp()
    {
        return firstCompositeTimeStamp_;
    }
    const TimeStamp&
    firstCompositeTimeStamp() const
    {
        return firstCompositeTimeStamp_;
    }

    uint32_t&
    frameID()
    {
        return frameID_;
    }
    const uint32_t&
    frameID() const
    {
        return frameID_;
    }

    uint32_t&
    producerID()
    {
        return producerID_;
    }
    const uint32_t&
    producerID() const
    {
        return producerID_;
    }

private:
    void
    StaticAssertions() const;
    CompositableHandle compositable_;
    TimeStamp imageTimeStamp_;
    TimeStamp firstCompositeTimeStamp_;
    uint32_t frameID_;
    uint32_t producerID_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::ImageCompositeNotification>
{
    typedef mozilla::layers::ImageCompositeNotification paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union AsyncParentMessageData|
//
namespace mozilla {
namespace layers {
class AsyncParentMessageData final
{
public:
    enum Type {
        T__None,
        TOpNotifyNotUsed = 1,
        TOpDeliverReleaseFence,
        T__Last = TOpDeliverReleaseFence
    };

private:
    typedef mozilla::layers::OpNotifyNotUsed OpNotifyNotUsed;
    typedef mozilla::layers::OpDeliverReleaseFence OpDeliverReleaseFence;
    typedef OpNotifyNotUsed OpNotifyNotUsed__tdef;
    typedef OpDeliverReleaseFence OpDeliverReleaseFence__tdef;

    union Value {
        mozilla::AlignedStorage2<OpNotifyNotUsed> VOpNotifyNotUsed;
        mozilla::AlignedStorage2<OpDeliverReleaseFence> VOpDeliverReleaseFence;
    };

    OpNotifyNotUsed*
    ptr_OpNotifyNotUsed()
    {
        return ((mValue).VOpNotifyNotUsed).addr();
    }
    const OpNotifyNotUsed*
    constptr_OpNotifyNotUsed() const
    {
        return ((mValue).VOpNotifyNotUsed).addr();
    }
    OpDeliverReleaseFence*
    ptr_OpDeliverReleaseFence()
    {
        return ((mValue).VOpDeliverReleaseFence).addr();
    }
    const OpDeliverReleaseFence*
    constptr_OpDeliverReleaseFence() const
    {
        return ((mValue).VOpDeliverReleaseFence).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT AsyncParentMessageData() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT AsyncParentMessageData(const OpNotifyNotUsed& aOther);

    MOZ_IMPLICIT AsyncParentMessageData(OpNotifyNotUsed&& aOther);

    MOZ_IMPLICIT AsyncParentMessageData(const OpDeliverReleaseFence& aOther);

    MOZ_IMPLICIT AsyncParentMessageData(OpDeliverReleaseFence&& aOther);

    MOZ_IMPLICIT AsyncParentMessageData(const AsyncParentMessageData& aOther);

    MOZ_IMPLICIT AsyncParentMessageData(AsyncParentMessageData&& aOther);

    ~AsyncParentMessageData();

    Type
    type() const
    {
        return mType;
    }

    AsyncParentMessageData&
    operator=(const OpNotifyNotUsed& aRhs);

    AsyncParentMessageData&
    operator=(OpNotifyNotUsed&& aRhs);

    AsyncParentMessageData&
    operator=(const OpDeliverReleaseFence& aRhs);

    AsyncParentMessageData&
    operator=(OpDeliverReleaseFence&& aRhs);

    AsyncParentMessageData&
    operator=(const AsyncParentMessageData& aRhs);

    AsyncParentMessageData&
    operator=(AsyncParentMessageData&& aRhs);

    OpNotifyNotUsed&
    get_OpNotifyNotUsed()
    {
        AssertSanity(TOpNotifyNotUsed);
        return (*(ptr_OpNotifyNotUsed()));
    }
    const OpNotifyNotUsed&
    get_OpNotifyNotUsed() const
    {
        AssertSanity(TOpNotifyNotUsed);
        return (*(constptr_OpNotifyNotUsed()));
    }
    operator OpNotifyNotUsed&()
    {
        return get_OpNotifyNotUsed();
    }
    operator const OpNotifyNotUsed&() const
    {
        return get_OpNotifyNotUsed();
    }

    OpDeliverReleaseFence&
    get_OpDeliverReleaseFence()
    {
        AssertSanity(TOpDeliverReleaseFence);
        return (*(ptr_OpDeliverReleaseFence()));
    }
    const OpDeliverReleaseFence&
    get_OpDeliverReleaseFence() const
    {
        AssertSanity(TOpDeliverReleaseFence);
        return (*(constptr_OpDeliverReleaseFence()));
    }
    operator OpDeliverReleaseFence&()
    {
        return get_OpDeliverReleaseFence();
    }
    operator const OpDeliverReleaseFence&() const
    {
        return get_OpDeliverReleaseFence();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::AsyncParentMessageData>
{
    typedef mozilla::layers::AsyncParentMessageData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct PaintTiming|
//
namespace mozilla {
namespace layers {
class PaintTiming final
{
private:

public:
    MOZ_IMPLICIT PaintTiming() :
        serializeMs_(),
        sendMs_(),
        dlMs_(),
        dl2Ms_(),
        flbMs_(),
        rasterMs_()
    {
    }

    MOZ_IMPLICIT PaintTiming(
            const float& _serializeMs,
            const float& _sendMs,
            const float& _dlMs,
            const float& _dl2Ms,
            const float& _flbMs,
            const float& _rasterMs) :
        serializeMs_(_serializeMs),
        sendMs_(_sendMs),
        dlMs_(_dlMs),
        dl2Ms_(_dl2Ms),
        flbMs_(_flbMs),
        rasterMs_(_rasterMs)
    {
    }

    float&
    serializeMs()
    {
        return serializeMs_;
    }
    const float&
    serializeMs() const
    {
        return serializeMs_;
    }

    float&
    sendMs()
    {
        return sendMs_;
    }
    const float&
    sendMs() const
    {
        return sendMs_;
    }

    float&
    dlMs()
    {
        return dlMs_;
    }
    const float&
    dlMs() const
    {
        return dlMs_;
    }

    float&
    dl2Ms()
    {
        return dl2Ms_;
    }
    const float&
    dl2Ms() const
    {
        return dl2Ms_;
    }

    float&
    flbMs()
    {
        return flbMs_;
    }
    const float&
    flbMs() const
    {
        return flbMs_;
    }

    float&
    rasterMs()
    {
        return rasterMs_;
    }
    const float&
    rasterMs() const
    {
        return rasterMs_;
    }

private:
    void
    StaticAssertions() const;
    float serializeMs_;
    float sendMs_;
    float dlMs_;
    float dl2Ms_;
    float flbMs_;
    float rasterMs_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::PaintTiming>
{
    typedef mozilla::layers::PaintTiming paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct TransactionInfo|
//
namespace mozilla {
namespace layers {
class TransactionInfo final
{
private:
    typedef mozilla::layers::Edit Edit;
    typedef mozilla::layers::OpSetSimpleLayerAttributes OpSetSimpleLayerAttributes;
    typedef mozilla::layers::OpSetLayerAttributes OpSetLayerAttributes;
    typedef mozilla::layers::CompositableOperation CompositableOperation;
    typedef mozilla::layers::OpDestroy OpDestroy;
    typedef mozilla::layers::TransactionId TransactionId;
    typedef mozilla::layers::TargetConfig TargetConfig;
    typedef mozilla::layers::PluginWindowData PluginWindowData;
    typedef mozilla::layers::FocusTarget FocusTarget;
    typedef mozilla::VsyncId VsyncId;
    typedef mozilla::TimeStamp TimeStamp;
    typedef mozilla::layers::CompositionPayload CompositionPayload;

public:
    MOZ_IMPLICIT TransactionInfo() :
        cset_(),
        setSimpleAttrs_(),
        setAttrs_(),
        paints_(),
        toDestroy_(),
        id_(),
        targetConfig_(),
        plugins_(),
        isFirstPaint_(),
        focusTarget_(),
        scheduleComposite_(),
        isRepeatTransaction_(),
        vsyncId_(),
        vsyncStart_(),
        refreshStart_(),
        transactionStart_(),
        containsSVG_(),
        url_(),
        fwdTime_(),
        payload_(),
        fwdTransactionId_(),
        paintSequenceNumber_()
    {
    }

    MOZ_IMPLICIT TransactionInfo(
            const nsTArray<Edit>& _cset,
            const nsTArray<OpSetSimpleLayerAttributes>& _setSimpleAttrs,
            const nsTArray<OpSetLayerAttributes>& _setAttrs,
            const nsTArray<CompositableOperation>& _paints,
            const nsTArray<OpDestroy>& _toDestroy,
            const uint64_t& _fwdTransactionId,
            const TransactionId& _id,
            const TargetConfig& _targetConfig,
            const nsTArray<PluginWindowData>& _plugins,
            const bool& _isFirstPaint,
            const FocusTarget& _focusTarget,
            const bool& _scheduleComposite,
            const uint32_t& _paintSequenceNumber,
            const bool& _isRepeatTransaction,
            const VsyncId& _vsyncId,
            const TimeStamp& _vsyncStart,
            const TimeStamp& _refreshStart,
            const TimeStamp& _transactionStart,
            const bool& _containsSVG,
            const nsCString& _url,
            const TimeStamp& _fwdTime,
            const nsTArray<CompositionPayload>& _payload) :
        cset_(_cset),
        setSimpleAttrs_(_setSimpleAttrs),
        setAttrs_(_setAttrs),
        paints_(_paints),
        toDestroy_(_toDestroy),
        id_(_id),
        targetConfig_(_targetConfig),
        plugins_(_plugins),
        isFirstPaint_(_isFirstPaint),
        focusTarget_(_focusTarget),
        scheduleComposite_(_scheduleComposite),
        isRepeatTransaction_(_isRepeatTransaction),
        vsyncId_(_vsyncId),
        vsyncStart_(_vsyncStart),
        refreshStart_(_refreshStart),
        transactionStart_(_transactionStart),
        containsSVG_(_containsSVG),
        url_(_url),
        fwdTime_(_fwdTime),
        payload_(_payload),
        fwdTransactionId_(_fwdTransactionId),
        paintSequenceNumber_(_paintSequenceNumber)
    {
    }

    nsTArray<Edit>&
    cset()
    {
        return cset_;
    }
    const nsTArray<Edit>&
    cset() const
    {
        return cset_;
    }

    nsTArray<OpSetSimpleLayerAttributes>&
    setSimpleAttrs()
    {
        return setSimpleAttrs_;
    }
    const nsTArray<OpSetSimpleLayerAttributes>&
    setSimpleAttrs() const
    {
        return setSimpleAttrs_;
    }

    nsTArray<OpSetLayerAttributes>&
    setAttrs()
    {
        return setAttrs_;
    }
    const nsTArray<OpSetLayerAttributes>&
    setAttrs() const
    {
        return setAttrs_;
    }

    nsTArray<CompositableOperation>&
    paints()
    {
        return paints_;
    }
    const nsTArray<CompositableOperation>&
    paints() const
    {
        return paints_;
    }

    nsTArray<OpDestroy>&
    toDestroy()
    {
        return toDestroy_;
    }
    const nsTArray<OpDestroy>&
    toDestroy() const
    {
        return toDestroy_;
    }

    uint64_t&
    fwdTransactionId()
    {
        return fwdTransactionId_;
    }
    const uint64_t&
    fwdTransactionId() const
    {
        return fwdTransactionId_;
    }

    TransactionId&
    id()
    {
        return id_;
    }
    const TransactionId&
    id() const
    {
        return id_;
    }

    TargetConfig&
    targetConfig()
    {
        return targetConfig_;
    }
    const TargetConfig&
    targetConfig() const
    {
        return targetConfig_;
    }

    nsTArray<PluginWindowData>&
    plugins()
    {
        return plugins_;
    }
    const nsTArray<PluginWindowData>&
    plugins() const
    {
        return plugins_;
    }

    bool&
    isFirstPaint()
    {
        return isFirstPaint_;
    }
    const bool&
    isFirstPaint() const
    {
        return isFirstPaint_;
    }

    FocusTarget&
    focusTarget()
    {
        return focusTarget_;
    }
    const FocusTarget&
    focusTarget() const
    {
        return focusTarget_;
    }

    bool&
    scheduleComposite()
    {
        return scheduleComposite_;
    }
    const bool&
    scheduleComposite() const
    {
        return scheduleComposite_;
    }

    uint32_t&
    paintSequenceNumber()
    {
        return paintSequenceNumber_;
    }
    const uint32_t&
    paintSequenceNumber() const
    {
        return paintSequenceNumber_;
    }

    bool&
    isRepeatTransaction()
    {
        return isRepeatTransaction_;
    }
    const bool&
    isRepeatTransaction() const
    {
        return isRepeatTransaction_;
    }

    VsyncId&
    vsyncId()
    {
        return vsyncId_;
    }
    const VsyncId&
    vsyncId() const
    {
        return vsyncId_;
    }

    TimeStamp&
    vsyncStart()
    {
        return vsyncStart_;
    }
    const TimeStamp&
    vsyncStart() const
    {
        return vsyncStart_;
    }

    TimeStamp&
    refreshStart()
    {
        return refreshStart_;
    }
    const TimeStamp&
    refreshStart() const
    {
        return refreshStart_;
    }

    TimeStamp&
    transactionStart()
    {
        return transactionStart_;
    }
    const TimeStamp&
    transactionStart() const
    {
        return transactionStart_;
    }

    bool&
    containsSVG()
    {
        return containsSVG_;
    }
    const bool&
    containsSVG() const
    {
        return containsSVG_;
    }

    nsCString&
    url()
    {
        return url_;
    }
    const nsCString&
    url() const
    {
        return url_;
    }

    TimeStamp&
    fwdTime()
    {
        return fwdTime_;
    }
    const TimeStamp&
    fwdTime() const
    {
        return fwdTime_;
    }

    nsTArray<CompositionPayload>&
    payload()
    {
        return payload_;
    }
    const nsTArray<CompositionPayload>&
    payload() const
    {
        return payload_;
    }

private:
    CopyableTArray<Edit> cset_;
    CopyableTArray<OpSetSimpleLayerAttributes> setSimpleAttrs_;
    CopyableTArray<OpSetLayerAttributes> setAttrs_;
    CopyableTArray<CompositableOperation> paints_;
    CopyableTArray<OpDestroy> toDestroy_;
    TransactionId id_;
    TargetConfig targetConfig_;
    CopyableTArray<PluginWindowData> plugins_;
    bool isFirstPaint_;
    FocusTarget focusTarget_;
    bool scheduleComposite_;
    bool isRepeatTransaction_;
    VsyncId vsyncId_;
    TimeStamp vsyncStart_;
    TimeStamp refreshStart_;
    TimeStamp transactionStart_;
    bool containsSVG_;
    nsCString url_;
    TimeStamp fwdTime_;
    CopyableTArray<CompositionPayload> payload_;
    uint64_t fwdTransactionId_;
    uint32_t paintSequenceNumber_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::TransactionInfo>
{
    typedef mozilla::layers::TransactionInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union OMTAValue|
//
namespace mozilla {
namespace layers {
class OMTAValue final
{
public:
    enum Type {
        T__None,
        Tnull_t = 1,
        Tnscolor,
        Tfloat,
        TMatrix4x4,
        T__Last = TMatrix4x4
    };

private:
    typedef mozilla::null_t null_t;
    typedef mozilla::gfx::Matrix4x4 Matrix4x4;
    typedef null_t null_t__tdef;
    typedef nscolor nscolor__tdef;
    typedef float float__tdef;
    typedef Matrix4x4 Matrix4x4__tdef;

    union Value {
        mozilla::AlignedStorage2<null_t> Vnull_t;
        mozilla::AlignedStorage2<nscolor> Vnscolor;
        mozilla::AlignedStorage2<float> Vfloat;
        mozilla::AlignedStorage2<Matrix4x4> VMatrix4x4;
    };

    null_t*
    ptr_null_t()
    {
        return ((mValue).Vnull_t).addr();
    }
    const null_t*
    constptr_null_t() const
    {
        return ((mValue).Vnull_t).addr();
    }
    nscolor*
    ptr_nscolor()
    {
        return ((mValue).Vnscolor).addr();
    }
    const nscolor*
    constptr_nscolor() const
    {
        return ((mValue).Vnscolor).addr();
    }
    float*
    ptr_float()
    {
        return ((mValue).Vfloat).addr();
    }
    const float*
    constptr_float() const
    {
        return ((mValue).Vfloat).addr();
    }
    Matrix4x4*
    ptr_Matrix4x4()
    {
        return ((mValue).VMatrix4x4).addr();
    }
    const Matrix4x4*
    constptr_Matrix4x4() const
    {
        return ((mValue).VMatrix4x4).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT OMTAValue() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT OMTAValue(const null_t& aOther);

    MOZ_IMPLICIT OMTAValue(null_t&& aOther);

    MOZ_IMPLICIT OMTAValue(const nscolor& aOther);

    MOZ_IMPLICIT OMTAValue(nscolor&& aOther);

    MOZ_IMPLICIT OMTAValue(const float& aOther);

    MOZ_IMPLICIT OMTAValue(float&& aOther);

    MOZ_IMPLICIT OMTAValue(const Matrix4x4& aOther);

    MOZ_IMPLICIT OMTAValue(Matrix4x4&& aOther);

    MOZ_IMPLICIT OMTAValue(const OMTAValue& aOther);

    MOZ_IMPLICIT OMTAValue(OMTAValue&& aOther);

    ~OMTAValue();

    Type
    type() const
    {
        return mType;
    }

    OMTAValue&
    operator=(const null_t& aRhs);

    OMTAValue&
    operator=(null_t&& aRhs);

    OMTAValue&
    operator=(const nscolor& aRhs);

    OMTAValue&
    operator=(nscolor&& aRhs);

    OMTAValue&
    operator=(const float& aRhs);

    OMTAValue&
    operator=(float&& aRhs);

    OMTAValue&
    operator=(const Matrix4x4& aRhs);

    OMTAValue&
    operator=(Matrix4x4&& aRhs);

    OMTAValue&
    operator=(const OMTAValue& aRhs);

    OMTAValue&
    operator=(OMTAValue&& aRhs);

    null_t&
    get_null_t()
    {
        AssertSanity(Tnull_t);
        return (*(ptr_null_t()));
    }
    const null_t&
    get_null_t() const
    {
        AssertSanity(Tnull_t);
        return (*(constptr_null_t()));
    }
    operator null_t&()
    {
        return get_null_t();
    }
    operator const null_t&() const
    {
        return get_null_t();
    }

    nscolor&
    get_nscolor()
    {
        AssertSanity(Tnscolor);
        return (*(ptr_nscolor()));
    }
    const nscolor&
    get_nscolor() const
    {
        AssertSanity(Tnscolor);
        return (*(constptr_nscolor()));
    }
    operator nscolor&()
    {
        return get_nscolor();
    }
    operator const nscolor&() const
    {
        return get_nscolor();
    }

    float&
    get_float()
    {
        AssertSanity(Tfloat);
        return (*(ptr_float()));
    }
    const float&
    get_float() const
    {
        AssertSanity(Tfloat);
        return (*(constptr_float()));
    }
    operator float&()
    {
        return get_float();
    }
    operator const float&() const
    {
        return get_float();
    }

    Matrix4x4&
    get_Matrix4x4()
    {
        AssertSanity(TMatrix4x4);
        return (*(ptr_Matrix4x4()));
    }
    const Matrix4x4&
    get_Matrix4x4() const
    {
        AssertSanity(TMatrix4x4);
        return (*(constptr_Matrix4x4()));
    }
    operator Matrix4x4&()
    {
        return get_Matrix4x4();
    }
    operator const Matrix4x4&() const
    {
        return get_Matrix4x4();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::OMTAValue>
{
    typedef mozilla::layers::OMTAValue paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

#endif // ifndef LayersMessages_h
