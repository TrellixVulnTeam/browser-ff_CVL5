//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef LayersSurfaces_h
#define LayersSurfaces_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "ImageTypes.h"
#include "gfxipc/SurfaceDescriptor.h"
#include "mozilla/gfx/Point.h"
#include "mozilla/gfx/Rect.h"
#include "mozilla/gfx/Types.h"
#include "mozilla/ipc/IPCCore.h"
#include "mozilla/ipc/IPCTypes.h"
#include "mozilla/ipc/SharedMemoryBasic.h"
#include "mozilla/layers/VideoBridgeUtils.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SurfaceDescriptorFileMapping|
//
namespace mozilla {
namespace layers {
class SurfaceDescriptorFileMapping final
{
private:
    typedef mozilla::WindowsHandle WindowsHandle;
    typedef mozilla::gfx::SurfaceFormat SurfaceFormat;
    typedef mozilla::gfx::IntSize IntSize;

public:
    MOZ_IMPLICIT SurfaceDescriptorFileMapping() :
        handle_(),
        format_(),
        size_()
    {
    }

    MOZ_IMPLICIT SurfaceDescriptorFileMapping(
            const WindowsHandle& _handle,
            const SurfaceFormat& _format,
            const IntSize& _size) :
        handle_(_handle),
        format_(_format),
        size_(_size)
    {
    }

    bool
    operator==(const SurfaceDescriptorFileMapping& _o) const;

    bool
    operator!=(const SurfaceDescriptorFileMapping& _o) const;

    WindowsHandle&
    handle()
    {
        return handle_;
    }
    const WindowsHandle&
    handle() const
    {
        return handle_;
    }

    SurfaceFormat&
    format()
    {
        return format_;
    }
    const SurfaceFormat&
    format() const
    {
        return format_;
    }

    IntSize&
    size()
    {
        return size_;
    }
    const IntSize&
    size() const
    {
        return size_;
    }

private:
    WindowsHandle handle_;
    SurfaceFormat format_;
    IntSize size_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::SurfaceDescriptorFileMapping>
{
    typedef mozilla::layers::SurfaceDescriptorFileMapping paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SurfaceDescriptorDIB|
//
namespace mozilla {
namespace layers {
class SurfaceDescriptorDIB final
{
private:

public:
    MOZ_IMPLICIT SurfaceDescriptorDIB() :
        surface_()
    {
    }

    MOZ_IMPLICIT SurfaceDescriptorDIB(const uintptr_t& _surface) :
        surface_(_surface)
    {
    }

    bool
    operator==(const SurfaceDescriptorDIB& _o) const;

    bool
    operator!=(const SurfaceDescriptorDIB& _o) const;

    uintptr_t&
    surface()
    {
        return surface_;
    }
    const uintptr_t&
    surface() const
    {
        return surface_;
    }

private:
    uintptr_t surface_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::SurfaceDescriptorDIB>
{
    typedef mozilla::layers::SurfaceDescriptorDIB paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SurfaceDescriptorD3D10|
//
namespace mozilla {
namespace layers {
class SurfaceDescriptorD3D10 final
{
private:
    typedef mozilla::WindowsHandle WindowsHandle;
    typedef mozilla::gfx::SurfaceFormat SurfaceFormat;
    typedef mozilla::gfx::IntSize IntSize;
    typedef mozilla::gfx::YUVColorSpace YUVColorSpace;
    typedef mozilla::gfx::ColorRange ColorRange;

public:
    MOZ_IMPLICIT SurfaceDescriptorD3D10() :
        handle_(),
        format_(),
        size_(),
        yUVColorSpace_(),
        colorRange_()
    {
    }

    MOZ_IMPLICIT SurfaceDescriptorD3D10(
            const WindowsHandle& _handle,
            const SurfaceFormat& _format,
            const IntSize& _size,
            const YUVColorSpace& _yUVColorSpace,
            const ColorRange& _colorRange) :
        handle_(_handle),
        format_(_format),
        size_(_size),
        yUVColorSpace_(_yUVColorSpace),
        colorRange_(_colorRange)
    {
    }

    bool
    operator==(const SurfaceDescriptorD3D10& _o) const;

    bool
    operator!=(const SurfaceDescriptorD3D10& _o) const;

    WindowsHandle&
    handle()
    {
        return handle_;
    }
    const WindowsHandle&
    handle() const
    {
        return handle_;
    }

    SurfaceFormat&
    format()
    {
        return format_;
    }
    const SurfaceFormat&
    format() const
    {
        return format_;
    }

    IntSize&
    size()
    {
        return size_;
    }
    const IntSize&
    size() const
    {
        return size_;
    }

    YUVColorSpace&
    yUVColorSpace()
    {
        return yUVColorSpace_;
    }
    const YUVColorSpace&
    yUVColorSpace() const
    {
        return yUVColorSpace_;
    }

    ColorRange&
    colorRange()
    {
        return colorRange_;
    }
    const ColorRange&
    colorRange() const
    {
        return colorRange_;
    }

private:
    WindowsHandle handle_;
    SurfaceFormat format_;
    IntSize size_;
    YUVColorSpace yUVColorSpace_;
    ColorRange colorRange_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::SurfaceDescriptorD3D10>
{
    typedef mozilla::layers::SurfaceDescriptorD3D10 paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SurfaceDescriptorDXGIYCbCr|
//
namespace mozilla {
namespace layers {
class SurfaceDescriptorDXGIYCbCr final
{
private:
    typedef mozilla::WindowsHandle WindowsHandle;
    typedef mozilla::gfx::IntSize IntSize;
    typedef mozilla::gfx::ColorDepth ColorDepth;
    typedef mozilla::gfx::YUVColorSpace YUVColorSpace;
    typedef mozilla::gfx::ColorRange ColorRange;

public:
    MOZ_IMPLICIT SurfaceDescriptorDXGIYCbCr() :
        handleY_(),
        handleCb_(),
        handleCr_(),
        size_(),
        sizeY_(),
        sizeCbCr_(),
        colorDepth_(),
        yUVColorSpace_(),
        colorRange_()
    {
    }

    MOZ_IMPLICIT SurfaceDescriptorDXGIYCbCr(
            const WindowsHandle& _handleY,
            const WindowsHandle& _handleCb,
            const WindowsHandle& _handleCr,
            const IntSize& _size,
            const IntSize& _sizeY,
            const IntSize& _sizeCbCr,
            const ColorDepth& _colorDepth,
            const YUVColorSpace& _yUVColorSpace,
            const ColorRange& _colorRange) :
        handleY_(_handleY),
        handleCb_(_handleCb),
        handleCr_(_handleCr),
        size_(_size),
        sizeY_(_sizeY),
        sizeCbCr_(_sizeCbCr),
        colorDepth_(_colorDepth),
        yUVColorSpace_(_yUVColorSpace),
        colorRange_(_colorRange)
    {
    }

    bool
    operator==(const SurfaceDescriptorDXGIYCbCr& _o) const;

    bool
    operator!=(const SurfaceDescriptorDXGIYCbCr& _o) const;

    WindowsHandle&
    handleY()
    {
        return handleY_;
    }
    const WindowsHandle&
    handleY() const
    {
        return handleY_;
    }

    WindowsHandle&
    handleCb()
    {
        return handleCb_;
    }
    const WindowsHandle&
    handleCb() const
    {
        return handleCb_;
    }

    WindowsHandle&
    handleCr()
    {
        return handleCr_;
    }
    const WindowsHandle&
    handleCr() const
    {
        return handleCr_;
    }

    IntSize&
    size()
    {
        return size_;
    }
    const IntSize&
    size() const
    {
        return size_;
    }

    IntSize&
    sizeY()
    {
        return sizeY_;
    }
    const IntSize&
    sizeY() const
    {
        return sizeY_;
    }

    IntSize&
    sizeCbCr()
    {
        return sizeCbCr_;
    }
    const IntSize&
    sizeCbCr() const
    {
        return sizeCbCr_;
    }

    ColorDepth&
    colorDepth()
    {
        return colorDepth_;
    }
    const ColorDepth&
    colorDepth() const
    {
        return colorDepth_;
    }

    YUVColorSpace&
    yUVColorSpace()
    {
        return yUVColorSpace_;
    }
    const YUVColorSpace&
    yUVColorSpace() const
    {
        return yUVColorSpace_;
    }

    ColorRange&
    colorRange()
    {
        return colorRange_;
    }
    const ColorRange&
    colorRange() const
    {
        return colorRange_;
    }

private:
    WindowsHandle handleY_;
    WindowsHandle handleCb_;
    WindowsHandle handleCr_;
    IntSize size_;
    IntSize sizeY_;
    IntSize sizeCbCr_;
    ColorDepth colorDepth_;
    YUVColorSpace yUVColorSpace_;
    ColorRange colorRange_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::SurfaceDescriptorDXGIYCbCr>
{
    typedef mozilla::layers::SurfaceDescriptorDXGIYCbCr paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SurfaceDescriptorMacIOSurface|
//
namespace mozilla {
namespace layers {
class SurfaceDescriptorMacIOSurface final
{
private:
    typedef mozilla::gfx::YUVColorSpace YUVColorSpace;

public:
    MOZ_IMPLICIT SurfaceDescriptorMacIOSurface() :
        isOpaque_(),
        yUVColorSpace_(),
        scaleFactor_(),
        surfaceId_()
    {
    }

    MOZ_IMPLICIT SurfaceDescriptorMacIOSurface(
            const uint32_t& _surfaceId,
            const double& _scaleFactor,
            const bool& _isOpaque,
            const YUVColorSpace& _yUVColorSpace) :
        isOpaque_(_isOpaque),
        yUVColorSpace_(_yUVColorSpace),
        scaleFactor_(_scaleFactor),
        surfaceId_(_surfaceId)
    {
    }

    bool
    operator==(const SurfaceDescriptorMacIOSurface& _o) const;

    bool
    operator!=(const SurfaceDescriptorMacIOSurface& _o) const;

    uint32_t&
    surfaceId()
    {
        return surfaceId_;
    }
    const uint32_t&
    surfaceId() const
    {
        return surfaceId_;
    }

    double&
    scaleFactor()
    {
        return scaleFactor_;
    }
    const double&
    scaleFactor() const
    {
        return scaleFactor_;
    }

    bool&
    isOpaque()
    {
        return isOpaque_;
    }
    const bool&
    isOpaque() const
    {
        return isOpaque_;
    }

    YUVColorSpace&
    yUVColorSpace()
    {
        return yUVColorSpace_;
    }
    const YUVColorSpace&
    yUVColorSpace() const
    {
        return yUVColorSpace_;
    }

private:
    bool isOpaque_;
    YUVColorSpace yUVColorSpace_;
    double scaleFactor_;
    uint32_t surfaceId_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::SurfaceDescriptorMacIOSurface>
{
    typedef mozilla::layers::SurfaceDescriptorMacIOSurface paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SurfaceDescriptorDMABuf|
//
namespace mozilla {
namespace layers {
class SurfaceDescriptorDMABuf final
{
private:
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::gfx::YUVColorSpace YUVColorSpace;

public:
    MOZ_IMPLICIT SurfaceDescriptorDMABuf() :
        fds_(),
        width_(),
        height_(),
        format_(),
        strides_(),
        offsets_(),
        yUVColorSpace_(),
        fence_(),
        refCount_(),
        modifier_(),
        bufferType_(),
        flags_(),
        uid_()
    {
    }

    MOZ_IMPLICIT SurfaceDescriptorDMABuf(
            const uint32_t& _bufferType,
            const uint64_t& _modifier,
            const uint32_t& _flags,
            const nsTArray<FileDescriptor>& _fds,
            const nsTArray<uint32_t>& _width,
            const nsTArray<uint32_t>& _height,
            const nsTArray<uint32_t>& _format,
            const nsTArray<uint32_t>& _strides,
            const nsTArray<uint32_t>& _offsets,
            const YUVColorSpace& _yUVColorSpace,
            const nsTArray<FileDescriptor>& _fence,
            const uint32_t& _uid,
            const nsTArray<FileDescriptor>& _refCount) :
        fds_(_fds),
        width_(_width),
        height_(_height),
        format_(_format),
        strides_(_strides),
        offsets_(_offsets),
        yUVColorSpace_(_yUVColorSpace),
        fence_(_fence),
        refCount_(_refCount),
        modifier_(_modifier),
        bufferType_(_bufferType),
        flags_(_flags),
        uid_(_uid)
    {
    }

    bool
    operator==(const SurfaceDescriptorDMABuf& _o) const;

    bool
    operator!=(const SurfaceDescriptorDMABuf& _o) const;

    uint32_t&
    bufferType()
    {
        return bufferType_;
    }
    const uint32_t&
    bufferType() const
    {
        return bufferType_;
    }

    uint64_t&
    modifier()
    {
        return modifier_;
    }
    const uint64_t&
    modifier() const
    {
        return modifier_;
    }

    uint32_t&
    flags()
    {
        return flags_;
    }
    const uint32_t&
    flags() const
    {
        return flags_;
    }

    nsTArray<FileDescriptor>&
    fds()
    {
        return fds_;
    }
    const nsTArray<FileDescriptor>&
    fds() const
    {
        return fds_;
    }

    nsTArray<uint32_t>&
    width()
    {
        return width_;
    }
    const nsTArray<uint32_t>&
    width() const
    {
        return width_;
    }

    nsTArray<uint32_t>&
    height()
    {
        return height_;
    }
    const nsTArray<uint32_t>&
    height() const
    {
        return height_;
    }

    nsTArray<uint32_t>&
    format()
    {
        return format_;
    }
    const nsTArray<uint32_t>&
    format() const
    {
        return format_;
    }

    nsTArray<uint32_t>&
    strides()
    {
        return strides_;
    }
    const nsTArray<uint32_t>&
    strides() const
    {
        return strides_;
    }

    nsTArray<uint32_t>&
    offsets()
    {
        return offsets_;
    }
    const nsTArray<uint32_t>&
    offsets() const
    {
        return offsets_;
    }

    YUVColorSpace&
    yUVColorSpace()
    {
        return yUVColorSpace_;
    }
    const YUVColorSpace&
    yUVColorSpace() const
    {
        return yUVColorSpace_;
    }

    nsTArray<FileDescriptor>&
    fence()
    {
        return fence_;
    }
    const nsTArray<FileDescriptor>&
    fence() const
    {
        return fence_;
    }

    uint32_t&
    uid()
    {
        return uid_;
    }
    const uint32_t&
    uid() const
    {
        return uid_;
    }

    nsTArray<FileDescriptor>&
    refCount()
    {
        return refCount_;
    }
    const nsTArray<FileDescriptor>&
    refCount() const
    {
        return refCount_;
    }

private:
    void
    StaticAssertions() const;
    CopyableTArray<FileDescriptor> fds_;
    CopyableTArray<uint32_t> width_;
    CopyableTArray<uint32_t> height_;
    CopyableTArray<uint32_t> format_;
    CopyableTArray<uint32_t> strides_;
    CopyableTArray<uint32_t> offsets_;
    YUVColorSpace yUVColorSpace_;
    CopyableTArray<FileDescriptor> fence_;
    CopyableTArray<FileDescriptor> refCount_;
    uint64_t modifier_;
    uint32_t bufferType_;
    uint32_t flags_;
    uint32_t uid_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::SurfaceDescriptorDMABuf>
{
    typedef mozilla::layers::SurfaceDescriptorDMABuf paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SurfaceTextureDescriptor|
//
namespace mozilla {
namespace layers {
class SurfaceTextureDescriptor final
{
private:
    typedef mozilla::gfx::IntSize IntSize;
    typedef mozilla::gfx::SurfaceFormat SurfaceFormat;

public:
    MOZ_IMPLICIT SurfaceTextureDescriptor() :
        size_(),
        format_(),
        continuous_(),
        ignoreTransform_(),
        handle_()
    {
    }

    MOZ_IMPLICIT SurfaceTextureDescriptor(
            const uint64_t& _handle,
            const IntSize& _size,
            const SurfaceFormat& _format,
            const bool& _continuous,
            const bool& _ignoreTransform) :
        size_(_size),
        format_(_format),
        continuous_(_continuous),
        ignoreTransform_(_ignoreTransform),
        handle_(_handle)
    {
    }

    bool
    operator==(const SurfaceTextureDescriptor& _o) const;

    bool
    operator!=(const SurfaceTextureDescriptor& _o) const;

    uint64_t&
    handle()
    {
        return handle_;
    }
    const uint64_t&
    handle() const
    {
        return handle_;
    }

    IntSize&
    size()
    {
        return size_;
    }
    const IntSize&
    size() const
    {
        return size_;
    }

    SurfaceFormat&
    format()
    {
        return format_;
    }
    const SurfaceFormat&
    format() const
    {
        return format_;
    }

    bool&
    continuous()
    {
        return continuous_;
    }
    const bool&
    continuous() const
    {
        return continuous_;
    }

    bool&
    ignoreTransform()
    {
        return ignoreTransform_;
    }
    const bool&
    ignoreTransform() const
    {
        return ignoreTransform_;
    }

private:
    IntSize size_;
    SurfaceFormat format_;
    bool continuous_;
    bool ignoreTransform_;
    uint64_t handle_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::SurfaceTextureDescriptor>
{
    typedef mozilla::layers::SurfaceTextureDescriptor paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SurfaceDescriptorAndroidHardwareBuffer|
//
namespace mozilla {
namespace layers {
class SurfaceDescriptorAndroidHardwareBuffer final
{
private:
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef mozilla::gfx::IntSize IntSize;
    typedef mozilla::gfx::SurfaceFormat SurfaceFormat;

public:
    MOZ_IMPLICIT SurfaceDescriptorAndroidHardwareBuffer() :
        handle_(),
        size_(),
        format_(),
        bufferId_()
    {
    }

    MOZ_IMPLICIT SurfaceDescriptorAndroidHardwareBuffer(
            const FileDescriptor& _handle,
            const uint64_t& _bufferId,
            const IntSize& _size,
            const SurfaceFormat& _format) :
        handle_(_handle),
        size_(_size),
        format_(_format),
        bufferId_(_bufferId)
    {
    }

    bool
    operator==(const SurfaceDescriptorAndroidHardwareBuffer& _o) const;

    bool
    operator!=(const SurfaceDescriptorAndroidHardwareBuffer& _o) const;

    FileDescriptor&
    handle()
    {
        return handle_;
    }
    const FileDescriptor&
    handle() const
    {
        return const_cast<FileDescriptor&>(handle_);
    }

    uint64_t&
    bufferId()
    {
        return bufferId_;
    }
    const uint64_t&
    bufferId() const
    {
        return bufferId_;
    }

    IntSize&
    size()
    {
        return size_;
    }
    const IntSize&
    size() const
    {
        return size_;
    }

    SurfaceFormat&
    format()
    {
        return format_;
    }
    const SurfaceFormat&
    format() const
    {
        return format_;
    }

private:
    FileDescriptor handle_;
    IntSize size_;
    SurfaceFormat format_;
    uint64_t bufferId_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::SurfaceDescriptorAndroidHardwareBuffer>
{
    typedef mozilla::layers::SurfaceDescriptorAndroidHardwareBuffer paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct EGLImageDescriptor|
//
namespace mozilla {
namespace layers {
class EGLImageDescriptor final
{
private:
    typedef mozilla::gfx::IntSize IntSize;

public:
    MOZ_IMPLICIT EGLImageDescriptor() :
        image_(),
        fence_(),
        size_(),
        hasAlpha_()
    {
    }

    MOZ_IMPLICIT EGLImageDescriptor(
            const uintptr_t& _image,
            const uintptr_t& _fence,
            const IntSize& _size,
            const bool& _hasAlpha) :
        image_(_image),
        fence_(_fence),
        size_(_size),
        hasAlpha_(_hasAlpha)
    {
    }

    bool
    operator==(const EGLImageDescriptor& _o) const;

    bool
    operator!=(const EGLImageDescriptor& _o) const;

    uintptr_t&
    image()
    {
        return image_;
    }
    const uintptr_t&
    image() const
    {
        return image_;
    }

    uintptr_t&
    fence()
    {
        return fence_;
    }
    const uintptr_t&
    fence() const
    {
        return fence_;
    }

    IntSize&
    size()
    {
        return size_;
    }
    const IntSize&
    size() const
    {
        return size_;
    }

    bool&
    hasAlpha()
    {
        return hasAlpha_;
    }
    const bool&
    hasAlpha() const
    {
        return hasAlpha_;
    }

private:
    uintptr_t image_;
    uintptr_t fence_;
    IntSize size_;
    bool hasAlpha_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::EGLImageDescriptor>
{
    typedef mozilla::layers::EGLImageDescriptor paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SurfaceDescriptorSharedGLTexture|
//
namespace mozilla {
namespace layers {
class SurfaceDescriptorSharedGLTexture final
{
private:
    typedef mozilla::gfx::IntSize IntSize;

public:
    MOZ_IMPLICIT SurfaceDescriptorSharedGLTexture() :
        fence_(),
        size_(),
        hasAlpha_(),
        texture_(),
        target_()
    {
    }

    MOZ_IMPLICIT SurfaceDescriptorSharedGLTexture(
            const uint32_t& _texture,
            const uint32_t& _target,
            const uintptr_t& _fence,
            const IntSize& _size,
            const bool& _hasAlpha) :
        fence_(_fence),
        size_(_size),
        hasAlpha_(_hasAlpha),
        texture_(_texture),
        target_(_target)
    {
    }

    bool
    operator==(const SurfaceDescriptorSharedGLTexture& _o) const;

    bool
    operator!=(const SurfaceDescriptorSharedGLTexture& _o) const;

    uint32_t&
    texture()
    {
        return texture_;
    }
    const uint32_t&
    texture() const
    {
        return texture_;
    }

    uint32_t&
    target()
    {
        return target_;
    }
    const uint32_t&
    target() const
    {
        return target_;
    }

    uintptr_t&
    fence()
    {
        return fence_;
    }
    const uintptr_t&
    fence() const
    {
        return fence_;
    }

    IntSize&
    size()
    {
        return size_;
    }
    const IntSize&
    size() const
    {
        return size_;
    }

    bool&
    hasAlpha()
    {
        return hasAlpha_;
    }
    const bool&
    hasAlpha() const
    {
        return hasAlpha_;
    }

private:
    void
    StaticAssertions() const;
    uintptr_t fence_;
    IntSize size_;
    bool hasAlpha_;
    uint32_t texture_;
    uint32_t target_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::SurfaceDescriptorSharedGLTexture>
{
    typedef mozilla::layers::SurfaceDescriptorSharedGLTexture paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union RemoteDecoderVideoSubDescriptor|
//
namespace mozilla {
namespace layers {
class RemoteDecoderVideoSubDescriptor final
{
public:
    enum Type {
        T__None,
        TSurfaceDescriptorD3D10 = 1,
        TSurfaceDescriptorDXGIYCbCr,
        TSurfaceDescriptorDMABuf,
        TSurfaceDescriptorMacIOSurface,
        Tnull_t,
        T__Last = Tnull_t
    };

private:
    typedef mozilla::layers::SurfaceDescriptorD3D10 SurfaceDescriptorD3D10;
    typedef mozilla::layers::SurfaceDescriptorDXGIYCbCr SurfaceDescriptorDXGIYCbCr;
    typedef mozilla::layers::SurfaceDescriptorDMABuf SurfaceDescriptorDMABuf;
    typedef mozilla::layers::SurfaceDescriptorMacIOSurface SurfaceDescriptorMacIOSurface;
    typedef mozilla::null_t null_t;
    typedef SurfaceDescriptorD3D10 SurfaceDescriptorD3D10__tdef;
    typedef SurfaceDescriptorDXGIYCbCr SurfaceDescriptorDXGIYCbCr__tdef;
    typedef SurfaceDescriptorDMABuf SurfaceDescriptorDMABuf__tdef;
    typedef SurfaceDescriptorMacIOSurface SurfaceDescriptorMacIOSurface__tdef;
    typedef null_t null_t__tdef;

    union Value {
        mozilla::AlignedStorage2<SurfaceDescriptorD3D10> VSurfaceDescriptorD3D10;
        mozilla::AlignedStorage2<SurfaceDescriptorDXGIYCbCr> VSurfaceDescriptorDXGIYCbCr;
        mozilla::AlignedStorage2<SurfaceDescriptorDMABuf> VSurfaceDescriptorDMABuf;
        mozilla::AlignedStorage2<SurfaceDescriptorMacIOSurface> VSurfaceDescriptorMacIOSurface;
        mozilla::AlignedStorage2<null_t> Vnull_t;
    };

    SurfaceDescriptorD3D10*
    ptr_SurfaceDescriptorD3D10()
    {
        return ((mValue).VSurfaceDescriptorD3D10).addr();
    }
    const SurfaceDescriptorD3D10*
    constptr_SurfaceDescriptorD3D10() const
    {
        return ((mValue).VSurfaceDescriptorD3D10).addr();
    }
    SurfaceDescriptorDXGIYCbCr*
    ptr_SurfaceDescriptorDXGIYCbCr()
    {
        return ((mValue).VSurfaceDescriptorDXGIYCbCr).addr();
    }
    const SurfaceDescriptorDXGIYCbCr*
    constptr_SurfaceDescriptorDXGIYCbCr() const
    {
        return ((mValue).VSurfaceDescriptorDXGIYCbCr).addr();
    }
    SurfaceDescriptorDMABuf*
    ptr_SurfaceDescriptorDMABuf()
    {
        return ((mValue).VSurfaceDescriptorDMABuf).addr();
    }
    const SurfaceDescriptorDMABuf*
    constptr_SurfaceDescriptorDMABuf() const
    {
        return ((mValue).VSurfaceDescriptorDMABuf).addr();
    }
    SurfaceDescriptorMacIOSurface*
    ptr_SurfaceDescriptorMacIOSurface()
    {
        return ((mValue).VSurfaceDescriptorMacIOSurface).addr();
    }
    const SurfaceDescriptorMacIOSurface*
    constptr_SurfaceDescriptorMacIOSurface() const
    {
        return ((mValue).VSurfaceDescriptorMacIOSurface).addr();
    }
    null_t*
    ptr_null_t()
    {
        return ((mValue).Vnull_t).addr();
    }
    const null_t*
    constptr_null_t() const
    {
        return ((mValue).Vnull_t).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT RemoteDecoderVideoSubDescriptor() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT RemoteDecoderVideoSubDescriptor(const SurfaceDescriptorD3D10& aOther);

    MOZ_IMPLICIT RemoteDecoderVideoSubDescriptor(SurfaceDescriptorD3D10&& aOther);

    MOZ_IMPLICIT RemoteDecoderVideoSubDescriptor(const SurfaceDescriptorDXGIYCbCr& aOther);

    MOZ_IMPLICIT RemoteDecoderVideoSubDescriptor(SurfaceDescriptorDXGIYCbCr&& aOther);

    MOZ_IMPLICIT RemoteDecoderVideoSubDescriptor(const SurfaceDescriptorDMABuf& aOther);

    MOZ_IMPLICIT RemoteDecoderVideoSubDescriptor(SurfaceDescriptorDMABuf&& aOther);

    MOZ_IMPLICIT RemoteDecoderVideoSubDescriptor(const SurfaceDescriptorMacIOSurface& aOther);

    MOZ_IMPLICIT RemoteDecoderVideoSubDescriptor(SurfaceDescriptorMacIOSurface&& aOther);

    MOZ_IMPLICIT RemoteDecoderVideoSubDescriptor(const null_t& aOther);

    MOZ_IMPLICIT RemoteDecoderVideoSubDescriptor(null_t&& aOther);

    MOZ_IMPLICIT RemoteDecoderVideoSubDescriptor(const RemoteDecoderVideoSubDescriptor& aOther);

    MOZ_IMPLICIT RemoteDecoderVideoSubDescriptor(RemoteDecoderVideoSubDescriptor&& aOther);

    ~RemoteDecoderVideoSubDescriptor();

    Type
    type() const
    {
        return mType;
    }

    RemoteDecoderVideoSubDescriptor&
    operator=(const SurfaceDescriptorD3D10& aRhs);

    RemoteDecoderVideoSubDescriptor&
    operator=(SurfaceDescriptorD3D10&& aRhs);

    RemoteDecoderVideoSubDescriptor&
    operator=(const SurfaceDescriptorDXGIYCbCr& aRhs);

    RemoteDecoderVideoSubDescriptor&
    operator=(SurfaceDescriptorDXGIYCbCr&& aRhs);

    RemoteDecoderVideoSubDescriptor&
    operator=(const SurfaceDescriptorDMABuf& aRhs);

    RemoteDecoderVideoSubDescriptor&
    operator=(SurfaceDescriptorDMABuf&& aRhs);

    RemoteDecoderVideoSubDescriptor&
    operator=(const SurfaceDescriptorMacIOSurface& aRhs);

    RemoteDecoderVideoSubDescriptor&
    operator=(SurfaceDescriptorMacIOSurface&& aRhs);

    RemoteDecoderVideoSubDescriptor&
    operator=(const null_t& aRhs);

    RemoteDecoderVideoSubDescriptor&
    operator=(null_t&& aRhs);

    RemoteDecoderVideoSubDescriptor&
    operator=(const RemoteDecoderVideoSubDescriptor& aRhs);

    RemoteDecoderVideoSubDescriptor&
    operator=(RemoteDecoderVideoSubDescriptor&& aRhs);

    bool
    operator==(const SurfaceDescriptorD3D10& aRhs) const;

    bool
    operator==(const SurfaceDescriptorDXGIYCbCr& aRhs) const;

    bool
    operator==(const SurfaceDescriptorDMABuf& aRhs) const;

    bool
    operator==(const SurfaceDescriptorMacIOSurface& aRhs) const;

    bool
    operator==(const null_t& aRhs) const;

    bool
    operator==(const RemoteDecoderVideoSubDescriptor& aRhs) const;

    SurfaceDescriptorD3D10&
    get_SurfaceDescriptorD3D10()
    {
        AssertSanity(TSurfaceDescriptorD3D10);
        return (*(ptr_SurfaceDescriptorD3D10()));
    }
    const SurfaceDescriptorD3D10&
    get_SurfaceDescriptorD3D10() const
    {
        AssertSanity(TSurfaceDescriptorD3D10);
        return (*(constptr_SurfaceDescriptorD3D10()));
    }
    operator SurfaceDescriptorD3D10&()
    {
        return get_SurfaceDescriptorD3D10();
    }
    operator const SurfaceDescriptorD3D10&() const
    {
        return get_SurfaceDescriptorD3D10();
    }

    SurfaceDescriptorDXGIYCbCr&
    get_SurfaceDescriptorDXGIYCbCr()
    {
        AssertSanity(TSurfaceDescriptorDXGIYCbCr);
        return (*(ptr_SurfaceDescriptorDXGIYCbCr()));
    }
    const SurfaceDescriptorDXGIYCbCr&
    get_SurfaceDescriptorDXGIYCbCr() const
    {
        AssertSanity(TSurfaceDescriptorDXGIYCbCr);
        return (*(constptr_SurfaceDescriptorDXGIYCbCr()));
    }
    operator SurfaceDescriptorDXGIYCbCr&()
    {
        return get_SurfaceDescriptorDXGIYCbCr();
    }
    operator const SurfaceDescriptorDXGIYCbCr&() const
    {
        return get_SurfaceDescriptorDXGIYCbCr();
    }

    SurfaceDescriptorDMABuf&
    get_SurfaceDescriptorDMABuf()
    {
        AssertSanity(TSurfaceDescriptorDMABuf);
        return (*(ptr_SurfaceDescriptorDMABuf()));
    }
    const SurfaceDescriptorDMABuf&
    get_SurfaceDescriptorDMABuf() const
    {
        AssertSanity(TSurfaceDescriptorDMABuf);
        return (*(constptr_SurfaceDescriptorDMABuf()));
    }
    operator SurfaceDescriptorDMABuf&()
    {
        return get_SurfaceDescriptorDMABuf();
    }
    operator const SurfaceDescriptorDMABuf&() const
    {
        return get_SurfaceDescriptorDMABuf();
    }

    SurfaceDescriptorMacIOSurface&
    get_SurfaceDescriptorMacIOSurface()
    {
        AssertSanity(TSurfaceDescriptorMacIOSurface);
        return (*(ptr_SurfaceDescriptorMacIOSurface()));
    }
    const SurfaceDescriptorMacIOSurface&
    get_SurfaceDescriptorMacIOSurface() const
    {
        AssertSanity(TSurfaceDescriptorMacIOSurface);
        return (*(constptr_SurfaceDescriptorMacIOSurface()));
    }
    operator SurfaceDescriptorMacIOSurface&()
    {
        return get_SurfaceDescriptorMacIOSurface();
    }
    operator const SurfaceDescriptorMacIOSurface&() const
    {
        return get_SurfaceDescriptorMacIOSurface();
    }

    null_t&
    get_null_t()
    {
        AssertSanity(Tnull_t);
        return (*(ptr_null_t()));
    }
    const null_t&
    get_null_t() const
    {
        AssertSanity(Tnull_t);
        return (*(constptr_null_t()));
    }
    operator null_t&()
    {
        return get_null_t();
    }
    operator const null_t&() const
    {
        return get_null_t();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::RemoteDecoderVideoSubDescriptor>
{
    typedef mozilla::layers::RemoteDecoderVideoSubDescriptor paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SurfaceDescriptorRemoteDecoder|
//
namespace mozilla {
namespace layers {
class SurfaceDescriptorRemoteDecoder final
{
private:
    typedef mozilla::layers::RemoteDecoderVideoSubDescriptor RemoteDecoderVideoSubDescriptor;
    typedef mozilla::layers::MaybeVideoBridgeSource MaybeVideoBridgeSource;

public:
    MOZ_IMPLICIT SurfaceDescriptorRemoteDecoder() :
        subdesc_(),
        source_(),
        handle_()
    {
    }

    MOZ_IMPLICIT SurfaceDescriptorRemoteDecoder(
            const uint64_t& _handle,
            const RemoteDecoderVideoSubDescriptor& _subdesc,
            const MaybeVideoBridgeSource& _source) :
        subdesc_(_subdesc),
        source_(_source),
        handle_(_handle)
    {
    }

    bool
    operator==(const SurfaceDescriptorRemoteDecoder& _o) const;

    bool
    operator!=(const SurfaceDescriptorRemoteDecoder& _o) const;

    uint64_t&
    handle()
    {
        return handle_;
    }
    const uint64_t&
    handle() const
    {
        return handle_;
    }

    RemoteDecoderVideoSubDescriptor&
    subdesc()
    {
        return subdesc_;
    }
    const RemoteDecoderVideoSubDescriptor&
    subdesc() const
    {
        return subdesc_;
    }

    MaybeVideoBridgeSource&
    source()
    {
        return source_;
    }
    const MaybeVideoBridgeSource&
    source() const
    {
        return source_;
    }

private:
    RemoteDecoderVideoSubDescriptor subdesc_;
    MaybeVideoBridgeSource source_;
    uint64_t handle_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::SurfaceDescriptorRemoteDecoder>
{
    typedef mozilla::layers::SurfaceDescriptorRemoteDecoder paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SurfaceDescriptorPlugin|
//
namespace mozilla {
namespace layers {
class SurfaceDescriptorPlugin final
{
private:
    typedef mozilla::layers::SurfaceDescriptorD3D10 SurfaceDescriptorD3D10;

public:
    MOZ_IMPLICIT SurfaceDescriptorPlugin() :
        pluginSurf_(),
        displaySurf_(),
        id_()
    {
    }

    MOZ_IMPLICIT SurfaceDescriptorPlugin(
            const uint64_t& _id,
            const SurfaceDescriptorD3D10& _pluginSurf,
            const SurfaceDescriptorD3D10& _displaySurf) :
        pluginSurf_(_pluginSurf),
        displaySurf_(_displaySurf),
        id_(_id)
    {
    }

    bool
    operator==(const SurfaceDescriptorPlugin& _o) const;

    bool
    operator!=(const SurfaceDescriptorPlugin& _o) const;

    uint64_t&
    id()
    {
        return id_;
    }
    const uint64_t&
    id() const
    {
        return id_;
    }

    SurfaceDescriptorD3D10&
    pluginSurf()
    {
        return pluginSurf_;
    }
    const SurfaceDescriptorD3D10&
    pluginSurf() const
    {
        return pluginSurf_;
    }

    SurfaceDescriptorD3D10&
    displaySurf()
    {
        return displaySurf_;
    }
    const SurfaceDescriptorD3D10&
    displaySurf() const
    {
        return displaySurf_;
    }

private:
    SurfaceDescriptorD3D10 pluginSurf_;
    SurfaceDescriptorD3D10 displaySurf_;
    uint64_t id_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::SurfaceDescriptorPlugin>
{
    typedef mozilla::layers::SurfaceDescriptorPlugin paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union SurfaceDescriptorGPUVideo|
//
namespace mozilla {
namespace layers {
class SurfaceDescriptorGPUVideo final
{
public:
    enum Type {
        T__None,
        TSurfaceDescriptorRemoteDecoder = 1,
        TSurfaceDescriptorPlugin,
        T__Last = TSurfaceDescriptorPlugin
    };

private:
    typedef mozilla::layers::SurfaceDescriptorRemoteDecoder SurfaceDescriptorRemoteDecoder;
    typedef mozilla::layers::SurfaceDescriptorPlugin SurfaceDescriptorPlugin;
    typedef SurfaceDescriptorRemoteDecoder SurfaceDescriptorRemoteDecoder__tdef;
    typedef SurfaceDescriptorPlugin SurfaceDescriptorPlugin__tdef;

    union Value {
        mozilla::AlignedStorage2<SurfaceDescriptorRemoteDecoder> VSurfaceDescriptorRemoteDecoder;
        mozilla::AlignedStorage2<SurfaceDescriptorPlugin> VSurfaceDescriptorPlugin;
    };

    SurfaceDescriptorRemoteDecoder*
    ptr_SurfaceDescriptorRemoteDecoder()
    {
        return ((mValue).VSurfaceDescriptorRemoteDecoder).addr();
    }
    const SurfaceDescriptorRemoteDecoder*
    constptr_SurfaceDescriptorRemoteDecoder() const
    {
        return ((mValue).VSurfaceDescriptorRemoteDecoder).addr();
    }
    SurfaceDescriptorPlugin*
    ptr_SurfaceDescriptorPlugin()
    {
        return ((mValue).VSurfaceDescriptorPlugin).addr();
    }
    const SurfaceDescriptorPlugin*
    constptr_SurfaceDescriptorPlugin() const
    {
        return ((mValue).VSurfaceDescriptorPlugin).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT SurfaceDescriptorGPUVideo() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT SurfaceDescriptorGPUVideo(const SurfaceDescriptorRemoteDecoder& aOther);

    MOZ_IMPLICIT SurfaceDescriptorGPUVideo(SurfaceDescriptorRemoteDecoder&& aOther);

    MOZ_IMPLICIT SurfaceDescriptorGPUVideo(const SurfaceDescriptorPlugin& aOther);

    MOZ_IMPLICIT SurfaceDescriptorGPUVideo(SurfaceDescriptorPlugin&& aOther);

    MOZ_IMPLICIT SurfaceDescriptorGPUVideo(const SurfaceDescriptorGPUVideo& aOther);

    MOZ_IMPLICIT SurfaceDescriptorGPUVideo(SurfaceDescriptorGPUVideo&& aOther);

    ~SurfaceDescriptorGPUVideo();

    Type
    type() const
    {
        return mType;
    }

    SurfaceDescriptorGPUVideo&
    operator=(const SurfaceDescriptorRemoteDecoder& aRhs);

    SurfaceDescriptorGPUVideo&
    operator=(SurfaceDescriptorRemoteDecoder&& aRhs);

    SurfaceDescriptorGPUVideo&
    operator=(const SurfaceDescriptorPlugin& aRhs);

    SurfaceDescriptorGPUVideo&
    operator=(SurfaceDescriptorPlugin&& aRhs);

    SurfaceDescriptorGPUVideo&
    operator=(const SurfaceDescriptorGPUVideo& aRhs);

    SurfaceDescriptorGPUVideo&
    operator=(SurfaceDescriptorGPUVideo&& aRhs);

    bool
    operator==(const SurfaceDescriptorRemoteDecoder& aRhs) const;

    bool
    operator==(const SurfaceDescriptorPlugin& aRhs) const;

    bool
    operator==(const SurfaceDescriptorGPUVideo& aRhs) const;

    SurfaceDescriptorRemoteDecoder&
    get_SurfaceDescriptorRemoteDecoder()
    {
        AssertSanity(TSurfaceDescriptorRemoteDecoder);
        return (*(ptr_SurfaceDescriptorRemoteDecoder()));
    }
    const SurfaceDescriptorRemoteDecoder&
    get_SurfaceDescriptorRemoteDecoder() const
    {
        AssertSanity(TSurfaceDescriptorRemoteDecoder);
        return (*(constptr_SurfaceDescriptorRemoteDecoder()));
    }
    operator SurfaceDescriptorRemoteDecoder&()
    {
        return get_SurfaceDescriptorRemoteDecoder();
    }
    operator const SurfaceDescriptorRemoteDecoder&() const
    {
        return get_SurfaceDescriptorRemoteDecoder();
    }

    SurfaceDescriptorPlugin&
    get_SurfaceDescriptorPlugin()
    {
        AssertSanity(TSurfaceDescriptorPlugin);
        return (*(ptr_SurfaceDescriptorPlugin()));
    }
    const SurfaceDescriptorPlugin&
    get_SurfaceDescriptorPlugin() const
    {
        AssertSanity(TSurfaceDescriptorPlugin);
        return (*(constptr_SurfaceDescriptorPlugin()));
    }
    operator SurfaceDescriptorPlugin&()
    {
        return get_SurfaceDescriptorPlugin();
    }
    operator const SurfaceDescriptorPlugin&() const
    {
        return get_SurfaceDescriptorPlugin();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::SurfaceDescriptorGPUVideo>
{
    typedef mozilla::layers::SurfaceDescriptorGPUVideo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct RGBDescriptor|
//
namespace mozilla {
namespace layers {
class RGBDescriptor final
{
private:
    typedef mozilla::gfx::IntSize IntSize;
    typedef mozilla::gfx::SurfaceFormat SurfaceFormat;

public:
    MOZ_IMPLICIT RGBDescriptor() :
        size_(),
        format_(),
        hasIntermediateBuffer_()
    {
    }

    MOZ_IMPLICIT RGBDescriptor(
            const IntSize& _size,
            const SurfaceFormat& _format,
            const bool& _hasIntermediateBuffer) :
        size_(_size),
        format_(_format),
        hasIntermediateBuffer_(_hasIntermediateBuffer)
    {
    }

    bool
    operator==(const RGBDescriptor& _o) const;

    bool
    operator!=(const RGBDescriptor& _o) const;

    IntSize&
    size()
    {
        return size_;
    }
    const IntSize&
    size() const
    {
        return size_;
    }

    SurfaceFormat&
    format()
    {
        return format_;
    }
    const SurfaceFormat&
    format() const
    {
        return format_;
    }

    bool&
    hasIntermediateBuffer()
    {
        return hasIntermediateBuffer_;
    }
    const bool&
    hasIntermediateBuffer() const
    {
        return hasIntermediateBuffer_;
    }

private:
    IntSize size_;
    SurfaceFormat format_;
    bool hasIntermediateBuffer_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::RGBDescriptor>
{
    typedef mozilla::layers::RGBDescriptor paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct YCbCrDescriptor|
//
namespace mozilla {
namespace layers {
class YCbCrDescriptor final
{
private:
    typedef mozilla::gfx::IntRect IntRect;
    typedef mozilla::gfx::IntSize IntSize;
    typedef mozilla::StereoMode StereoMode;
    typedef mozilla::gfx::ColorDepth ColorDepth;
    typedef mozilla::gfx::YUVColorSpace YUVColorSpace;
    typedef mozilla::gfx::ColorRange ColorRange;

public:
    MOZ_IMPLICIT YCbCrDescriptor() :
        display_(),
        ySize_(),
        cbCrSize_(),
        stereoMode_(),
        colorDepth_(),
        yUVColorSpace_(),
        colorRange_(),
        hasIntermediateBuffer_(),
        yStride_(),
        cbCrStride_(),
        yOffset_(),
        cbOffset_(),
        crOffset_()
    {
    }

    MOZ_IMPLICIT YCbCrDescriptor(
            const IntRect& _display,
            const IntSize& _ySize,
            const uint32_t& _yStride,
            const IntSize& _cbCrSize,
            const uint32_t& _cbCrStride,
            const uint32_t& _yOffset,
            const uint32_t& _cbOffset,
            const uint32_t& _crOffset,
            const StereoMode& _stereoMode,
            const ColorDepth& _colorDepth,
            const YUVColorSpace& _yUVColorSpace,
            const ColorRange& _colorRange,
            const bool& _hasIntermediateBuffer) :
        display_(_display),
        ySize_(_ySize),
        cbCrSize_(_cbCrSize),
        stereoMode_(_stereoMode),
        colorDepth_(_colorDepth),
        yUVColorSpace_(_yUVColorSpace),
        colorRange_(_colorRange),
        hasIntermediateBuffer_(_hasIntermediateBuffer),
        yStride_(_yStride),
        cbCrStride_(_cbCrStride),
        yOffset_(_yOffset),
        cbOffset_(_cbOffset),
        crOffset_(_crOffset)
    {
    }

    bool
    operator==(const YCbCrDescriptor& _o) const;

    bool
    operator!=(const YCbCrDescriptor& _o) const;

    IntRect&
    display()
    {
        return display_;
    }
    const IntRect&
    display() const
    {
        return display_;
    }

    IntSize&
    ySize()
    {
        return ySize_;
    }
    const IntSize&
    ySize() const
    {
        return ySize_;
    }

    uint32_t&
    yStride()
    {
        return yStride_;
    }
    const uint32_t&
    yStride() const
    {
        return yStride_;
    }

    IntSize&
    cbCrSize()
    {
        return cbCrSize_;
    }
    const IntSize&
    cbCrSize() const
    {
        return cbCrSize_;
    }

    uint32_t&
    cbCrStride()
    {
        return cbCrStride_;
    }
    const uint32_t&
    cbCrStride() const
    {
        return cbCrStride_;
    }

    uint32_t&
    yOffset()
    {
        return yOffset_;
    }
    const uint32_t&
    yOffset() const
    {
        return yOffset_;
    }

    uint32_t&
    cbOffset()
    {
        return cbOffset_;
    }
    const uint32_t&
    cbOffset() const
    {
        return cbOffset_;
    }

    uint32_t&
    crOffset()
    {
        return crOffset_;
    }
    const uint32_t&
    crOffset() const
    {
        return crOffset_;
    }

    StereoMode&
    stereoMode()
    {
        return stereoMode_;
    }
    const StereoMode&
    stereoMode() const
    {
        return stereoMode_;
    }

    ColorDepth&
    colorDepth()
    {
        return colorDepth_;
    }
    const ColorDepth&
    colorDepth() const
    {
        return colorDepth_;
    }

    YUVColorSpace&
    yUVColorSpace()
    {
        return yUVColorSpace_;
    }
    const YUVColorSpace&
    yUVColorSpace() const
    {
        return yUVColorSpace_;
    }

    ColorRange&
    colorRange()
    {
        return colorRange_;
    }
    const ColorRange&
    colorRange() const
    {
        return colorRange_;
    }

    bool&
    hasIntermediateBuffer()
    {
        return hasIntermediateBuffer_;
    }
    const bool&
    hasIntermediateBuffer() const
    {
        return hasIntermediateBuffer_;
    }

private:
    void
    StaticAssertions() const;
    IntRect display_;
    IntSize ySize_;
    IntSize cbCrSize_;
    StereoMode stereoMode_;
    ColorDepth colorDepth_;
    YUVColorSpace yUVColorSpace_;
    ColorRange colorRange_;
    bool hasIntermediateBuffer_;
    uint32_t yStride_;
    uint32_t cbCrStride_;
    uint32_t yOffset_;
    uint32_t cbOffset_;
    uint32_t crOffset_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::YCbCrDescriptor>
{
    typedef mozilla::layers::YCbCrDescriptor paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union BufferDescriptor|
//
namespace mozilla {
namespace layers {
class BufferDescriptor final
{
public:
    enum Type {
        T__None,
        TRGBDescriptor = 1,
        TYCbCrDescriptor,
        T__Last = TYCbCrDescriptor
    };

private:
    typedef mozilla::layers::RGBDescriptor RGBDescriptor;
    typedef mozilla::layers::YCbCrDescriptor YCbCrDescriptor;
    typedef RGBDescriptor RGBDescriptor__tdef;
    typedef YCbCrDescriptor YCbCrDescriptor__tdef;

    union Value {
        mozilla::AlignedStorage2<RGBDescriptor> VRGBDescriptor;
        mozilla::AlignedStorage2<YCbCrDescriptor> VYCbCrDescriptor;
    };

    RGBDescriptor*
    ptr_RGBDescriptor()
    {
        return ((mValue).VRGBDescriptor).addr();
    }
    const RGBDescriptor*
    constptr_RGBDescriptor() const
    {
        return ((mValue).VRGBDescriptor).addr();
    }
    YCbCrDescriptor*
    ptr_YCbCrDescriptor()
    {
        return ((mValue).VYCbCrDescriptor).addr();
    }
    const YCbCrDescriptor*
    constptr_YCbCrDescriptor() const
    {
        return ((mValue).VYCbCrDescriptor).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT BufferDescriptor() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT BufferDescriptor(const RGBDescriptor& aOther);

    MOZ_IMPLICIT BufferDescriptor(RGBDescriptor&& aOther);

    MOZ_IMPLICIT BufferDescriptor(const YCbCrDescriptor& aOther);

    MOZ_IMPLICIT BufferDescriptor(YCbCrDescriptor&& aOther);

    MOZ_IMPLICIT BufferDescriptor(const BufferDescriptor& aOther);

    MOZ_IMPLICIT BufferDescriptor(BufferDescriptor&& aOther);

    ~BufferDescriptor();

    Type
    type() const
    {
        return mType;
    }

    BufferDescriptor&
    operator=(const RGBDescriptor& aRhs);

    BufferDescriptor&
    operator=(RGBDescriptor&& aRhs);

    BufferDescriptor&
    operator=(const YCbCrDescriptor& aRhs);

    BufferDescriptor&
    operator=(YCbCrDescriptor&& aRhs);

    BufferDescriptor&
    operator=(const BufferDescriptor& aRhs);

    BufferDescriptor&
    operator=(BufferDescriptor&& aRhs);

    bool
    operator==(const RGBDescriptor& aRhs) const;

    bool
    operator==(const YCbCrDescriptor& aRhs) const;

    bool
    operator==(const BufferDescriptor& aRhs) const;

    RGBDescriptor&
    get_RGBDescriptor()
    {
        AssertSanity(TRGBDescriptor);
        return (*(ptr_RGBDescriptor()));
    }
    const RGBDescriptor&
    get_RGBDescriptor() const
    {
        AssertSanity(TRGBDescriptor);
        return (*(constptr_RGBDescriptor()));
    }
    operator RGBDescriptor&()
    {
        return get_RGBDescriptor();
    }
    operator const RGBDescriptor&() const
    {
        return get_RGBDescriptor();
    }

    YCbCrDescriptor&
    get_YCbCrDescriptor()
    {
        AssertSanity(TYCbCrDescriptor);
        return (*(ptr_YCbCrDescriptor()));
    }
    const YCbCrDescriptor&
    get_YCbCrDescriptor() const
    {
        AssertSanity(TYCbCrDescriptor);
        return (*(constptr_YCbCrDescriptor()));
    }
    operator YCbCrDescriptor&()
    {
        return get_YCbCrDescriptor();
    }
    operator const YCbCrDescriptor&() const
    {
        return get_YCbCrDescriptor();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::BufferDescriptor>
{
    typedef mozilla::layers::BufferDescriptor paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union MemoryOrShmem|
//
namespace mozilla {
namespace layers {
class MemoryOrShmem final
{
public:
    enum Type {
        T__None,
        Tuintptr_t = 1,
        TShmem,
        T__Last = TShmem
    };

private:
    typedef mozilla::ipc::Shmem Shmem;
    typedef uintptr_t uintptr_t__tdef;
    typedef Shmem Shmem__tdef;

    union Value {
        mozilla::AlignedStorage2<uintptr_t> Vuintptr_t;
        mozilla::AlignedStorage2<Shmem> VShmem;
    };

    uintptr_t*
    ptr_uintptr_t()
    {
        return ((mValue).Vuintptr_t).addr();
    }
    const uintptr_t*
    constptr_uintptr_t() const
    {
        return ((mValue).Vuintptr_t).addr();
    }
    Shmem*
    ptr_Shmem()
    {
        return ((mValue).VShmem).addr();
    }
    const Shmem*
    constptr_Shmem() const
    {
        return ((mValue).VShmem).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT MemoryOrShmem() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT MemoryOrShmem(const uintptr_t& aOther);

    MOZ_IMPLICIT MemoryOrShmem(uintptr_t&& aOther);

    MOZ_IMPLICIT MemoryOrShmem(Shmem&& aOther);

    MOZ_IMPLICIT MemoryOrShmem(const MemoryOrShmem& aOther);

    MOZ_IMPLICIT MemoryOrShmem(MemoryOrShmem&& aOther);

    ~MemoryOrShmem();

    Type
    type() const
    {
        return mType;
    }

    MemoryOrShmem&
    operator=(const uintptr_t& aRhs);

    MemoryOrShmem&
    operator=(uintptr_t&& aRhs);

    MemoryOrShmem&
    operator=(Shmem&& aRhs);

    MemoryOrShmem&
    operator=(const MemoryOrShmem& aRhs);

    MemoryOrShmem&
    operator=(MemoryOrShmem&& aRhs);

    bool
    operator==(const uintptr_t& aRhs) const;

    bool
    operator==(Shmem&& aRhs) const;

    bool
    operator==(const MemoryOrShmem& aRhs) const;

    uintptr_t&
    get_uintptr_t()
    {
        AssertSanity(Tuintptr_t);
        return (*(ptr_uintptr_t()));
    }
    const uintptr_t&
    get_uintptr_t() const
    {
        AssertSanity(Tuintptr_t);
        return (*(constptr_uintptr_t()));
    }
    operator uintptr_t&()
    {
        return get_uintptr_t();
    }
    operator const uintptr_t&() const
    {
        return get_uintptr_t();
    }

    Shmem&
    get_Shmem()
    {
        AssertSanity(TShmem);
        return (*(ptr_Shmem()));
    }
    Shmem&
    get_Shmem() const
    {
        AssertSanity(TShmem);
        return const_cast<Shmem&>((*(constptr_Shmem())));
    }
    operator Shmem&()
    {
        return get_Shmem();
    }
    operator Shmem&() const
    {
        return get_Shmem();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::MemoryOrShmem>
{
    typedef mozilla::layers::MemoryOrShmem paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SurfaceDescriptorBuffer|
//
namespace mozilla {
namespace layers {
class SurfaceDescriptorBuffer final
{
private:
    typedef mozilla::layers::BufferDescriptor BufferDescriptor;
    typedef mozilla::layers::MemoryOrShmem MemoryOrShmem;

public:
    MOZ_IMPLICIT SurfaceDescriptorBuffer() :
        desc_(),
        data_()
    {
    }

    MOZ_IMPLICIT SurfaceDescriptorBuffer(
            const BufferDescriptor& _desc,
            const MemoryOrShmem& _data) :
        desc_(_desc),
        data_(_data)
    {
    }

    bool
    operator==(const SurfaceDescriptorBuffer& _o) const;

    bool
    operator!=(const SurfaceDescriptorBuffer& _o) const;

    BufferDescriptor&
    desc()
    {
        return desc_;
    }
    const BufferDescriptor&
    desc() const
    {
        return desc_;
    }

    MemoryOrShmem&
    data()
    {
        return data_;
    }
    const MemoryOrShmem&
    data() const
    {
        return data_;
    }

private:
    BufferDescriptor desc_;
    MemoryOrShmem data_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::SurfaceDescriptorBuffer>
{
    typedef mozilla::layers::SurfaceDescriptorBuffer paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SurfaceDescriptorShared|
//
namespace mozilla {
namespace layers {
class SurfaceDescriptorShared final
{
private:
    typedef mozilla::gfx::IntSize IntSize;
    typedef mozilla::gfx::SurfaceFormat SurfaceFormat;
    typedef mozilla::ipc::SharedMemoryBasic::Handle Handle;

public:
    MOZ_IMPLICIT SurfaceDescriptorShared() :
        size_(),
        format_(),
        handle_(),
        stride_()
    {
    }

    MOZ_IMPLICIT SurfaceDescriptorShared(
            const IntSize& _size,
            const int32_t& _stride,
            const SurfaceFormat& _format,
            const Handle& _handle) :
        size_(_size),
        format_(_format),
        handle_(_handle),
        stride_(_stride)
    {
    }

    bool
    operator==(const SurfaceDescriptorShared& _o) const;

    bool
    operator!=(const SurfaceDescriptorShared& _o) const;

    IntSize&
    size()
    {
        return size_;
    }
    const IntSize&
    size() const
    {
        return size_;
    }

    int32_t&
    stride()
    {
        return stride_;
    }
    const int32_t&
    stride() const
    {
        return stride_;
    }

    SurfaceFormat&
    format()
    {
        return format_;
    }
    const SurfaceFormat&
    format() const
    {
        return format_;
    }

    Handle&
    handle()
    {
        return handle_;
    }
    const Handle&
    handle() const
    {
        return handle_;
    }

private:
    IntSize size_;
    SurfaceFormat format_;
    Handle handle_;
    int32_t stride_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::SurfaceDescriptorShared>
{
    typedef mozilla::layers::SurfaceDescriptorShared paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SurfaceDescriptorRecorded|
//
namespace mozilla {
namespace layers {
class SurfaceDescriptorRecorded final
{
private:

public:
    MOZ_IMPLICIT SurfaceDescriptorRecorded() :
        textureId_()
    {
    }

    MOZ_IMPLICIT SurfaceDescriptorRecorded(const int64_t& _textureId) :
        textureId_(_textureId)
    {
    }

    bool
    operator==(const SurfaceDescriptorRecorded& _o) const;

    bool
    operator!=(const SurfaceDescriptorRecorded& _o) const;

    int64_t&
    textureId()
    {
        return textureId_;
    }
    const int64_t&
    textureId() const
    {
        return textureId_;
    }

private:
    int64_t textureId_;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::SurfaceDescriptorRecorded>
{
    typedef mozilla::layers::SurfaceDescriptorRecorded paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union SurfaceDescriptor|
//
namespace mozilla {
namespace layers {
class SurfaceDescriptor final
{
public:
    enum Type {
        T__None,
        TSurfaceDescriptorBuffer = 1,
        TSurfaceDescriptorDIB,
        TSurfaceDescriptorD3D10,
        TSurfaceDescriptorFileMapping,
        TSurfaceDescriptorDXGIYCbCr,
        TSurfaceDescriptorX11,
        TSurfaceDescriptorDMABuf,
        TSurfaceTextureDescriptor,
        TSurfaceDescriptorAndroidHardwareBuffer,
        TEGLImageDescriptor,
        TSurfaceDescriptorMacIOSurface,
        TSurfaceDescriptorSharedGLTexture,
        TSurfaceDescriptorGPUVideo,
        TSurfaceDescriptorRecorded,
        Tnull_t,
        T__Last = Tnull_t
    };

private:
    typedef mozilla::layers::SurfaceDescriptorBuffer SurfaceDescriptorBuffer;
    typedef mozilla::layers::SurfaceDescriptorDIB SurfaceDescriptorDIB;
    typedef mozilla::layers::SurfaceDescriptorD3D10 SurfaceDescriptorD3D10;
    typedef mozilla::layers::SurfaceDescriptorFileMapping SurfaceDescriptorFileMapping;
    typedef mozilla::layers::SurfaceDescriptorDXGIYCbCr SurfaceDescriptorDXGIYCbCr;
    typedef mozilla::layers::SurfaceDescriptorX11 SurfaceDescriptorX11;
    typedef mozilla::layers::SurfaceDescriptorDMABuf SurfaceDescriptorDMABuf;
    typedef mozilla::layers::SurfaceTextureDescriptor SurfaceTextureDescriptor;
    typedef mozilla::layers::SurfaceDescriptorAndroidHardwareBuffer SurfaceDescriptorAndroidHardwareBuffer;
    typedef mozilla::layers::EGLImageDescriptor EGLImageDescriptor;
    typedef mozilla::layers::SurfaceDescriptorMacIOSurface SurfaceDescriptorMacIOSurface;
    typedef mozilla::layers::SurfaceDescriptorSharedGLTexture SurfaceDescriptorSharedGLTexture;
    typedef mozilla::layers::SurfaceDescriptorGPUVideo SurfaceDescriptorGPUVideo;
    typedef mozilla::layers::SurfaceDescriptorRecorded SurfaceDescriptorRecorded;
    typedef mozilla::null_t null_t;
    typedef SurfaceDescriptorBuffer SurfaceDescriptorBuffer__tdef;
    typedef SurfaceDescriptorDIB SurfaceDescriptorDIB__tdef;
    typedef SurfaceDescriptorD3D10 SurfaceDescriptorD3D10__tdef;
    typedef SurfaceDescriptorFileMapping SurfaceDescriptorFileMapping__tdef;
    typedef SurfaceDescriptorDXGIYCbCr SurfaceDescriptorDXGIYCbCr__tdef;
    typedef SurfaceDescriptorX11 SurfaceDescriptorX11__tdef;
    typedef SurfaceDescriptorDMABuf SurfaceDescriptorDMABuf__tdef;
    typedef SurfaceTextureDescriptor SurfaceTextureDescriptor__tdef;
    typedef SurfaceDescriptorAndroidHardwareBuffer SurfaceDescriptorAndroidHardwareBuffer__tdef;
    typedef EGLImageDescriptor EGLImageDescriptor__tdef;
    typedef SurfaceDescriptorMacIOSurface SurfaceDescriptorMacIOSurface__tdef;
    typedef SurfaceDescriptorSharedGLTexture SurfaceDescriptorSharedGLTexture__tdef;
    typedef SurfaceDescriptorGPUVideo SurfaceDescriptorGPUVideo__tdef;
    typedef SurfaceDescriptorRecorded SurfaceDescriptorRecorded__tdef;
    typedef null_t null_t__tdef;

    union Value {
        mozilla::AlignedStorage2<SurfaceDescriptorBuffer> VSurfaceDescriptorBuffer;
        mozilla::AlignedStorage2<SurfaceDescriptorDIB> VSurfaceDescriptorDIB;
        mozilla::AlignedStorage2<SurfaceDescriptorD3D10> VSurfaceDescriptorD3D10;
        mozilla::AlignedStorage2<SurfaceDescriptorFileMapping> VSurfaceDescriptorFileMapping;
        mozilla::AlignedStorage2<SurfaceDescriptorDXGIYCbCr> VSurfaceDescriptorDXGIYCbCr;
        mozilla::AlignedStorage2<SurfaceDescriptorX11> VSurfaceDescriptorX11;
        mozilla::AlignedStorage2<SurfaceDescriptorDMABuf> VSurfaceDescriptorDMABuf;
        mozilla::AlignedStorage2<SurfaceTextureDescriptor> VSurfaceTextureDescriptor;
        mozilla::AlignedStorage2<SurfaceDescriptorAndroidHardwareBuffer> VSurfaceDescriptorAndroidHardwareBuffer;
        mozilla::AlignedStorage2<EGLImageDescriptor> VEGLImageDescriptor;
        mozilla::AlignedStorage2<SurfaceDescriptorMacIOSurface> VSurfaceDescriptorMacIOSurface;
        mozilla::AlignedStorage2<SurfaceDescriptorSharedGLTexture> VSurfaceDescriptorSharedGLTexture;
        mozilla::AlignedStorage2<SurfaceDescriptorGPUVideo> VSurfaceDescriptorGPUVideo;
        mozilla::AlignedStorage2<SurfaceDescriptorRecorded> VSurfaceDescriptorRecorded;
        mozilla::AlignedStorage2<null_t> Vnull_t;
    };

    SurfaceDescriptorBuffer*
    ptr_SurfaceDescriptorBuffer()
    {
        return ((mValue).VSurfaceDescriptorBuffer).addr();
    }
    const SurfaceDescriptorBuffer*
    constptr_SurfaceDescriptorBuffer() const
    {
        return ((mValue).VSurfaceDescriptorBuffer).addr();
    }
    SurfaceDescriptorDIB*
    ptr_SurfaceDescriptorDIB()
    {
        return ((mValue).VSurfaceDescriptorDIB).addr();
    }
    const SurfaceDescriptorDIB*
    constptr_SurfaceDescriptorDIB() const
    {
        return ((mValue).VSurfaceDescriptorDIB).addr();
    }
    SurfaceDescriptorD3D10*
    ptr_SurfaceDescriptorD3D10()
    {
        return ((mValue).VSurfaceDescriptorD3D10).addr();
    }
    const SurfaceDescriptorD3D10*
    constptr_SurfaceDescriptorD3D10() const
    {
        return ((mValue).VSurfaceDescriptorD3D10).addr();
    }
    SurfaceDescriptorFileMapping*
    ptr_SurfaceDescriptorFileMapping()
    {
        return ((mValue).VSurfaceDescriptorFileMapping).addr();
    }
    const SurfaceDescriptorFileMapping*
    constptr_SurfaceDescriptorFileMapping() const
    {
        return ((mValue).VSurfaceDescriptorFileMapping).addr();
    }
    SurfaceDescriptorDXGIYCbCr*
    ptr_SurfaceDescriptorDXGIYCbCr()
    {
        return ((mValue).VSurfaceDescriptorDXGIYCbCr).addr();
    }
    const SurfaceDescriptorDXGIYCbCr*
    constptr_SurfaceDescriptorDXGIYCbCr() const
    {
        return ((mValue).VSurfaceDescriptorDXGIYCbCr).addr();
    }
    SurfaceDescriptorX11*
    ptr_SurfaceDescriptorX11()
    {
        return ((mValue).VSurfaceDescriptorX11).addr();
    }
    const SurfaceDescriptorX11*
    constptr_SurfaceDescriptorX11() const
    {
        return ((mValue).VSurfaceDescriptorX11).addr();
    }
    SurfaceDescriptorDMABuf*
    ptr_SurfaceDescriptorDMABuf()
    {
        return ((mValue).VSurfaceDescriptorDMABuf).addr();
    }
    const SurfaceDescriptorDMABuf*
    constptr_SurfaceDescriptorDMABuf() const
    {
        return ((mValue).VSurfaceDescriptorDMABuf).addr();
    }
    SurfaceTextureDescriptor*
    ptr_SurfaceTextureDescriptor()
    {
        return ((mValue).VSurfaceTextureDescriptor).addr();
    }
    const SurfaceTextureDescriptor*
    constptr_SurfaceTextureDescriptor() const
    {
        return ((mValue).VSurfaceTextureDescriptor).addr();
    }
    SurfaceDescriptorAndroidHardwareBuffer*
    ptr_SurfaceDescriptorAndroidHardwareBuffer()
    {
        return ((mValue).VSurfaceDescriptorAndroidHardwareBuffer).addr();
    }
    const SurfaceDescriptorAndroidHardwareBuffer*
    constptr_SurfaceDescriptorAndroidHardwareBuffer() const
    {
        return ((mValue).VSurfaceDescriptorAndroidHardwareBuffer).addr();
    }
    EGLImageDescriptor*
    ptr_EGLImageDescriptor()
    {
        return ((mValue).VEGLImageDescriptor).addr();
    }
    const EGLImageDescriptor*
    constptr_EGLImageDescriptor() const
    {
        return ((mValue).VEGLImageDescriptor).addr();
    }
    SurfaceDescriptorMacIOSurface*
    ptr_SurfaceDescriptorMacIOSurface()
    {
        return ((mValue).VSurfaceDescriptorMacIOSurface).addr();
    }
    const SurfaceDescriptorMacIOSurface*
    constptr_SurfaceDescriptorMacIOSurface() const
    {
        return ((mValue).VSurfaceDescriptorMacIOSurface).addr();
    }
    SurfaceDescriptorSharedGLTexture*
    ptr_SurfaceDescriptorSharedGLTexture()
    {
        return ((mValue).VSurfaceDescriptorSharedGLTexture).addr();
    }
    const SurfaceDescriptorSharedGLTexture*
    constptr_SurfaceDescriptorSharedGLTexture() const
    {
        return ((mValue).VSurfaceDescriptorSharedGLTexture).addr();
    }
    SurfaceDescriptorGPUVideo*
    ptr_SurfaceDescriptorGPUVideo()
    {
        return ((mValue).VSurfaceDescriptorGPUVideo).addr();
    }
    const SurfaceDescriptorGPUVideo*
    constptr_SurfaceDescriptorGPUVideo() const
    {
        return ((mValue).VSurfaceDescriptorGPUVideo).addr();
    }
    SurfaceDescriptorRecorded*
    ptr_SurfaceDescriptorRecorded()
    {
        return ((mValue).VSurfaceDescriptorRecorded).addr();
    }
    const SurfaceDescriptorRecorded*
    constptr_SurfaceDescriptorRecorded() const
    {
        return ((mValue).VSurfaceDescriptorRecorded).addr();
    }
    null_t*
    ptr_null_t()
    {
        return ((mValue).Vnull_t).addr();
    }
    const null_t*
    constptr_null_t() const
    {
        return ((mValue).Vnull_t).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT SurfaceDescriptor() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT SurfaceDescriptor(const SurfaceDescriptorBuffer& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(SurfaceDescriptorBuffer&& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(const SurfaceDescriptorDIB& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(SurfaceDescriptorDIB&& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(const SurfaceDescriptorD3D10& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(SurfaceDescriptorD3D10&& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(const SurfaceDescriptorFileMapping& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(SurfaceDescriptorFileMapping&& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(const SurfaceDescriptorDXGIYCbCr& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(SurfaceDescriptorDXGIYCbCr&& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(const SurfaceDescriptorX11& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(SurfaceDescriptorX11&& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(const SurfaceDescriptorDMABuf& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(SurfaceDescriptorDMABuf&& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(const SurfaceTextureDescriptor& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(SurfaceTextureDescriptor&& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(const SurfaceDescriptorAndroidHardwareBuffer& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(SurfaceDescriptorAndroidHardwareBuffer&& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(const EGLImageDescriptor& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(EGLImageDescriptor&& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(const SurfaceDescriptorMacIOSurface& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(SurfaceDescriptorMacIOSurface&& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(const SurfaceDescriptorSharedGLTexture& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(SurfaceDescriptorSharedGLTexture&& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(const SurfaceDescriptorGPUVideo& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(SurfaceDescriptorGPUVideo&& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(const SurfaceDescriptorRecorded& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(SurfaceDescriptorRecorded&& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(const null_t& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(null_t&& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(const SurfaceDescriptor& aOther);

    MOZ_IMPLICIT SurfaceDescriptor(SurfaceDescriptor&& aOther);

    ~SurfaceDescriptor();

    Type
    type() const
    {
        return mType;
    }

    SurfaceDescriptor&
    operator=(const SurfaceDescriptorBuffer& aRhs);

    SurfaceDescriptor&
    operator=(SurfaceDescriptorBuffer&& aRhs);

    SurfaceDescriptor&
    operator=(const SurfaceDescriptorDIB& aRhs);

    SurfaceDescriptor&
    operator=(SurfaceDescriptorDIB&& aRhs);

    SurfaceDescriptor&
    operator=(const SurfaceDescriptorD3D10& aRhs);

    SurfaceDescriptor&
    operator=(SurfaceDescriptorD3D10&& aRhs);

    SurfaceDescriptor&
    operator=(const SurfaceDescriptorFileMapping& aRhs);

    SurfaceDescriptor&
    operator=(SurfaceDescriptorFileMapping&& aRhs);

    SurfaceDescriptor&
    operator=(const SurfaceDescriptorDXGIYCbCr& aRhs);

    SurfaceDescriptor&
    operator=(SurfaceDescriptorDXGIYCbCr&& aRhs);

    SurfaceDescriptor&
    operator=(const SurfaceDescriptorX11& aRhs);

    SurfaceDescriptor&
    operator=(SurfaceDescriptorX11&& aRhs);

    SurfaceDescriptor&
    operator=(const SurfaceDescriptorDMABuf& aRhs);

    SurfaceDescriptor&
    operator=(SurfaceDescriptorDMABuf&& aRhs);

    SurfaceDescriptor&
    operator=(const SurfaceTextureDescriptor& aRhs);

    SurfaceDescriptor&
    operator=(SurfaceTextureDescriptor&& aRhs);

    SurfaceDescriptor&
    operator=(const SurfaceDescriptorAndroidHardwareBuffer& aRhs);

    SurfaceDescriptor&
    operator=(SurfaceDescriptorAndroidHardwareBuffer&& aRhs);

    SurfaceDescriptor&
    operator=(const EGLImageDescriptor& aRhs);

    SurfaceDescriptor&
    operator=(EGLImageDescriptor&& aRhs);

    SurfaceDescriptor&
    operator=(const SurfaceDescriptorMacIOSurface& aRhs);

    SurfaceDescriptor&
    operator=(SurfaceDescriptorMacIOSurface&& aRhs);

    SurfaceDescriptor&
    operator=(const SurfaceDescriptorSharedGLTexture& aRhs);

    SurfaceDescriptor&
    operator=(SurfaceDescriptorSharedGLTexture&& aRhs);

    SurfaceDescriptor&
    operator=(const SurfaceDescriptorGPUVideo& aRhs);

    SurfaceDescriptor&
    operator=(SurfaceDescriptorGPUVideo&& aRhs);

    SurfaceDescriptor&
    operator=(const SurfaceDescriptorRecorded& aRhs);

    SurfaceDescriptor&
    operator=(SurfaceDescriptorRecorded&& aRhs);

    SurfaceDescriptor&
    operator=(const null_t& aRhs);

    SurfaceDescriptor&
    operator=(null_t&& aRhs);

    SurfaceDescriptor&
    operator=(const SurfaceDescriptor& aRhs);

    SurfaceDescriptor&
    operator=(SurfaceDescriptor&& aRhs);

    bool
    operator==(const SurfaceDescriptorBuffer& aRhs) const;

    bool
    operator==(const SurfaceDescriptorDIB& aRhs) const;

    bool
    operator==(const SurfaceDescriptorD3D10& aRhs) const;

    bool
    operator==(const SurfaceDescriptorFileMapping& aRhs) const;

    bool
    operator==(const SurfaceDescriptorDXGIYCbCr& aRhs) const;

    bool
    operator==(const SurfaceDescriptorX11& aRhs) const;

    bool
    operator==(const SurfaceDescriptorDMABuf& aRhs) const;

    bool
    operator==(const SurfaceTextureDescriptor& aRhs) const;

    bool
    operator==(const SurfaceDescriptorAndroidHardwareBuffer& aRhs) const;

    bool
    operator==(const EGLImageDescriptor& aRhs) const;

    bool
    operator==(const SurfaceDescriptorMacIOSurface& aRhs) const;

    bool
    operator==(const SurfaceDescriptorSharedGLTexture& aRhs) const;

    bool
    operator==(const SurfaceDescriptorGPUVideo& aRhs) const;

    bool
    operator==(const SurfaceDescriptorRecorded& aRhs) const;

    bool
    operator==(const null_t& aRhs) const;

    bool
    operator==(const SurfaceDescriptor& aRhs) const;

    SurfaceDescriptorBuffer&
    get_SurfaceDescriptorBuffer()
    {
        AssertSanity(TSurfaceDescriptorBuffer);
        return (*(ptr_SurfaceDescriptorBuffer()));
    }
    const SurfaceDescriptorBuffer&
    get_SurfaceDescriptorBuffer() const
    {
        AssertSanity(TSurfaceDescriptorBuffer);
        return (*(constptr_SurfaceDescriptorBuffer()));
    }
    operator SurfaceDescriptorBuffer&()
    {
        return get_SurfaceDescriptorBuffer();
    }
    operator const SurfaceDescriptorBuffer&() const
    {
        return get_SurfaceDescriptorBuffer();
    }

    SurfaceDescriptorDIB&
    get_SurfaceDescriptorDIB()
    {
        AssertSanity(TSurfaceDescriptorDIB);
        return (*(ptr_SurfaceDescriptorDIB()));
    }
    const SurfaceDescriptorDIB&
    get_SurfaceDescriptorDIB() const
    {
        AssertSanity(TSurfaceDescriptorDIB);
        return (*(constptr_SurfaceDescriptorDIB()));
    }
    operator SurfaceDescriptorDIB&()
    {
        return get_SurfaceDescriptorDIB();
    }
    operator const SurfaceDescriptorDIB&() const
    {
        return get_SurfaceDescriptorDIB();
    }

    SurfaceDescriptorD3D10&
    get_SurfaceDescriptorD3D10()
    {
        AssertSanity(TSurfaceDescriptorD3D10);
        return (*(ptr_SurfaceDescriptorD3D10()));
    }
    const SurfaceDescriptorD3D10&
    get_SurfaceDescriptorD3D10() const
    {
        AssertSanity(TSurfaceDescriptorD3D10);
        return (*(constptr_SurfaceDescriptorD3D10()));
    }
    operator SurfaceDescriptorD3D10&()
    {
        return get_SurfaceDescriptorD3D10();
    }
    operator const SurfaceDescriptorD3D10&() const
    {
        return get_SurfaceDescriptorD3D10();
    }

    SurfaceDescriptorFileMapping&
    get_SurfaceDescriptorFileMapping()
    {
        AssertSanity(TSurfaceDescriptorFileMapping);
        return (*(ptr_SurfaceDescriptorFileMapping()));
    }
    const SurfaceDescriptorFileMapping&
    get_SurfaceDescriptorFileMapping() const
    {
        AssertSanity(TSurfaceDescriptorFileMapping);
        return (*(constptr_SurfaceDescriptorFileMapping()));
    }
    operator SurfaceDescriptorFileMapping&()
    {
        return get_SurfaceDescriptorFileMapping();
    }
    operator const SurfaceDescriptorFileMapping&() const
    {
        return get_SurfaceDescriptorFileMapping();
    }

    SurfaceDescriptorDXGIYCbCr&
    get_SurfaceDescriptorDXGIYCbCr()
    {
        AssertSanity(TSurfaceDescriptorDXGIYCbCr);
        return (*(ptr_SurfaceDescriptorDXGIYCbCr()));
    }
    const SurfaceDescriptorDXGIYCbCr&
    get_SurfaceDescriptorDXGIYCbCr() const
    {
        AssertSanity(TSurfaceDescriptorDXGIYCbCr);
        return (*(constptr_SurfaceDescriptorDXGIYCbCr()));
    }
    operator SurfaceDescriptorDXGIYCbCr&()
    {
        return get_SurfaceDescriptorDXGIYCbCr();
    }
    operator const SurfaceDescriptorDXGIYCbCr&() const
    {
        return get_SurfaceDescriptorDXGIYCbCr();
    }

    SurfaceDescriptorX11&
    get_SurfaceDescriptorX11()
    {
        AssertSanity(TSurfaceDescriptorX11);
        return (*(ptr_SurfaceDescriptorX11()));
    }
    const SurfaceDescriptorX11&
    get_SurfaceDescriptorX11() const
    {
        AssertSanity(TSurfaceDescriptorX11);
        return (*(constptr_SurfaceDescriptorX11()));
    }
    operator SurfaceDescriptorX11&()
    {
        return get_SurfaceDescriptorX11();
    }
    operator const SurfaceDescriptorX11&() const
    {
        return get_SurfaceDescriptorX11();
    }

    SurfaceDescriptorDMABuf&
    get_SurfaceDescriptorDMABuf()
    {
        AssertSanity(TSurfaceDescriptorDMABuf);
        return (*(ptr_SurfaceDescriptorDMABuf()));
    }
    const SurfaceDescriptorDMABuf&
    get_SurfaceDescriptorDMABuf() const
    {
        AssertSanity(TSurfaceDescriptorDMABuf);
        return (*(constptr_SurfaceDescriptorDMABuf()));
    }
    operator SurfaceDescriptorDMABuf&()
    {
        return get_SurfaceDescriptorDMABuf();
    }
    operator const SurfaceDescriptorDMABuf&() const
    {
        return get_SurfaceDescriptorDMABuf();
    }

    SurfaceTextureDescriptor&
    get_SurfaceTextureDescriptor()
    {
        AssertSanity(TSurfaceTextureDescriptor);
        return (*(ptr_SurfaceTextureDescriptor()));
    }
    const SurfaceTextureDescriptor&
    get_SurfaceTextureDescriptor() const
    {
        AssertSanity(TSurfaceTextureDescriptor);
        return (*(constptr_SurfaceTextureDescriptor()));
    }
    operator SurfaceTextureDescriptor&()
    {
        return get_SurfaceTextureDescriptor();
    }
    operator const SurfaceTextureDescriptor&() const
    {
        return get_SurfaceTextureDescriptor();
    }

    SurfaceDescriptorAndroidHardwareBuffer&
    get_SurfaceDescriptorAndroidHardwareBuffer()
    {
        AssertSanity(TSurfaceDescriptorAndroidHardwareBuffer);
        return (*(ptr_SurfaceDescriptorAndroidHardwareBuffer()));
    }
    const SurfaceDescriptorAndroidHardwareBuffer&
    get_SurfaceDescriptorAndroidHardwareBuffer() const
    {
        AssertSanity(TSurfaceDescriptorAndroidHardwareBuffer);
        return (*(constptr_SurfaceDescriptorAndroidHardwareBuffer()));
    }
    operator SurfaceDescriptorAndroidHardwareBuffer&()
    {
        return get_SurfaceDescriptorAndroidHardwareBuffer();
    }
    operator const SurfaceDescriptorAndroidHardwareBuffer&() const
    {
        return get_SurfaceDescriptorAndroidHardwareBuffer();
    }

    EGLImageDescriptor&
    get_EGLImageDescriptor()
    {
        AssertSanity(TEGLImageDescriptor);
        return (*(ptr_EGLImageDescriptor()));
    }
    const EGLImageDescriptor&
    get_EGLImageDescriptor() const
    {
        AssertSanity(TEGLImageDescriptor);
        return (*(constptr_EGLImageDescriptor()));
    }
    operator EGLImageDescriptor&()
    {
        return get_EGLImageDescriptor();
    }
    operator const EGLImageDescriptor&() const
    {
        return get_EGLImageDescriptor();
    }

    SurfaceDescriptorMacIOSurface&
    get_SurfaceDescriptorMacIOSurface()
    {
        AssertSanity(TSurfaceDescriptorMacIOSurface);
        return (*(ptr_SurfaceDescriptorMacIOSurface()));
    }
    const SurfaceDescriptorMacIOSurface&
    get_SurfaceDescriptorMacIOSurface() const
    {
        AssertSanity(TSurfaceDescriptorMacIOSurface);
        return (*(constptr_SurfaceDescriptorMacIOSurface()));
    }
    operator SurfaceDescriptorMacIOSurface&()
    {
        return get_SurfaceDescriptorMacIOSurface();
    }
    operator const SurfaceDescriptorMacIOSurface&() const
    {
        return get_SurfaceDescriptorMacIOSurface();
    }

    SurfaceDescriptorSharedGLTexture&
    get_SurfaceDescriptorSharedGLTexture()
    {
        AssertSanity(TSurfaceDescriptorSharedGLTexture);
        return (*(ptr_SurfaceDescriptorSharedGLTexture()));
    }
    const SurfaceDescriptorSharedGLTexture&
    get_SurfaceDescriptorSharedGLTexture() const
    {
        AssertSanity(TSurfaceDescriptorSharedGLTexture);
        return (*(constptr_SurfaceDescriptorSharedGLTexture()));
    }
    operator SurfaceDescriptorSharedGLTexture&()
    {
        return get_SurfaceDescriptorSharedGLTexture();
    }
    operator const SurfaceDescriptorSharedGLTexture&() const
    {
        return get_SurfaceDescriptorSharedGLTexture();
    }

    SurfaceDescriptorGPUVideo&
    get_SurfaceDescriptorGPUVideo()
    {
        AssertSanity(TSurfaceDescriptorGPUVideo);
        return (*(ptr_SurfaceDescriptorGPUVideo()));
    }
    const SurfaceDescriptorGPUVideo&
    get_SurfaceDescriptorGPUVideo() const
    {
        AssertSanity(TSurfaceDescriptorGPUVideo);
        return (*(constptr_SurfaceDescriptorGPUVideo()));
    }
    operator SurfaceDescriptorGPUVideo&()
    {
        return get_SurfaceDescriptorGPUVideo();
    }
    operator const SurfaceDescriptorGPUVideo&() const
    {
        return get_SurfaceDescriptorGPUVideo();
    }

    SurfaceDescriptorRecorded&
    get_SurfaceDescriptorRecorded()
    {
        AssertSanity(TSurfaceDescriptorRecorded);
        return (*(ptr_SurfaceDescriptorRecorded()));
    }
    const SurfaceDescriptorRecorded&
    get_SurfaceDescriptorRecorded() const
    {
        AssertSanity(TSurfaceDescriptorRecorded);
        return (*(constptr_SurfaceDescriptorRecorded()));
    }
    operator SurfaceDescriptorRecorded&()
    {
        return get_SurfaceDescriptorRecorded();
    }
    operator const SurfaceDescriptorRecorded&() const
    {
        return get_SurfaceDescriptorRecorded();
    }

    null_t&
    get_null_t()
    {
        AssertSanity(Tnull_t);
        return (*(ptr_null_t()));
    }
    const null_t&
    get_null_t() const
    {
        AssertSanity(Tnull_t);
        return (*(constptr_null_t()));
    }
    operator null_t&()
    {
        return get_null_t();
    }
    operator const null_t&() const
    {
        return get_null_t();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace layers
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::layers::SurfaceDescriptor>
{
    typedef mozilla::layers::SurfaceDescriptor paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

#endif // ifndef LayersSurfaces_h
