//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PCameras_h
#define PCameras_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"
#include "mozilla/ipc/PBackgroundSharedTypes.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct VideoCaptureCapability|
//
namespace mozilla {
namespace camera {
class VideoCaptureCapability final
{
private:

public:
    MOZ_IMPLICIT VideoCaptureCapability() :
        width_(),
        height_(),
        maxFPS_(),
        videoType_(),
        interlaced_()
    {
    }

    MOZ_IMPLICIT VideoCaptureCapability(
            const int& _width,
            const int& _height,
            const int& _maxFPS,
            const int& _videoType,
            const bool& _interlaced) :
        width_(_width),
        height_(_height),
        maxFPS_(_maxFPS),
        videoType_(_videoType),
        interlaced_(_interlaced)
    {
    }

    int&
    width()
    {
        return width_;
    }
    const int&
    width() const
    {
        return width_;
    }

    int&
    height()
    {
        return height_;
    }
    const int&
    height() const
    {
        return height_;
    }

    int&
    maxFPS()
    {
        return maxFPS_;
    }
    const int&
    maxFPS() const
    {
        return maxFPS_;
    }

    int&
    videoType()
    {
        return videoType_;
    }
    const int&
    videoType() const
    {
        return videoType_;
    }

    bool&
    interlaced()
    {
        return interlaced_;
    }
    const bool&
    interlaced() const
    {
        return interlaced_;
    }

private:
    int width_;
    int height_;
    int maxFPS_;
    int videoType_;
    bool interlaced_;
};
} // namespace camera
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::camera::VideoCaptureCapability>
{
    typedef mozilla::camera::VideoCaptureCapability paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct VideoFrameProperties|
//
namespace mozilla {
namespace camera {
class VideoFrameProperties final
{
private:

public:
    MOZ_IMPLICIT VideoFrameProperties() :
        rotation_(),
        yAllocatedSize_(),
        uAllocatedSize_(),
        vAllocatedSize_(),
        width_(),
        height_(),
        yStride_(),
        uStride_(),
        vStride_(),
        ntpTimeMs_(),
        renderTimeMs_(),
        bufferSize_(),
        timeStamp_()
    {
    }

    MOZ_IMPLICIT VideoFrameProperties(
            const uint32_t& _bufferSize,
            const uint32_t& _timeStamp,
            const int64_t& _ntpTimeMs,
            const int64_t& _renderTimeMs,
            const int& _rotation,
            const int& _yAllocatedSize,
            const int& _uAllocatedSize,
            const int& _vAllocatedSize,
            const int& _width,
            const int& _height,
            const int& _yStride,
            const int& _uStride,
            const int& _vStride) :
        rotation_(_rotation),
        yAllocatedSize_(_yAllocatedSize),
        uAllocatedSize_(_uAllocatedSize),
        vAllocatedSize_(_vAllocatedSize),
        width_(_width),
        height_(_height),
        yStride_(_yStride),
        uStride_(_uStride),
        vStride_(_vStride),
        ntpTimeMs_(_ntpTimeMs),
        renderTimeMs_(_renderTimeMs),
        bufferSize_(_bufferSize),
        timeStamp_(_timeStamp)
    {
    }

    uint32_t&
    bufferSize()
    {
        return bufferSize_;
    }
    const uint32_t&
    bufferSize() const
    {
        return bufferSize_;
    }

    uint32_t&
    timeStamp()
    {
        return timeStamp_;
    }
    const uint32_t&
    timeStamp() const
    {
        return timeStamp_;
    }

    int64_t&
    ntpTimeMs()
    {
        return ntpTimeMs_;
    }
    const int64_t&
    ntpTimeMs() const
    {
        return ntpTimeMs_;
    }

    int64_t&
    renderTimeMs()
    {
        return renderTimeMs_;
    }
    const int64_t&
    renderTimeMs() const
    {
        return renderTimeMs_;
    }

    int&
    rotation()
    {
        return rotation_;
    }
    const int&
    rotation() const
    {
        return rotation_;
    }

    int&
    yAllocatedSize()
    {
        return yAllocatedSize_;
    }
    const int&
    yAllocatedSize() const
    {
        return yAllocatedSize_;
    }

    int&
    uAllocatedSize()
    {
        return uAllocatedSize_;
    }
    const int&
    uAllocatedSize() const
    {
        return uAllocatedSize_;
    }

    int&
    vAllocatedSize()
    {
        return vAllocatedSize_;
    }
    const int&
    vAllocatedSize() const
    {
        return vAllocatedSize_;
    }

    int&
    width()
    {
        return width_;
    }
    const int&
    width() const
    {
        return width_;
    }

    int&
    height()
    {
        return height_;
    }
    const int&
    height() const
    {
        return height_;
    }

    int&
    yStride()
    {
        return yStride_;
    }
    const int&
    yStride() const
    {
        return yStride_;
    }

    int&
    uStride()
    {
        return uStride_;
    }
    const int&
    uStride() const
    {
        return uStride_;
    }

    int&
    vStride()
    {
        return vStride_;
    }
    const int&
    vStride() const
    {
        return vStride_;
    }

private:
    void
    StaticAssertions() const;
    int rotation_;
    int yAllocatedSize_;
    int uAllocatedSize_;
    int vAllocatedSize_;
    int width_;
    int height_;
    int yStride_;
    int uStride_;
    int vStride_;
    int64_t ntpTimeMs_;
    int64_t renderTimeMs_;
    uint32_t bufferSize_;
    uint32_t timeStamp_;
};
} // namespace camera
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::camera::VideoFrameProperties>
{
    typedef mozilla::camera::VideoFrameProperties paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace camera {
class PCamerasParent;
} // namespace camera
} // namespace mozilla
namespace mozilla {
namespace camera {
class PCamerasChild;
} // namespace camera
} // namespace mozilla

//-----------------------------------------------------------------------------
// Code common to PCamerasChild and PCamerasParent
//
namespace mozilla {
namespace camera {
namespace PCameras {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::camera::PCamerasParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::camera::PCamerasChild>* aChild);

enum MessageType {
    PCamerasStart = PCamerasMsgStart << 16,
    Msg_DeliverFrame__ID,
    Msg_DeviceChange__ID,
    Msg_ReplyNumberOfCaptureDevices__ID,
    Msg_ReplyNumberOfCapabilities__ID,
    Msg_ReplyAllocateCaptureDevice__ID,
    Msg_ReplyGetCaptureCapability__ID,
    Msg_ReplyGetCaptureDevice__ID,
    Msg_ReplyFailure__ID,
    Msg_ReplySuccess__ID,
    Msg___delete____ID,
    Reply___delete____ID,
    Msg_NumberOfCaptureDevices__ID,
    Msg_NumberOfCapabilities__ID,
    Msg_GetCaptureCapability__ID,
    Msg_GetCaptureDevice__ID,
    Msg_AllocateCaptureDevice__ID,
    Msg_ReleaseCaptureDevice__ID,
    Msg_StartCapture__ID,
    Msg_FocusOnSelectedSource__ID,
    Msg_StopCapture__ID,
    Msg_ReleaseFrame__ID,
    Msg_AllDone__ID,
    Msg_EnsureInitialized__ID,
    PCamerasEnd
};

IPC::Message*
Msg_DeliverFrame(int32_t routingId);

IPC::Message*
Msg_DeviceChange(int32_t routingId);

IPC::Message*
Msg_ReplyNumberOfCaptureDevices(int32_t routingId);

IPC::Message*
Msg_ReplyNumberOfCapabilities(int32_t routingId);

IPC::Message*
Msg_ReplyAllocateCaptureDevice(int32_t routingId);

IPC::Message*
Msg_ReplyGetCaptureCapability(int32_t routingId);

IPC::Message*
Msg_ReplyGetCaptureDevice(int32_t routingId);

IPC::Message*
Msg_ReplyFailure(int32_t routingId);

IPC::Message*
Msg_ReplySuccess(int32_t routingId);

IPC::Message*
Msg___delete__(int32_t routingId);
IPC::Message*
Reply___delete__(int32_t routingId);

IPC::Message*
Msg_NumberOfCaptureDevices(int32_t routingId);

IPC::Message*
Msg_NumberOfCapabilities(int32_t routingId);

IPC::Message*
Msg_GetCaptureCapability(int32_t routingId);

IPC::Message*
Msg_GetCaptureDevice(int32_t routingId);

IPC::Message*
Msg_AllocateCaptureDevice(int32_t routingId);

IPC::Message*
Msg_ReleaseCaptureDevice(int32_t routingId);

IPC::Message*
Msg_StartCapture(int32_t routingId);

IPC::Message*
Msg_FocusOnSelectedSource(int32_t routingId);

IPC::Message*
Msg_StopCapture(int32_t routingId);

IPC::Message*
Msg_ReleaseFrame(int32_t routingId);

IPC::Message*
Msg_AllDone(int32_t routingId);

IPC::Message*
Msg_EnsureInitialized(int32_t routingId);



} // namespace PCameras
} // namespace camera
} // namespace mozilla

#endif // ifndef PCameras_h
