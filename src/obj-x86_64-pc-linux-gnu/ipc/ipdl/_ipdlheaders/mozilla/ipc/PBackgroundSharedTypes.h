//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PBackgroundSharedTypes_h
#define PBackgroundSharedTypes_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "mozilla/ipc/BackgroundUtils.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ContentSecurityPolicy|
//
namespace mozilla {
namespace ipc {
class ContentSecurityPolicy final
{
private:

public:
    MOZ_IMPLICIT ContentSecurityPolicy() :
        policy_(),
        reportOnlyFlag_(),
        deliveredViaMetaTagFlag_()
    {
    }

    MOZ_IMPLICIT ContentSecurityPolicy(
            const nsString& _policy,
            const bool& _reportOnlyFlag,
            const bool& _deliveredViaMetaTagFlag) :
        policy_(_policy),
        reportOnlyFlag_(_reportOnlyFlag),
        deliveredViaMetaTagFlag_(_deliveredViaMetaTagFlag)
    {
    }

    bool
    operator==(const ContentSecurityPolicy& _o) const;

    bool
    operator!=(const ContentSecurityPolicy& _o) const;

    nsString&
    policy()
    {
        return policy_;
    }
    const nsString&
    policy() const
    {
        return policy_;
    }

    bool&
    reportOnlyFlag()
    {
        return reportOnlyFlag_;
    }
    const bool&
    reportOnlyFlag() const
    {
        return reportOnlyFlag_;
    }

    bool&
    deliveredViaMetaTagFlag()
    {
        return deliveredViaMetaTagFlag_;
    }
    const bool&
    deliveredViaMetaTagFlag() const
    {
        return deliveredViaMetaTagFlag_;
    }

private:
    nsString policy_;
    bool reportOnlyFlag_;
    bool deliveredViaMetaTagFlag_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::ContentSecurityPolicy>
{
    typedef mozilla::ipc::ContentSecurityPolicy paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ContentPrincipalInfo|
//
namespace mozilla {
namespace ipc {
class ContentPrincipalInfo final
{
private:
    typedef mozilla::OriginAttributes OriginAttributes;

public:
    MOZ_IMPLICIT ContentPrincipalInfo() :
        attrs_(),
        originNoSuffix_(),
        spec_(),
        domain_(),
        baseDomain_()
    {
    }

    MOZ_IMPLICIT ContentPrincipalInfo(
            const OriginAttributes& _attrs,
            const nsCString& _originNoSuffix,
            const nsCString& _spec,
            const mozilla::Maybe<nsCString>& _domain,
            const nsCString& _baseDomain) :
        attrs_(_attrs),
        originNoSuffix_(_originNoSuffix),
        spec_(_spec),
        domain_(_domain),
        baseDomain_(_baseDomain)
    {
    }

    bool
    operator==(const ContentPrincipalInfo& _o) const;

    bool
    operator!=(const ContentPrincipalInfo& _o) const;

    OriginAttributes&
    attrs()
    {
        return attrs_;
    }
    const OriginAttributes&
    attrs() const
    {
        return attrs_;
    }

    nsCString&
    originNoSuffix()
    {
        return originNoSuffix_;
    }
    const nsCString&
    originNoSuffix() const
    {
        return originNoSuffix_;
    }

    nsCString&
    spec()
    {
        return spec_;
    }
    const nsCString&
    spec() const
    {
        return spec_;
    }

    mozilla::Maybe<nsCString>&
    domain()
    {
        return domain_;
    }
    const mozilla::Maybe<nsCString>&
    domain() const
    {
        return domain_;
    }

    nsCString&
    baseDomain()
    {
        return baseDomain_;
    }
    const nsCString&
    baseDomain() const
    {
        return baseDomain_;
    }

private:
    OriginAttributes attrs_;
    nsCString originNoSuffix_;
    nsCString spec_;
    mozilla::Maybe<nsCString> domain_;
    nsCString baseDomain_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::ContentPrincipalInfo>
{
    typedef mozilla::ipc::ContentPrincipalInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SystemPrincipalInfo|
//
namespace mozilla {
namespace ipc {
class SystemPrincipalInfo final
{
private:

public:
    MOZ_IMPLICIT SystemPrincipalInfo()
    {
    }

    bool
    operator==(const SystemPrincipalInfo& _o) const;

    bool
    operator!=(const SystemPrincipalInfo& _o) const;

private:
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::SystemPrincipalInfo>
{
    typedef mozilla::ipc::SystemPrincipalInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct NullPrincipalInfo|
//
namespace mozilla {
namespace ipc {
class NullPrincipalInfo final
{
private:
    typedef mozilla::OriginAttributes OriginAttributes;

public:
    MOZ_IMPLICIT NullPrincipalInfo() :
        attrs_(),
        spec_()
    {
    }

    MOZ_IMPLICIT NullPrincipalInfo(
            const OriginAttributes& _attrs,
            const nsCString& _spec) :
        attrs_(_attrs),
        spec_(_spec)
    {
    }

    bool
    operator==(const NullPrincipalInfo& _o) const;

    bool
    operator!=(const NullPrincipalInfo& _o) const;

    OriginAttributes&
    attrs()
    {
        return attrs_;
    }
    const OriginAttributes&
    attrs() const
    {
        return attrs_;
    }

    nsCString&
    spec()
    {
        return spec_;
    }
    const nsCString&
    spec() const
    {
        return spec_;
    }

private:
    OriginAttributes attrs_;
    nsCString spec_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::NullPrincipalInfo>
{
    typedef mozilla::ipc::NullPrincipalInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
class ExpandedPrincipalInfo;
} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union PrincipalInfo|
//
namespace mozilla {
namespace ipc {
class PrincipalInfo final
{
public:
    enum Type {
        T__None,
        TContentPrincipalInfo = 1,
        TSystemPrincipalInfo,
        TNullPrincipalInfo,
        TExpandedPrincipalInfo,
        T__Last = TExpandedPrincipalInfo
    };

private:
    typedef mozilla::ipc::ContentPrincipalInfo ContentPrincipalInfo;
    typedef mozilla::ipc::SystemPrincipalInfo SystemPrincipalInfo;
    typedef mozilla::ipc::NullPrincipalInfo NullPrincipalInfo;
    typedef mozilla::ipc::ExpandedPrincipalInfo ExpandedPrincipalInfo;
    typedef ContentPrincipalInfo ContentPrincipalInfo__tdef;
    typedef SystemPrincipalInfo SystemPrincipalInfo__tdef;
    typedef NullPrincipalInfo NullPrincipalInfo__tdef;
    typedef ExpandedPrincipalInfo* ExpandedPrincipalInfo__tdef;

    union Value {
        mozilla::AlignedStorage2<ContentPrincipalInfo> VContentPrincipalInfo;
        mozilla::AlignedStorage2<SystemPrincipalInfo> VSystemPrincipalInfo;
        mozilla::AlignedStorage2<NullPrincipalInfo> VNullPrincipalInfo;
        ExpandedPrincipalInfo* VExpandedPrincipalInfo;
    };

    ContentPrincipalInfo*
    ptr_ContentPrincipalInfo()
    {
        return ((mValue).VContentPrincipalInfo).addr();
    }
    const ContentPrincipalInfo*
    constptr_ContentPrincipalInfo() const
    {
        return ((mValue).VContentPrincipalInfo).addr();
    }
    SystemPrincipalInfo*
    ptr_SystemPrincipalInfo()
    {
        return ((mValue).VSystemPrincipalInfo).addr();
    }
    const SystemPrincipalInfo*
    constptr_SystemPrincipalInfo() const
    {
        return ((mValue).VSystemPrincipalInfo).addr();
    }
    NullPrincipalInfo*
    ptr_NullPrincipalInfo()
    {
        return ((mValue).VNullPrincipalInfo).addr();
    }
    const NullPrincipalInfo*
    constptr_NullPrincipalInfo() const
    {
        return ((mValue).VNullPrincipalInfo).addr();
    }
    ExpandedPrincipalInfo*&
    ptr_ExpandedPrincipalInfo()
    {
        return (mValue).VExpandedPrincipalInfo;
    }
    const ExpandedPrincipalInfo*
    constptr_ExpandedPrincipalInfo() const
    {
        return (mValue).VExpandedPrincipalInfo;
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT PrincipalInfo() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT PrincipalInfo(const ContentPrincipalInfo& aOther);

    MOZ_IMPLICIT PrincipalInfo(ContentPrincipalInfo&& aOther);

    MOZ_IMPLICIT PrincipalInfo(const SystemPrincipalInfo& aOther);

    MOZ_IMPLICIT PrincipalInfo(SystemPrincipalInfo&& aOther);

    MOZ_IMPLICIT PrincipalInfo(const NullPrincipalInfo& aOther);

    MOZ_IMPLICIT PrincipalInfo(NullPrincipalInfo&& aOther);

    MOZ_IMPLICIT PrincipalInfo(const ExpandedPrincipalInfo& aOther);

    MOZ_IMPLICIT PrincipalInfo(ExpandedPrincipalInfo&& aOther);

    MOZ_IMPLICIT PrincipalInfo(const PrincipalInfo& aOther);

    MOZ_IMPLICIT PrincipalInfo(PrincipalInfo&& aOther);

    ~PrincipalInfo();

    Type
    type() const
    {
        return mType;
    }

    PrincipalInfo&
    operator=(const ContentPrincipalInfo& aRhs);

    PrincipalInfo&
    operator=(ContentPrincipalInfo&& aRhs);

    PrincipalInfo&
    operator=(const SystemPrincipalInfo& aRhs);

    PrincipalInfo&
    operator=(SystemPrincipalInfo&& aRhs);

    PrincipalInfo&
    operator=(const NullPrincipalInfo& aRhs);

    PrincipalInfo&
    operator=(NullPrincipalInfo&& aRhs);

    PrincipalInfo&
    operator=(const ExpandedPrincipalInfo& aRhs);

    PrincipalInfo&
    operator=(ExpandedPrincipalInfo&& aRhs);

    PrincipalInfo&
    operator=(const PrincipalInfo& aRhs);

    PrincipalInfo&
    operator=(PrincipalInfo&& aRhs);

    bool
    operator==(const ContentPrincipalInfo& aRhs) const;

    bool
    operator==(const SystemPrincipalInfo& aRhs) const;

    bool
    operator==(const NullPrincipalInfo& aRhs) const;

    bool
    operator==(const ExpandedPrincipalInfo& aRhs) const;

    bool
    operator==(const PrincipalInfo& aRhs) const;

    ContentPrincipalInfo&
    get_ContentPrincipalInfo()
    {
        AssertSanity(TContentPrincipalInfo);
        return (*(ptr_ContentPrincipalInfo()));
    }
    const ContentPrincipalInfo&
    get_ContentPrincipalInfo() const
    {
        AssertSanity(TContentPrincipalInfo);
        return (*(constptr_ContentPrincipalInfo()));
    }
    operator ContentPrincipalInfo&()
    {
        return get_ContentPrincipalInfo();
    }
    operator const ContentPrincipalInfo&() const
    {
        return get_ContentPrincipalInfo();
    }

    SystemPrincipalInfo&
    get_SystemPrincipalInfo()
    {
        AssertSanity(TSystemPrincipalInfo);
        return (*(ptr_SystemPrincipalInfo()));
    }
    const SystemPrincipalInfo&
    get_SystemPrincipalInfo() const
    {
        AssertSanity(TSystemPrincipalInfo);
        return (*(constptr_SystemPrincipalInfo()));
    }
    operator SystemPrincipalInfo&()
    {
        return get_SystemPrincipalInfo();
    }
    operator const SystemPrincipalInfo&() const
    {
        return get_SystemPrincipalInfo();
    }

    NullPrincipalInfo&
    get_NullPrincipalInfo()
    {
        AssertSanity(TNullPrincipalInfo);
        return (*(ptr_NullPrincipalInfo()));
    }
    const NullPrincipalInfo&
    get_NullPrincipalInfo() const
    {
        AssertSanity(TNullPrincipalInfo);
        return (*(constptr_NullPrincipalInfo()));
    }
    operator NullPrincipalInfo&()
    {
        return get_NullPrincipalInfo();
    }
    operator const NullPrincipalInfo&() const
    {
        return get_NullPrincipalInfo();
    }

    ExpandedPrincipalInfo&
    get_ExpandedPrincipalInfo()
    {
        AssertSanity(TExpandedPrincipalInfo);
        return (*(ptr_ExpandedPrincipalInfo()));
    }
    const ExpandedPrincipalInfo&
    get_ExpandedPrincipalInfo() const
    {
        AssertSanity(TExpandedPrincipalInfo);
        return (*(constptr_ExpandedPrincipalInfo()));
    }
    operator ExpandedPrincipalInfo&()
    {
        return get_ExpandedPrincipalInfo();
    }
    operator const ExpandedPrincipalInfo&() const
    {
        return get_ExpandedPrincipalInfo();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::PrincipalInfo>
{
    typedef mozilla::ipc::PrincipalInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ExpandedPrincipalInfo|
//
namespace mozilla {
namespace ipc {
class ExpandedPrincipalInfo final
{
private:
    typedef mozilla::OriginAttributes OriginAttributes;
    typedef mozilla::ipc::PrincipalInfo PrincipalInfo;

public:
    MOZ_IMPLICIT ExpandedPrincipalInfo() :
        attrs_(),
        allowlist_()
    {
    }

    MOZ_IMPLICIT ExpandedPrincipalInfo(
            const OriginAttributes& _attrs,
            const nsTArray<PrincipalInfo>& _allowlist) :
        attrs_(_attrs),
        allowlist_(_allowlist)
    {
    }

    bool
    operator==(const ExpandedPrincipalInfo& _o) const;

    bool
    operator!=(const ExpandedPrincipalInfo& _o) const;

    OriginAttributes&
    attrs()
    {
        return attrs_;
    }
    const OriginAttributes&
    attrs() const
    {
        return attrs_;
    }

    nsTArray<PrincipalInfo>&
    allowlist()
    {
        return allowlist_;
    }
    const nsTArray<PrincipalInfo>&
    allowlist() const
    {
        return allowlist_;
    }

private:
    OriginAttributes attrs_;
    CopyableTArray<PrincipalInfo> allowlist_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::ExpandedPrincipalInfo>
{
    typedef mozilla::ipc::ExpandedPrincipalInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CSPInfo|
//
namespace mozilla {
namespace ipc {
class CSPInfo final
{
private:
    typedef mozilla::ipc::ContentSecurityPolicy ContentSecurityPolicy;
    typedef mozilla::ipc::PrincipalInfo PrincipalInfo;

public:
    MOZ_IMPLICIT CSPInfo() :
        policyInfos_(),
        requestPrincipalInfo_(),
        selfURISpec_(),
        referrer_(),
        skipAllowInlineStyleCheck_(),
        innerWindowID_()
    {
    }

    MOZ_IMPLICIT CSPInfo(
            const nsTArray<ContentSecurityPolicy>& _policyInfos,
            const PrincipalInfo& _requestPrincipalInfo,
            const nsCString& _selfURISpec,
            const nsString& _referrer,
            const uint64_t& _innerWindowID,
            const bool& _skipAllowInlineStyleCheck) :
        policyInfos_(_policyInfos),
        requestPrincipalInfo_(_requestPrincipalInfo),
        selfURISpec_(_selfURISpec),
        referrer_(_referrer),
        skipAllowInlineStyleCheck_(_skipAllowInlineStyleCheck),
        innerWindowID_(_innerWindowID)
    {
    }

    bool
    operator==(const CSPInfo& _o) const;

    bool
    operator!=(const CSPInfo& _o) const;

    nsTArray<ContentSecurityPolicy>&
    policyInfos()
    {
        return policyInfos_;
    }
    const nsTArray<ContentSecurityPolicy>&
    policyInfos() const
    {
        return policyInfos_;
    }

    PrincipalInfo&
    requestPrincipalInfo()
    {
        return requestPrincipalInfo_;
    }
    const PrincipalInfo&
    requestPrincipalInfo() const
    {
        return requestPrincipalInfo_;
    }

    nsCString&
    selfURISpec()
    {
        return selfURISpec_;
    }
    const nsCString&
    selfURISpec() const
    {
        return selfURISpec_;
    }

    nsString&
    referrer()
    {
        return referrer_;
    }
    const nsString&
    referrer() const
    {
        return referrer_;
    }

    uint64_t&
    innerWindowID()
    {
        return innerWindowID_;
    }
    const uint64_t&
    innerWindowID() const
    {
        return innerWindowID_;
    }

    bool&
    skipAllowInlineStyleCheck()
    {
        return skipAllowInlineStyleCheck_;
    }
    const bool&
    skipAllowInlineStyleCheck() const
    {
        return skipAllowInlineStyleCheck_;
    }

private:
    CopyableTArray<ContentSecurityPolicy> policyInfos_;
    PrincipalInfo requestPrincipalInfo_;
    nsCString selfURISpec_;
    nsString referrer_;
    bool skipAllowInlineStyleCheck_;
    uint64_t innerWindowID_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::CSPInfo>
{
    typedef mozilla::ipc::CSPInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

#endif // ifndef PBackgroundSharedTypes_h
