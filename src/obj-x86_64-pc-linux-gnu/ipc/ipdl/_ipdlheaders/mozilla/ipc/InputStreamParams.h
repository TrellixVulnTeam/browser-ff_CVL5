//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef InputStreamParams_h
#define InputStreamParams_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"
#include "mozilla/ipc/ProtocolTypes.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct HeaderEntry|
//
namespace mozilla {
namespace ipc {
class HeaderEntry final
{
private:

public:
    MOZ_IMPLICIT HeaderEntry() :
        name_(),
        value_()
    {
    }

    MOZ_IMPLICIT HeaderEntry(
            const nsCString& _name,
            const nsCString& _value) :
        name_(_name),
        value_(_value)
    {
    }

    nsCString&
    name()
    {
        return name_;
    }
    const nsCString&
    name() const
    {
        return name_;
    }

    nsCString&
    value()
    {
        return value_;
    }
    const nsCString&
    value() const
    {
        return value_;
    }

private:
    nsCString name_;
    nsCString value_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::HeaderEntry>
{
    typedef mozilla::ipc::HeaderEntry paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct StringInputStreamParams|
//
namespace mozilla {
namespace ipc {
class StringInputStreamParams final
{
private:

public:
    MOZ_IMPLICIT StringInputStreamParams() :
        data_()
    {
    }

    MOZ_IMPLICIT StringInputStreamParams(const nsCString& _data) :
        data_(_data)
    {
    }

    nsCString&
    data()
    {
        return data_;
    }
    const nsCString&
    data() const
    {
        return data_;
    }

private:
    nsCString data_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::StringInputStreamParams>
{
    typedef mozilla::ipc::StringInputStreamParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct FileInputStreamParams|
//
namespace mozilla {
namespace ipc {
class FileInputStreamParams final
{
private:

public:
    MOZ_IMPLICIT FileInputStreamParams() :
        fileDescriptorIndex_(),
        behaviorFlags_(),
        ioFlags_()
    {
    }

    MOZ_IMPLICIT FileInputStreamParams(
            const uint32_t& _fileDescriptorIndex,
            const int32_t& _behaviorFlags,
            const int32_t& _ioFlags) :
        fileDescriptorIndex_(_fileDescriptorIndex),
        behaviorFlags_(_behaviorFlags),
        ioFlags_(_ioFlags)
    {
    }

    uint32_t&
    fileDescriptorIndex()
    {
        return fileDescriptorIndex_;
    }
    const uint32_t&
    fileDescriptorIndex() const
    {
        return fileDescriptorIndex_;
    }

    int32_t&
    behaviorFlags()
    {
        return behaviorFlags_;
    }
    const int32_t&
    behaviorFlags() const
    {
        return behaviorFlags_;
    }

    int32_t&
    ioFlags()
    {
        return ioFlags_;
    }
    const int32_t&
    ioFlags() const
    {
        return ioFlags_;
    }

private:
    void
    StaticAssertions() const;
    uint32_t fileDescriptorIndex_;
    int32_t behaviorFlags_;
    int32_t ioFlags_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::FileInputStreamParams>
{
    typedef mozilla::ipc::FileInputStreamParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct RemoteLazyInputStreamRef|
//
namespace mozilla {
namespace ipc {
class RemoteLazyInputStreamRef final
{
private:

public:
    MOZ_IMPLICIT RemoteLazyInputStreamRef() :
        id_(),
        start_(),
        length_()
    {
    }

    MOZ_IMPLICIT RemoteLazyInputStreamRef(
            const nsID& _id,
            const uint64_t& _start,
            const uint64_t& _length) :
        id_(_id),
        start_(_start),
        length_(_length)
    {
    }

    nsID&
    id()
    {
        return id_;
    }
    const nsID&
    id() const
    {
        return id_;
    }

    uint64_t&
    start()
    {
        return start_;
    }
    const uint64_t&
    start() const
    {
        return start_;
    }

    uint64_t&
    length()
    {
        return length_;
    }
    const uint64_t&
    length() const
    {
        return length_;
    }

private:
    void
    StaticAssertions() const;
    nsID id_;
    uint64_t start_;
    uint64_t length_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::RemoteLazyInputStreamRef>
{
    typedef mozilla::ipc::RemoteLazyInputStreamRef paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
class PRemoteLazyInputStreamParent;
} // namespace mozilla

namespace mozilla {
class PRemoteLazyInputStreamChild;
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union RemoteLazyInputStreamParams|
//
namespace mozilla {
namespace ipc {
class RemoteLazyInputStreamParams final
{
public:
    enum Type {
        T__None,
        TRemoteLazyInputStreamRef = 1,
        TPRemoteLazyInputStreamParent,
        TPRemoteLazyInputStreamChild,
        T__Last = TPRemoteLazyInputStreamChild
    };

private:
    typedef mozilla::ipc::RemoteLazyInputStreamRef RemoteLazyInputStreamRef;
    typedef mozilla::PRemoteLazyInputStreamParent PRemoteLazyInputStreamParent;
    typedef mozilla::PRemoteLazyInputStreamChild PRemoteLazyInputStreamChild;
    typedef RemoteLazyInputStreamRef RemoteLazyInputStreamRef__tdef;
    typedef PRemoteLazyInputStreamParent* PRemoteLazyInputStreamParent__tdef;
    typedef PRemoteLazyInputStreamChild* PRemoteLazyInputStreamChild__tdef;

    union Value {
        mozilla::AlignedStorage2<RemoteLazyInputStreamRef> VRemoteLazyInputStreamRef;
        mozilla::AlignedStorage2<PRemoteLazyInputStreamParent*> VPRemoteLazyInputStreamParent;
        mozilla::AlignedStorage2<PRemoteLazyInputStreamChild*> VPRemoteLazyInputStreamChild;
    };

    RemoteLazyInputStreamRef*
    ptr_RemoteLazyInputStreamRef()
    {
        return ((mValue).VRemoteLazyInputStreamRef).addr();
    }
    const RemoteLazyInputStreamRef*
    constptr_RemoteLazyInputStreamRef() const
    {
        return ((mValue).VRemoteLazyInputStreamRef).addr();
    }
    PRemoteLazyInputStreamParent**
    ptr_PRemoteLazyInputStreamParent()
    {
        return ((mValue).VPRemoteLazyInputStreamParent).addr();
    }
    PRemoteLazyInputStreamParent* const*
    constptr_PRemoteLazyInputStreamParent() const
    {
        return ((mValue).VPRemoteLazyInputStreamParent).addr();
    }
    PRemoteLazyInputStreamChild**
    ptr_PRemoteLazyInputStreamChild()
    {
        return ((mValue).VPRemoteLazyInputStreamChild).addr();
    }
    PRemoteLazyInputStreamChild* const*
    constptr_PRemoteLazyInputStreamChild() const
    {
        return ((mValue).VPRemoteLazyInputStreamChild).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT RemoteLazyInputStreamParams() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT RemoteLazyInputStreamParams(const RemoteLazyInputStreamRef& aOther);

    MOZ_IMPLICIT RemoteLazyInputStreamParams(RemoteLazyInputStreamRef&& aOther);

    MOZ_IMPLICIT RemoteLazyInputStreamParams(PRemoteLazyInputStreamParent* aOther);

    MOZ_IMPLICIT RemoteLazyInputStreamParams(PRemoteLazyInputStreamChild* aOther);

    MOZ_IMPLICIT RemoteLazyInputStreamParams(const RemoteLazyInputStreamParams& aOther);

    MOZ_IMPLICIT RemoteLazyInputStreamParams(RemoteLazyInputStreamParams&& aOther);

    ~RemoteLazyInputStreamParams();

    Type
    type() const
    {
        return mType;
    }

    RemoteLazyInputStreamParams&
    operator=(const RemoteLazyInputStreamRef& aRhs);

    RemoteLazyInputStreamParams&
    operator=(RemoteLazyInputStreamRef&& aRhs);

    RemoteLazyInputStreamParams&
    operator=(PRemoteLazyInputStreamParent* aRhs);

    RemoteLazyInputStreamParams&
    operator=(PRemoteLazyInputStreamChild* aRhs);

    RemoteLazyInputStreamParams&
    operator=(const RemoteLazyInputStreamParams& aRhs);

    RemoteLazyInputStreamParams&
    operator=(RemoteLazyInputStreamParams&& aRhs);

    RemoteLazyInputStreamRef&
    get_RemoteLazyInputStreamRef()
    {
        AssertSanity(TRemoteLazyInputStreamRef);
        return (*(ptr_RemoteLazyInputStreamRef()));
    }
    const RemoteLazyInputStreamRef&
    get_RemoteLazyInputStreamRef() const
    {
        AssertSanity(TRemoteLazyInputStreamRef);
        return (*(constptr_RemoteLazyInputStreamRef()));
    }
    operator RemoteLazyInputStreamRef&()
    {
        return get_RemoteLazyInputStreamRef();
    }
    operator const RemoteLazyInputStreamRef&() const
    {
        return get_RemoteLazyInputStreamRef();
    }

    PRemoteLazyInputStreamParent*&
    get_PRemoteLazyInputStreamParent()
    {
        AssertSanity(TPRemoteLazyInputStreamParent);
        return (*(ptr_PRemoteLazyInputStreamParent()));
    }
    PRemoteLazyInputStreamParent*
    get_PRemoteLazyInputStreamParent() const
    {
        AssertSanity(TPRemoteLazyInputStreamParent);
        return (*(constptr_PRemoteLazyInputStreamParent()));
    }
    operator PRemoteLazyInputStreamParent*&()
    {
        return get_PRemoteLazyInputStreamParent();
    }
    operator PRemoteLazyInputStreamParent*() const
    {
        return get_PRemoteLazyInputStreamParent();
    }

    PRemoteLazyInputStreamChild*&
    get_PRemoteLazyInputStreamChild()
    {
        AssertSanity(TPRemoteLazyInputStreamChild);
        return (*(ptr_PRemoteLazyInputStreamChild()));
    }
    PRemoteLazyInputStreamChild*
    get_PRemoteLazyInputStreamChild() const
    {
        AssertSanity(TPRemoteLazyInputStreamChild);
        return (*(constptr_PRemoteLazyInputStreamChild()));
    }
    operator PRemoteLazyInputStreamChild*&()
    {
        return get_PRemoteLazyInputStreamChild();
    }
    operator PRemoteLazyInputStreamChild*() const
    {
        return get_PRemoteLazyInputStreamChild();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::RemoteLazyInputStreamParams>
{
    typedef mozilla::ipc::RemoteLazyInputStreamParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
class PChildToParentStreamParent;
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
class PChildToParentStreamChild;
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
class PParentToChildStreamParent;
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
class PParentToChildStreamChild;
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union IPCRemoteStreamType|
//
namespace mozilla {
namespace ipc {
class IPCRemoteStreamType final
{
public:
    enum Type {
        T__None,
        TPChildToParentStreamParent = 1,
        TPChildToParentStreamChild,
        TPParentToChildStreamParent,
        TPParentToChildStreamChild,
        T__Last = TPParentToChildStreamChild
    };

private:
    typedef mozilla::ipc::PChildToParentStreamParent PChildToParentStreamParent;
    typedef mozilla::ipc::PChildToParentStreamChild PChildToParentStreamChild;
    typedef mozilla::ipc::PParentToChildStreamParent PParentToChildStreamParent;
    typedef mozilla::ipc::PParentToChildStreamChild PParentToChildStreamChild;
    typedef PChildToParentStreamParent* PChildToParentStreamParent__tdef;
    typedef PChildToParentStreamChild* PChildToParentStreamChild__tdef;
    typedef PParentToChildStreamParent* PParentToChildStreamParent__tdef;
    typedef PParentToChildStreamChild* PParentToChildStreamChild__tdef;

    union Value {
        mozilla::AlignedStorage2<PChildToParentStreamParent*> VPChildToParentStreamParent;
        mozilla::AlignedStorage2<PChildToParentStreamChild*> VPChildToParentStreamChild;
        mozilla::AlignedStorage2<PParentToChildStreamParent*> VPParentToChildStreamParent;
        mozilla::AlignedStorage2<PParentToChildStreamChild*> VPParentToChildStreamChild;
    };

    PChildToParentStreamParent**
    ptr_PChildToParentStreamParent()
    {
        return ((mValue).VPChildToParentStreamParent).addr();
    }
    PChildToParentStreamParent* const*
    constptr_PChildToParentStreamParent() const
    {
        return ((mValue).VPChildToParentStreamParent).addr();
    }
    PChildToParentStreamChild**
    ptr_PChildToParentStreamChild()
    {
        return ((mValue).VPChildToParentStreamChild).addr();
    }
    PChildToParentStreamChild* const*
    constptr_PChildToParentStreamChild() const
    {
        return ((mValue).VPChildToParentStreamChild).addr();
    }
    PParentToChildStreamParent**
    ptr_PParentToChildStreamParent()
    {
        return ((mValue).VPParentToChildStreamParent).addr();
    }
    PParentToChildStreamParent* const*
    constptr_PParentToChildStreamParent() const
    {
        return ((mValue).VPParentToChildStreamParent).addr();
    }
    PParentToChildStreamChild**
    ptr_PParentToChildStreamChild()
    {
        return ((mValue).VPParentToChildStreamChild).addr();
    }
    PParentToChildStreamChild* const*
    constptr_PParentToChildStreamChild() const
    {
        return ((mValue).VPParentToChildStreamChild).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT IPCRemoteStreamType() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT IPCRemoteStreamType(PChildToParentStreamParent* aOther);

    MOZ_IMPLICIT IPCRemoteStreamType(PChildToParentStreamChild* aOther);

    MOZ_IMPLICIT IPCRemoteStreamType(PParentToChildStreamParent* aOther);

    MOZ_IMPLICIT IPCRemoteStreamType(PParentToChildStreamChild* aOther);

    MOZ_IMPLICIT IPCRemoteStreamType(const IPCRemoteStreamType& aOther);

    MOZ_IMPLICIT IPCRemoteStreamType(IPCRemoteStreamType&& aOther);

    ~IPCRemoteStreamType();

    Type
    type() const
    {
        return mType;
    }

    IPCRemoteStreamType&
    operator=(PChildToParentStreamParent* aRhs);

    IPCRemoteStreamType&
    operator=(PChildToParentStreamChild* aRhs);

    IPCRemoteStreamType&
    operator=(PParentToChildStreamParent* aRhs);

    IPCRemoteStreamType&
    operator=(PParentToChildStreamChild* aRhs);

    IPCRemoteStreamType&
    operator=(const IPCRemoteStreamType& aRhs);

    IPCRemoteStreamType&
    operator=(IPCRemoteStreamType&& aRhs);

    PChildToParentStreamParent*&
    get_PChildToParentStreamParent()
    {
        AssertSanity(TPChildToParentStreamParent);
        return (*(ptr_PChildToParentStreamParent()));
    }
    PChildToParentStreamParent*
    get_PChildToParentStreamParent() const
    {
        AssertSanity(TPChildToParentStreamParent);
        return (*(constptr_PChildToParentStreamParent()));
    }
    operator PChildToParentStreamParent*&()
    {
        return get_PChildToParentStreamParent();
    }
    operator PChildToParentStreamParent*() const
    {
        return get_PChildToParentStreamParent();
    }

    PChildToParentStreamChild*&
    get_PChildToParentStreamChild()
    {
        AssertSanity(TPChildToParentStreamChild);
        return (*(ptr_PChildToParentStreamChild()));
    }
    PChildToParentStreamChild*
    get_PChildToParentStreamChild() const
    {
        AssertSanity(TPChildToParentStreamChild);
        return (*(constptr_PChildToParentStreamChild()));
    }
    operator PChildToParentStreamChild*&()
    {
        return get_PChildToParentStreamChild();
    }
    operator PChildToParentStreamChild*() const
    {
        return get_PChildToParentStreamChild();
    }

    PParentToChildStreamParent*&
    get_PParentToChildStreamParent()
    {
        AssertSanity(TPParentToChildStreamParent);
        return (*(ptr_PParentToChildStreamParent()));
    }
    PParentToChildStreamParent*
    get_PParentToChildStreamParent() const
    {
        AssertSanity(TPParentToChildStreamParent);
        return (*(constptr_PParentToChildStreamParent()));
    }
    operator PParentToChildStreamParent*&()
    {
        return get_PParentToChildStreamParent();
    }
    operator PParentToChildStreamParent*() const
    {
        return get_PParentToChildStreamParent();
    }

    PParentToChildStreamChild*&
    get_PParentToChildStreamChild()
    {
        AssertSanity(TPParentToChildStreamChild);
        return (*(ptr_PParentToChildStreamChild()));
    }
    PParentToChildStreamChild*
    get_PParentToChildStreamChild() const
    {
        AssertSanity(TPParentToChildStreamChild);
        return (*(constptr_PParentToChildStreamChild()));
    }
    operator PParentToChildStreamChild*&()
    {
        return get_PParentToChildStreamChild();
    }
    operator PParentToChildStreamChild*() const
    {
        return get_PParentToChildStreamChild();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::IPCRemoteStreamType>
{
    typedef mozilla::ipc::IPCRemoteStreamType paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct IPCRemoteStreamParams|
//
namespace mozilla {
namespace ipc {
class IPCRemoteStreamParams final
{
private:
    typedef mozilla::ipc::IPCRemoteStreamType IPCRemoteStreamType;

public:
    MOZ_IMPLICIT IPCRemoteStreamParams() :
        delayedStart_(),
        stream_(),
        length_()
    {
    }

    MOZ_IMPLICIT IPCRemoteStreamParams(
            const bool& _delayedStart,
            const IPCRemoteStreamType& _stream,
            const int64_t& _length) :
        delayedStart_(_delayedStart),
        stream_(_stream),
        length_(_length)
    {
    }

    bool&
    delayedStart()
    {
        return delayedStart_;
    }
    const bool&
    delayedStart() const
    {
        return delayedStart_;
    }

    IPCRemoteStreamType&
    stream()
    {
        return stream_;
    }
    const IPCRemoteStreamType&
    stream() const
    {
        return stream_;
    }

    int64_t&
    length()
    {
        return length_;
    }
    const int64_t&
    length() const
    {
        return length_;
    }

private:
    bool delayedStart_;
    IPCRemoteStreamType stream_;
    int64_t length_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::IPCRemoteStreamParams>
{
    typedef mozilla::ipc::IPCRemoteStreamParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct EncryptedFileInputStreamParams|
//
namespace mozilla {
namespace ipc {
class EncryptedFileInputStreamParams final
{
private:
    typedef mozilla::ipc::FileInputStreamParams FileInputStreamParams;

public:
    MOZ_IMPLICIT EncryptedFileInputStreamParams() :
        fileInputStreamParams_(),
        key_(),
        blockSize_()
    {
    }

    MOZ_IMPLICIT EncryptedFileInputStreamParams(
            const FileInputStreamParams& _fileInputStreamParams,
            const nsTArray<uint8_t>& _key,
            const uint32_t& _blockSize) :
        fileInputStreamParams_(_fileInputStreamParams),
        key_(_key),
        blockSize_(_blockSize)
    {
    }

    FileInputStreamParams&
    fileInputStreamParams()
    {
        return fileInputStreamParams_;
    }
    const FileInputStreamParams&
    fileInputStreamParams() const
    {
        return fileInputStreamParams_;
    }

    nsTArray<uint8_t>&
    key()
    {
        return key_;
    }
    const nsTArray<uint8_t>&
    key() const
    {
        return key_;
    }

    uint32_t&
    blockSize()
    {
        return blockSize_;
    }
    const uint32_t&
    blockSize() const
    {
        return blockSize_;
    }

private:
    FileInputStreamParams fileInputStreamParams_;
    CopyableTArray<uint8_t> key_;
    uint32_t blockSize_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::EncryptedFileInputStreamParams>
{
    typedef mozilla::ipc::EncryptedFileInputStreamParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
class BufferedInputStreamParams;
} // namespace ipc
} // namespace mozilla
namespace mozilla {
namespace ipc {
class MIMEInputStreamParams;
} // namespace ipc
} // namespace mozilla
namespace mozilla {
namespace ipc {
class MultiplexInputStreamParams;
} // namespace ipc
} // namespace mozilla
namespace mozilla {
namespace ipc {
class SlicedInputStreamParams;
} // namespace ipc
} // namespace mozilla
namespace mozilla {
namespace ipc {
class InputStreamLengthWrapperParams;
} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union InputStreamParams|
//
namespace mozilla {
namespace ipc {
class InputStreamParams final
{
public:
    enum Type {
        T__None,
        TStringInputStreamParams = 1,
        TFileInputStreamParams,
        TBufferedInputStreamParams,
        TMIMEInputStreamParams,
        TMultiplexInputStreamParams,
        TSlicedInputStreamParams,
        TRemoteLazyInputStreamParams,
        TInputStreamLengthWrapperParams,
        TIPCRemoteStreamParams,
        TEncryptedFileInputStreamParams,
        T__Last = TEncryptedFileInputStreamParams
    };

private:
    typedef mozilla::ipc::StringInputStreamParams StringInputStreamParams;
    typedef mozilla::ipc::FileInputStreamParams FileInputStreamParams;
    typedef mozilla::ipc::BufferedInputStreamParams BufferedInputStreamParams;
    typedef mozilla::ipc::MIMEInputStreamParams MIMEInputStreamParams;
    typedef mozilla::ipc::MultiplexInputStreamParams MultiplexInputStreamParams;
    typedef mozilla::ipc::SlicedInputStreamParams SlicedInputStreamParams;
    typedef mozilla::ipc::RemoteLazyInputStreamParams RemoteLazyInputStreamParams;
    typedef mozilla::ipc::InputStreamLengthWrapperParams InputStreamLengthWrapperParams;
    typedef mozilla::ipc::IPCRemoteStreamParams IPCRemoteStreamParams;
    typedef mozilla::ipc::EncryptedFileInputStreamParams EncryptedFileInputStreamParams;
    typedef StringInputStreamParams StringInputStreamParams__tdef;
    typedef FileInputStreamParams FileInputStreamParams__tdef;
    typedef BufferedInputStreamParams* BufferedInputStreamParams__tdef;
    typedef MIMEInputStreamParams* MIMEInputStreamParams__tdef;
    typedef MultiplexInputStreamParams* MultiplexInputStreamParams__tdef;
    typedef SlicedInputStreamParams* SlicedInputStreamParams__tdef;
    typedef RemoteLazyInputStreamParams RemoteLazyInputStreamParams__tdef;
    typedef InputStreamLengthWrapperParams* InputStreamLengthWrapperParams__tdef;
    typedef IPCRemoteStreamParams IPCRemoteStreamParams__tdef;
    typedef EncryptedFileInputStreamParams EncryptedFileInputStreamParams__tdef;

    union Value {
        mozilla::AlignedStorage2<StringInputStreamParams> VStringInputStreamParams;
        mozilla::AlignedStorage2<FileInputStreamParams> VFileInputStreamParams;
        BufferedInputStreamParams* VBufferedInputStreamParams;
        MIMEInputStreamParams* VMIMEInputStreamParams;
        MultiplexInputStreamParams* VMultiplexInputStreamParams;
        SlicedInputStreamParams* VSlicedInputStreamParams;
        mozilla::AlignedStorage2<RemoteLazyInputStreamParams> VRemoteLazyInputStreamParams;
        InputStreamLengthWrapperParams* VInputStreamLengthWrapperParams;
        mozilla::AlignedStorage2<IPCRemoteStreamParams> VIPCRemoteStreamParams;
        mozilla::AlignedStorage2<EncryptedFileInputStreamParams> VEncryptedFileInputStreamParams;
    };

    StringInputStreamParams*
    ptr_StringInputStreamParams()
    {
        return ((mValue).VStringInputStreamParams).addr();
    }
    const StringInputStreamParams*
    constptr_StringInputStreamParams() const
    {
        return ((mValue).VStringInputStreamParams).addr();
    }
    FileInputStreamParams*
    ptr_FileInputStreamParams()
    {
        return ((mValue).VFileInputStreamParams).addr();
    }
    const FileInputStreamParams*
    constptr_FileInputStreamParams() const
    {
        return ((mValue).VFileInputStreamParams).addr();
    }
    BufferedInputStreamParams*&
    ptr_BufferedInputStreamParams()
    {
        return (mValue).VBufferedInputStreamParams;
    }
    const BufferedInputStreamParams*
    constptr_BufferedInputStreamParams() const
    {
        return (mValue).VBufferedInputStreamParams;
    }
    MIMEInputStreamParams*&
    ptr_MIMEInputStreamParams()
    {
        return (mValue).VMIMEInputStreamParams;
    }
    const MIMEInputStreamParams*
    constptr_MIMEInputStreamParams() const
    {
        return (mValue).VMIMEInputStreamParams;
    }
    MultiplexInputStreamParams*&
    ptr_MultiplexInputStreamParams()
    {
        return (mValue).VMultiplexInputStreamParams;
    }
    const MultiplexInputStreamParams*
    constptr_MultiplexInputStreamParams() const
    {
        return (mValue).VMultiplexInputStreamParams;
    }
    SlicedInputStreamParams*&
    ptr_SlicedInputStreamParams()
    {
        return (mValue).VSlicedInputStreamParams;
    }
    const SlicedInputStreamParams*
    constptr_SlicedInputStreamParams() const
    {
        return (mValue).VSlicedInputStreamParams;
    }
    RemoteLazyInputStreamParams*
    ptr_RemoteLazyInputStreamParams()
    {
        return ((mValue).VRemoteLazyInputStreamParams).addr();
    }
    const RemoteLazyInputStreamParams*
    constptr_RemoteLazyInputStreamParams() const
    {
        return ((mValue).VRemoteLazyInputStreamParams).addr();
    }
    InputStreamLengthWrapperParams*&
    ptr_InputStreamLengthWrapperParams()
    {
        return (mValue).VInputStreamLengthWrapperParams;
    }
    const InputStreamLengthWrapperParams*
    constptr_InputStreamLengthWrapperParams() const
    {
        return (mValue).VInputStreamLengthWrapperParams;
    }
    IPCRemoteStreamParams*
    ptr_IPCRemoteStreamParams()
    {
        return ((mValue).VIPCRemoteStreamParams).addr();
    }
    const IPCRemoteStreamParams*
    constptr_IPCRemoteStreamParams() const
    {
        return ((mValue).VIPCRemoteStreamParams).addr();
    }
    EncryptedFileInputStreamParams*
    ptr_EncryptedFileInputStreamParams()
    {
        return ((mValue).VEncryptedFileInputStreamParams).addr();
    }
    const EncryptedFileInputStreamParams*
    constptr_EncryptedFileInputStreamParams() const
    {
        return ((mValue).VEncryptedFileInputStreamParams).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT InputStreamParams() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT InputStreamParams(const StringInputStreamParams& aOther);

    MOZ_IMPLICIT InputStreamParams(StringInputStreamParams&& aOther);

    MOZ_IMPLICIT InputStreamParams(const FileInputStreamParams& aOther);

    MOZ_IMPLICIT InputStreamParams(FileInputStreamParams&& aOther);

    MOZ_IMPLICIT InputStreamParams(const BufferedInputStreamParams& aOther);

    MOZ_IMPLICIT InputStreamParams(BufferedInputStreamParams&& aOther);

    MOZ_IMPLICIT InputStreamParams(const MIMEInputStreamParams& aOther);

    MOZ_IMPLICIT InputStreamParams(MIMEInputStreamParams&& aOther);

    MOZ_IMPLICIT InputStreamParams(const MultiplexInputStreamParams& aOther);

    MOZ_IMPLICIT InputStreamParams(MultiplexInputStreamParams&& aOther);

    MOZ_IMPLICIT InputStreamParams(const SlicedInputStreamParams& aOther);

    MOZ_IMPLICIT InputStreamParams(SlicedInputStreamParams&& aOther);

    MOZ_IMPLICIT InputStreamParams(const RemoteLazyInputStreamParams& aOther);

    MOZ_IMPLICIT InputStreamParams(RemoteLazyInputStreamParams&& aOther);

    MOZ_IMPLICIT InputStreamParams(const InputStreamLengthWrapperParams& aOther);

    MOZ_IMPLICIT InputStreamParams(InputStreamLengthWrapperParams&& aOther);

    MOZ_IMPLICIT InputStreamParams(const IPCRemoteStreamParams& aOther);

    MOZ_IMPLICIT InputStreamParams(IPCRemoteStreamParams&& aOther);

    MOZ_IMPLICIT InputStreamParams(const EncryptedFileInputStreamParams& aOther);

    MOZ_IMPLICIT InputStreamParams(EncryptedFileInputStreamParams&& aOther);

    MOZ_IMPLICIT InputStreamParams(const InputStreamParams& aOther);

    MOZ_IMPLICIT InputStreamParams(InputStreamParams&& aOther);

    ~InputStreamParams();

    Type
    type() const
    {
        return mType;
    }

    InputStreamParams&
    operator=(const StringInputStreamParams& aRhs);

    InputStreamParams&
    operator=(StringInputStreamParams&& aRhs);

    InputStreamParams&
    operator=(const FileInputStreamParams& aRhs);

    InputStreamParams&
    operator=(FileInputStreamParams&& aRhs);

    InputStreamParams&
    operator=(const BufferedInputStreamParams& aRhs);

    InputStreamParams&
    operator=(BufferedInputStreamParams&& aRhs);

    InputStreamParams&
    operator=(const MIMEInputStreamParams& aRhs);

    InputStreamParams&
    operator=(MIMEInputStreamParams&& aRhs);

    InputStreamParams&
    operator=(const MultiplexInputStreamParams& aRhs);

    InputStreamParams&
    operator=(MultiplexInputStreamParams&& aRhs);

    InputStreamParams&
    operator=(const SlicedInputStreamParams& aRhs);

    InputStreamParams&
    operator=(SlicedInputStreamParams&& aRhs);

    InputStreamParams&
    operator=(const RemoteLazyInputStreamParams& aRhs);

    InputStreamParams&
    operator=(RemoteLazyInputStreamParams&& aRhs);

    InputStreamParams&
    operator=(const InputStreamLengthWrapperParams& aRhs);

    InputStreamParams&
    operator=(InputStreamLengthWrapperParams&& aRhs);

    InputStreamParams&
    operator=(const IPCRemoteStreamParams& aRhs);

    InputStreamParams&
    operator=(IPCRemoteStreamParams&& aRhs);

    InputStreamParams&
    operator=(const EncryptedFileInputStreamParams& aRhs);

    InputStreamParams&
    operator=(EncryptedFileInputStreamParams&& aRhs);

    InputStreamParams&
    operator=(const InputStreamParams& aRhs);

    InputStreamParams&
    operator=(InputStreamParams&& aRhs);

    StringInputStreamParams&
    get_StringInputStreamParams()
    {
        AssertSanity(TStringInputStreamParams);
        return (*(ptr_StringInputStreamParams()));
    }
    const StringInputStreamParams&
    get_StringInputStreamParams() const
    {
        AssertSanity(TStringInputStreamParams);
        return (*(constptr_StringInputStreamParams()));
    }
    operator StringInputStreamParams&()
    {
        return get_StringInputStreamParams();
    }
    operator const StringInputStreamParams&() const
    {
        return get_StringInputStreamParams();
    }

    FileInputStreamParams&
    get_FileInputStreamParams()
    {
        AssertSanity(TFileInputStreamParams);
        return (*(ptr_FileInputStreamParams()));
    }
    const FileInputStreamParams&
    get_FileInputStreamParams() const
    {
        AssertSanity(TFileInputStreamParams);
        return (*(constptr_FileInputStreamParams()));
    }
    operator FileInputStreamParams&()
    {
        return get_FileInputStreamParams();
    }
    operator const FileInputStreamParams&() const
    {
        return get_FileInputStreamParams();
    }

    BufferedInputStreamParams&
    get_BufferedInputStreamParams()
    {
        AssertSanity(TBufferedInputStreamParams);
        return (*(ptr_BufferedInputStreamParams()));
    }
    const BufferedInputStreamParams&
    get_BufferedInputStreamParams() const
    {
        AssertSanity(TBufferedInputStreamParams);
        return (*(constptr_BufferedInputStreamParams()));
    }
    operator BufferedInputStreamParams&()
    {
        return get_BufferedInputStreamParams();
    }
    operator const BufferedInputStreamParams&() const
    {
        return get_BufferedInputStreamParams();
    }

    MIMEInputStreamParams&
    get_MIMEInputStreamParams()
    {
        AssertSanity(TMIMEInputStreamParams);
        return (*(ptr_MIMEInputStreamParams()));
    }
    const MIMEInputStreamParams&
    get_MIMEInputStreamParams() const
    {
        AssertSanity(TMIMEInputStreamParams);
        return (*(constptr_MIMEInputStreamParams()));
    }
    operator MIMEInputStreamParams&()
    {
        return get_MIMEInputStreamParams();
    }
    operator const MIMEInputStreamParams&() const
    {
        return get_MIMEInputStreamParams();
    }

    MultiplexInputStreamParams&
    get_MultiplexInputStreamParams()
    {
        AssertSanity(TMultiplexInputStreamParams);
        return (*(ptr_MultiplexInputStreamParams()));
    }
    const MultiplexInputStreamParams&
    get_MultiplexInputStreamParams() const
    {
        AssertSanity(TMultiplexInputStreamParams);
        return (*(constptr_MultiplexInputStreamParams()));
    }
    operator MultiplexInputStreamParams&()
    {
        return get_MultiplexInputStreamParams();
    }
    operator const MultiplexInputStreamParams&() const
    {
        return get_MultiplexInputStreamParams();
    }

    SlicedInputStreamParams&
    get_SlicedInputStreamParams()
    {
        AssertSanity(TSlicedInputStreamParams);
        return (*(ptr_SlicedInputStreamParams()));
    }
    const SlicedInputStreamParams&
    get_SlicedInputStreamParams() const
    {
        AssertSanity(TSlicedInputStreamParams);
        return (*(constptr_SlicedInputStreamParams()));
    }
    operator SlicedInputStreamParams&()
    {
        return get_SlicedInputStreamParams();
    }
    operator const SlicedInputStreamParams&() const
    {
        return get_SlicedInputStreamParams();
    }

    RemoteLazyInputStreamParams&
    get_RemoteLazyInputStreamParams()
    {
        AssertSanity(TRemoteLazyInputStreamParams);
        return (*(ptr_RemoteLazyInputStreamParams()));
    }
    const RemoteLazyInputStreamParams&
    get_RemoteLazyInputStreamParams() const
    {
        AssertSanity(TRemoteLazyInputStreamParams);
        return (*(constptr_RemoteLazyInputStreamParams()));
    }
    operator RemoteLazyInputStreamParams&()
    {
        return get_RemoteLazyInputStreamParams();
    }
    operator const RemoteLazyInputStreamParams&() const
    {
        return get_RemoteLazyInputStreamParams();
    }

    InputStreamLengthWrapperParams&
    get_InputStreamLengthWrapperParams()
    {
        AssertSanity(TInputStreamLengthWrapperParams);
        return (*(ptr_InputStreamLengthWrapperParams()));
    }
    const InputStreamLengthWrapperParams&
    get_InputStreamLengthWrapperParams() const
    {
        AssertSanity(TInputStreamLengthWrapperParams);
        return (*(constptr_InputStreamLengthWrapperParams()));
    }
    operator InputStreamLengthWrapperParams&()
    {
        return get_InputStreamLengthWrapperParams();
    }
    operator const InputStreamLengthWrapperParams&() const
    {
        return get_InputStreamLengthWrapperParams();
    }

    IPCRemoteStreamParams&
    get_IPCRemoteStreamParams()
    {
        AssertSanity(TIPCRemoteStreamParams);
        return (*(ptr_IPCRemoteStreamParams()));
    }
    const IPCRemoteStreamParams&
    get_IPCRemoteStreamParams() const
    {
        AssertSanity(TIPCRemoteStreamParams);
        return (*(constptr_IPCRemoteStreamParams()));
    }
    operator IPCRemoteStreamParams&()
    {
        return get_IPCRemoteStreamParams();
    }
    operator const IPCRemoteStreamParams&() const
    {
        return get_IPCRemoteStreamParams();
    }

    EncryptedFileInputStreamParams&
    get_EncryptedFileInputStreamParams()
    {
        AssertSanity(TEncryptedFileInputStreamParams);
        return (*(ptr_EncryptedFileInputStreamParams()));
    }
    const EncryptedFileInputStreamParams&
    get_EncryptedFileInputStreamParams() const
    {
        AssertSanity(TEncryptedFileInputStreamParams);
        return (*(constptr_EncryptedFileInputStreamParams()));
    }
    operator EncryptedFileInputStreamParams&()
    {
        return get_EncryptedFileInputStreamParams();
    }
    operator const EncryptedFileInputStreamParams&() const
    {
        return get_EncryptedFileInputStreamParams();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::InputStreamParams>
{
    typedef mozilla::ipc::InputStreamParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct MultiplexInputStreamParams|
//
namespace mozilla {
namespace ipc {
class MultiplexInputStreamParams final
{
private:
    typedef mozilla::ipc::InputStreamParams InputStreamParams;

public:
    MOZ_IMPLICIT MultiplexInputStreamParams() :
        streams_(),
        status_(),
        startedReadingCurrent_(),
        currentStream_()
    {
    }

    MOZ_IMPLICIT MultiplexInputStreamParams(
            const nsTArray<InputStreamParams>& _streams,
            const uint32_t& _currentStream,
            const nsresult& _status,
            const bool& _startedReadingCurrent) :
        streams_(_streams),
        status_(_status),
        startedReadingCurrent_(_startedReadingCurrent),
        currentStream_(_currentStream)
    {
    }

    nsTArray<InputStreamParams>&
    streams()
    {
        return streams_;
    }
    const nsTArray<InputStreamParams>&
    streams() const
    {
        return streams_;
    }

    uint32_t&
    currentStream()
    {
        return currentStream_;
    }
    const uint32_t&
    currentStream() const
    {
        return currentStream_;
    }

    nsresult&
    status()
    {
        return status_;
    }
    const nsresult&
    status() const
    {
        return status_;
    }

    bool&
    startedReadingCurrent()
    {
        return startedReadingCurrent_;
    }
    const bool&
    startedReadingCurrent() const
    {
        return startedReadingCurrent_;
    }

private:
    CopyableTArray<InputStreamParams> streams_;
    nsresult status_;
    bool startedReadingCurrent_;
    uint32_t currentStream_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::MultiplexInputStreamParams>
{
    typedef mozilla::ipc::MultiplexInputStreamParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SlicedInputStreamParams|
//
namespace mozilla {
namespace ipc {
class SlicedInputStreamParams final
{
private:
    typedef mozilla::ipc::InputStreamParams InputStreamParams;

public:
    MOZ_IMPLICIT SlicedInputStreamParams() :
        stream_(),
        closed_(),
        start_(),
        length_(),
        curPos_()
    {
    }

    MOZ_IMPLICIT SlicedInputStreamParams(
            const InputStreamParams& _stream,
            const uint64_t& _start,
            const uint64_t& _length,
            const uint64_t& _curPos,
            const bool& _closed) :
        stream_(_stream),
        closed_(_closed),
        start_(_start),
        length_(_length),
        curPos_(_curPos)
    {
    }

    InputStreamParams&
    stream()
    {
        return stream_;
    }
    const InputStreamParams&
    stream() const
    {
        return stream_;
    }

    uint64_t&
    start()
    {
        return start_;
    }
    const uint64_t&
    start() const
    {
        return start_;
    }

    uint64_t&
    length()
    {
        return length_;
    }
    const uint64_t&
    length() const
    {
        return length_;
    }

    uint64_t&
    curPos()
    {
        return curPos_;
    }
    const uint64_t&
    curPos() const
    {
        return curPos_;
    }

    bool&
    closed()
    {
        return closed_;
    }
    const bool&
    closed() const
    {
        return closed_;
    }

private:
    void
    StaticAssertions() const;
    InputStreamParams stream_;
    bool closed_;
    uint64_t start_;
    uint64_t length_;
    uint64_t curPos_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::SlicedInputStreamParams>
{
    typedef mozilla::ipc::SlicedInputStreamParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct BufferedInputStreamParams|
//
namespace mozilla {
namespace ipc {
class BufferedInputStreamParams final
{
private:
    typedef mozilla::ipc::InputStreamParams InputStreamParams;

public:
    MOZ_IMPLICIT BufferedInputStreamParams() :
        optionalStream_(),
        bufferSize_()
    {
    }

    MOZ_IMPLICIT BufferedInputStreamParams(
            const mozilla::Maybe<InputStreamParams>& _optionalStream,
            const uint32_t& _bufferSize) :
        optionalStream_(_optionalStream),
        bufferSize_(_bufferSize)
    {
    }

    mozilla::Maybe<InputStreamParams>&
    optionalStream()
    {
        return optionalStream_;
    }
    const mozilla::Maybe<InputStreamParams>&
    optionalStream() const
    {
        return optionalStream_;
    }

    uint32_t&
    bufferSize()
    {
        return bufferSize_;
    }
    const uint32_t&
    bufferSize() const
    {
        return bufferSize_;
    }

private:
    mozilla::Maybe<InputStreamParams> optionalStream_;
    uint32_t bufferSize_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::BufferedInputStreamParams>
{
    typedef mozilla::ipc::BufferedInputStreamParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct MIMEInputStreamParams|
//
namespace mozilla {
namespace ipc {
class MIMEInputStreamParams final
{
private:
    typedef mozilla::ipc::InputStreamParams InputStreamParams;
    typedef mozilla::ipc::HeaderEntry HeaderEntry;

public:
    MOZ_IMPLICIT MIMEInputStreamParams() :
        optionalStream_(),
        headers_(),
        startedReading_()
    {
    }

    MOZ_IMPLICIT MIMEInputStreamParams(
            const mozilla::Maybe<InputStreamParams>& _optionalStream,
            const nsTArray<HeaderEntry>& _headers,
            const bool& _startedReading) :
        optionalStream_(_optionalStream),
        headers_(_headers),
        startedReading_(_startedReading)
    {
    }

    mozilla::Maybe<InputStreamParams>&
    optionalStream()
    {
        return optionalStream_;
    }
    const mozilla::Maybe<InputStreamParams>&
    optionalStream() const
    {
        return optionalStream_;
    }

    nsTArray<HeaderEntry>&
    headers()
    {
        return headers_;
    }
    const nsTArray<HeaderEntry>&
    headers() const
    {
        return headers_;
    }

    bool&
    startedReading()
    {
        return startedReading_;
    }
    const bool&
    startedReading() const
    {
        return startedReading_;
    }

private:
    mozilla::Maybe<InputStreamParams> optionalStream_;
    CopyableTArray<HeaderEntry> headers_;
    bool startedReading_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::MIMEInputStreamParams>
{
    typedef mozilla::ipc::MIMEInputStreamParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct InputStreamLengthWrapperParams|
//
namespace mozilla {
namespace ipc {
class InputStreamLengthWrapperParams final
{
private:
    typedef mozilla::ipc::InputStreamParams InputStreamParams;

public:
    MOZ_IMPLICIT InputStreamLengthWrapperParams() :
        stream_(),
        consumed_(),
        length_()
    {
    }

    MOZ_IMPLICIT InputStreamLengthWrapperParams(
            const InputStreamParams& _stream,
            const int64_t& _length,
            const bool& _consumed) :
        stream_(_stream),
        consumed_(_consumed),
        length_(_length)
    {
    }

    InputStreamParams&
    stream()
    {
        return stream_;
    }
    const InputStreamParams&
    stream() const
    {
        return stream_;
    }

    int64_t&
    length()
    {
        return length_;
    }
    const int64_t&
    length() const
    {
        return length_;
    }

    bool&
    consumed()
    {
        return consumed_;
    }
    const bool&
    consumed() const
    {
        return consumed_;
    }

private:
    InputStreamParams stream_;
    bool consumed_;
    int64_t length_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::InputStreamLengthWrapperParams>
{
    typedef mozilla::ipc::InputStreamLengthWrapperParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

#endif // ifndef InputStreamParams_h
