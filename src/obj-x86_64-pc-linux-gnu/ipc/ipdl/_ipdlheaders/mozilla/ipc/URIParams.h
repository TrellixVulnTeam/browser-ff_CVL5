//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef URIParams_h
#define URIParams_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"
#include "mozilla/ipc/PBackgroundSharedTypes.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SimpleURIParams|
//
namespace mozilla {
namespace ipc {
class SimpleURIParams final
{
private:

public:
    MOZ_IMPLICIT SimpleURIParams() :
        scheme_(),
        path_(),
        ref_(),
        query_()
    {
    }

    MOZ_IMPLICIT SimpleURIParams(
            const nsCString& _scheme,
            const nsCString& _path,
            const nsCString& _ref,
            const nsCString& _query) :
        scheme_(_scheme),
        path_(_path),
        ref_(_ref),
        query_(_query)
    {
    }

    nsCString&
    scheme()
    {
        return scheme_;
    }
    const nsCString&
    scheme() const
    {
        return scheme_;
    }

    nsCString&
    path()
    {
        return path_;
    }
    const nsCString&
    path() const
    {
        return path_;
    }

    nsCString&
    ref()
    {
        return ref_;
    }
    const nsCString&
    ref() const
    {
        return ref_;
    }

    nsCString&
    query()
    {
        return query_;
    }
    const nsCString&
    query() const
    {
        return query_;
    }

private:
    nsCString scheme_;
    nsCString path_;
    nsCString ref_;
    nsCString query_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::SimpleURIParams>
{
    typedef mozilla::ipc::SimpleURIParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct DefaultURIParams|
//
namespace mozilla {
namespace ipc {
class DefaultURIParams final
{
private:

public:
    MOZ_IMPLICIT DefaultURIParams() :
        spec_()
    {
    }

    MOZ_IMPLICIT DefaultURIParams(const nsCString& _spec) :
        spec_(_spec)
    {
    }

    nsCString&
    spec()
    {
        return spec_;
    }
    const nsCString&
    spec() const
    {
        return spec_;
    }

private:
    nsCString spec_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::DefaultURIParams>
{
    typedef mozilla::ipc::DefaultURIParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct StandardURLSegment|
//
namespace mozilla {
namespace ipc {
class StandardURLSegment final
{
private:

public:
    MOZ_IMPLICIT StandardURLSegment() :
        position_(),
        length_()
    {
    }

    MOZ_IMPLICIT StandardURLSegment(
            const uint32_t& _position,
            const int32_t& _length) :
        position_(_position),
        length_(_length)
    {
    }

    uint32_t&
    position()
    {
        return position_;
    }
    const uint32_t&
    position() const
    {
        return position_;
    }

    int32_t&
    length()
    {
        return length_;
    }
    const int32_t&
    length() const
    {
        return length_;
    }

private:
    void
    StaticAssertions() const;
    uint32_t position_;
    int32_t length_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::StandardURLSegment>
{
    typedef mozilla::ipc::StandardURLSegment paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct StandardURLParams|
//
namespace mozilla {
namespace ipc {
class StandardURLParams final
{
private:
    typedef mozilla::ipc::StandardURLSegment StandardURLSegment;

public:
    MOZ_IMPLICIT StandardURLParams() :
        spec_(),
        scheme_(),
        authority_(),
        username_(),
        password_(),
        host_(),
        path_(),
        filePath_(),
        directory_(),
        baseName_(),
        extension_(),
        query_(),
        ref_(),
        supportsFileURL_(),
        isSubstituting_(),
        urlType_(),
        port_(),
        defaultPort_()
    {
    }

    MOZ_IMPLICIT StandardURLParams(
            const uint32_t& _urlType,
            const int32_t& _port,
            const int32_t& _defaultPort,
            const nsCString& _spec,
            const StandardURLSegment& _scheme,
            const StandardURLSegment& _authority,
            const StandardURLSegment& _username,
            const StandardURLSegment& _password,
            const StandardURLSegment& _host,
            const StandardURLSegment& _path,
            const StandardURLSegment& _filePath,
            const StandardURLSegment& _directory,
            const StandardURLSegment& _baseName,
            const StandardURLSegment& _extension,
            const StandardURLSegment& _query,
            const StandardURLSegment& _ref,
            const bool& _supportsFileURL,
            const bool& _isSubstituting) :
        spec_(_spec),
        scheme_(_scheme),
        authority_(_authority),
        username_(_username),
        password_(_password),
        host_(_host),
        path_(_path),
        filePath_(_filePath),
        directory_(_directory),
        baseName_(_baseName),
        extension_(_extension),
        query_(_query),
        ref_(_ref),
        supportsFileURL_(_supportsFileURL),
        isSubstituting_(_isSubstituting),
        urlType_(_urlType),
        port_(_port),
        defaultPort_(_defaultPort)
    {
    }

    uint32_t&
    urlType()
    {
        return urlType_;
    }
    const uint32_t&
    urlType() const
    {
        return urlType_;
    }

    int32_t&
    port()
    {
        return port_;
    }
    const int32_t&
    port() const
    {
        return port_;
    }

    int32_t&
    defaultPort()
    {
        return defaultPort_;
    }
    const int32_t&
    defaultPort() const
    {
        return defaultPort_;
    }

    nsCString&
    spec()
    {
        return spec_;
    }
    const nsCString&
    spec() const
    {
        return spec_;
    }

    StandardURLSegment&
    scheme()
    {
        return scheme_;
    }
    const StandardURLSegment&
    scheme() const
    {
        return scheme_;
    }

    StandardURLSegment&
    authority()
    {
        return authority_;
    }
    const StandardURLSegment&
    authority() const
    {
        return authority_;
    }

    StandardURLSegment&
    username()
    {
        return username_;
    }
    const StandardURLSegment&
    username() const
    {
        return username_;
    }

    StandardURLSegment&
    password()
    {
        return password_;
    }
    const StandardURLSegment&
    password() const
    {
        return password_;
    }

    StandardURLSegment&
    host()
    {
        return host_;
    }
    const StandardURLSegment&
    host() const
    {
        return host_;
    }

    StandardURLSegment&
    path()
    {
        return path_;
    }
    const StandardURLSegment&
    path() const
    {
        return path_;
    }

    StandardURLSegment&
    filePath()
    {
        return filePath_;
    }
    const StandardURLSegment&
    filePath() const
    {
        return filePath_;
    }

    StandardURLSegment&
    directory()
    {
        return directory_;
    }
    const StandardURLSegment&
    directory() const
    {
        return directory_;
    }

    StandardURLSegment&
    baseName()
    {
        return baseName_;
    }
    const StandardURLSegment&
    baseName() const
    {
        return baseName_;
    }

    StandardURLSegment&
    extension()
    {
        return extension_;
    }
    const StandardURLSegment&
    extension() const
    {
        return extension_;
    }

    StandardURLSegment&
    query()
    {
        return query_;
    }
    const StandardURLSegment&
    query() const
    {
        return query_;
    }

    StandardURLSegment&
    ref()
    {
        return ref_;
    }
    const StandardURLSegment&
    ref() const
    {
        return ref_;
    }

    bool&
    supportsFileURL()
    {
        return supportsFileURL_;
    }
    const bool&
    supportsFileURL() const
    {
        return supportsFileURL_;
    }

    bool&
    isSubstituting()
    {
        return isSubstituting_;
    }
    const bool&
    isSubstituting() const
    {
        return isSubstituting_;
    }

private:
    void
    StaticAssertions() const;
    nsCString spec_;
    StandardURLSegment scheme_;
    StandardURLSegment authority_;
    StandardURLSegment username_;
    StandardURLSegment password_;
    StandardURLSegment host_;
    StandardURLSegment path_;
    StandardURLSegment filePath_;
    StandardURLSegment directory_;
    StandardURLSegment baseName_;
    StandardURLSegment extension_;
    StandardURLSegment query_;
    StandardURLSegment ref_;
    bool supportsFileURL_;
    bool isSubstituting_;
    uint32_t urlType_;
    int32_t port_;
    int32_t defaultPort_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::StandardURLParams>
{
    typedef mozilla::ipc::StandardURLParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct NullPrincipalURIParams|
//
namespace mozilla {
namespace ipc {
class NullPrincipalURIParams final
{
private:

public:
    MOZ_IMPLICIT NullPrincipalURIParams()
    {
    }

private:
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::NullPrincipalURIParams>
{
    typedef mozilla::ipc::NullPrincipalURIParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct HostObjectURIParams|
//
namespace mozilla {
namespace ipc {
class HostObjectURIParams final
{
private:
    typedef mozilla::ipc::SimpleURIParams SimpleURIParams;

public:
    MOZ_IMPLICIT HostObjectURIParams() :
        simpleParams_(),
        revoked_()
    {
    }

    MOZ_IMPLICIT HostObjectURIParams(
            const SimpleURIParams& _simpleParams,
            const bool& _revoked) :
        simpleParams_(_simpleParams),
        revoked_(_revoked)
    {
    }

    SimpleURIParams&
    simpleParams()
    {
        return simpleParams_;
    }
    const SimpleURIParams&
    simpleParams() const
    {
        return simpleParams_;
    }

    bool&
    revoked()
    {
        return revoked_;
    }
    const bool&
    revoked() const
    {
        return revoked_;
    }

private:
    SimpleURIParams simpleParams_;
    bool revoked_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::HostObjectURIParams>
{
    typedef mozilla::ipc::HostObjectURIParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
class JARURIParams;
} // namespace ipc
} // namespace mozilla
namespace mozilla {
namespace ipc {
class IconURIParams;
} // namespace ipc
} // namespace mozilla
namespace mozilla {
namespace ipc {
class JSURIParams;
} // namespace ipc
} // namespace mozilla
namespace mozilla {
namespace ipc {
class SimpleNestedURIParams;
} // namespace ipc
} // namespace mozilla
namespace mozilla {
namespace ipc {
class NestedAboutURIParams;
} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union URIParams|
//
namespace mozilla {
namespace ipc {
class URIParams final
{
public:
    enum Type {
        T__None,
        TSimpleURIParams = 1,
        TStandardURLParams,
        TJARURIParams,
        TIconURIParams,
        TNullPrincipalURIParams,
        TJSURIParams,
        TSimpleNestedURIParams,
        THostObjectURIParams,
        TDefaultURIParams,
        TNestedAboutURIParams,
        T__Last = TNestedAboutURIParams
    };

private:
    typedef mozilla::ipc::SimpleURIParams SimpleURIParams;
    typedef mozilla::ipc::StandardURLParams StandardURLParams;
    typedef mozilla::ipc::JARURIParams JARURIParams;
    typedef mozilla::ipc::IconURIParams IconURIParams;
    typedef mozilla::ipc::NullPrincipalURIParams NullPrincipalURIParams;
    typedef mozilla::ipc::JSURIParams JSURIParams;
    typedef mozilla::ipc::SimpleNestedURIParams SimpleNestedURIParams;
    typedef mozilla::ipc::HostObjectURIParams HostObjectURIParams;
    typedef mozilla::ipc::DefaultURIParams DefaultURIParams;
    typedef mozilla::ipc::NestedAboutURIParams NestedAboutURIParams;
    typedef SimpleURIParams SimpleURIParams__tdef;
    typedef StandardURLParams StandardURLParams__tdef;
    typedef JARURIParams* JARURIParams__tdef;
    typedef IconURIParams* IconURIParams__tdef;
    typedef NullPrincipalURIParams NullPrincipalURIParams__tdef;
    typedef JSURIParams* JSURIParams__tdef;
    typedef SimpleNestedURIParams* SimpleNestedURIParams__tdef;
    typedef HostObjectURIParams HostObjectURIParams__tdef;
    typedef DefaultURIParams DefaultURIParams__tdef;
    typedef NestedAboutURIParams* NestedAboutURIParams__tdef;

    union Value {
        mozilla::AlignedStorage2<SimpleURIParams> VSimpleURIParams;
        mozilla::AlignedStorage2<StandardURLParams> VStandardURLParams;
        JARURIParams* VJARURIParams;
        IconURIParams* VIconURIParams;
        mozilla::AlignedStorage2<NullPrincipalURIParams> VNullPrincipalURIParams;
        JSURIParams* VJSURIParams;
        SimpleNestedURIParams* VSimpleNestedURIParams;
        mozilla::AlignedStorage2<HostObjectURIParams> VHostObjectURIParams;
        mozilla::AlignedStorage2<DefaultURIParams> VDefaultURIParams;
        NestedAboutURIParams* VNestedAboutURIParams;
    };

    SimpleURIParams*
    ptr_SimpleURIParams()
    {
        return ((mValue).VSimpleURIParams).addr();
    }
    const SimpleURIParams*
    constptr_SimpleURIParams() const
    {
        return ((mValue).VSimpleURIParams).addr();
    }
    StandardURLParams*
    ptr_StandardURLParams()
    {
        return ((mValue).VStandardURLParams).addr();
    }
    const StandardURLParams*
    constptr_StandardURLParams() const
    {
        return ((mValue).VStandardURLParams).addr();
    }
    JARURIParams*&
    ptr_JARURIParams()
    {
        return (mValue).VJARURIParams;
    }
    const JARURIParams*
    constptr_JARURIParams() const
    {
        return (mValue).VJARURIParams;
    }
    IconURIParams*&
    ptr_IconURIParams()
    {
        return (mValue).VIconURIParams;
    }
    const IconURIParams*
    constptr_IconURIParams() const
    {
        return (mValue).VIconURIParams;
    }
    NullPrincipalURIParams*
    ptr_NullPrincipalURIParams()
    {
        return ((mValue).VNullPrincipalURIParams).addr();
    }
    const NullPrincipalURIParams*
    constptr_NullPrincipalURIParams() const
    {
        return ((mValue).VNullPrincipalURIParams).addr();
    }
    JSURIParams*&
    ptr_JSURIParams()
    {
        return (mValue).VJSURIParams;
    }
    const JSURIParams*
    constptr_JSURIParams() const
    {
        return (mValue).VJSURIParams;
    }
    SimpleNestedURIParams*&
    ptr_SimpleNestedURIParams()
    {
        return (mValue).VSimpleNestedURIParams;
    }
    const SimpleNestedURIParams*
    constptr_SimpleNestedURIParams() const
    {
        return (mValue).VSimpleNestedURIParams;
    }
    HostObjectURIParams*
    ptr_HostObjectURIParams()
    {
        return ((mValue).VHostObjectURIParams).addr();
    }
    const HostObjectURIParams*
    constptr_HostObjectURIParams() const
    {
        return ((mValue).VHostObjectURIParams).addr();
    }
    DefaultURIParams*
    ptr_DefaultURIParams()
    {
        return ((mValue).VDefaultURIParams).addr();
    }
    const DefaultURIParams*
    constptr_DefaultURIParams() const
    {
        return ((mValue).VDefaultURIParams).addr();
    }
    NestedAboutURIParams*&
    ptr_NestedAboutURIParams()
    {
        return (mValue).VNestedAboutURIParams;
    }
    const NestedAboutURIParams*
    constptr_NestedAboutURIParams() const
    {
        return (mValue).VNestedAboutURIParams;
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT URIParams() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT URIParams(const SimpleURIParams& aOther);

    MOZ_IMPLICIT URIParams(SimpleURIParams&& aOther);

    MOZ_IMPLICIT URIParams(const StandardURLParams& aOther);

    MOZ_IMPLICIT URIParams(StandardURLParams&& aOther);

    MOZ_IMPLICIT URIParams(const JARURIParams& aOther);

    MOZ_IMPLICIT URIParams(JARURIParams&& aOther);

    MOZ_IMPLICIT URIParams(const IconURIParams& aOther);

    MOZ_IMPLICIT URIParams(IconURIParams&& aOther);

    MOZ_IMPLICIT URIParams(const NullPrincipalURIParams& aOther);

    MOZ_IMPLICIT URIParams(NullPrincipalURIParams&& aOther);

    MOZ_IMPLICIT URIParams(const JSURIParams& aOther);

    MOZ_IMPLICIT URIParams(JSURIParams&& aOther);

    MOZ_IMPLICIT URIParams(const SimpleNestedURIParams& aOther);

    MOZ_IMPLICIT URIParams(SimpleNestedURIParams&& aOther);

    MOZ_IMPLICIT URIParams(const HostObjectURIParams& aOther);

    MOZ_IMPLICIT URIParams(HostObjectURIParams&& aOther);

    MOZ_IMPLICIT URIParams(const DefaultURIParams& aOther);

    MOZ_IMPLICIT URIParams(DefaultURIParams&& aOther);

    MOZ_IMPLICIT URIParams(const NestedAboutURIParams& aOther);

    MOZ_IMPLICIT URIParams(NestedAboutURIParams&& aOther);

    MOZ_IMPLICIT URIParams(const URIParams& aOther);

    MOZ_IMPLICIT URIParams(URIParams&& aOther);

    ~URIParams();

    Type
    type() const
    {
        return mType;
    }

    URIParams&
    operator=(const SimpleURIParams& aRhs);

    URIParams&
    operator=(SimpleURIParams&& aRhs);

    URIParams&
    operator=(const StandardURLParams& aRhs);

    URIParams&
    operator=(StandardURLParams&& aRhs);

    URIParams&
    operator=(const JARURIParams& aRhs);

    URIParams&
    operator=(JARURIParams&& aRhs);

    URIParams&
    operator=(const IconURIParams& aRhs);

    URIParams&
    operator=(IconURIParams&& aRhs);

    URIParams&
    operator=(const NullPrincipalURIParams& aRhs);

    URIParams&
    operator=(NullPrincipalURIParams&& aRhs);

    URIParams&
    operator=(const JSURIParams& aRhs);

    URIParams&
    operator=(JSURIParams&& aRhs);

    URIParams&
    operator=(const SimpleNestedURIParams& aRhs);

    URIParams&
    operator=(SimpleNestedURIParams&& aRhs);

    URIParams&
    operator=(const HostObjectURIParams& aRhs);

    URIParams&
    operator=(HostObjectURIParams&& aRhs);

    URIParams&
    operator=(const DefaultURIParams& aRhs);

    URIParams&
    operator=(DefaultURIParams&& aRhs);

    URIParams&
    operator=(const NestedAboutURIParams& aRhs);

    URIParams&
    operator=(NestedAboutURIParams&& aRhs);

    URIParams&
    operator=(const URIParams& aRhs);

    URIParams&
    operator=(URIParams&& aRhs);

    SimpleURIParams&
    get_SimpleURIParams()
    {
        AssertSanity(TSimpleURIParams);
        return (*(ptr_SimpleURIParams()));
    }
    const SimpleURIParams&
    get_SimpleURIParams() const
    {
        AssertSanity(TSimpleURIParams);
        return (*(constptr_SimpleURIParams()));
    }
    operator SimpleURIParams&()
    {
        return get_SimpleURIParams();
    }
    operator const SimpleURIParams&() const
    {
        return get_SimpleURIParams();
    }

    StandardURLParams&
    get_StandardURLParams()
    {
        AssertSanity(TStandardURLParams);
        return (*(ptr_StandardURLParams()));
    }
    const StandardURLParams&
    get_StandardURLParams() const
    {
        AssertSanity(TStandardURLParams);
        return (*(constptr_StandardURLParams()));
    }
    operator StandardURLParams&()
    {
        return get_StandardURLParams();
    }
    operator const StandardURLParams&() const
    {
        return get_StandardURLParams();
    }

    JARURIParams&
    get_JARURIParams()
    {
        AssertSanity(TJARURIParams);
        return (*(ptr_JARURIParams()));
    }
    const JARURIParams&
    get_JARURIParams() const
    {
        AssertSanity(TJARURIParams);
        return (*(constptr_JARURIParams()));
    }
    operator JARURIParams&()
    {
        return get_JARURIParams();
    }
    operator const JARURIParams&() const
    {
        return get_JARURIParams();
    }

    IconURIParams&
    get_IconURIParams()
    {
        AssertSanity(TIconURIParams);
        return (*(ptr_IconURIParams()));
    }
    const IconURIParams&
    get_IconURIParams() const
    {
        AssertSanity(TIconURIParams);
        return (*(constptr_IconURIParams()));
    }
    operator IconURIParams&()
    {
        return get_IconURIParams();
    }
    operator const IconURIParams&() const
    {
        return get_IconURIParams();
    }

    NullPrincipalURIParams&
    get_NullPrincipalURIParams()
    {
        AssertSanity(TNullPrincipalURIParams);
        return (*(ptr_NullPrincipalURIParams()));
    }
    const NullPrincipalURIParams&
    get_NullPrincipalURIParams() const
    {
        AssertSanity(TNullPrincipalURIParams);
        return (*(constptr_NullPrincipalURIParams()));
    }
    operator NullPrincipalURIParams&()
    {
        return get_NullPrincipalURIParams();
    }
    operator const NullPrincipalURIParams&() const
    {
        return get_NullPrincipalURIParams();
    }

    JSURIParams&
    get_JSURIParams()
    {
        AssertSanity(TJSURIParams);
        return (*(ptr_JSURIParams()));
    }
    const JSURIParams&
    get_JSURIParams() const
    {
        AssertSanity(TJSURIParams);
        return (*(constptr_JSURIParams()));
    }
    operator JSURIParams&()
    {
        return get_JSURIParams();
    }
    operator const JSURIParams&() const
    {
        return get_JSURIParams();
    }

    SimpleNestedURIParams&
    get_SimpleNestedURIParams()
    {
        AssertSanity(TSimpleNestedURIParams);
        return (*(ptr_SimpleNestedURIParams()));
    }
    const SimpleNestedURIParams&
    get_SimpleNestedURIParams() const
    {
        AssertSanity(TSimpleNestedURIParams);
        return (*(constptr_SimpleNestedURIParams()));
    }
    operator SimpleNestedURIParams&()
    {
        return get_SimpleNestedURIParams();
    }
    operator const SimpleNestedURIParams&() const
    {
        return get_SimpleNestedURIParams();
    }

    HostObjectURIParams&
    get_HostObjectURIParams()
    {
        AssertSanity(THostObjectURIParams);
        return (*(ptr_HostObjectURIParams()));
    }
    const HostObjectURIParams&
    get_HostObjectURIParams() const
    {
        AssertSanity(THostObjectURIParams);
        return (*(constptr_HostObjectURIParams()));
    }
    operator HostObjectURIParams&()
    {
        return get_HostObjectURIParams();
    }
    operator const HostObjectURIParams&() const
    {
        return get_HostObjectURIParams();
    }

    DefaultURIParams&
    get_DefaultURIParams()
    {
        AssertSanity(TDefaultURIParams);
        return (*(ptr_DefaultURIParams()));
    }
    const DefaultURIParams&
    get_DefaultURIParams() const
    {
        AssertSanity(TDefaultURIParams);
        return (*(constptr_DefaultURIParams()));
    }
    operator DefaultURIParams&()
    {
        return get_DefaultURIParams();
    }
    operator const DefaultURIParams&() const
    {
        return get_DefaultURIParams();
    }

    NestedAboutURIParams&
    get_NestedAboutURIParams()
    {
        AssertSanity(TNestedAboutURIParams);
        return (*(ptr_NestedAboutURIParams()));
    }
    const NestedAboutURIParams&
    get_NestedAboutURIParams() const
    {
        AssertSanity(TNestedAboutURIParams);
        return (*(constptr_NestedAboutURIParams()));
    }
    operator NestedAboutURIParams&()
    {
        return get_NestedAboutURIParams();
    }
    operator const NestedAboutURIParams&() const
    {
        return get_NestedAboutURIParams();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::URIParams>
{
    typedef mozilla::ipc::URIParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct JARURIParams|
//
namespace mozilla {
namespace ipc {
class JARURIParams final
{
private:
    typedef mozilla::ipc::URIParams URIParams;

public:
    MOZ_IMPLICIT JARURIParams() :
        jarFile_(),
        jarEntry_(),
        charset_()
    {
    }

    MOZ_IMPLICIT JARURIParams(
            const URIParams& _jarFile,
            const URIParams& _jarEntry,
            const nsCString& _charset) :
        jarFile_(_jarFile),
        jarEntry_(_jarEntry),
        charset_(_charset)
    {
    }

    URIParams&
    jarFile()
    {
        return jarFile_;
    }
    const URIParams&
    jarFile() const
    {
        return jarFile_;
    }

    URIParams&
    jarEntry()
    {
        return jarEntry_;
    }
    const URIParams&
    jarEntry() const
    {
        return jarEntry_;
    }

    nsCString&
    charset()
    {
        return charset_;
    }
    const nsCString&
    charset() const
    {
        return charset_;
    }

private:
    URIParams jarFile_;
    URIParams jarEntry_;
    nsCString charset_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::JARURIParams>
{
    typedef mozilla::ipc::JARURIParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct IconURIParams|
//
namespace mozilla {
namespace ipc {
class IconURIParams final
{
private:
    typedef mozilla::ipc::URIParams URIParams;

public:
    MOZ_IMPLICIT IconURIParams() :
        uri_(),
        contentType_(),
        fileName_(),
        stockIcon_(),
        size_(),
        iconSize_(),
        iconState_()
    {
    }

    MOZ_IMPLICIT IconURIParams(
            const mozilla::Maybe<URIParams>& _uri,
            const uint32_t& _size,
            const nsCString& _contentType,
            const nsCString& _fileName,
            const nsCString& _stockIcon,
            const int32_t& _iconSize,
            const int32_t& _iconState) :
        uri_(_uri),
        contentType_(_contentType),
        fileName_(_fileName),
        stockIcon_(_stockIcon),
        size_(_size),
        iconSize_(_iconSize),
        iconState_(_iconState)
    {
    }

    mozilla::Maybe<URIParams>&
    uri()
    {
        return uri_;
    }
    const mozilla::Maybe<URIParams>&
    uri() const
    {
        return uri_;
    }

    uint32_t&
    size()
    {
        return size_;
    }
    const uint32_t&
    size() const
    {
        return size_;
    }

    nsCString&
    contentType()
    {
        return contentType_;
    }
    const nsCString&
    contentType() const
    {
        return contentType_;
    }

    nsCString&
    fileName()
    {
        return fileName_;
    }
    const nsCString&
    fileName() const
    {
        return fileName_;
    }

    nsCString&
    stockIcon()
    {
        return stockIcon_;
    }
    const nsCString&
    stockIcon() const
    {
        return stockIcon_;
    }

    int32_t&
    iconSize()
    {
        return iconSize_;
    }
    const int32_t&
    iconSize() const
    {
        return iconSize_;
    }

    int32_t&
    iconState()
    {
        return iconState_;
    }
    const int32_t&
    iconState() const
    {
        return iconState_;
    }

private:
    void
    StaticAssertions() const;
    mozilla::Maybe<URIParams> uri_;
    nsCString contentType_;
    nsCString fileName_;
    nsCString stockIcon_;
    uint32_t size_;
    int32_t iconSize_;
    int32_t iconState_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::IconURIParams>
{
    typedef mozilla::ipc::IconURIParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct JSURIParams|
//
namespace mozilla {
namespace ipc {
class JSURIParams final
{
private:
    typedef mozilla::ipc::SimpleURIParams SimpleURIParams;
    typedef mozilla::ipc::URIParams URIParams;

public:
    MOZ_IMPLICIT JSURIParams() :
        simpleParams_(),
        baseURI_()
    {
    }

    MOZ_IMPLICIT JSURIParams(
            const SimpleURIParams& _simpleParams,
            const mozilla::Maybe<URIParams>& _baseURI) :
        simpleParams_(_simpleParams),
        baseURI_(_baseURI)
    {
    }

    SimpleURIParams&
    simpleParams()
    {
        return simpleParams_;
    }
    const SimpleURIParams&
    simpleParams() const
    {
        return simpleParams_;
    }

    mozilla::Maybe<URIParams>&
    baseURI()
    {
        return baseURI_;
    }
    const mozilla::Maybe<URIParams>&
    baseURI() const
    {
        return baseURI_;
    }

private:
    SimpleURIParams simpleParams_;
    mozilla::Maybe<URIParams> baseURI_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::JSURIParams>
{
    typedef mozilla::ipc::JSURIParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SimpleNestedURIParams|
//
namespace mozilla {
namespace ipc {
class SimpleNestedURIParams final
{
private:
    typedef mozilla::ipc::SimpleURIParams SimpleURIParams;
    typedef mozilla::ipc::URIParams URIParams;

public:
    MOZ_IMPLICIT SimpleNestedURIParams() :
        simpleParams_(),
        innerURI_()
    {
    }

    MOZ_IMPLICIT SimpleNestedURIParams(
            const SimpleURIParams& _simpleParams,
            const URIParams& _innerURI) :
        simpleParams_(_simpleParams),
        innerURI_(_innerURI)
    {
    }

    SimpleURIParams&
    simpleParams()
    {
        return simpleParams_;
    }
    const SimpleURIParams&
    simpleParams() const
    {
        return simpleParams_;
    }

    URIParams&
    innerURI()
    {
        return innerURI_;
    }
    const URIParams&
    innerURI() const
    {
        return innerURI_;
    }

private:
    SimpleURIParams simpleParams_;
    URIParams innerURI_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::SimpleNestedURIParams>
{
    typedef mozilla::ipc::SimpleNestedURIParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct NestedAboutURIParams|
//
namespace mozilla {
namespace ipc {
class NestedAboutURIParams final
{
private:
    typedef mozilla::ipc::SimpleNestedURIParams SimpleNestedURIParams;
    typedef mozilla::ipc::URIParams URIParams;

public:
    MOZ_IMPLICIT NestedAboutURIParams() :
        nestedParams_(),
        baseURI_()
    {
    }

    MOZ_IMPLICIT NestedAboutURIParams(
            const SimpleNestedURIParams& _nestedParams,
            const mozilla::Maybe<URIParams>& _baseURI) :
        nestedParams_(_nestedParams),
        baseURI_(_baseURI)
    {
    }

    SimpleNestedURIParams&
    nestedParams()
    {
        return nestedParams_;
    }
    const SimpleNestedURIParams&
    nestedParams() const
    {
        return nestedParams_;
    }

    mozilla::Maybe<URIParams>&
    baseURI()
    {
        return baseURI_;
    }
    const mozilla::Maybe<URIParams>&
    baseURI() const
    {
        return baseURI_;
    }

private:
    SimpleNestedURIParams nestedParams_;
    mozilla::Maybe<URIParams> baseURI_;
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ipc::NestedAboutURIParams>
{
    typedef mozilla::ipc::NestedAboutURIParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

#endif // ifndef URIParams_h
