//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PProcessHangMonitor_h
#define PProcessHangMonitor_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "base/process.h"
#include "mozilla/dom/ipc/IdType.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SlowScriptData|
//
namespace mozilla {
class SlowScriptData final
{
private:
    typedef mozilla::dom::TabId TabId;

public:
    MOZ_IMPLICIT SlowScriptData() :
        tabId_(),
        filename_(),
        addonId_(),
        duration_()
    {
    }

    MOZ_IMPLICIT SlowScriptData(
            const TabId& _tabId,
            const nsCString& _filename,
            const nsString& _addonId,
            const double& _duration) :
        tabId_(_tabId),
        filename_(_filename),
        addonId_(_addonId),
        duration_(_duration)
    {
    }

    TabId&
    tabId()
    {
        return tabId_;
    }
    const TabId&
    tabId() const
    {
        return tabId_;
    }

    nsCString&
    filename()
    {
        return filename_;
    }
    const nsCString&
    filename() const
    {
        return filename_;
    }

    nsString&
    addonId()
    {
        return addonId_;
    }
    const nsString&
    addonId() const
    {
        return addonId_;
    }

    double&
    duration()
    {
        return duration_;
    }
    const double&
    duration() const
    {
        return duration_;
    }

private:
    TabId tabId_;
    nsCString filename_;
    nsString addonId_;
    double duration_;
};
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::SlowScriptData>
{
    typedef mozilla::SlowScriptData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct PluginHangData|
//
namespace mozilla {
class PluginHangData final
{
private:
    typedef base::ProcessId ProcessId;

public:
    MOZ_IMPLICIT PluginHangData() :
        contentProcessId_(),
        pluginId_()
    {
    }

    MOZ_IMPLICIT PluginHangData(
            const uint32_t& _pluginId,
            const ProcessId& _contentProcessId) :
        contentProcessId_(_contentProcessId),
        pluginId_(_pluginId)
    {
    }

    uint32_t&
    pluginId()
    {
        return pluginId_;
    }
    const uint32_t&
    pluginId() const
    {
        return pluginId_;
    }

    ProcessId&
    contentProcessId()
    {
        return contentProcessId_;
    }
    const ProcessId&
    contentProcessId() const
    {
        return contentProcessId_;
    }

private:
    ProcessId contentProcessId_;
    uint32_t pluginId_;
};
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::PluginHangData>
{
    typedef mozilla::PluginHangData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union HangData|
//
namespace mozilla {
class HangData final
{
public:
    enum Type {
        T__None,
        TSlowScriptData = 1,
        TPluginHangData,
        T__Last = TPluginHangData
    };

private:
    typedef mozilla::SlowScriptData SlowScriptData;
    typedef mozilla::PluginHangData PluginHangData;
    typedef SlowScriptData SlowScriptData__tdef;
    typedef PluginHangData PluginHangData__tdef;

    union Value {
        mozilla::AlignedStorage2<SlowScriptData> VSlowScriptData;
        mozilla::AlignedStorage2<PluginHangData> VPluginHangData;
    };

    SlowScriptData*
    ptr_SlowScriptData()
    {
        return ((mValue).VSlowScriptData).addr();
    }
    const SlowScriptData*
    constptr_SlowScriptData() const
    {
        return ((mValue).VSlowScriptData).addr();
    }
    PluginHangData*
    ptr_PluginHangData()
    {
        return ((mValue).VPluginHangData).addr();
    }
    const PluginHangData*
    constptr_PluginHangData() const
    {
        return ((mValue).VPluginHangData).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT HangData() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT HangData(const SlowScriptData& aOther);

    MOZ_IMPLICIT HangData(SlowScriptData&& aOther);

    MOZ_IMPLICIT HangData(const PluginHangData& aOther);

    MOZ_IMPLICIT HangData(PluginHangData&& aOther);

    MOZ_IMPLICIT HangData(const HangData& aOther);

    MOZ_IMPLICIT HangData(HangData&& aOther);

    ~HangData();

    Type
    type() const
    {
        return mType;
    }

    HangData&
    operator=(const SlowScriptData& aRhs);

    HangData&
    operator=(SlowScriptData&& aRhs);

    HangData&
    operator=(const PluginHangData& aRhs);

    HangData&
    operator=(PluginHangData&& aRhs);

    HangData&
    operator=(const HangData& aRhs);

    HangData&
    operator=(HangData&& aRhs);

    SlowScriptData&
    get_SlowScriptData()
    {
        AssertSanity(TSlowScriptData);
        return (*(ptr_SlowScriptData()));
    }
    const SlowScriptData&
    get_SlowScriptData() const
    {
        AssertSanity(TSlowScriptData);
        return (*(constptr_SlowScriptData()));
    }
    operator SlowScriptData&()
    {
        return get_SlowScriptData();
    }
    operator const SlowScriptData&() const
    {
        return get_SlowScriptData();
    }

    PluginHangData&
    get_PluginHangData()
    {
        AssertSanity(TPluginHangData);
        return (*(ptr_PluginHangData()));
    }
    const PluginHangData&
    get_PluginHangData() const
    {
        AssertSanity(TPluginHangData);
        return (*(constptr_PluginHangData()));
    }
    operator PluginHangData&()
    {
        return get_PluginHangData();
    }
    operator const PluginHangData&() const
    {
        return get_PluginHangData();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::HangData>
{
    typedef mozilla::HangData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
class PProcessHangMonitorParent;
} // namespace mozilla
namespace mozilla {
class PProcessHangMonitorChild;
} // namespace mozilla

//-----------------------------------------------------------------------------
// Code common to PProcessHangMonitorChild and PProcessHangMonitorParent
//
namespace mozilla {
namespace PProcessHangMonitor {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::PProcessHangMonitorParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::PProcessHangMonitorChild>* aChild);

enum MessageType {
    PProcessHangMonitorStart = PProcessHangMonitorMsgStart << 16,
    Msg_HangEvidence__ID,
    Msg_ClearHang__ID,
    Msg_TerminateScript__ID,
    Msg_BeginStartingDebugger__ID,
    Msg_EndStartingDebugger__ID,
    Msg_PaintWhileInterruptingJS__ID,
    Msg_CancelContentJSExecutionIfRunning__ID,
    PProcessHangMonitorEnd
};

IPC::Message*
Msg_HangEvidence(int32_t routingId);

IPC::Message*
Msg_ClearHang(int32_t routingId);

IPC::Message*
Msg_TerminateScript(int32_t routingId);

IPC::Message*
Msg_BeginStartingDebugger(int32_t routingId);

IPC::Message*
Msg_EndStartingDebugger(int32_t routingId);

IPC::Message*
Msg_PaintWhileInterruptingJS(int32_t routingId);

IPC::Message*
Msg_CancelContentJSExecutionIfRunning(int32_t routingId);



} // namespace PProcessHangMonitor
} // namespace mozilla

#endif // ifndef PProcessHangMonitor_h
