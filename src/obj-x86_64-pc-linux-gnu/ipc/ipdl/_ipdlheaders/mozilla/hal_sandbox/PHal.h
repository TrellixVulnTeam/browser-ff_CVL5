//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PHal_h
#define PHal_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "mozilla/HalScreenConfiguration.h"
#include "mozilla/HalSensor.h"
#include "nsRect.h"
#include "prtime.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct BatteryInformation|
//
namespace mozilla {
namespace hal {
class BatteryInformation final
{
private:

public:
    MOZ_IMPLICIT BatteryInformation() :
        charging_(),
        level_(),
        remainingTime_()
    {
    }

    MOZ_IMPLICIT BatteryInformation(
            const double& _level,
            const bool& _charging,
            const double& _remainingTime) :
        charging_(_charging),
        level_(_level),
        remainingTime_(_remainingTime)
    {
    }

    double&
    level()
    {
        return level_;
    }
    const double&
    level() const
    {
        return level_;
    }

    bool&
    charging()
    {
        return charging_;
    }
    const bool&
    charging() const
    {
        return charging_;
    }

    double&
    remainingTime()
    {
        return remainingTime_;
    }
    const double&
    remainingTime() const
    {
        return remainingTime_;
    }

private:
    void
    StaticAssertions() const;
    bool charging_;
    double level_;
    double remainingTime_;
};
} // namespace hal
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::hal::BatteryInformation>
{
    typedef mozilla::hal::BatteryInformation paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SensorData|
//
namespace mozilla {
namespace hal {
class SensorData final
{
private:
    typedef mozilla::hal::SensorType SensorType;

public:
    MOZ_IMPLICIT SensorData() :
        sensor_(),
        timestamp_(),
        values_()
    {
    }

    MOZ_IMPLICIT SensorData(
            const SensorType& _sensor,
            const PRTime& _timestamp,
            const nsTArray<float>& _values) :
        sensor_(_sensor),
        timestamp_(_timestamp),
        values_(_values)
    {
    }

    SensorType&
    sensor()
    {
        return sensor_;
    }
    const SensorType&
    sensor() const
    {
        return sensor_;
    }

    PRTime&
    timestamp()
    {
        return timestamp_;
    }
    const PRTime&
    timestamp() const
    {
        return timestamp_;
    }

    nsTArray<float>&
    values()
    {
        return values_;
    }
    const nsTArray<float>&
    values() const
    {
        return values_;
    }

private:
    SensorType sensor_;
    PRTime timestamp_;
    CopyableTArray<float> values_;
};
} // namespace hal
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::hal::SensorData>
{
    typedef mozilla::hal::SensorData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct NetworkInformation|
//
namespace mozilla {
namespace hal {
class NetworkInformation final
{
private:

public:
    MOZ_IMPLICIT NetworkInformation() :
        isWifi_(),
        type_(),
        dhcpGateway_()
    {
    }

    MOZ_IMPLICIT NetworkInformation(
            const uint32_t& _type,
            const bool& _isWifi,
            const uint32_t& _dhcpGateway) :
        isWifi_(_isWifi),
        type_(_type),
        dhcpGateway_(_dhcpGateway)
    {
    }

    uint32_t&
    type()
    {
        return type_;
    }
    const uint32_t&
    type() const
    {
        return type_;
    }

    bool&
    isWifi()
    {
        return isWifi_;
    }
    const bool&
    isWifi() const
    {
        return isWifi_;
    }

    uint32_t&
    dhcpGateway()
    {
        return dhcpGateway_;
    }
    const uint32_t&
    dhcpGateway() const
    {
        return dhcpGateway_;
    }

private:
    void
    StaticAssertions() const;
    bool isWifi_;
    uint32_t type_;
    uint32_t dhcpGateway_;
};
} // namespace hal
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::hal::NetworkInformation>
{
    typedef mozilla::hal::NetworkInformation paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct WakeLockInformation|
//
namespace mozilla {
namespace hal {
class WakeLockInformation final
{
private:

public:
    MOZ_IMPLICIT WakeLockInformation() :
        topic_(),
        lockingProcesses_(),
        numLocks_(),
        numHidden_()
    {
    }

    MOZ_IMPLICIT WakeLockInformation(
            const nsString& _topic,
            const uint32_t& _numLocks,
            const uint32_t& _numHidden,
            const nsTArray<uint64_t>& _lockingProcesses) :
        topic_(_topic),
        lockingProcesses_(_lockingProcesses),
        numLocks_(_numLocks),
        numHidden_(_numHidden)
    {
    }

    nsString&
    topic()
    {
        return topic_;
    }
    const nsString&
    topic() const
    {
        return topic_;
    }

    uint32_t&
    numLocks()
    {
        return numLocks_;
    }
    const uint32_t&
    numLocks() const
    {
        return numLocks_;
    }

    uint32_t&
    numHidden()
    {
        return numHidden_;
    }
    const uint32_t&
    numHidden() const
    {
        return numHidden_;
    }

    nsTArray<uint64_t>&
    lockingProcesses()
    {
        return lockingProcesses_;
    }
    const nsTArray<uint64_t>&
    lockingProcesses() const
    {
        return lockingProcesses_;
    }

private:
    void
    StaticAssertions() const;
    nsString topic_;
    CopyableTArray<uint64_t> lockingProcesses_;
    uint32_t numLocks_;
    uint32_t numHidden_;
};
} // namespace hal
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::hal::WakeLockInformation>
{
    typedef mozilla::hal::WakeLockInformation paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ScreenConfiguration|
//
namespace mozilla {
namespace hal {
class ScreenConfiguration final
{
private:
    typedef hal::ScreenOrientation ScreenOrientation;

public:
    MOZ_IMPLICIT ScreenConfiguration() :
        rect_(),
        orientation_(),
        colorDepth_(),
        pixelDepth_(),
        angle_()
    {
    }

    MOZ_IMPLICIT ScreenConfiguration(
            const nsIntRect& _rect,
            const ScreenOrientation& _orientation,
            const uint16_t& _angle,
            const uint32_t& _colorDepth,
            const uint32_t& _pixelDepth) :
        rect_(_rect),
        orientation_(_orientation),
        colorDepth_(_colorDepth),
        pixelDepth_(_pixelDepth),
        angle_(_angle)
    {
    }

    nsIntRect&
    rect()
    {
        return rect_;
    }
    const nsIntRect&
    rect() const
    {
        return rect_;
    }

    ScreenOrientation&
    orientation()
    {
        return orientation_;
    }
    const ScreenOrientation&
    orientation() const
    {
        return orientation_;
    }

    uint16_t&
    angle()
    {
        return angle_;
    }
    const uint16_t&
    angle() const
    {
        return angle_;
    }

    uint32_t&
    colorDepth()
    {
        return colorDepth_;
    }
    const uint32_t&
    colorDepth() const
    {
        return colorDepth_;
    }

    uint32_t&
    pixelDepth()
    {
        return pixelDepth_;
    }
    const uint32_t&
    pixelDepth() const
    {
        return pixelDepth_;
    }

private:
    void
    StaticAssertions() const;
    nsIntRect rect_;
    ScreenOrientation orientation_;
    uint32_t colorDepth_;
    uint32_t pixelDepth_;
    uint16_t angle_;
};
} // namespace hal
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::hal::ScreenConfiguration>
{
    typedef mozilla::hal::ScreenConfiguration paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace hal_sandbox {
class PHalParent;
} // namespace hal_sandbox
} // namespace mozilla
namespace mozilla {
namespace hal_sandbox {
class PHalChild;
} // namespace hal_sandbox
} // namespace mozilla

//-----------------------------------------------------------------------------
// Code common to PHalChild and PHalParent
//
namespace mozilla {
namespace hal_sandbox {
namespace PHal {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::hal_sandbox::PHalParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::hal_sandbox::PHalChild>* aChild);

enum MessageType {
    PHalStart = PHalMsgStart << 16,
    Msg_NotifyBatteryChange__ID,
    Msg_NotifyNetworkChange__ID,
    Msg_NotifyWakeLockChange__ID,
    Msg_NotifyScreenConfigurationChange__ID,
    Msg_Vibrate__ID,
    Msg_CancelVibrate__ID,
    Msg_EnableBatteryNotifications__ID,
    Msg_DisableBatteryNotifications__ID,
    Msg_GetCurrentBatteryInformation__ID,
    Reply_GetCurrentBatteryInformation__ID,
    Msg_EnableNetworkNotifications__ID,
    Msg_DisableNetworkNotifications__ID,
    Msg_GetCurrentNetworkInformation__ID,
    Reply_GetCurrentNetworkInformation__ID,
    Msg_ModifyWakeLock__ID,
    Msg_EnableWakeLockNotifications__ID,
    Msg_DisableWakeLockNotifications__ID,
    Msg_GetWakeLockInfo__ID,
    Reply_GetWakeLockInfo__ID,
    Msg_EnableScreenConfigurationNotifications__ID,
    Msg_DisableScreenConfigurationNotifications__ID,
    Msg_LockScreenOrientation__ID,
    Reply_LockScreenOrientation__ID,
    Msg_UnlockScreenOrientation__ID,
    Msg_NotifySensorChange__ID,
    Msg_EnableSensorNotifications__ID,
    Msg_DisableSensorNotifications__ID,
    Msg___delete____ID,
    Reply___delete____ID,
    PHalEnd
};

IPC::Message*
Msg_NotifyBatteryChange(int32_t routingId);

IPC::Message*
Msg_NotifyNetworkChange(int32_t routingId);

IPC::Message*
Msg_NotifyWakeLockChange(int32_t routingId);

IPC::Message*
Msg_NotifyScreenConfigurationChange(int32_t routingId);

IPC::Message*
Msg_Vibrate(int32_t routingId);

IPC::Message*
Msg_CancelVibrate(int32_t routingId);

IPC::Message*
Msg_EnableBatteryNotifications(int32_t routingId);

IPC::Message*
Msg_DisableBatteryNotifications(int32_t routingId);

IPC::Message*
Msg_GetCurrentBatteryInformation(int32_t routingId);
IPC::Message*
Reply_GetCurrentBatteryInformation(int32_t routingId);

IPC::Message*
Msg_EnableNetworkNotifications(int32_t routingId);

IPC::Message*
Msg_DisableNetworkNotifications(int32_t routingId);

IPC::Message*
Msg_GetCurrentNetworkInformation(int32_t routingId);
IPC::Message*
Reply_GetCurrentNetworkInformation(int32_t routingId);

IPC::Message*
Msg_ModifyWakeLock(int32_t routingId);

IPC::Message*
Msg_EnableWakeLockNotifications(int32_t routingId);

IPC::Message*
Msg_DisableWakeLockNotifications(int32_t routingId);

IPC::Message*
Msg_GetWakeLockInfo(int32_t routingId);
IPC::Message*
Reply_GetWakeLockInfo(int32_t routingId);

IPC::Message*
Msg_EnableScreenConfigurationNotifications(int32_t routingId);

IPC::Message*
Msg_DisableScreenConfigurationNotifications(int32_t routingId);

IPC::Message*
Msg_LockScreenOrientation(int32_t routingId);
IPC::Message*
Reply_LockScreenOrientation(int32_t routingId);

IPC::Message*
Msg_UnlockScreenOrientation(int32_t routingId);

IPC::Message*
Msg_NotifySensorChange(int32_t routingId);

IPC::Message*
Msg_EnableSensorNotifications(int32_t routingId);

IPC::Message*
Msg_DisableSensorNotifications(int32_t routingId);

IPC::Message*
Msg___delete__(int32_t routingId);
IPC::Message*
Reply___delete__(int32_t routingId);



} // namespace PHal
} // namespace hal_sandbox
} // namespace mozilla

#endif // ifndef PHal_h
