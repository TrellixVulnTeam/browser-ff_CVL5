//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PPluginScriptableObject_h
#define PPluginScriptableObject_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "mozilla/ipc/IPCCore.h"
#include "mozilla/plugins/PluginTypes.h"

namespace mozilla {
namespace plugins {
class PPluginScriptableObjectParent;
} // namespace plugins
} // namespace mozilla

namespace mozilla {
namespace plugins {
class PPluginScriptableObjectChild;
} // namespace plugins
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union Variant|
//
namespace mozilla {
namespace plugins {
class Variant final
{
public:
    enum Type {
        T__None,
        Tvoid_t = 1,
        Tnull_t,
        Tbool,
        Tint,
        Tdouble,
        TnsCString,
        TPPluginScriptableObjectParent,
        TPPluginScriptableObjectChild,
        T__Last = TPPluginScriptableObjectChild
    };

private:
    typedef mozilla::void_t void_t;
    typedef mozilla::null_t null_t;
    typedef mozilla::plugins::PPluginScriptableObjectParent PPluginScriptableObjectParent;
    typedef mozilla::plugins::PPluginScriptableObjectChild PPluginScriptableObjectChild;
    typedef void_t void_t__tdef;
    typedef null_t null_t__tdef;
    typedef bool bool__tdef;
    typedef int int__tdef;
    typedef double double__tdef;
    typedef nsCString nsCString__tdef;
    typedef PPluginScriptableObjectParent* PPluginScriptableObjectParent__tdef;
    typedef PPluginScriptableObjectChild* PPluginScriptableObjectChild__tdef;

    union Value {
        mozilla::AlignedStorage2<void_t> Vvoid_t;
        mozilla::AlignedStorage2<null_t> Vnull_t;
        mozilla::AlignedStorage2<bool> Vbool;
        mozilla::AlignedStorage2<int> Vint;
        mozilla::AlignedStorage2<double> Vdouble;
        mozilla::AlignedStorage2<nsCString> VnsCString;
        mozilla::AlignedStorage2<PPluginScriptableObjectParent*> VPPluginScriptableObjectParent;
        mozilla::AlignedStorage2<PPluginScriptableObjectChild*> VPPluginScriptableObjectChild;
    };

    void_t*
    ptr_void_t()
    {
        return ((mValue).Vvoid_t).addr();
    }
    const void_t*
    constptr_void_t() const
    {
        return ((mValue).Vvoid_t).addr();
    }
    null_t*
    ptr_null_t()
    {
        return ((mValue).Vnull_t).addr();
    }
    const null_t*
    constptr_null_t() const
    {
        return ((mValue).Vnull_t).addr();
    }
    bool*
    ptr_bool()
    {
        return ((mValue).Vbool).addr();
    }
    const bool*
    constptr_bool() const
    {
        return ((mValue).Vbool).addr();
    }
    int*
    ptr_int()
    {
        return ((mValue).Vint).addr();
    }
    const int*
    constptr_int() const
    {
        return ((mValue).Vint).addr();
    }
    double*
    ptr_double()
    {
        return ((mValue).Vdouble).addr();
    }
    const double*
    constptr_double() const
    {
        return ((mValue).Vdouble).addr();
    }
    nsCString*
    ptr_nsCString()
    {
        return ((mValue).VnsCString).addr();
    }
    const nsCString*
    constptr_nsCString() const
    {
        return ((mValue).VnsCString).addr();
    }
    PPluginScriptableObjectParent**
    ptr_PPluginScriptableObjectParent()
    {
        return ((mValue).VPPluginScriptableObjectParent).addr();
    }
    PPluginScriptableObjectParent* const*
    constptr_PPluginScriptableObjectParent() const
    {
        return ((mValue).VPPluginScriptableObjectParent).addr();
    }
    PPluginScriptableObjectChild**
    ptr_PPluginScriptableObjectChild()
    {
        return ((mValue).VPPluginScriptableObjectChild).addr();
    }
    PPluginScriptableObjectChild* const*
    constptr_PPluginScriptableObjectChild() const
    {
        return ((mValue).VPPluginScriptableObjectChild).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT Variant() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT Variant(const void_t& aOther);

    MOZ_IMPLICIT Variant(void_t&& aOther);

    MOZ_IMPLICIT Variant(const null_t& aOther);

    MOZ_IMPLICIT Variant(null_t&& aOther);

    MOZ_IMPLICIT Variant(const bool& aOther);

    MOZ_IMPLICIT Variant(bool&& aOther);

    MOZ_IMPLICIT Variant(const int& aOther);

    MOZ_IMPLICIT Variant(int&& aOther);

    MOZ_IMPLICIT Variant(const double& aOther);

    MOZ_IMPLICIT Variant(double&& aOther);

    MOZ_IMPLICIT Variant(const nsCString& aOther);

    MOZ_IMPLICIT Variant(nsCString&& aOther);

    MOZ_IMPLICIT Variant(PPluginScriptableObjectParent* aOther);

    MOZ_IMPLICIT Variant(PPluginScriptableObjectChild* aOther);

    MOZ_IMPLICIT Variant(const Variant& aOther);

    MOZ_IMPLICIT Variant(Variant&& aOther);

    ~Variant();

    Type
    type() const
    {
        return mType;
    }

    Variant&
    operator=(const void_t& aRhs);

    Variant&
    operator=(void_t&& aRhs);

    Variant&
    operator=(const null_t& aRhs);

    Variant&
    operator=(null_t&& aRhs);

    Variant&
    operator=(const bool& aRhs);

    Variant&
    operator=(bool&& aRhs);

    Variant&
    operator=(const int& aRhs);

    Variant&
    operator=(int&& aRhs);

    Variant&
    operator=(const double& aRhs);

    Variant&
    operator=(double&& aRhs);

    Variant&
    operator=(const nsCString& aRhs);

    Variant&
    operator=(nsCString&& aRhs);

    Variant&
    operator=(PPluginScriptableObjectParent* aRhs);

    Variant&
    operator=(PPluginScriptableObjectChild* aRhs);

    Variant&
    operator=(const Variant& aRhs);

    Variant&
    operator=(Variant&& aRhs);

    void_t&
    get_void_t()
    {
        AssertSanity(Tvoid_t);
        return (*(ptr_void_t()));
    }
    const void_t&
    get_void_t() const
    {
        AssertSanity(Tvoid_t);
        return (*(constptr_void_t()));
    }
    operator void_t&()
    {
        return get_void_t();
    }
    operator const void_t&() const
    {
        return get_void_t();
    }

    null_t&
    get_null_t()
    {
        AssertSanity(Tnull_t);
        return (*(ptr_null_t()));
    }
    const null_t&
    get_null_t() const
    {
        AssertSanity(Tnull_t);
        return (*(constptr_null_t()));
    }
    operator null_t&()
    {
        return get_null_t();
    }
    operator const null_t&() const
    {
        return get_null_t();
    }

    bool&
    get_bool()
    {
        AssertSanity(Tbool);
        return (*(ptr_bool()));
    }
    const bool&
    get_bool() const
    {
        AssertSanity(Tbool);
        return (*(constptr_bool()));
    }
    operator bool&()
    {
        return get_bool();
    }
    operator const bool&() const
    {
        return get_bool();
    }

    int&
    get_int()
    {
        AssertSanity(Tint);
        return (*(ptr_int()));
    }
    const int&
    get_int() const
    {
        AssertSanity(Tint);
        return (*(constptr_int()));
    }
    operator int&()
    {
        return get_int();
    }
    operator const int&() const
    {
        return get_int();
    }

    double&
    get_double()
    {
        AssertSanity(Tdouble);
        return (*(ptr_double()));
    }
    const double&
    get_double() const
    {
        AssertSanity(Tdouble);
        return (*(constptr_double()));
    }
    operator double&()
    {
        return get_double();
    }
    operator const double&() const
    {
        return get_double();
    }

    nsCString&
    get_nsCString()
    {
        AssertSanity(TnsCString);
        return (*(ptr_nsCString()));
    }
    const nsCString&
    get_nsCString() const
    {
        AssertSanity(TnsCString);
        return (*(constptr_nsCString()));
    }
    operator nsCString&()
    {
        return get_nsCString();
    }
    operator const nsCString&() const
    {
        return get_nsCString();
    }

    PPluginScriptableObjectParent*&
    get_PPluginScriptableObjectParent()
    {
        AssertSanity(TPPluginScriptableObjectParent);
        return (*(ptr_PPluginScriptableObjectParent()));
    }
    PPluginScriptableObjectParent*
    get_PPluginScriptableObjectParent() const
    {
        AssertSanity(TPPluginScriptableObjectParent);
        return (*(constptr_PPluginScriptableObjectParent()));
    }
    operator PPluginScriptableObjectParent*&()
    {
        return get_PPluginScriptableObjectParent();
    }
    operator PPluginScriptableObjectParent*() const
    {
        return get_PPluginScriptableObjectParent();
    }

    PPluginScriptableObjectChild*&
    get_PPluginScriptableObjectChild()
    {
        AssertSanity(TPPluginScriptableObjectChild);
        return (*(ptr_PPluginScriptableObjectChild()));
    }
    PPluginScriptableObjectChild*
    get_PPluginScriptableObjectChild() const
    {
        AssertSanity(TPPluginScriptableObjectChild);
        return (*(constptr_PPluginScriptableObjectChild()));
    }
    operator PPluginScriptableObjectChild*&()
    {
        return get_PPluginScriptableObjectChild();
    }
    operator PPluginScriptableObjectChild*() const
    {
        return get_PPluginScriptableObjectChild();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace plugins
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::plugins::Variant>
{
    typedef mozilla::plugins::Variant paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace plugins {
class PPluginScriptableObjectParent;
} // namespace plugins
} // namespace mozilla
namespace mozilla {
namespace plugins {
class PPluginScriptableObjectChild;
} // namespace plugins
} // namespace mozilla

//-----------------------------------------------------------------------------
// Code common to PPluginScriptableObjectChild and PPluginScriptableObjectParent
//
namespace mozilla {
namespace plugins {
namespace PPluginScriptableObject {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::plugins::PPluginScriptableObjectParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::plugins::PPluginScriptableObjectChild>* aChild);

enum MessageType {
    PPluginScriptableObjectStart = PPluginScriptableObjectMsgStart << 16,
    Msg___delete____ID,
    Reply___delete____ID,
    Msg_NPN_Evaluate__ID,
    Reply_NPN_Evaluate__ID,
    Msg_Invalidate__ID,
    Reply_Invalidate__ID,
    Msg_HasMethod__ID,
    Reply_HasMethod__ID,
    Msg_Invoke__ID,
    Reply_Invoke__ID,
    Msg_InvokeDefault__ID,
    Reply_InvokeDefault__ID,
    Msg_HasProperty__ID,
    Reply_HasProperty__ID,
    Msg_SetProperty__ID,
    Reply_SetProperty__ID,
    Msg_RemoveProperty__ID,
    Reply_RemoveProperty__ID,
    Msg_Enumerate__ID,
    Reply_Enumerate__ID,
    Msg_Construct__ID,
    Reply_Construct__ID,
    Msg_Protect__ID,
    Msg_Unprotect__ID,
    Msg_GetParentProperty__ID,
    Reply_GetParentProperty__ID,
    Msg_GetChildProperty__ID,
    Reply_GetChildProperty__ID,
    PPluginScriptableObjectEnd
};

IPC::Message*
Msg___delete__(int32_t routingId);
IPC::Message*
Reply___delete__(int32_t routingId);

IPC::Message*
Msg_NPN_Evaluate(int32_t routingId);
IPC::Message*
Reply_NPN_Evaluate(int32_t routingId);

IPC::Message*
Msg_Invalidate(int32_t routingId);
IPC::Message*
Reply_Invalidate(int32_t routingId);

IPC::Message*
Msg_HasMethod(int32_t routingId);
IPC::Message*
Reply_HasMethod(int32_t routingId);

IPC::Message*
Msg_Invoke(int32_t routingId);
IPC::Message*
Reply_Invoke(int32_t routingId);

IPC::Message*
Msg_InvokeDefault(int32_t routingId);
IPC::Message*
Reply_InvokeDefault(int32_t routingId);

IPC::Message*
Msg_HasProperty(int32_t routingId);
IPC::Message*
Reply_HasProperty(int32_t routingId);

IPC::Message*
Msg_SetProperty(int32_t routingId);
IPC::Message*
Reply_SetProperty(int32_t routingId);

IPC::Message*
Msg_RemoveProperty(int32_t routingId);
IPC::Message*
Reply_RemoveProperty(int32_t routingId);

IPC::Message*
Msg_Enumerate(int32_t routingId);
IPC::Message*
Reply_Enumerate(int32_t routingId);

IPC::Message*
Msg_Construct(int32_t routingId);
IPC::Message*
Reply_Construct(int32_t routingId);

IPC::Message*
Msg_Protect(int32_t routingId);

IPC::Message*
Msg_Unprotect(int32_t routingId);

IPC::Message*
Msg_GetParentProperty(int32_t routingId);
IPC::Message*
Reply_GetParentProperty(int32_t routingId);

IPC::Message*
Msg_GetChildProperty(int32_t routingId);
IPC::Message*
Reply_GetChildProperty(int32_t routingId);



} // namespace PPluginScriptableObject
} // namespace plugins
} // namespace mozilla

#endif // ifndef PPluginScriptableObject_h
