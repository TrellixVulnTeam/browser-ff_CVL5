//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef IPCBlob_h
#define IPCBlob_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"
#include "mozilla/ipc/IPCStream.h"
#include "mozilla/ipc/ProtocolTypes.h"

namespace mozilla {
class PRemoteLazyInputStreamParent;
} // namespace mozilla

namespace mozilla {
class PRemoteLazyInputStreamChild;
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union RemoteLazyStream|
//
namespace mozilla {
class RemoteLazyStream final
{
public:
    enum Type {
        T__None,
        TPRemoteLazyInputStreamParent = 1,
        TPRemoteLazyInputStreamChild,
        TIPCStream,
        T__Last = TIPCStream
    };

private:
    typedef mozilla::PRemoteLazyInputStreamParent PRemoteLazyInputStreamParent;
    typedef mozilla::PRemoteLazyInputStreamChild PRemoteLazyInputStreamChild;
    typedef mozilla::ipc::IPCStream IPCStream;
    typedef PRemoteLazyInputStreamParent* PRemoteLazyInputStreamParent__tdef;
    typedef PRemoteLazyInputStreamChild* PRemoteLazyInputStreamChild__tdef;
    typedef IPCStream IPCStream__tdef;

    union Value {
        mozilla::AlignedStorage2<PRemoteLazyInputStreamParent*> VPRemoteLazyInputStreamParent;
        mozilla::AlignedStorage2<PRemoteLazyInputStreamChild*> VPRemoteLazyInputStreamChild;
        mozilla::AlignedStorage2<IPCStream> VIPCStream;
    };

    PRemoteLazyInputStreamParent**
    ptr_PRemoteLazyInputStreamParent()
    {
        return ((mValue).VPRemoteLazyInputStreamParent).addr();
    }
    PRemoteLazyInputStreamParent* const*
    constptr_PRemoteLazyInputStreamParent() const
    {
        return ((mValue).VPRemoteLazyInputStreamParent).addr();
    }
    PRemoteLazyInputStreamChild**
    ptr_PRemoteLazyInputStreamChild()
    {
        return ((mValue).VPRemoteLazyInputStreamChild).addr();
    }
    PRemoteLazyInputStreamChild* const*
    constptr_PRemoteLazyInputStreamChild() const
    {
        return ((mValue).VPRemoteLazyInputStreamChild).addr();
    }
    IPCStream*
    ptr_IPCStream()
    {
        return ((mValue).VIPCStream).addr();
    }
    const IPCStream*
    constptr_IPCStream() const
    {
        return ((mValue).VIPCStream).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT RemoteLazyStream() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT RemoteLazyStream(PRemoteLazyInputStreamParent* aOther);

    MOZ_IMPLICIT RemoteLazyStream(PRemoteLazyInputStreamChild* aOther);

    MOZ_IMPLICIT RemoteLazyStream(const IPCStream& aOther);

    MOZ_IMPLICIT RemoteLazyStream(IPCStream&& aOther);

    MOZ_IMPLICIT RemoteLazyStream(const RemoteLazyStream& aOther);

    MOZ_IMPLICIT RemoteLazyStream(RemoteLazyStream&& aOther);

    ~RemoteLazyStream();

    Type
    type() const
    {
        return mType;
    }

    RemoteLazyStream&
    operator=(PRemoteLazyInputStreamParent* aRhs);

    RemoteLazyStream&
    operator=(PRemoteLazyInputStreamChild* aRhs);

    RemoteLazyStream&
    operator=(const IPCStream& aRhs);

    RemoteLazyStream&
    operator=(IPCStream&& aRhs);

    RemoteLazyStream&
    operator=(const RemoteLazyStream& aRhs);

    RemoteLazyStream&
    operator=(RemoteLazyStream&& aRhs);

    PRemoteLazyInputStreamParent*&
    get_PRemoteLazyInputStreamParent()
    {
        AssertSanity(TPRemoteLazyInputStreamParent);
        return (*(ptr_PRemoteLazyInputStreamParent()));
    }
    PRemoteLazyInputStreamParent*
    get_PRemoteLazyInputStreamParent() const
    {
        AssertSanity(TPRemoteLazyInputStreamParent);
        return (*(constptr_PRemoteLazyInputStreamParent()));
    }
    operator PRemoteLazyInputStreamParent*&()
    {
        return get_PRemoteLazyInputStreamParent();
    }
    operator PRemoteLazyInputStreamParent*() const
    {
        return get_PRemoteLazyInputStreamParent();
    }

    PRemoteLazyInputStreamChild*&
    get_PRemoteLazyInputStreamChild()
    {
        AssertSanity(TPRemoteLazyInputStreamChild);
        return (*(ptr_PRemoteLazyInputStreamChild()));
    }
    PRemoteLazyInputStreamChild*
    get_PRemoteLazyInputStreamChild() const
    {
        AssertSanity(TPRemoteLazyInputStreamChild);
        return (*(constptr_PRemoteLazyInputStreamChild()));
    }
    operator PRemoteLazyInputStreamChild*&()
    {
        return get_PRemoteLazyInputStreamChild();
    }
    operator PRemoteLazyInputStreamChild*() const
    {
        return get_PRemoteLazyInputStreamChild();
    }

    IPCStream&
    get_IPCStream()
    {
        AssertSanity(TIPCStream);
        return (*(ptr_IPCStream()));
    }
    const IPCStream&
    get_IPCStream() const
    {
        AssertSanity(TIPCStream);
        return (*(constptr_IPCStream()));
    }
    operator IPCStream&()
    {
        return get_IPCStream();
    }
    operator const IPCStream&() const
    {
        return get_IPCStream();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::RemoteLazyStream>
{
    typedef mozilla::RemoteLazyStream paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct IPCFile|
//
namespace mozilla {
namespace dom {
class IPCFile final
{
private:

public:
    MOZ_IMPLICIT IPCFile() :
        name_(),
        DOMPath_(),
        fullPath_(),
        isDirectory_(),
        lastModified_()
    {
    }

    MOZ_IMPLICIT IPCFile(
            const nsString& _name,
            const int64_t& _lastModified,
            const nsString& _DOMPath,
            const nsString& _fullPath,
            const bool& _isDirectory) :
        name_(_name),
        DOMPath_(_DOMPath),
        fullPath_(_fullPath),
        isDirectory_(_isDirectory),
        lastModified_(_lastModified)
    {
    }

    nsString&
    name()
    {
        return name_;
    }
    const nsString&
    name() const
    {
        return name_;
    }

    int64_t&
    lastModified()
    {
        return lastModified_;
    }
    const int64_t&
    lastModified() const
    {
        return lastModified_;
    }

    nsString&
    DOMPath()
    {
        return DOMPath_;
    }
    const nsString&
    DOMPath() const
    {
        return DOMPath_;
    }

    nsString&
    fullPath()
    {
        return fullPath_;
    }
    const nsString&
    fullPath() const
    {
        return fullPath_;
    }

    bool&
    isDirectory()
    {
        return isDirectory_;
    }
    const bool&
    isDirectory() const
    {
        return isDirectory_;
    }

private:
    nsString name_;
    nsString DOMPath_;
    nsString fullPath_;
    bool isDirectory_;
    int64_t lastModified_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPCFile>
{
    typedef mozilla::dom::IPCFile paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct IPCBlob|
//
namespace mozilla {
namespace dom {
class IPCBlob final
{
private:
    typedef mozilla::RemoteLazyStream RemoteLazyStream;
    typedef mozilla::dom::IPCFile IPCFile;

public:
    MOZ_IMPLICIT IPCBlob() :
        type_(),
        blobImplType_(),
        inputStream_(),
        file_(),
        size_(),
        fileId_()
    {
    }

    MOZ_IMPLICIT IPCBlob(
            const nsString& _type,
            const uint64_t& _size,
            const nsString& _blobImplType,
            const RemoteLazyStream& _inputStream,
            const mozilla::Maybe<IPCFile>& _file,
            const int64_t& _fileId) :
        type_(_type),
        blobImplType_(_blobImplType),
        inputStream_(_inputStream),
        file_(_file),
        size_(_size),
        fileId_(_fileId)
    {
    }

    nsString&
    type()
    {
        return type_;
    }
    const nsString&
    type() const
    {
        return type_;
    }

    uint64_t&
    size()
    {
        return size_;
    }
    const uint64_t&
    size() const
    {
        return size_;
    }

    nsString&
    blobImplType()
    {
        return blobImplType_;
    }
    const nsString&
    blobImplType() const
    {
        return blobImplType_;
    }

    RemoteLazyStream&
    inputStream()
    {
        return inputStream_;
    }
    const RemoteLazyStream&
    inputStream() const
    {
        return inputStream_;
    }

    mozilla::Maybe<IPCFile>&
    file()
    {
        return file_;
    }
    const mozilla::Maybe<IPCFile>&
    file() const
    {
        return file_;
    }

    int64_t&
    fileId()
    {
        return fileId_;
    }
    const int64_t&
    fileId() const
    {
        return fileId_;
    }

private:
    void
    StaticAssertions() const;
    nsString type_;
    nsString blobImplType_;
    RemoteLazyStream inputStream_;
    mozilla::Maybe<IPCFile> file_;
    uint64_t size_;
    int64_t fileId_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPCBlob>
{
    typedef mozilla::dom::IPCBlob paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

#endif // ifndef IPCBlob_h
