//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PBackgroundFileHandle_h
#define PBackgroundFileHandle_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"
#include "mozilla/dom/IPCBlob.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct FileRequestGetMetadataParams|
//
namespace mozilla {
namespace dom {
class FileRequestGetMetadataParams final
{
private:

public:
    MOZ_IMPLICIT FileRequestGetMetadataParams() :
        size_(),
        lastModified_()
    {
    }

    MOZ_IMPLICIT FileRequestGetMetadataParams(
            const bool& _size,
            const bool& _lastModified) :
        size_(_size),
        lastModified_(_lastModified)
    {
    }

    bool&
    size()
    {
        return size_;
    }
    const bool&
    size() const
    {
        return size_;
    }

    bool&
    lastModified()
    {
        return lastModified_;
    }
    const bool&
    lastModified() const
    {
        return lastModified_;
    }

private:
    bool size_;
    bool lastModified_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::FileRequestGetMetadataParams>
{
    typedef mozilla::dom::FileRequestGetMetadataParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct FileRequestReadParams|
//
namespace mozilla {
namespace dom {
class FileRequestReadParams final
{
private:

public:
    MOZ_IMPLICIT FileRequestReadParams() :
        offset_(),
        size_()
    {
    }

    MOZ_IMPLICIT FileRequestReadParams(
            const uint64_t& _offset,
            const uint64_t& _size) :
        offset_(_offset),
        size_(_size)
    {
    }

    uint64_t&
    offset()
    {
        return offset_;
    }
    const uint64_t&
    offset() const
    {
        return offset_;
    }

    uint64_t&
    size()
    {
        return size_;
    }
    const uint64_t&
    size() const
    {
        return size_;
    }

private:
    void
    StaticAssertions() const;
    uint64_t offset_;
    uint64_t size_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::FileRequestReadParams>
{
    typedef mozilla::dom::FileRequestReadParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct FileRequestStringData|
//
namespace mozilla {
namespace dom {
class FileRequestStringData final
{
private:

public:
    MOZ_IMPLICIT FileRequestStringData() :
        string_()
    {
    }

    MOZ_IMPLICIT FileRequestStringData(const nsCString& _string) :
        string_(_string)
    {
    }

    nsCString&
    string()
    {
        return string_;
    }
    const nsCString&
    string() const
    {
        return string_;
    }

private:
    nsCString string_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::FileRequestStringData>
{
    typedef mozilla::dom::FileRequestStringData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct FileRequestBlobData|
//
namespace mozilla {
namespace dom {
class FileRequestBlobData final
{
private:
    typedef mozilla::dom::IPCBlob IPCBlob;

public:
    MOZ_IMPLICIT FileRequestBlobData() :
        blob_()
    {
    }

    MOZ_IMPLICIT FileRequestBlobData(const IPCBlob& _blob) :
        blob_(_blob)
    {
    }

    IPCBlob&
    blob()
    {
        return blob_;
    }
    const IPCBlob&
    blob() const
    {
        return blob_;
    }

private:
    IPCBlob blob_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::FileRequestBlobData>
{
    typedef mozilla::dom::FileRequestBlobData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union FileRequestData|
//
namespace mozilla {
namespace dom {
class FileRequestData final
{
public:
    enum Type {
        T__None,
        TFileRequestStringData = 1,
        TFileRequestBlobData,
        T__Last = TFileRequestBlobData
    };

private:
    typedef mozilla::dom::FileRequestStringData FileRequestStringData;
    typedef mozilla::dom::FileRequestBlobData FileRequestBlobData;
    typedef FileRequestStringData FileRequestStringData__tdef;
    typedef FileRequestBlobData FileRequestBlobData__tdef;

    union Value {
        mozilla::AlignedStorage2<FileRequestStringData> VFileRequestStringData;
        mozilla::AlignedStorage2<FileRequestBlobData> VFileRequestBlobData;
    };

    FileRequestStringData*
    ptr_FileRequestStringData()
    {
        return ((mValue).VFileRequestStringData).addr();
    }
    const FileRequestStringData*
    constptr_FileRequestStringData() const
    {
        return ((mValue).VFileRequestStringData).addr();
    }
    FileRequestBlobData*
    ptr_FileRequestBlobData()
    {
        return ((mValue).VFileRequestBlobData).addr();
    }
    const FileRequestBlobData*
    constptr_FileRequestBlobData() const
    {
        return ((mValue).VFileRequestBlobData).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT FileRequestData() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT FileRequestData(const FileRequestStringData& aOther);

    MOZ_IMPLICIT FileRequestData(FileRequestStringData&& aOther);

    MOZ_IMPLICIT FileRequestData(const FileRequestBlobData& aOther);

    MOZ_IMPLICIT FileRequestData(FileRequestBlobData&& aOther);

    MOZ_IMPLICIT FileRequestData(const FileRequestData& aOther);

    MOZ_IMPLICIT FileRequestData(FileRequestData&& aOther);

    ~FileRequestData();

    Type
    type() const
    {
        return mType;
    }

    FileRequestData&
    operator=(const FileRequestStringData& aRhs);

    FileRequestData&
    operator=(FileRequestStringData&& aRhs);

    FileRequestData&
    operator=(const FileRequestBlobData& aRhs);

    FileRequestData&
    operator=(FileRequestBlobData&& aRhs);

    FileRequestData&
    operator=(const FileRequestData& aRhs);

    FileRequestData&
    operator=(FileRequestData&& aRhs);

    FileRequestStringData&
    get_FileRequestStringData()
    {
        AssertSanity(TFileRequestStringData);
        return (*(ptr_FileRequestStringData()));
    }
    const FileRequestStringData&
    get_FileRequestStringData() const
    {
        AssertSanity(TFileRequestStringData);
        return (*(constptr_FileRequestStringData()));
    }
    operator FileRequestStringData&()
    {
        return get_FileRequestStringData();
    }
    operator const FileRequestStringData&() const
    {
        return get_FileRequestStringData();
    }

    FileRequestBlobData&
    get_FileRequestBlobData()
    {
        AssertSanity(TFileRequestBlobData);
        return (*(ptr_FileRequestBlobData()));
    }
    const FileRequestBlobData&
    get_FileRequestBlobData() const
    {
        AssertSanity(TFileRequestBlobData);
        return (*(constptr_FileRequestBlobData()));
    }
    operator FileRequestBlobData&()
    {
        return get_FileRequestBlobData();
    }
    operator const FileRequestBlobData&() const
    {
        return get_FileRequestBlobData();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::FileRequestData>
{
    typedef mozilla::dom::FileRequestData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct FileRequestWriteParams|
//
namespace mozilla {
namespace dom {
class FileRequestWriteParams final
{
private:
    typedef mozilla::dom::FileRequestData FileRequestData;

public:
    MOZ_IMPLICIT FileRequestWriteParams() :
        data_(),
        offset_(),
        dataLength_()
    {
    }

    MOZ_IMPLICIT FileRequestWriteParams(
            const uint64_t& _offset,
            const FileRequestData& _data,
            const uint64_t& _dataLength) :
        data_(_data),
        offset_(_offset),
        dataLength_(_dataLength)
    {
    }

    uint64_t&
    offset()
    {
        return offset_;
    }
    const uint64_t&
    offset() const
    {
        return offset_;
    }

    FileRequestData&
    data()
    {
        return data_;
    }
    const FileRequestData&
    data() const
    {
        return data_;
    }

    uint64_t&
    dataLength()
    {
        return dataLength_;
    }
    const uint64_t&
    dataLength() const
    {
        return dataLength_;
    }

private:
    void
    StaticAssertions() const;
    FileRequestData data_;
    uint64_t offset_;
    uint64_t dataLength_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::FileRequestWriteParams>
{
    typedef mozilla::dom::FileRequestWriteParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct FileRequestTruncateParams|
//
namespace mozilla {
namespace dom {
class FileRequestTruncateParams final
{
private:

public:
    MOZ_IMPLICIT FileRequestTruncateParams() :
        offset_()
    {
    }

    MOZ_IMPLICIT FileRequestTruncateParams(const uint64_t& _offset) :
        offset_(_offset)
    {
    }

    uint64_t&
    offset()
    {
        return offset_;
    }
    const uint64_t&
    offset() const
    {
        return offset_;
    }

private:
    uint64_t offset_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::FileRequestTruncateParams>
{
    typedef mozilla::dom::FileRequestTruncateParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct FileRequestFlushParams|
//
namespace mozilla {
namespace dom {
class FileRequestFlushParams final
{
private:

public:
    MOZ_IMPLICIT FileRequestFlushParams()
    {
    }

private:
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::FileRequestFlushParams>
{
    typedef mozilla::dom::FileRequestFlushParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union FileRequestParams|
//
namespace mozilla {
namespace dom {
class FileRequestParams final
{
public:
    enum Type {
        T__None,
        TFileRequestGetMetadataParams = 1,
        TFileRequestReadParams,
        TFileRequestWriteParams,
        TFileRequestTruncateParams,
        TFileRequestFlushParams,
        T__Last = TFileRequestFlushParams
    };

private:
    typedef mozilla::dom::FileRequestGetMetadataParams FileRequestGetMetadataParams;
    typedef mozilla::dom::FileRequestReadParams FileRequestReadParams;
    typedef mozilla::dom::FileRequestWriteParams FileRequestWriteParams;
    typedef mozilla::dom::FileRequestTruncateParams FileRequestTruncateParams;
    typedef mozilla::dom::FileRequestFlushParams FileRequestFlushParams;
    typedef FileRequestGetMetadataParams FileRequestGetMetadataParams__tdef;
    typedef FileRequestReadParams FileRequestReadParams__tdef;
    typedef FileRequestWriteParams FileRequestWriteParams__tdef;
    typedef FileRequestTruncateParams FileRequestTruncateParams__tdef;
    typedef FileRequestFlushParams FileRequestFlushParams__tdef;

    union Value {
        mozilla::AlignedStorage2<FileRequestGetMetadataParams> VFileRequestGetMetadataParams;
        mozilla::AlignedStorage2<FileRequestReadParams> VFileRequestReadParams;
        mozilla::AlignedStorage2<FileRequestWriteParams> VFileRequestWriteParams;
        mozilla::AlignedStorage2<FileRequestTruncateParams> VFileRequestTruncateParams;
        mozilla::AlignedStorage2<FileRequestFlushParams> VFileRequestFlushParams;
    };

    FileRequestGetMetadataParams*
    ptr_FileRequestGetMetadataParams()
    {
        return ((mValue).VFileRequestGetMetadataParams).addr();
    }
    const FileRequestGetMetadataParams*
    constptr_FileRequestGetMetadataParams() const
    {
        return ((mValue).VFileRequestGetMetadataParams).addr();
    }
    FileRequestReadParams*
    ptr_FileRequestReadParams()
    {
        return ((mValue).VFileRequestReadParams).addr();
    }
    const FileRequestReadParams*
    constptr_FileRequestReadParams() const
    {
        return ((mValue).VFileRequestReadParams).addr();
    }
    FileRequestWriteParams*
    ptr_FileRequestWriteParams()
    {
        return ((mValue).VFileRequestWriteParams).addr();
    }
    const FileRequestWriteParams*
    constptr_FileRequestWriteParams() const
    {
        return ((mValue).VFileRequestWriteParams).addr();
    }
    FileRequestTruncateParams*
    ptr_FileRequestTruncateParams()
    {
        return ((mValue).VFileRequestTruncateParams).addr();
    }
    const FileRequestTruncateParams*
    constptr_FileRequestTruncateParams() const
    {
        return ((mValue).VFileRequestTruncateParams).addr();
    }
    FileRequestFlushParams*
    ptr_FileRequestFlushParams()
    {
        return ((mValue).VFileRequestFlushParams).addr();
    }
    const FileRequestFlushParams*
    constptr_FileRequestFlushParams() const
    {
        return ((mValue).VFileRequestFlushParams).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT FileRequestParams() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT FileRequestParams(const FileRequestGetMetadataParams& aOther);

    MOZ_IMPLICIT FileRequestParams(FileRequestGetMetadataParams&& aOther);

    MOZ_IMPLICIT FileRequestParams(const FileRequestReadParams& aOther);

    MOZ_IMPLICIT FileRequestParams(FileRequestReadParams&& aOther);

    MOZ_IMPLICIT FileRequestParams(const FileRequestWriteParams& aOther);

    MOZ_IMPLICIT FileRequestParams(FileRequestWriteParams&& aOther);

    MOZ_IMPLICIT FileRequestParams(const FileRequestTruncateParams& aOther);

    MOZ_IMPLICIT FileRequestParams(FileRequestTruncateParams&& aOther);

    MOZ_IMPLICIT FileRequestParams(const FileRequestFlushParams& aOther);

    MOZ_IMPLICIT FileRequestParams(FileRequestFlushParams&& aOther);

    MOZ_IMPLICIT FileRequestParams(const FileRequestParams& aOther);

    MOZ_IMPLICIT FileRequestParams(FileRequestParams&& aOther);

    ~FileRequestParams();

    Type
    type() const
    {
        return mType;
    }

    FileRequestParams&
    operator=(const FileRequestGetMetadataParams& aRhs);

    FileRequestParams&
    operator=(FileRequestGetMetadataParams&& aRhs);

    FileRequestParams&
    operator=(const FileRequestReadParams& aRhs);

    FileRequestParams&
    operator=(FileRequestReadParams&& aRhs);

    FileRequestParams&
    operator=(const FileRequestWriteParams& aRhs);

    FileRequestParams&
    operator=(FileRequestWriteParams&& aRhs);

    FileRequestParams&
    operator=(const FileRequestTruncateParams& aRhs);

    FileRequestParams&
    operator=(FileRequestTruncateParams&& aRhs);

    FileRequestParams&
    operator=(const FileRequestFlushParams& aRhs);

    FileRequestParams&
    operator=(FileRequestFlushParams&& aRhs);

    FileRequestParams&
    operator=(const FileRequestParams& aRhs);

    FileRequestParams&
    operator=(FileRequestParams&& aRhs);

    FileRequestGetMetadataParams&
    get_FileRequestGetMetadataParams()
    {
        AssertSanity(TFileRequestGetMetadataParams);
        return (*(ptr_FileRequestGetMetadataParams()));
    }
    const FileRequestGetMetadataParams&
    get_FileRequestGetMetadataParams() const
    {
        AssertSanity(TFileRequestGetMetadataParams);
        return (*(constptr_FileRequestGetMetadataParams()));
    }
    operator FileRequestGetMetadataParams&()
    {
        return get_FileRequestGetMetadataParams();
    }
    operator const FileRequestGetMetadataParams&() const
    {
        return get_FileRequestGetMetadataParams();
    }

    FileRequestReadParams&
    get_FileRequestReadParams()
    {
        AssertSanity(TFileRequestReadParams);
        return (*(ptr_FileRequestReadParams()));
    }
    const FileRequestReadParams&
    get_FileRequestReadParams() const
    {
        AssertSanity(TFileRequestReadParams);
        return (*(constptr_FileRequestReadParams()));
    }
    operator FileRequestReadParams&()
    {
        return get_FileRequestReadParams();
    }
    operator const FileRequestReadParams&() const
    {
        return get_FileRequestReadParams();
    }

    FileRequestWriteParams&
    get_FileRequestWriteParams()
    {
        AssertSanity(TFileRequestWriteParams);
        return (*(ptr_FileRequestWriteParams()));
    }
    const FileRequestWriteParams&
    get_FileRequestWriteParams() const
    {
        AssertSanity(TFileRequestWriteParams);
        return (*(constptr_FileRequestWriteParams()));
    }
    operator FileRequestWriteParams&()
    {
        return get_FileRequestWriteParams();
    }
    operator const FileRequestWriteParams&() const
    {
        return get_FileRequestWriteParams();
    }

    FileRequestTruncateParams&
    get_FileRequestTruncateParams()
    {
        AssertSanity(TFileRequestTruncateParams);
        return (*(ptr_FileRequestTruncateParams()));
    }
    const FileRequestTruncateParams&
    get_FileRequestTruncateParams() const
    {
        AssertSanity(TFileRequestTruncateParams);
        return (*(constptr_FileRequestTruncateParams()));
    }
    operator FileRequestTruncateParams&()
    {
        return get_FileRequestTruncateParams();
    }
    operator const FileRequestTruncateParams&() const
    {
        return get_FileRequestTruncateParams();
    }

    FileRequestFlushParams&
    get_FileRequestFlushParams()
    {
        AssertSanity(TFileRequestFlushParams);
        return (*(ptr_FileRequestFlushParams()));
    }
    const FileRequestFlushParams&
    get_FileRequestFlushParams() const
    {
        AssertSanity(TFileRequestFlushParams);
        return (*(constptr_FileRequestFlushParams()));
    }
    operator FileRequestFlushParams&()
    {
        return get_FileRequestFlushParams();
    }
    operator const FileRequestFlushParams&() const
    {
        return get_FileRequestFlushParams();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::FileRequestParams>
{
    typedef mozilla::dom::FileRequestParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace dom {
class PBackgroundFileHandleParent;
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
class PBackgroundFileHandleChild;
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Code common to PBackgroundFileHandleChild and PBackgroundFileHandleParent
//
namespace mozilla {
namespace dom {
namespace PBackgroundFileHandle {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::dom::PBackgroundFileHandleParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::dom::PBackgroundFileHandleChild>* aChild);

enum MessageType {
    PBackgroundFileHandleStart = PBackgroundFileHandleMsgStart << 16,
    Msg_DeleteMe__ID,
    Msg_Finish__ID,
    Msg_Abort__ID,
    Msg_PBackgroundFileRequestConstructor__ID,
    Reply_PBackgroundFileRequestConstructor__ID,
    Msg___delete____ID,
    Reply___delete____ID,
    Msg_Complete__ID,
    PBackgroundFileHandleEnd
};

IPC::Message*
Msg_DeleteMe(int32_t routingId);

IPC::Message*
Msg_Finish(int32_t routingId);

IPC::Message*
Msg_Abort(int32_t routingId);

IPC::Message*
Msg_PBackgroundFileRequestConstructor(int32_t routingId);
IPC::Message*
Reply_PBackgroundFileRequestConstructor(int32_t routingId);

IPC::Message*
Msg___delete__(int32_t routingId);
IPC::Message*
Reply___delete__(int32_t routingId);

IPC::Message*
Msg_Complete(int32_t routingId);



} // namespace PBackgroundFileHandle
} // namespace dom
} // namespace mozilla

#endif // ifndef PBackgroundFileHandle_h
