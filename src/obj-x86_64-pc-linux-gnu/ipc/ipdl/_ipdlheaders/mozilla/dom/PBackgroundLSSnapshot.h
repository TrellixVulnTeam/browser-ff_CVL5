//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PBackgroundLSSnapshot_h
#define PBackgroundLSSnapshot_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "mozilla/dom/LSValue.h"
#include "mozilla/dom/PBackgroundLSSharedTypes.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct LSSetItemInfo|
//
namespace mozilla {
namespace dom {
class LSSetItemInfo final
{
private:
    typedef mozilla::dom::LSValue LSValue;

public:
    MOZ_IMPLICIT LSSetItemInfo() :
        key_(),
        value_()
    {
    }

    MOZ_IMPLICIT LSSetItemInfo(
            const nsString& _key,
            const LSValue& _value) :
        key_(_key),
        value_(_value)
    {
    }

    nsString&
    key()
    {
        return key_;
    }
    const nsString&
    key() const
    {
        return key_;
    }

    LSValue&
    value()
    {
        return value_;
    }
    const LSValue&
    value() const
    {
        return value_;
    }

private:
    nsString key_;
    LSValue value_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::LSSetItemInfo>
{
    typedef mozilla::dom::LSSetItemInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct LSRemoveItemInfo|
//
namespace mozilla {
namespace dom {
class LSRemoveItemInfo final
{
private:

public:
    MOZ_IMPLICIT LSRemoveItemInfo() :
        key_()
    {
    }

    MOZ_IMPLICIT LSRemoveItemInfo(const nsString& _key) :
        key_(_key)
    {
    }

    nsString&
    key()
    {
        return key_;
    }
    const nsString&
    key() const
    {
        return key_;
    }

private:
    nsString key_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::LSRemoveItemInfo>
{
    typedef mozilla::dom::LSRemoveItemInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct LSClearInfo|
//
namespace mozilla {
namespace dom {
class LSClearInfo final
{
private:

public:
    MOZ_IMPLICIT LSClearInfo()
    {
    }

private:
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::LSClearInfo>
{
    typedef mozilla::dom::LSClearInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union LSWriteInfo|
//
namespace mozilla {
namespace dom {
class LSWriteInfo final
{
public:
    enum Type {
        T__None,
        TLSSetItemInfo = 1,
        TLSRemoveItemInfo,
        TLSClearInfo,
        T__Last = TLSClearInfo
    };

private:
    typedef mozilla::dom::LSSetItemInfo LSSetItemInfo;
    typedef mozilla::dom::LSRemoveItemInfo LSRemoveItemInfo;
    typedef mozilla::dom::LSClearInfo LSClearInfo;
    typedef LSSetItemInfo LSSetItemInfo__tdef;
    typedef LSRemoveItemInfo LSRemoveItemInfo__tdef;
    typedef LSClearInfo LSClearInfo__tdef;

    union Value {
        mozilla::AlignedStorage2<LSSetItemInfo> VLSSetItemInfo;
        mozilla::AlignedStorage2<LSRemoveItemInfo> VLSRemoveItemInfo;
        mozilla::AlignedStorage2<LSClearInfo> VLSClearInfo;
    };

    LSSetItemInfo*
    ptr_LSSetItemInfo()
    {
        return ((mValue).VLSSetItemInfo).addr();
    }
    const LSSetItemInfo*
    constptr_LSSetItemInfo() const
    {
        return ((mValue).VLSSetItemInfo).addr();
    }
    LSRemoveItemInfo*
    ptr_LSRemoveItemInfo()
    {
        return ((mValue).VLSRemoveItemInfo).addr();
    }
    const LSRemoveItemInfo*
    constptr_LSRemoveItemInfo() const
    {
        return ((mValue).VLSRemoveItemInfo).addr();
    }
    LSClearInfo*
    ptr_LSClearInfo()
    {
        return ((mValue).VLSClearInfo).addr();
    }
    const LSClearInfo*
    constptr_LSClearInfo() const
    {
        return ((mValue).VLSClearInfo).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT LSWriteInfo() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT LSWriteInfo(const LSSetItemInfo& aOther);

    MOZ_IMPLICIT LSWriteInfo(LSSetItemInfo&& aOther);

    MOZ_IMPLICIT LSWriteInfo(const LSRemoveItemInfo& aOther);

    MOZ_IMPLICIT LSWriteInfo(LSRemoveItemInfo&& aOther);

    MOZ_IMPLICIT LSWriteInfo(const LSClearInfo& aOther);

    MOZ_IMPLICIT LSWriteInfo(LSClearInfo&& aOther);

    MOZ_IMPLICIT LSWriteInfo(const LSWriteInfo& aOther);

    MOZ_IMPLICIT LSWriteInfo(LSWriteInfo&& aOther);

    ~LSWriteInfo();

    Type
    type() const
    {
        return mType;
    }

    LSWriteInfo&
    operator=(const LSSetItemInfo& aRhs);

    LSWriteInfo&
    operator=(LSSetItemInfo&& aRhs);

    LSWriteInfo&
    operator=(const LSRemoveItemInfo& aRhs);

    LSWriteInfo&
    operator=(LSRemoveItemInfo&& aRhs);

    LSWriteInfo&
    operator=(const LSClearInfo& aRhs);

    LSWriteInfo&
    operator=(LSClearInfo&& aRhs);

    LSWriteInfo&
    operator=(const LSWriteInfo& aRhs);

    LSWriteInfo&
    operator=(LSWriteInfo&& aRhs);

    LSSetItemInfo&
    get_LSSetItemInfo()
    {
        AssertSanity(TLSSetItemInfo);
        return (*(ptr_LSSetItemInfo()));
    }
    const LSSetItemInfo&
    get_LSSetItemInfo() const
    {
        AssertSanity(TLSSetItemInfo);
        return (*(constptr_LSSetItemInfo()));
    }
    operator LSSetItemInfo&()
    {
        return get_LSSetItemInfo();
    }
    operator const LSSetItemInfo&() const
    {
        return get_LSSetItemInfo();
    }

    LSRemoveItemInfo&
    get_LSRemoveItemInfo()
    {
        AssertSanity(TLSRemoveItemInfo);
        return (*(ptr_LSRemoveItemInfo()));
    }
    const LSRemoveItemInfo&
    get_LSRemoveItemInfo() const
    {
        AssertSanity(TLSRemoveItemInfo);
        return (*(constptr_LSRemoveItemInfo()));
    }
    operator LSRemoveItemInfo&()
    {
        return get_LSRemoveItemInfo();
    }
    operator const LSRemoveItemInfo&() const
    {
        return get_LSRemoveItemInfo();
    }

    LSClearInfo&
    get_LSClearInfo()
    {
        AssertSanity(TLSClearInfo);
        return (*(ptr_LSClearInfo()));
    }
    const LSClearInfo&
    get_LSClearInfo() const
    {
        AssertSanity(TLSClearInfo);
        return (*(constptr_LSClearInfo()));
    }
    operator LSClearInfo&()
    {
        return get_LSClearInfo();
    }
    operator const LSClearInfo&() const
    {
        return get_LSClearInfo();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::LSWriteInfo>
{
    typedef mozilla::dom::LSWriteInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct LSSetItemAndNotifyInfo|
//
namespace mozilla {
namespace dom {
class LSSetItemAndNotifyInfo final
{
private:
    typedef mozilla::dom::LSValue LSValue;

public:
    MOZ_IMPLICIT LSSetItemAndNotifyInfo() :
        key_(),
        oldValue_(),
        value_()
    {
    }

    MOZ_IMPLICIT LSSetItemAndNotifyInfo(
            const nsString& _key,
            const LSValue& _oldValue,
            const LSValue& _value) :
        key_(_key),
        oldValue_(_oldValue),
        value_(_value)
    {
    }

    nsString&
    key()
    {
        return key_;
    }
    const nsString&
    key() const
    {
        return key_;
    }

    LSValue&
    oldValue()
    {
        return oldValue_;
    }
    const LSValue&
    oldValue() const
    {
        return oldValue_;
    }

    LSValue&
    value()
    {
        return value_;
    }
    const LSValue&
    value() const
    {
        return value_;
    }

private:
    nsString key_;
    LSValue oldValue_;
    LSValue value_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::LSSetItemAndNotifyInfo>
{
    typedef mozilla::dom::LSSetItemAndNotifyInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct LSRemoveItemAndNotifyInfo|
//
namespace mozilla {
namespace dom {
class LSRemoveItemAndNotifyInfo final
{
private:
    typedef mozilla::dom::LSValue LSValue;

public:
    MOZ_IMPLICIT LSRemoveItemAndNotifyInfo() :
        key_(),
        oldValue_()
    {
    }

    MOZ_IMPLICIT LSRemoveItemAndNotifyInfo(
            const nsString& _key,
            const LSValue& _oldValue) :
        key_(_key),
        oldValue_(_oldValue)
    {
    }

    nsString&
    key()
    {
        return key_;
    }
    const nsString&
    key() const
    {
        return key_;
    }

    LSValue&
    oldValue()
    {
        return oldValue_;
    }
    const LSValue&
    oldValue() const
    {
        return oldValue_;
    }

private:
    nsString key_;
    LSValue oldValue_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::LSRemoveItemAndNotifyInfo>
{
    typedef mozilla::dom::LSRemoveItemAndNotifyInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union LSWriteAndNotifyInfo|
//
namespace mozilla {
namespace dom {
class LSWriteAndNotifyInfo final
{
public:
    enum Type {
        T__None,
        TLSSetItemAndNotifyInfo = 1,
        TLSRemoveItemAndNotifyInfo,
        TLSClearInfo,
        T__Last = TLSClearInfo
    };

private:
    typedef mozilla::dom::LSSetItemAndNotifyInfo LSSetItemAndNotifyInfo;
    typedef mozilla::dom::LSRemoveItemAndNotifyInfo LSRemoveItemAndNotifyInfo;
    typedef mozilla::dom::LSClearInfo LSClearInfo;
    typedef LSSetItemAndNotifyInfo LSSetItemAndNotifyInfo__tdef;
    typedef LSRemoveItemAndNotifyInfo LSRemoveItemAndNotifyInfo__tdef;
    typedef LSClearInfo LSClearInfo__tdef;

    union Value {
        mozilla::AlignedStorage2<LSSetItemAndNotifyInfo> VLSSetItemAndNotifyInfo;
        mozilla::AlignedStorage2<LSRemoveItemAndNotifyInfo> VLSRemoveItemAndNotifyInfo;
        mozilla::AlignedStorage2<LSClearInfo> VLSClearInfo;
    };

    LSSetItemAndNotifyInfo*
    ptr_LSSetItemAndNotifyInfo()
    {
        return ((mValue).VLSSetItemAndNotifyInfo).addr();
    }
    const LSSetItemAndNotifyInfo*
    constptr_LSSetItemAndNotifyInfo() const
    {
        return ((mValue).VLSSetItemAndNotifyInfo).addr();
    }
    LSRemoveItemAndNotifyInfo*
    ptr_LSRemoveItemAndNotifyInfo()
    {
        return ((mValue).VLSRemoveItemAndNotifyInfo).addr();
    }
    const LSRemoveItemAndNotifyInfo*
    constptr_LSRemoveItemAndNotifyInfo() const
    {
        return ((mValue).VLSRemoveItemAndNotifyInfo).addr();
    }
    LSClearInfo*
    ptr_LSClearInfo()
    {
        return ((mValue).VLSClearInfo).addr();
    }
    const LSClearInfo*
    constptr_LSClearInfo() const
    {
        return ((mValue).VLSClearInfo).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT LSWriteAndNotifyInfo() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT LSWriteAndNotifyInfo(const LSSetItemAndNotifyInfo& aOther);

    MOZ_IMPLICIT LSWriteAndNotifyInfo(LSSetItemAndNotifyInfo&& aOther);

    MOZ_IMPLICIT LSWriteAndNotifyInfo(const LSRemoveItemAndNotifyInfo& aOther);

    MOZ_IMPLICIT LSWriteAndNotifyInfo(LSRemoveItemAndNotifyInfo&& aOther);

    MOZ_IMPLICIT LSWriteAndNotifyInfo(const LSClearInfo& aOther);

    MOZ_IMPLICIT LSWriteAndNotifyInfo(LSClearInfo&& aOther);

    MOZ_IMPLICIT LSWriteAndNotifyInfo(const LSWriteAndNotifyInfo& aOther);

    MOZ_IMPLICIT LSWriteAndNotifyInfo(LSWriteAndNotifyInfo&& aOther);

    ~LSWriteAndNotifyInfo();

    Type
    type() const
    {
        return mType;
    }

    LSWriteAndNotifyInfo&
    operator=(const LSSetItemAndNotifyInfo& aRhs);

    LSWriteAndNotifyInfo&
    operator=(LSSetItemAndNotifyInfo&& aRhs);

    LSWriteAndNotifyInfo&
    operator=(const LSRemoveItemAndNotifyInfo& aRhs);

    LSWriteAndNotifyInfo&
    operator=(LSRemoveItemAndNotifyInfo&& aRhs);

    LSWriteAndNotifyInfo&
    operator=(const LSClearInfo& aRhs);

    LSWriteAndNotifyInfo&
    operator=(LSClearInfo&& aRhs);

    LSWriteAndNotifyInfo&
    operator=(const LSWriteAndNotifyInfo& aRhs);

    LSWriteAndNotifyInfo&
    operator=(LSWriteAndNotifyInfo&& aRhs);

    LSSetItemAndNotifyInfo&
    get_LSSetItemAndNotifyInfo()
    {
        AssertSanity(TLSSetItemAndNotifyInfo);
        return (*(ptr_LSSetItemAndNotifyInfo()));
    }
    const LSSetItemAndNotifyInfo&
    get_LSSetItemAndNotifyInfo() const
    {
        AssertSanity(TLSSetItemAndNotifyInfo);
        return (*(constptr_LSSetItemAndNotifyInfo()));
    }
    operator LSSetItemAndNotifyInfo&()
    {
        return get_LSSetItemAndNotifyInfo();
    }
    operator const LSSetItemAndNotifyInfo&() const
    {
        return get_LSSetItemAndNotifyInfo();
    }

    LSRemoveItemAndNotifyInfo&
    get_LSRemoveItemAndNotifyInfo()
    {
        AssertSanity(TLSRemoveItemAndNotifyInfo);
        return (*(ptr_LSRemoveItemAndNotifyInfo()));
    }
    const LSRemoveItemAndNotifyInfo&
    get_LSRemoveItemAndNotifyInfo() const
    {
        AssertSanity(TLSRemoveItemAndNotifyInfo);
        return (*(constptr_LSRemoveItemAndNotifyInfo()));
    }
    operator LSRemoveItemAndNotifyInfo&()
    {
        return get_LSRemoveItemAndNotifyInfo();
    }
    operator const LSRemoveItemAndNotifyInfo&() const
    {
        return get_LSRemoveItemAndNotifyInfo();
    }

    LSClearInfo&
    get_LSClearInfo()
    {
        AssertSanity(TLSClearInfo);
        return (*(ptr_LSClearInfo()));
    }
    const LSClearInfo&
    get_LSClearInfo() const
    {
        AssertSanity(TLSClearInfo);
        return (*(constptr_LSClearInfo()));
    }
    operator LSClearInfo&()
    {
        return get_LSClearInfo();
    }
    operator const LSClearInfo&() const
    {
        return get_LSClearInfo();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::LSWriteAndNotifyInfo>
{
    typedef mozilla::dom::LSWriteAndNotifyInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace dom {
class PBackgroundLSSnapshotParent;
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
class PBackgroundLSSnapshotChild;
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Code common to PBackgroundLSSnapshotChild and PBackgroundLSSnapshotParent
//
namespace mozilla {
namespace dom {
namespace PBackgroundLSSnapshot {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::dom::PBackgroundLSSnapshotParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::dom::PBackgroundLSSnapshotChild>* aChild);

enum MessageType {
    PBackgroundLSSnapshotStart = PBackgroundLSSnapshotMsgStart << 16,
    Msg_DeleteMe__ID,
    Msg_Checkpoint__ID,
    Msg_CheckpointAndNotify__ID,
    Msg_Finish__ID,
    Msg_Loaded__ID,
    Msg_LoadValueAndMoreItems__ID,
    Reply_LoadValueAndMoreItems__ID,
    Msg_LoadKeys__ID,
    Reply_LoadKeys__ID,
    Msg_IncreasePeakUsage__ID,
    Reply_IncreasePeakUsage__ID,
    Msg_Ping__ID,
    Reply_Ping__ID,
    Msg_MarkDirty__ID,
    Msg___delete____ID,
    Reply___delete____ID,
    PBackgroundLSSnapshotEnd
};

IPC::Message*
Msg_DeleteMe(int32_t routingId);

IPC::Message*
Msg_Checkpoint(int32_t routingId);

IPC::Message*
Msg_CheckpointAndNotify(int32_t routingId);

IPC::Message*
Msg_Finish(int32_t routingId);

IPC::Message*
Msg_Loaded(int32_t routingId);

IPC::Message*
Msg_LoadValueAndMoreItems(int32_t routingId);
IPC::Message*
Reply_LoadValueAndMoreItems(int32_t routingId);

IPC::Message*
Msg_LoadKeys(int32_t routingId);
IPC::Message*
Reply_LoadKeys(int32_t routingId);

IPC::Message*
Msg_IncreasePeakUsage(int32_t routingId);
IPC::Message*
Reply_IncreasePeakUsage(int32_t routingId);

IPC::Message*
Msg_Ping(int32_t routingId);
IPC::Message*
Reply_Ping(int32_t routingId);

IPC::Message*
Msg_MarkDirty(int32_t routingId);

IPC::Message*
Msg___delete__(int32_t routingId);
IPC::Message*
Reply___delete__(int32_t routingId);



} // namespace PBackgroundLSSnapshot
} // namespace dom
} // namespace mozilla

#endif // ifndef PBackgroundLSSnapshot_h
