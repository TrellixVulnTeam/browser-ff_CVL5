//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef DOMTypes_h
#define DOMTypes_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "Units.h"
#include "mozilla/HalScreenConfiguration.h"
#include "mozilla/ScrollbarPreferences.h"
#include "mozilla/TimeStamp.h"
#include "mozilla/dom/BrowsingContext.h"
#include "mozilla/dom/SessionHistoryEntry.h"
#include "mozilla/gfx/Types.h"
#include "mozilla/ipc/IPCStreamUtils.h"
#include "mozilla/ipc/SerializedStructuredCloneBuffer.h"
#include "nsIContentSecurityPolicy.h"
#include "nsIPrincipal.h"
#include "nsIReferrerInfo.h"
#include "nsIURI.h"
#include "nsIVariant.h"
#include "nsIWidgetListener.h"
#include "mozilla/dom/IPCBlob.h"
#include "mozilla/ipc/IPCStream.h"
#include "mozilla/ipc/ProtocolTypes.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct MessagePortIdentifier|
//
namespace mozilla {
namespace dom {
class MessagePortIdentifier final
{
private:

public:
    MOZ_IMPLICIT MessagePortIdentifier() :
        uuid_(),
        destinationUuid_(),
        neutered_(),
        sequenceId_()
    {
    }

    MOZ_IMPLICIT MessagePortIdentifier(
            const nsID& _uuid,
            const nsID& _destinationUuid,
            const uint32_t& _sequenceId,
            const bool& _neutered) :
        uuid_(_uuid),
        destinationUuid_(_destinationUuid),
        neutered_(_neutered),
        sequenceId_(_sequenceId)
    {
    }

    nsID&
    uuid()
    {
        return uuid_;
    }
    const nsID&
    uuid() const
    {
        return uuid_;
    }

    nsID&
    destinationUuid()
    {
        return destinationUuid_;
    }
    const nsID&
    destinationUuid() const
    {
        return destinationUuid_;
    }

    uint32_t&
    sequenceId()
    {
        return sequenceId_;
    }
    const uint32_t&
    sequenceId() const
    {
        return sequenceId_;
    }

    bool&
    neutered()
    {
        return neutered_;
    }
    const bool&
    neutered() const
    {
        return neutered_;
    }

private:
    nsID uuid_;
    nsID destinationUuid_;
    bool neutered_;
    uint32_t sequenceId_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::MessagePortIdentifier>
{
    typedef mozilla::dom::MessagePortIdentifier paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ClonedMessageData|
//
namespace mozilla {
namespace dom {
class ClonedMessageData final
{
private:
    typedef mozilla::SerializedStructuredCloneBuffer SerializedStructuredCloneBuffer;
    typedef mozilla::dom::IPCBlob IPCBlob;
    typedef mozilla::ipc::IPCStream IPCStream;
    typedef mozilla::dom::MessagePortIdentifier MessagePortIdentifier;

public:
    MOZ_IMPLICIT ClonedMessageData() :
        data_(),
        blobs_(),
        inputStreams_(),
        identifiers_()
    {
    }

    MOZ_IMPLICIT ClonedMessageData(
            SerializedStructuredCloneBuffer&& _data,
            const nsTArray<IPCBlob>& _blobs,
            const nsTArray<IPCStream>& _inputStreams,
            const nsTArray<MessagePortIdentifier>& _identifiers) :
        data_(std::move(_data)),
        blobs_(_blobs),
        inputStreams_(_inputStreams),
        identifiers_(_identifiers)
    {
    }

    SerializedStructuredCloneBuffer&
    data()
    {
        return data_;
    }
    const SerializedStructuredCloneBuffer&
    data() const
    {
        return data_;
    }

    nsTArray<IPCBlob>&
    blobs()
    {
        return blobs_;
    }
    const nsTArray<IPCBlob>&
    blobs() const
    {
        return blobs_;
    }

    nsTArray<IPCStream>&
    inputStreams()
    {
        return inputStreams_;
    }
    const nsTArray<IPCStream>&
    inputStreams() const
    {
        return inputStreams_;
    }

    nsTArray<MessagePortIdentifier>&
    identifiers()
    {
        return identifiers_;
    }
    const nsTArray<MessagePortIdentifier>&
    identifiers() const
    {
        return identifiers_;
    }

private:
    SerializedStructuredCloneBuffer data_;
    CopyableTArray<IPCBlob> blobs_;
    CopyableTArray<IPCStream> inputStreams_;
    CopyableTArray<MessagePortIdentifier> identifiers_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ClonedMessageData>
{
    typedef mozilla::dom::ClonedMessageData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ErrorMessageData|
//
namespace mozilla {
namespace dom {
class ErrorMessageData final
{
private:

public:
    MOZ_IMPLICIT ErrorMessageData()
    {
    }

private:
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ErrorMessageData>
{
    typedef mozilla::dom::ErrorMessageData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union ClonedOrErrorMessageData|
//
namespace mozilla {
namespace dom {
class ClonedOrErrorMessageData final
{
public:
    enum Type {
        T__None,
        TClonedMessageData = 1,
        TErrorMessageData,
        T__Last = TErrorMessageData
    };

private:
    typedef mozilla::dom::ClonedMessageData ClonedMessageData;
    typedef mozilla::dom::ErrorMessageData ErrorMessageData;
    typedef ClonedMessageData ClonedMessageData__tdef;
    typedef ErrorMessageData ErrorMessageData__tdef;

    union Value {
        mozilla::AlignedStorage2<ClonedMessageData> VClonedMessageData;
        mozilla::AlignedStorage2<ErrorMessageData> VErrorMessageData;
    };

    ClonedMessageData*
    ptr_ClonedMessageData()
    {
        return ((mValue).VClonedMessageData).addr();
    }
    const ClonedMessageData*
    constptr_ClonedMessageData() const
    {
        return ((mValue).VClonedMessageData).addr();
    }
    ErrorMessageData*
    ptr_ErrorMessageData()
    {
        return ((mValue).VErrorMessageData).addr();
    }
    const ErrorMessageData*
    constptr_ErrorMessageData() const
    {
        return ((mValue).VErrorMessageData).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT ClonedOrErrorMessageData() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT ClonedOrErrorMessageData(ClonedMessageData&& aOther);

    MOZ_IMPLICIT ClonedOrErrorMessageData(const ErrorMessageData& aOther);

    MOZ_IMPLICIT ClonedOrErrorMessageData(ErrorMessageData&& aOther);

    MOZ_IMPLICIT ClonedOrErrorMessageData(ClonedOrErrorMessageData&& aOther);

    ~ClonedOrErrorMessageData();

    Type
    type() const
    {
        return mType;
    }

    ClonedOrErrorMessageData&
    operator=(ClonedMessageData&& aRhs);

    ClonedOrErrorMessageData&
    operator=(const ErrorMessageData& aRhs);

    ClonedOrErrorMessageData&
    operator=(ErrorMessageData&& aRhs);

    ClonedOrErrorMessageData&
    operator=(ClonedOrErrorMessageData&& aRhs);

    ClonedMessageData&
    get_ClonedMessageData()
    {
        AssertSanity(TClonedMessageData);
        return (*(ptr_ClonedMessageData()));
    }
    const ClonedMessageData&
    get_ClonedMessageData() const
    {
        AssertSanity(TClonedMessageData);
        return (*(constptr_ClonedMessageData()));
    }
    operator ClonedMessageData&()
    {
        return get_ClonedMessageData();
    }
    operator const ClonedMessageData&() const
    {
        return get_ClonedMessageData();
    }

    ErrorMessageData&
    get_ErrorMessageData()
    {
        AssertSanity(TErrorMessageData);
        return (*(ptr_ErrorMessageData()));
    }
    const ErrorMessageData&
    get_ErrorMessageData() const
    {
        AssertSanity(TErrorMessageData);
        return (*(constptr_ErrorMessageData()));
    }
    operator ErrorMessageData&()
    {
        return get_ErrorMessageData();
    }
    operator const ErrorMessageData&() const
    {
        return get_ErrorMessageData();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ClonedOrErrorMessageData>
{
    typedef mozilla::dom::ClonedOrErrorMessageData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct RefMessageData|
//
namespace mozilla {
namespace dom {
class RefMessageData final
{
private:

public:
    MOZ_IMPLICIT RefMessageData() :
        uuid_()
    {
    }

    MOZ_IMPLICIT RefMessageData(const nsID& _uuid) :
        uuid_(_uuid)
    {
    }

    nsID&
    uuid()
    {
        return uuid_;
    }
    const nsID&
    uuid() const
    {
        return uuid_;
    }

private:
    nsID uuid_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::RefMessageData>
{
    typedef mozilla::dom::RefMessageData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union MessageDataType|
//
namespace mozilla {
namespace dom {
class MessageDataType final
{
public:
    enum Type {
        T__None,
        TClonedMessageData = 1,
        TRefMessageData,
        T__Last = TRefMessageData
    };

private:
    typedef mozilla::dom::ClonedMessageData ClonedMessageData;
    typedef mozilla::dom::RefMessageData RefMessageData;
    typedef ClonedMessageData ClonedMessageData__tdef;
    typedef RefMessageData RefMessageData__tdef;

    union Value {
        mozilla::AlignedStorage2<ClonedMessageData> VClonedMessageData;
        mozilla::AlignedStorage2<RefMessageData> VRefMessageData;
    };

    ClonedMessageData*
    ptr_ClonedMessageData()
    {
        return ((mValue).VClonedMessageData).addr();
    }
    const ClonedMessageData*
    constptr_ClonedMessageData() const
    {
        return ((mValue).VClonedMessageData).addr();
    }
    RefMessageData*
    ptr_RefMessageData()
    {
        return ((mValue).VRefMessageData).addr();
    }
    const RefMessageData*
    constptr_RefMessageData() const
    {
        return ((mValue).VRefMessageData).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT MessageDataType() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT MessageDataType(ClonedMessageData&& aOther);

    MOZ_IMPLICIT MessageDataType(const RefMessageData& aOther);

    MOZ_IMPLICIT MessageDataType(RefMessageData&& aOther);

    MOZ_IMPLICIT MessageDataType(MessageDataType&& aOther);

    ~MessageDataType();

    Type
    type() const
    {
        return mType;
    }

    MessageDataType&
    operator=(ClonedMessageData&& aRhs);

    MessageDataType&
    operator=(const RefMessageData& aRhs);

    MessageDataType&
    operator=(RefMessageData&& aRhs);

    MessageDataType&
    operator=(MessageDataType&& aRhs);

    ClonedMessageData&
    get_ClonedMessageData()
    {
        AssertSanity(TClonedMessageData);
        return (*(ptr_ClonedMessageData()));
    }
    const ClonedMessageData&
    get_ClonedMessageData() const
    {
        AssertSanity(TClonedMessageData);
        return (*(constptr_ClonedMessageData()));
    }
    operator ClonedMessageData&()
    {
        return get_ClonedMessageData();
    }
    operator const ClonedMessageData&() const
    {
        return get_ClonedMessageData();
    }

    RefMessageData&
    get_RefMessageData()
    {
        AssertSanity(TRefMessageData);
        return (*(ptr_RefMessageData()));
    }
    const RefMessageData&
    get_RefMessageData() const
    {
        AssertSanity(TRefMessageData);
        return (*(constptr_RefMessageData()));
    }
    operator RefMessageData&()
    {
        return get_RefMessageData();
    }
    operator const RefMessageData&() const
    {
        return get_RefMessageData();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::MessageDataType>
{
    typedef mozilla::dom::MessageDataType paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct MessageData|
//
namespace mozilla {
namespace dom {
class MessageData final
{
private:
    typedef mozilla::dom::MessageDataType MessageDataType;

public:
    MOZ_IMPLICIT MessageData() :
        agentClusterId_(),
        data_()
    {
    }

    MOZ_IMPLICIT MessageData(
            const mozilla::Maybe<nsID>& _agentClusterId,
            MessageDataType&& _data) :
        agentClusterId_(_agentClusterId),
        data_(std::move(_data))
    {
    }

    mozilla::Maybe<nsID>&
    agentClusterId()
    {
        return agentClusterId_;
    }
    const mozilla::Maybe<nsID>&
    agentClusterId() const
    {
        return agentClusterId_;
    }

    MessageDataType&
    data()
    {
        return data_;
    }
    const MessageDataType&
    data() const
    {
        return data_;
    }

private:
    mozilla::Maybe<nsID> agentClusterId_;
    MessageDataType data_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::MessageData>
{
    typedef mozilla::dom::MessageData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union IPCDataTransferData|
//
namespace mozilla {
namespace dom {
class IPCDataTransferData final
{
public:
    enum Type {
        T__None,
        TnsString = 1,
        TShmem,
        TIPCBlob,
        T__Last = TIPCBlob
    };

private:
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::dom::IPCBlob IPCBlob;
    typedef nsString nsString__tdef;
    typedef Shmem Shmem__tdef;
    typedef IPCBlob IPCBlob__tdef;

    union Value {
        mozilla::AlignedStorage2<nsString> VnsString;
        mozilla::AlignedStorage2<Shmem> VShmem;
        mozilla::AlignedStorage2<IPCBlob> VIPCBlob;
    };

    nsString*
    ptr_nsString()
    {
        return ((mValue).VnsString).addr();
    }
    const nsString*
    constptr_nsString() const
    {
        return ((mValue).VnsString).addr();
    }
    Shmem*
    ptr_Shmem()
    {
        return ((mValue).VShmem).addr();
    }
    const Shmem*
    constptr_Shmem() const
    {
        return ((mValue).VShmem).addr();
    }
    IPCBlob*
    ptr_IPCBlob()
    {
        return ((mValue).VIPCBlob).addr();
    }
    const IPCBlob*
    constptr_IPCBlob() const
    {
        return ((mValue).VIPCBlob).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT IPCDataTransferData() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT IPCDataTransferData(const nsString& aOther);

    MOZ_IMPLICIT IPCDataTransferData(nsString&& aOther);

    MOZ_IMPLICIT IPCDataTransferData(Shmem&& aOther);

    MOZ_IMPLICIT IPCDataTransferData(const IPCBlob& aOther);

    MOZ_IMPLICIT IPCDataTransferData(IPCBlob&& aOther);

    MOZ_IMPLICIT IPCDataTransferData(const IPCDataTransferData& aOther);

    MOZ_IMPLICIT IPCDataTransferData(IPCDataTransferData&& aOther);

    ~IPCDataTransferData();

    Type
    type() const
    {
        return mType;
    }

    IPCDataTransferData&
    operator=(const nsString& aRhs);

    IPCDataTransferData&
    operator=(nsString&& aRhs);

    IPCDataTransferData&
    operator=(Shmem&& aRhs);

    IPCDataTransferData&
    operator=(const IPCBlob& aRhs);

    IPCDataTransferData&
    operator=(IPCBlob&& aRhs);

    IPCDataTransferData&
    operator=(const IPCDataTransferData& aRhs);

    IPCDataTransferData&
    operator=(IPCDataTransferData&& aRhs);

    nsString&
    get_nsString()
    {
        AssertSanity(TnsString);
        return (*(ptr_nsString()));
    }
    const nsString&
    get_nsString() const
    {
        AssertSanity(TnsString);
        return (*(constptr_nsString()));
    }
    operator nsString&()
    {
        return get_nsString();
    }
    operator const nsString&() const
    {
        return get_nsString();
    }

    Shmem&
    get_Shmem()
    {
        AssertSanity(TShmem);
        return (*(ptr_Shmem()));
    }
    Shmem&
    get_Shmem() const
    {
        AssertSanity(TShmem);
        return const_cast<Shmem&>((*(constptr_Shmem())));
    }
    operator Shmem&()
    {
        return get_Shmem();
    }
    operator Shmem&() const
    {
        return get_Shmem();
    }

    IPCBlob&
    get_IPCBlob()
    {
        AssertSanity(TIPCBlob);
        return (*(ptr_IPCBlob()));
    }
    const IPCBlob&
    get_IPCBlob() const
    {
        AssertSanity(TIPCBlob);
        return (*(constptr_IPCBlob()));
    }
    operator IPCBlob&()
    {
        return get_IPCBlob();
    }
    operator const IPCBlob&() const
    {
        return get_IPCBlob();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPCDataTransferData>
{
    typedef mozilla::dom::IPCDataTransferData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct IPCDataTransferImage|
//
namespace mozilla {
namespace dom {
class IPCDataTransferImage final
{
private:
    typedef mozilla::gfx::SurfaceFormat SurfaceFormat;

public:
    MOZ_IMPLICIT IPCDataTransferImage() :
        format_(),
        width_(),
        height_(),
        stride_()
    {
    }

    MOZ_IMPLICIT IPCDataTransferImage(
            const uint32_t& _width,
            const uint32_t& _height,
            const uint32_t& _stride,
            const SurfaceFormat& _format) :
        format_(_format),
        width_(_width),
        height_(_height),
        stride_(_stride)
    {
    }

    uint32_t&
    width()
    {
        return width_;
    }
    const uint32_t&
    width() const
    {
        return width_;
    }

    uint32_t&
    height()
    {
        return height_;
    }
    const uint32_t&
    height() const
    {
        return height_;
    }

    uint32_t&
    stride()
    {
        return stride_;
    }
    const uint32_t&
    stride() const
    {
        return stride_;
    }

    SurfaceFormat&
    format()
    {
        return format_;
    }
    const SurfaceFormat&
    format() const
    {
        return format_;
    }

private:
    void
    StaticAssertions() const;
    SurfaceFormat format_;
    uint32_t width_;
    uint32_t height_;
    uint32_t stride_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPCDataTransferImage>
{
    typedef mozilla::dom::IPCDataTransferImage paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct IPCDataTransferItem|
//
namespace mozilla {
namespace dom {
class IPCDataTransferItem final
{
private:
    typedef mozilla::dom::IPCDataTransferImage IPCDataTransferImage;
    typedef mozilla::dom::IPCDataTransferData IPCDataTransferData;

public:
    MOZ_IMPLICIT IPCDataTransferItem() :
        flavor_(),
        imageDetails_(),
        data_()
    {
    }

    MOZ_IMPLICIT IPCDataTransferItem(
            const nsCString& _flavor,
            const IPCDataTransferImage& _imageDetails,
            const IPCDataTransferData& _data) :
        flavor_(_flavor),
        imageDetails_(_imageDetails),
        data_(_data)
    {
    }

    nsCString&
    flavor()
    {
        return flavor_;
    }
    const nsCString&
    flavor() const
    {
        return flavor_;
    }

    IPCDataTransferImage&
    imageDetails()
    {
        return imageDetails_;
    }
    const IPCDataTransferImage&
    imageDetails() const
    {
        return imageDetails_;
    }

    IPCDataTransferData&
    data()
    {
        return data_;
    }
    const IPCDataTransferData&
    data() const
    {
        return data_;
    }

private:
    nsCString flavor_;
    IPCDataTransferImage imageDetails_;
    IPCDataTransferData data_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPCDataTransferItem>
{
    typedef mozilla::dom::IPCDataTransferItem paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct IPCDataTransfer|
//
namespace mozilla {
namespace dom {
class IPCDataTransfer final
{
private:
    typedef mozilla::dom::IPCDataTransferItem IPCDataTransferItem;

public:
    MOZ_IMPLICIT IPCDataTransfer() :
        items_()
    {
    }

    MOZ_IMPLICIT IPCDataTransfer(const nsTArray<IPCDataTransferItem>& _items) :
        items_(_items)
    {
    }

    nsTArray<IPCDataTransferItem>&
    items()
    {
        return items_;
    }
    const nsTArray<IPCDataTransferItem>&
    items() const
    {
        return items_;
    }

private:
    CopyableTArray<IPCDataTransferItem> items_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPCDataTransfer>
{
    typedef mozilla::dom::IPCDataTransfer paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ScreenDetails|
//
namespace mozilla {
namespace dom {
class ScreenDetails final
{
private:

public:
    MOZ_IMPLICIT ScreenDetails() :
        rect_(),
        rectDisplayPix_(),
        availRect_(),
        availRectDisplayPix_(),
        contentsScaleFactor_(),
        defaultCSSScaleFactor_(),
        pixelDepth_(),
        colorDepth_(),
        dpi_()
    {
    }

    MOZ_IMPLICIT ScreenDetails(
            const LayoutDeviceIntRect& _rect,
            const DesktopIntRect& _rectDisplayPix,
            const LayoutDeviceIntRect& _availRect,
            const DesktopIntRect& _availRectDisplayPix,
            const int32_t& _pixelDepth,
            const int32_t& _colorDepth,
            const DesktopToLayoutDeviceScale& _contentsScaleFactor,
            const CSSToLayoutDeviceScale& _defaultCSSScaleFactor,
            const float& _dpi) :
        rect_(_rect),
        rectDisplayPix_(_rectDisplayPix),
        availRect_(_availRect),
        availRectDisplayPix_(_availRectDisplayPix),
        contentsScaleFactor_(_contentsScaleFactor),
        defaultCSSScaleFactor_(_defaultCSSScaleFactor),
        pixelDepth_(_pixelDepth),
        colorDepth_(_colorDepth),
        dpi_(_dpi)
    {
    }

    LayoutDeviceIntRect&
    rect()
    {
        return rect_;
    }
    const LayoutDeviceIntRect&
    rect() const
    {
        return rect_;
    }

    DesktopIntRect&
    rectDisplayPix()
    {
        return rectDisplayPix_;
    }
    const DesktopIntRect&
    rectDisplayPix() const
    {
        return rectDisplayPix_;
    }

    LayoutDeviceIntRect&
    availRect()
    {
        return availRect_;
    }
    const LayoutDeviceIntRect&
    availRect() const
    {
        return availRect_;
    }

    DesktopIntRect&
    availRectDisplayPix()
    {
        return availRectDisplayPix_;
    }
    const DesktopIntRect&
    availRectDisplayPix() const
    {
        return availRectDisplayPix_;
    }

    int32_t&
    pixelDepth()
    {
        return pixelDepth_;
    }
    const int32_t&
    pixelDepth() const
    {
        return pixelDepth_;
    }

    int32_t&
    colorDepth()
    {
        return colorDepth_;
    }
    const int32_t&
    colorDepth() const
    {
        return colorDepth_;
    }

    DesktopToLayoutDeviceScale&
    contentsScaleFactor()
    {
        return contentsScaleFactor_;
    }
    const DesktopToLayoutDeviceScale&
    contentsScaleFactor() const
    {
        return contentsScaleFactor_;
    }

    CSSToLayoutDeviceScale&
    defaultCSSScaleFactor()
    {
        return defaultCSSScaleFactor_;
    }
    const CSSToLayoutDeviceScale&
    defaultCSSScaleFactor() const
    {
        return defaultCSSScaleFactor_;
    }

    float&
    dpi()
    {
        return dpi_;
    }
    const float&
    dpi() const
    {
        return dpi_;
    }

private:
    void
    StaticAssertions() const;
    LayoutDeviceIntRect rect_;
    DesktopIntRect rectDisplayPix_;
    LayoutDeviceIntRect availRect_;
    DesktopIntRect availRectDisplayPix_;
    DesktopToLayoutDeviceScale contentsScaleFactor_;
    CSSToLayoutDeviceScale defaultCSSScaleFactor_;
    int32_t pixelDepth_;
    int32_t colorDepth_;
    float dpi_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ScreenDetails>
{
    typedef mozilla::dom::ScreenDetails paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct DimensionInfo|
//
namespace mozilla {
namespace dom {
class DimensionInfo final
{
private:
    typedef hal::ScreenOrientation ScreenOrientation;
    typedef mozilla::LayoutDeviceIntPoint LayoutDeviceIntPoint;

public:
    MOZ_IMPLICIT DimensionInfo() :
        rect_(),
        size_(),
        orientation_(),
        clientOffset_(),
        chromeOffset_()
    {
    }

    MOZ_IMPLICIT DimensionInfo(
            const CSSRect& _rect,
            const CSSSize& _size,
            const ScreenOrientation& _orientation,
            const LayoutDeviceIntPoint& _clientOffset,
            const LayoutDeviceIntPoint& _chromeOffset) :
        rect_(_rect),
        size_(_size),
        orientation_(_orientation),
        clientOffset_(_clientOffset),
        chromeOffset_(_chromeOffset)
    {
    }

    CSSRect&
    rect()
    {
        return rect_;
    }
    const CSSRect&
    rect() const
    {
        return rect_;
    }

    CSSSize&
    size()
    {
        return size_;
    }
    const CSSSize&
    size() const
    {
        return size_;
    }

    ScreenOrientation&
    orientation()
    {
        return orientation_;
    }
    const ScreenOrientation&
    orientation() const
    {
        return orientation_;
    }

    LayoutDeviceIntPoint&
    clientOffset()
    {
        return clientOffset_;
    }
    const LayoutDeviceIntPoint&
    clientOffset() const
    {
        return clientOffset_;
    }

    LayoutDeviceIntPoint&
    chromeOffset()
    {
        return chromeOffset_;
    }
    const LayoutDeviceIntPoint&
    chromeOffset() const
    {
        return chromeOffset_;
    }

private:
    CSSRect rect_;
    CSSSize size_;
    ScreenOrientation orientation_;
    LayoutDeviceIntPoint clientOffset_;
    LayoutDeviceIntPoint chromeOffset_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::DimensionInfo>
{
    typedef mozilla::dom::DimensionInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct FrameScriptInfo|
//
namespace mozilla {
namespace dom {
class FrameScriptInfo final
{
private:

public:
    MOZ_IMPLICIT FrameScriptInfo() :
        url_(),
        runInGlobalScope_()
    {
    }

    MOZ_IMPLICIT FrameScriptInfo(
            const nsString& _url,
            const bool& _runInGlobalScope) :
        url_(_url),
        runInGlobalScope_(_runInGlobalScope)
    {
    }

    nsString&
    url()
    {
        return url_;
    }
    const nsString&
    url() const
    {
        return url_;
    }

    bool&
    runInGlobalScope()
    {
        return runInGlobalScope_;
    }
    const bool&
    runInGlobalScope() const
    {
        return runInGlobalScope_;
    }

private:
    nsString url_;
    bool runInGlobalScope_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::FrameScriptInfo>
{
    typedef mozilla::dom::FrameScriptInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct FeaturePolicyInfo|
//
namespace mozilla {
namespace dom {
class FeaturePolicyInfo final
{
private:

public:
    MOZ_IMPLICIT FeaturePolicyInfo() :
        inheritedDeniedFeatureNames_(),
        attributeEnabledFeatureNames_(),
        declaredString_(),
        defaultOrigin_(),
        selfOrigin_(),
        srcOrigin_()
    {
    }

    MOZ_IMPLICIT FeaturePolicyInfo(
            const nsTArray<nsString>& _inheritedDeniedFeatureNames,
            const nsTArray<nsString>& _attributeEnabledFeatureNames,
            const nsString& _declaredString,
            nsIPrincipal* _defaultOrigin,
            nsIPrincipal* _selfOrigin,
            nsIPrincipal* _srcOrigin) :
        inheritedDeniedFeatureNames_(_inheritedDeniedFeatureNames),
        attributeEnabledFeatureNames_(_attributeEnabledFeatureNames),
        declaredString_(_declaredString),
        defaultOrigin_(_defaultOrigin),
        selfOrigin_(_selfOrigin),
        srcOrigin_(_srcOrigin)
    {
    }

    nsTArray<nsString>&
    inheritedDeniedFeatureNames()
    {
        return inheritedDeniedFeatureNames_;
    }
    const nsTArray<nsString>&
    inheritedDeniedFeatureNames() const
    {
        return inheritedDeniedFeatureNames_;
    }

    nsTArray<nsString>&
    attributeEnabledFeatureNames()
    {
        return attributeEnabledFeatureNames_;
    }
    const nsTArray<nsString>&
    attributeEnabledFeatureNames() const
    {
        return attributeEnabledFeatureNames_;
    }

    nsString&
    declaredString()
    {
        return declaredString_;
    }
    const nsString&
    declaredString() const
    {
        return declaredString_;
    }

    RefPtr<nsIPrincipal>&
    defaultOrigin()
    {
        return defaultOrigin_;
    }
    nsIPrincipal*
    defaultOrigin() const
    {
        return defaultOrigin_;
    }

    RefPtr<nsIPrincipal>&
    selfOrigin()
    {
        return selfOrigin_;
    }
    nsIPrincipal*
    selfOrigin() const
    {
        return selfOrigin_;
    }

    RefPtr<nsIPrincipal>&
    srcOrigin()
    {
        return srcOrigin_;
    }
    nsIPrincipal*
    srcOrigin() const
    {
        return srcOrigin_;
    }

private:
    CopyableTArray<nsString> inheritedDeniedFeatureNames_;
    CopyableTArray<nsString> attributeEnabledFeatureNames_;
    nsString declaredString_;
    RefPtr<nsIPrincipal> defaultOrigin_;
    RefPtr<nsIPrincipal> selfOrigin_;
    RefPtr<nsIPrincipal> srcOrigin_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::FeaturePolicyInfo>
{
    typedef mozilla::dom::FeaturePolicyInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CreatedWindowInfo|
//
namespace mozilla {
namespace dom {
class CreatedWindowInfo final
{
private:
    typedef mozilla::dom::FrameScriptInfo FrameScriptInfo;
    typedef mozilla::dom::DimensionInfo DimensionInfo;

public:
    MOZ_IMPLICIT CreatedWindowInfo() :
        rv_(),
        windowOpened_(),
        frameScripts_(),
        dimensions_(),
        hasSiblings_(),
        maxTouchPoints_()
    {
    }

    MOZ_IMPLICIT CreatedWindowInfo(
            const nsresult& _rv,
            const bool& _windowOpened,
            const nsTArray<FrameScriptInfo>& _frameScripts,
            const uint32_t& _maxTouchPoints,
            const DimensionInfo& _dimensions,
            const bool& _hasSiblings) :
        rv_(_rv),
        windowOpened_(_windowOpened),
        frameScripts_(_frameScripts),
        dimensions_(_dimensions),
        hasSiblings_(_hasSiblings),
        maxTouchPoints_(_maxTouchPoints)
    {
    }

    nsresult&
    rv()
    {
        return rv_;
    }
    const nsresult&
    rv() const
    {
        return rv_;
    }

    bool&
    windowOpened()
    {
        return windowOpened_;
    }
    const bool&
    windowOpened() const
    {
        return windowOpened_;
    }

    nsTArray<FrameScriptInfo>&
    frameScripts()
    {
        return frameScripts_;
    }
    const nsTArray<FrameScriptInfo>&
    frameScripts() const
    {
        return frameScripts_;
    }

    uint32_t&
    maxTouchPoints()
    {
        return maxTouchPoints_;
    }
    const uint32_t&
    maxTouchPoints() const
    {
        return maxTouchPoints_;
    }

    DimensionInfo&
    dimensions()
    {
        return dimensions_;
    }
    const DimensionInfo&
    dimensions() const
    {
        return dimensions_;
    }

    bool&
    hasSiblings()
    {
        return hasSiblings_;
    }
    const bool&
    hasSiblings() const
    {
        return hasSiblings_;
    }

private:
    nsresult rv_;
    bool windowOpened_;
    CopyableTArray<FrameScriptInfo> frameScripts_;
    DimensionInfo dimensions_;
    bool hasSiblings_;
    uint32_t maxTouchPoints_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::CreatedWindowInfo>
{
    typedef mozilla::dom::CreatedWindowInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct MediaMemoryInfo|
//
namespace mozilla {
namespace dom {
class MediaMemoryInfo final
{
private:

public:
    MOZ_IMPLICIT MediaMemoryInfo() :
        audioSize_(),
        videoSize_(),
        resourcesSize_()
    {
    }

    MOZ_IMPLICIT MediaMemoryInfo(
            const uint64_t& _audioSize,
            const uint64_t& _videoSize,
            const uint64_t& _resourcesSize) :
        audioSize_(_audioSize),
        videoSize_(_videoSize),
        resourcesSize_(_resourcesSize)
    {
    }

    uint64_t&
    audioSize()
    {
        return audioSize_;
    }
    const uint64_t&
    audioSize() const
    {
        return audioSize_;
    }

    uint64_t&
    videoSize()
    {
        return videoSize_;
    }
    const uint64_t&
    videoSize() const
    {
        return videoSize_;
    }

    uint64_t&
    resourcesSize()
    {
        return resourcesSize_;
    }
    const uint64_t&
    resourcesSize() const
    {
        return resourcesSize_;
    }

private:
    void
    StaticAssertions() const;
    uint64_t audioSize_;
    uint64_t videoSize_;
    uint64_t resourcesSize_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::MediaMemoryInfo>
{
    typedef mozilla::dom::MediaMemoryInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct PerformanceMemoryInfo|
//
namespace mozilla {
namespace dom {
class PerformanceMemoryInfo final
{
private:
    typedef mozilla::dom::MediaMemoryInfo MediaMemoryInfo;

public:
    MOZ_IMPLICIT PerformanceMemoryInfo() :
        media_(),
        domDom_(),
        domStyle_(),
        domOther_(),
        GCHeapUsage_()
    {
    }

    MOZ_IMPLICIT PerformanceMemoryInfo(
            const MediaMemoryInfo& _media,
            const uint64_t& _domDom,
            const uint64_t& _domStyle,
            const uint64_t& _domOther,
            const uint64_t& _GCHeapUsage) :
        media_(_media),
        domDom_(_domDom),
        domStyle_(_domStyle),
        domOther_(_domOther),
        GCHeapUsage_(_GCHeapUsage)
    {
    }

    MediaMemoryInfo&
    media()
    {
        return media_;
    }
    const MediaMemoryInfo&
    media() const
    {
        return media_;
    }

    uint64_t&
    domDom()
    {
        return domDom_;
    }
    const uint64_t&
    domDom() const
    {
        return domDom_;
    }

    uint64_t&
    domStyle()
    {
        return domStyle_;
    }
    const uint64_t&
    domStyle() const
    {
        return domStyle_;
    }

    uint64_t&
    domOther()
    {
        return domOther_;
    }
    const uint64_t&
    domOther() const
    {
        return domOther_;
    }

    uint64_t&
    GCHeapUsage()
    {
        return GCHeapUsage_;
    }
    const uint64_t&
    GCHeapUsage() const
    {
        return GCHeapUsage_;
    }

private:
    void
    StaticAssertions() const;
    MediaMemoryInfo media_;
    uint64_t domDom_;
    uint64_t domStyle_;
    uint64_t domOther_;
    uint64_t GCHeapUsage_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::PerformanceMemoryInfo>
{
    typedef mozilla::dom::PerformanceMemoryInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CategoryDispatch|
//
namespace mozilla {
namespace dom {
class CategoryDispatch final
{
private:

public:
    MOZ_IMPLICIT CategoryDispatch() :
        category_(),
        count_()
    {
    }

    MOZ_IMPLICIT CategoryDispatch(
            const uint16_t& _category,
            const uint16_t& _count) :
        category_(_category),
        count_(_count)
    {
    }

    uint16_t&
    category()
    {
        return category_;
    }
    const uint16_t&
    category() const
    {
        return category_;
    }

    uint16_t&
    count()
    {
        return count_;
    }
    const uint16_t&
    count() const
    {
        return count_;
    }

private:
    void
    StaticAssertions() const;
    uint16_t category_;
    uint16_t count_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::CategoryDispatch>
{
    typedef mozilla::dom::CategoryDispatch paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct PerformanceInfo|
//
namespace mozilla {
namespace dom {
class PerformanceInfo final
{
private:
    typedef mozilla::dom::PerformanceMemoryInfo PerformanceMemoryInfo;
    typedef mozilla::dom::CategoryDispatch CategoryDispatch;

public:
    MOZ_IMPLICIT PerformanceInfo() :
        host_(),
        isWorker_(),
        isTopLevel_(),
        memory_(),
        items_(),
        windowId_(),
        duration_(),
        counterId_(),
        pid_()
    {
    }

    MOZ_IMPLICIT PerformanceInfo(
            const nsCString& _host,
            const uint32_t& _pid,
            const uint64_t& _windowId,
            const uint64_t& _duration,
            const uint64_t& _counterId,
            const bool& _isWorker,
            const bool& _isTopLevel,
            const PerformanceMemoryInfo& _memory,
            const nsTArray<CategoryDispatch>& _items) :
        host_(_host),
        isWorker_(_isWorker),
        isTopLevel_(_isTopLevel),
        memory_(_memory),
        items_(_items),
        windowId_(_windowId),
        duration_(_duration),
        counterId_(_counterId),
        pid_(_pid)
    {
    }

    nsCString&
    host()
    {
        return host_;
    }
    const nsCString&
    host() const
    {
        return host_;
    }

    uint32_t&
    pid()
    {
        return pid_;
    }
    const uint32_t&
    pid() const
    {
        return pid_;
    }

    uint64_t&
    windowId()
    {
        return windowId_;
    }
    const uint64_t&
    windowId() const
    {
        return windowId_;
    }

    uint64_t&
    duration()
    {
        return duration_;
    }
    const uint64_t&
    duration() const
    {
        return duration_;
    }

    uint64_t&
    counterId()
    {
        return counterId_;
    }
    const uint64_t&
    counterId() const
    {
        return counterId_;
    }

    bool&
    isWorker()
    {
        return isWorker_;
    }
    const bool&
    isWorker() const
    {
        return isWorker_;
    }

    bool&
    isTopLevel()
    {
        return isTopLevel_;
    }
    const bool&
    isTopLevel() const
    {
        return isTopLevel_;
    }

    PerformanceMemoryInfo&
    memory()
    {
        return memory_;
    }
    const PerformanceMemoryInfo&
    memory() const
    {
        return memory_;
    }

    nsTArray<CategoryDispatch>&
    items()
    {
        return items_;
    }
    const nsTArray<CategoryDispatch>&
    items() const
    {
        return items_;
    }

private:
    void
    StaticAssertions() const;
    nsCString host_;
    bool isWorker_;
    bool isTopLevel_;
    PerformanceMemoryInfo memory_;
    CopyableTArray<CategoryDispatch> items_;
    uint64_t windowId_;
    uint64_t duration_;
    uint64_t counterId_;
    uint32_t pid_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::PerformanceInfo>
{
    typedef mozilla::dom::PerformanceInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct DocShellLoadStateInit|
//
namespace mozilla {
namespace dom {
class DocShellLoadStateInit final
{
private:
    typedef mozilla::dom::MaybeDiscardedBrowsingContext MaybeDiscardedBrowsingContext;
    typedef mozilla::dom::LoadingSessionHistoryInfo LoadingSessionHistoryInfo;

public:
    MOZ_IMPLICIT DocShellLoadStateInit() :
        URI_(),
        OriginalURI_(),
        ResultPrincipalURI_(),
        ResultPrincipalURIIsSome_(),
        TriggeringPrincipal_(),
        ReferrerInfo_(),
        KeepResultPrincipalURIIfSet_(),
        LoadReplace_(),
        InheritPrincipal_(),
        PrincipalIsExplicit_(),
        PrincipalToInherit_(),
        PartitionedPrincipalToInherit_(),
        ForceAllowDataURI_(),
        OriginalFrameSrc_(),
        IsFormSubmission_(),
        Target_(),
        BaseURI_(),
        FirstParty_(),
        HasValidUserGestureActivation_(),
        AllowFocusMove_(),
        TypeHint_(),
        FileName_(),
        IsFromProcessingFrameAttributes_(),
        Csp_(),
        SourceBrowsingContext_(),
        TargetBrowsingContext_(),
        OriginalURIString_(),
        CancelContentJSEpoch_(),
        PostDataStream_(),
        HeadersStream_(),
        SrcdocData_(),
        ChannelInitialized_(),
        TryToReplaceWithSessionHistoryLoad_(),
        loadingSessionHistoryInfo_(),
        LoadIdentifier_(),
        LoadType_(),
        LoadFlags_(),
        InternalLoadFlags_(),
        TriggeringSandboxFlags_()
    {
    }

    MOZ_IMPLICIT DocShellLoadStateInit(
            nsIURI* _URI,
            nsIURI* _OriginalURI,
            nsIURI* _ResultPrincipalURI,
            const bool& _ResultPrincipalURIIsSome,
            nsIPrincipal* _TriggeringPrincipal,
            nsIReferrerInfo* _ReferrerInfo,
            const bool& _KeepResultPrincipalURIIfSet,
            const bool& _LoadReplace,
            const bool& _InheritPrincipal,
            const bool& _PrincipalIsExplicit,
            nsIPrincipal* _PrincipalToInherit,
            nsIPrincipal* _PartitionedPrincipalToInherit,
            const bool& _ForceAllowDataURI,
            const bool& _OriginalFrameSrc,
            const bool& _IsFormSubmission,
            const uint32_t& _LoadType,
            const nsString& _Target,
            nsIURI* _BaseURI,
            const uint32_t& _LoadFlags,
            const uint32_t& _InternalLoadFlags,
            const bool& _FirstParty,
            const bool& _HasValidUserGestureActivation,
            const bool& _AllowFocusMove,
            const nsCString& _TypeHint,
            const nsString& _FileName,
            const bool& _IsFromProcessingFrameAttributes,
            nsIContentSecurityPolicy* _Csp,
            const MaybeDiscardedBrowsingContext& _SourceBrowsingContext,
            const MaybeDiscardedBrowsingContext& _TargetBrowsingContext,
            const uint32_t& _TriggeringSandboxFlags,
            const mozilla::Maybe<nsCString>& _OriginalURIString,
            const mozilla::Maybe<int32_t>& _CancelContentJSEpoch,
            nsIInputStream* _PostDataStream,
            nsIInputStream* _HeadersStream,
            const nsString& _SrcdocData,
            const uint64_t& _LoadIdentifier,
            const bool& _ChannelInitialized,
            const bool& _TryToReplaceWithSessionHistoryLoad,
            const mozilla::Maybe<LoadingSessionHistoryInfo>& _loadingSessionHistoryInfo) :
        URI_(_URI),
        OriginalURI_(_OriginalURI),
        ResultPrincipalURI_(_ResultPrincipalURI),
        ResultPrincipalURIIsSome_(_ResultPrincipalURIIsSome),
        TriggeringPrincipal_(_TriggeringPrincipal),
        ReferrerInfo_(_ReferrerInfo),
        KeepResultPrincipalURIIfSet_(_KeepResultPrincipalURIIfSet),
        LoadReplace_(_LoadReplace),
        InheritPrincipal_(_InheritPrincipal),
        PrincipalIsExplicit_(_PrincipalIsExplicit),
        PrincipalToInherit_(_PrincipalToInherit),
        PartitionedPrincipalToInherit_(_PartitionedPrincipalToInherit),
        ForceAllowDataURI_(_ForceAllowDataURI),
        OriginalFrameSrc_(_OriginalFrameSrc),
        IsFormSubmission_(_IsFormSubmission),
        Target_(_Target),
        BaseURI_(_BaseURI),
        FirstParty_(_FirstParty),
        HasValidUserGestureActivation_(_HasValidUserGestureActivation),
        AllowFocusMove_(_AllowFocusMove),
        TypeHint_(_TypeHint),
        FileName_(_FileName),
        IsFromProcessingFrameAttributes_(_IsFromProcessingFrameAttributes),
        Csp_(_Csp),
        SourceBrowsingContext_(_SourceBrowsingContext),
        TargetBrowsingContext_(_TargetBrowsingContext),
        OriginalURIString_(_OriginalURIString),
        CancelContentJSEpoch_(_CancelContentJSEpoch),
        PostDataStream_(_PostDataStream),
        HeadersStream_(_HeadersStream),
        SrcdocData_(_SrcdocData),
        ChannelInitialized_(_ChannelInitialized),
        TryToReplaceWithSessionHistoryLoad_(_TryToReplaceWithSessionHistoryLoad),
        loadingSessionHistoryInfo_(_loadingSessionHistoryInfo),
        LoadIdentifier_(_LoadIdentifier),
        LoadType_(_LoadType),
        LoadFlags_(_LoadFlags),
        InternalLoadFlags_(_InternalLoadFlags),
        TriggeringSandboxFlags_(_TriggeringSandboxFlags)
    {
    }

    RefPtr<nsIURI>&
    URI()
    {
        return URI_;
    }
    nsIURI*
    URI() const
    {
        return URI_;
    }

    RefPtr<nsIURI>&
    OriginalURI()
    {
        return OriginalURI_;
    }
    nsIURI*
    OriginalURI() const
    {
        return OriginalURI_;
    }

    RefPtr<nsIURI>&
    ResultPrincipalURI()
    {
        return ResultPrincipalURI_;
    }
    nsIURI*
    ResultPrincipalURI() const
    {
        return ResultPrincipalURI_;
    }

    bool&
    ResultPrincipalURIIsSome()
    {
        return ResultPrincipalURIIsSome_;
    }
    const bool&
    ResultPrincipalURIIsSome() const
    {
        return ResultPrincipalURIIsSome_;
    }

    RefPtr<nsIPrincipal>&
    TriggeringPrincipal()
    {
        return TriggeringPrincipal_;
    }
    nsIPrincipal*
    TriggeringPrincipal() const
    {
        return TriggeringPrincipal_;
    }

    RefPtr<nsIReferrerInfo>&
    ReferrerInfo()
    {
        return ReferrerInfo_;
    }
    nsIReferrerInfo*
    ReferrerInfo() const
    {
        return ReferrerInfo_;
    }

    bool&
    KeepResultPrincipalURIIfSet()
    {
        return KeepResultPrincipalURIIfSet_;
    }
    const bool&
    KeepResultPrincipalURIIfSet() const
    {
        return KeepResultPrincipalURIIfSet_;
    }

    bool&
    LoadReplace()
    {
        return LoadReplace_;
    }
    const bool&
    LoadReplace() const
    {
        return LoadReplace_;
    }

    bool&
    InheritPrincipal()
    {
        return InheritPrincipal_;
    }
    const bool&
    InheritPrincipal() const
    {
        return InheritPrincipal_;
    }

    bool&
    PrincipalIsExplicit()
    {
        return PrincipalIsExplicit_;
    }
    const bool&
    PrincipalIsExplicit() const
    {
        return PrincipalIsExplicit_;
    }

    RefPtr<nsIPrincipal>&
    PrincipalToInherit()
    {
        return PrincipalToInherit_;
    }
    nsIPrincipal*
    PrincipalToInherit() const
    {
        return PrincipalToInherit_;
    }

    RefPtr<nsIPrincipal>&
    PartitionedPrincipalToInherit()
    {
        return PartitionedPrincipalToInherit_;
    }
    nsIPrincipal*
    PartitionedPrincipalToInherit() const
    {
        return PartitionedPrincipalToInherit_;
    }

    bool&
    ForceAllowDataURI()
    {
        return ForceAllowDataURI_;
    }
    const bool&
    ForceAllowDataURI() const
    {
        return ForceAllowDataURI_;
    }

    bool&
    OriginalFrameSrc()
    {
        return OriginalFrameSrc_;
    }
    const bool&
    OriginalFrameSrc() const
    {
        return OriginalFrameSrc_;
    }

    bool&
    IsFormSubmission()
    {
        return IsFormSubmission_;
    }
    const bool&
    IsFormSubmission() const
    {
        return IsFormSubmission_;
    }

    uint32_t&
    LoadType()
    {
        return LoadType_;
    }
    const uint32_t&
    LoadType() const
    {
        return LoadType_;
    }

    nsString&
    Target()
    {
        return Target_;
    }
    const nsString&
    Target() const
    {
        return Target_;
    }

    RefPtr<nsIURI>&
    BaseURI()
    {
        return BaseURI_;
    }
    nsIURI*
    BaseURI() const
    {
        return BaseURI_;
    }

    uint32_t&
    LoadFlags()
    {
        return LoadFlags_;
    }
    const uint32_t&
    LoadFlags() const
    {
        return LoadFlags_;
    }

    uint32_t&
    InternalLoadFlags()
    {
        return InternalLoadFlags_;
    }
    const uint32_t&
    InternalLoadFlags() const
    {
        return InternalLoadFlags_;
    }

    bool&
    FirstParty()
    {
        return FirstParty_;
    }
    const bool&
    FirstParty() const
    {
        return FirstParty_;
    }

    bool&
    HasValidUserGestureActivation()
    {
        return HasValidUserGestureActivation_;
    }
    const bool&
    HasValidUserGestureActivation() const
    {
        return HasValidUserGestureActivation_;
    }

    bool&
    AllowFocusMove()
    {
        return AllowFocusMove_;
    }
    const bool&
    AllowFocusMove() const
    {
        return AllowFocusMove_;
    }

    nsCString&
    TypeHint()
    {
        return TypeHint_;
    }
    const nsCString&
    TypeHint() const
    {
        return TypeHint_;
    }

    nsString&
    FileName()
    {
        return FileName_;
    }
    const nsString&
    FileName() const
    {
        return FileName_;
    }

    bool&
    IsFromProcessingFrameAttributes()
    {
        return IsFromProcessingFrameAttributes_;
    }
    const bool&
    IsFromProcessingFrameAttributes() const
    {
        return IsFromProcessingFrameAttributes_;
    }

    RefPtr<nsIContentSecurityPolicy>&
    Csp()
    {
        return Csp_;
    }
    nsIContentSecurityPolicy*
    Csp() const
    {
        return Csp_;
    }

    MaybeDiscardedBrowsingContext&
    SourceBrowsingContext()
    {
        return SourceBrowsingContext_;
    }
    const MaybeDiscardedBrowsingContext&
    SourceBrowsingContext() const
    {
        return SourceBrowsingContext_;
    }

    MaybeDiscardedBrowsingContext&
    TargetBrowsingContext()
    {
        return TargetBrowsingContext_;
    }
    const MaybeDiscardedBrowsingContext&
    TargetBrowsingContext() const
    {
        return TargetBrowsingContext_;
    }

    uint32_t&
    TriggeringSandboxFlags()
    {
        return TriggeringSandboxFlags_;
    }
    const uint32_t&
    TriggeringSandboxFlags() const
    {
        return TriggeringSandboxFlags_;
    }

    mozilla::Maybe<nsCString>&
    OriginalURIString()
    {
        return OriginalURIString_;
    }
    const mozilla::Maybe<nsCString>&
    OriginalURIString() const
    {
        return OriginalURIString_;
    }

    mozilla::Maybe<int32_t>&
    CancelContentJSEpoch()
    {
        return CancelContentJSEpoch_;
    }
    const mozilla::Maybe<int32_t>&
    CancelContentJSEpoch() const
    {
        return CancelContentJSEpoch_;
    }

    RefPtr<nsIInputStream>&
    PostDataStream()
    {
        return PostDataStream_;
    }
    nsIInputStream*
    PostDataStream() const
    {
        return PostDataStream_;
    }

    RefPtr<nsIInputStream>&
    HeadersStream()
    {
        return HeadersStream_;
    }
    nsIInputStream*
    HeadersStream() const
    {
        return HeadersStream_;
    }

    nsString&
    SrcdocData()
    {
        return SrcdocData_;
    }
    const nsString&
    SrcdocData() const
    {
        return SrcdocData_;
    }

    uint64_t&
    LoadIdentifier()
    {
        return LoadIdentifier_;
    }
    const uint64_t&
    LoadIdentifier() const
    {
        return LoadIdentifier_;
    }

    bool&
    ChannelInitialized()
    {
        return ChannelInitialized_;
    }
    const bool&
    ChannelInitialized() const
    {
        return ChannelInitialized_;
    }

    bool&
    TryToReplaceWithSessionHistoryLoad()
    {
        return TryToReplaceWithSessionHistoryLoad_;
    }
    const bool&
    TryToReplaceWithSessionHistoryLoad() const
    {
        return TryToReplaceWithSessionHistoryLoad_;
    }

    mozilla::Maybe<LoadingSessionHistoryInfo>&
    loadingSessionHistoryInfo()
    {
        return loadingSessionHistoryInfo_;
    }
    const mozilla::Maybe<LoadingSessionHistoryInfo>&
    loadingSessionHistoryInfo() const
    {
        return loadingSessionHistoryInfo_;
    }

private:
    void
    StaticAssertions() const;
    RefPtr<nsIURI> URI_;
    RefPtr<nsIURI> OriginalURI_;
    RefPtr<nsIURI> ResultPrincipalURI_;
    bool ResultPrincipalURIIsSome_;
    RefPtr<nsIPrincipal> TriggeringPrincipal_;
    RefPtr<nsIReferrerInfo> ReferrerInfo_;
    bool KeepResultPrincipalURIIfSet_;
    bool LoadReplace_;
    bool InheritPrincipal_;
    bool PrincipalIsExplicit_;
    RefPtr<nsIPrincipal> PrincipalToInherit_;
    RefPtr<nsIPrincipal> PartitionedPrincipalToInherit_;
    bool ForceAllowDataURI_;
    bool OriginalFrameSrc_;
    bool IsFormSubmission_;
    nsString Target_;
    RefPtr<nsIURI> BaseURI_;
    bool FirstParty_;
    bool HasValidUserGestureActivation_;
    bool AllowFocusMove_;
    nsCString TypeHint_;
    nsString FileName_;
    bool IsFromProcessingFrameAttributes_;
    RefPtr<nsIContentSecurityPolicy> Csp_;
    MaybeDiscardedBrowsingContext SourceBrowsingContext_;
    MaybeDiscardedBrowsingContext TargetBrowsingContext_;
    mozilla::Maybe<nsCString> OriginalURIString_;
    mozilla::Maybe<int32_t> CancelContentJSEpoch_;
    RefPtr<nsIInputStream> PostDataStream_;
    RefPtr<nsIInputStream> HeadersStream_;
    nsString SrcdocData_;
    bool ChannelInitialized_;
    bool TryToReplaceWithSessionHistoryLoad_;
    mozilla::Maybe<LoadingSessionHistoryInfo> loadingSessionHistoryInfo_;
    uint64_t LoadIdentifier_;
    uint32_t LoadType_;
    uint32_t LoadFlags_;
    uint32_t InternalLoadFlags_;
    uint32_t TriggeringSandboxFlags_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::DocShellLoadStateInit>
{
    typedef mozilla::dom::DocShellLoadStateInit paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct TimedChannelInfo|
//
namespace mozilla {
namespace dom {
class TimedChannelInfo final
{
private:
    typedef mozilla::TimeStamp TimeStamp;

public:
    MOZ_IMPLICIT TimedChannelInfo() :
        timingEnabled_(),
        asyncOpen_(),
        channelCreation_(),
        redirectStart_(),
        redirectEnd_(),
        initiatorType_(),
        allRedirectsSameOrigin_(),
        allRedirectsPassTimingAllowCheck_(),
        timingAllowCheckForPrincipal_(),
        launchServiceWorkerStart_(),
        launchServiceWorkerEnd_(),
        dispatchFetchEventStart_(),
        dispatchFetchEventEnd_(),
        handleFetchEventStart_(),
        handleFetchEventEnd_(),
        responseStart_(),
        responseEnd_(),
        redirectCount_(),
        internalRedirectCount_()
    {
    }

    MOZ_IMPLICIT TimedChannelInfo(
            const bool& _timingEnabled,
            const int8_t& _redirectCount,
            const int8_t& _internalRedirectCount,
            const TimeStamp& _asyncOpen,
            const TimeStamp& _channelCreation,
            const TimeStamp& _redirectStart,
            const TimeStamp& _redirectEnd,
            const nsString& _initiatorType,
            const bool& _allRedirectsSameOrigin,
            const bool& _allRedirectsPassTimingAllowCheck,
            const mozilla::Maybe<bool>& _timingAllowCheckForPrincipal,
            const TimeStamp& _launchServiceWorkerStart,
            const TimeStamp& _launchServiceWorkerEnd,
            const TimeStamp& _dispatchFetchEventStart,
            const TimeStamp& _dispatchFetchEventEnd,
            const TimeStamp& _handleFetchEventStart,
            const TimeStamp& _handleFetchEventEnd,
            const TimeStamp& _responseStart,
            const TimeStamp& _responseEnd) :
        timingEnabled_(_timingEnabled),
        asyncOpen_(_asyncOpen),
        channelCreation_(_channelCreation),
        redirectStart_(_redirectStart),
        redirectEnd_(_redirectEnd),
        initiatorType_(_initiatorType),
        allRedirectsSameOrigin_(_allRedirectsSameOrigin),
        allRedirectsPassTimingAllowCheck_(_allRedirectsPassTimingAllowCheck),
        timingAllowCheckForPrincipal_(_timingAllowCheckForPrincipal),
        launchServiceWorkerStart_(_launchServiceWorkerStart),
        launchServiceWorkerEnd_(_launchServiceWorkerEnd),
        dispatchFetchEventStart_(_dispatchFetchEventStart),
        dispatchFetchEventEnd_(_dispatchFetchEventEnd),
        handleFetchEventStart_(_handleFetchEventStart),
        handleFetchEventEnd_(_handleFetchEventEnd),
        responseStart_(_responseStart),
        responseEnd_(_responseEnd),
        redirectCount_(_redirectCount),
        internalRedirectCount_(_internalRedirectCount)
    {
    }

    bool&
    timingEnabled()
    {
        return timingEnabled_;
    }
    const bool&
    timingEnabled() const
    {
        return timingEnabled_;
    }

    int8_t&
    redirectCount()
    {
        return redirectCount_;
    }
    const int8_t&
    redirectCount() const
    {
        return redirectCount_;
    }

    int8_t&
    internalRedirectCount()
    {
        return internalRedirectCount_;
    }
    const int8_t&
    internalRedirectCount() const
    {
        return internalRedirectCount_;
    }

    TimeStamp&
    asyncOpen()
    {
        return asyncOpen_;
    }
    const TimeStamp&
    asyncOpen() const
    {
        return asyncOpen_;
    }

    TimeStamp&
    channelCreation()
    {
        return channelCreation_;
    }
    const TimeStamp&
    channelCreation() const
    {
        return channelCreation_;
    }

    TimeStamp&
    redirectStart()
    {
        return redirectStart_;
    }
    const TimeStamp&
    redirectStart() const
    {
        return redirectStart_;
    }

    TimeStamp&
    redirectEnd()
    {
        return redirectEnd_;
    }
    const TimeStamp&
    redirectEnd() const
    {
        return redirectEnd_;
    }

    nsString&
    initiatorType()
    {
        return initiatorType_;
    }
    const nsString&
    initiatorType() const
    {
        return initiatorType_;
    }

    bool&
    allRedirectsSameOrigin()
    {
        return allRedirectsSameOrigin_;
    }
    const bool&
    allRedirectsSameOrigin() const
    {
        return allRedirectsSameOrigin_;
    }

    bool&
    allRedirectsPassTimingAllowCheck()
    {
        return allRedirectsPassTimingAllowCheck_;
    }
    const bool&
    allRedirectsPassTimingAllowCheck() const
    {
        return allRedirectsPassTimingAllowCheck_;
    }

    mozilla::Maybe<bool>&
    timingAllowCheckForPrincipal()
    {
        return timingAllowCheckForPrincipal_;
    }
    const mozilla::Maybe<bool>&
    timingAllowCheckForPrincipal() const
    {
        return timingAllowCheckForPrincipal_;
    }

    TimeStamp&
    launchServiceWorkerStart()
    {
        return launchServiceWorkerStart_;
    }
    const TimeStamp&
    launchServiceWorkerStart() const
    {
        return launchServiceWorkerStart_;
    }

    TimeStamp&
    launchServiceWorkerEnd()
    {
        return launchServiceWorkerEnd_;
    }
    const TimeStamp&
    launchServiceWorkerEnd() const
    {
        return launchServiceWorkerEnd_;
    }

    TimeStamp&
    dispatchFetchEventStart()
    {
        return dispatchFetchEventStart_;
    }
    const TimeStamp&
    dispatchFetchEventStart() const
    {
        return dispatchFetchEventStart_;
    }

    TimeStamp&
    dispatchFetchEventEnd()
    {
        return dispatchFetchEventEnd_;
    }
    const TimeStamp&
    dispatchFetchEventEnd() const
    {
        return dispatchFetchEventEnd_;
    }

    TimeStamp&
    handleFetchEventStart()
    {
        return handleFetchEventStart_;
    }
    const TimeStamp&
    handleFetchEventStart() const
    {
        return handleFetchEventStart_;
    }

    TimeStamp&
    handleFetchEventEnd()
    {
        return handleFetchEventEnd_;
    }
    const TimeStamp&
    handleFetchEventEnd() const
    {
        return handleFetchEventEnd_;
    }

    TimeStamp&
    responseStart()
    {
        return responseStart_;
    }
    const TimeStamp&
    responseStart() const
    {
        return responseStart_;
    }

    TimeStamp&
    responseEnd()
    {
        return responseEnd_;
    }
    const TimeStamp&
    responseEnd() const
    {
        return responseEnd_;
    }

private:
    void
    StaticAssertions() const;
    bool timingEnabled_;
    TimeStamp asyncOpen_;
    TimeStamp channelCreation_;
    TimeStamp redirectStart_;
    TimeStamp redirectEnd_;
    nsString initiatorType_;
    bool allRedirectsSameOrigin_;
    bool allRedirectsPassTimingAllowCheck_;
    mozilla::Maybe<bool> timingAllowCheckForPrincipal_;
    TimeStamp launchServiceWorkerStart_;
    TimeStamp launchServiceWorkerEnd_;
    TimeStamp dispatchFetchEventStart_;
    TimeStamp dispatchFetchEventEnd_;
    TimeStamp handleFetchEventStart_;
    TimeStamp handleFetchEventEnd_;
    TimeStamp responseStart_;
    TimeStamp responseEnd_;
    int8_t redirectCount_;
    int8_t internalRedirectCount_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::TimedChannelInfo>
{
    typedef mozilla::dom::TimedChannelInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
class PRemoteLazyInputStreamParent;
} // namespace mozilla

namespace mozilla {
class PRemoteLazyInputStreamChild;
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ReplacementChannelConfigInit|
//
namespace mozilla {
namespace dom {
class ReplacementChannelConfigInit final
{
private:
    typedef mozilla::dom::TimedChannelInfo TimedChannelInfo;
    typedef mozilla::PRemoteLazyInputStreamParent PRemoteLazyInputStreamParent;
    typedef mozilla::PRemoteLazyInputStreamChild PRemoteLazyInputStreamChild;

public:
    MOZ_IMPLICIT ReplacementChannelConfigInit() :
        privateBrowsing_(),
        method_(),
        referrerInfo_(),
        timedChannel_(),
        uploadStreamParent_(),
        uploadStreamChild_(),
        uploadStreamHasHeaders_(),
        contentType_(),
        contentLength_(),
        redirectFlags_(),
        classOfService_()
    {
    }

    MOZ_IMPLICIT ReplacementChannelConfigInit(
            const uint32_t& _redirectFlags,
            const uint32_t& _classOfService,
            const mozilla::Maybe<bool>& _privateBrowsing,
            const mozilla::Maybe<nsCString>& _method,
            nsIReferrerInfo* _referrerInfo,
            const mozilla::Maybe<TimedChannelInfo>& _timedChannel,
            PRemoteLazyInputStreamParent* _uploadStreamParent,
            PRemoteLazyInputStreamChild* _uploadStreamChild,
            const bool& _uploadStreamHasHeaders,
            const mozilla::Maybe<nsCString>& _contentType,
            const mozilla::Maybe<nsCString>& _contentLength) :
        privateBrowsing_(_privateBrowsing),
        method_(_method),
        referrerInfo_(_referrerInfo),
        timedChannel_(_timedChannel),
        uploadStreamParent_(_uploadStreamParent),
        uploadStreamChild_(_uploadStreamChild),
        uploadStreamHasHeaders_(_uploadStreamHasHeaders),
        contentType_(_contentType),
        contentLength_(_contentLength),
        redirectFlags_(_redirectFlags),
        classOfService_(_classOfService)
    {
    }

    uint32_t&
    redirectFlags()
    {
        return redirectFlags_;
    }
    const uint32_t&
    redirectFlags() const
    {
        return redirectFlags_;
    }

    uint32_t&
    classOfService()
    {
        return classOfService_;
    }
    const uint32_t&
    classOfService() const
    {
        return classOfService_;
    }

    mozilla::Maybe<bool>&
    privateBrowsing()
    {
        return privateBrowsing_;
    }
    const mozilla::Maybe<bool>&
    privateBrowsing() const
    {
        return privateBrowsing_;
    }

    mozilla::Maybe<nsCString>&
    method()
    {
        return method_;
    }
    const mozilla::Maybe<nsCString>&
    method() const
    {
        return method_;
    }

    RefPtr<nsIReferrerInfo>&
    referrerInfo()
    {
        return referrerInfo_;
    }
    nsIReferrerInfo*
    referrerInfo() const
    {
        return referrerInfo_;
    }

    mozilla::Maybe<TimedChannelInfo>&
    timedChannel()
    {
        return timedChannel_;
    }
    const mozilla::Maybe<TimedChannelInfo>&
    timedChannel() const
    {
        return timedChannel_;
    }

    PRemoteLazyInputStreamParent*&
    uploadStreamParent()
    {
        return uploadStreamParent_;
    }
    PRemoteLazyInputStreamParent*
    uploadStreamParent() const
    {
        return uploadStreamParent_;
    }

    PRemoteLazyInputStreamChild*&
    uploadStreamChild()
    {
        return uploadStreamChild_;
    }
    PRemoteLazyInputStreamChild*
    uploadStreamChild() const
    {
        return uploadStreamChild_;
    }

    bool&
    uploadStreamHasHeaders()
    {
        return uploadStreamHasHeaders_;
    }
    const bool&
    uploadStreamHasHeaders() const
    {
        return uploadStreamHasHeaders_;
    }

    mozilla::Maybe<nsCString>&
    contentType()
    {
        return contentType_;
    }
    const mozilla::Maybe<nsCString>&
    contentType() const
    {
        return contentType_;
    }

    mozilla::Maybe<nsCString>&
    contentLength()
    {
        return contentLength_;
    }
    const mozilla::Maybe<nsCString>&
    contentLength() const
    {
        return contentLength_;
    }

private:
    void
    StaticAssertions() const;
    mozilla::Maybe<bool> privateBrowsing_;
    mozilla::Maybe<nsCString> method_;
    RefPtr<nsIReferrerInfo> referrerInfo_;
    mozilla::Maybe<TimedChannelInfo> timedChannel_;
    PRemoteLazyInputStreamParent* uploadStreamParent_;
    PRemoteLazyInputStreamChild* uploadStreamChild_;
    bool uploadStreamHasHeaders_;
    mozilla::Maybe<nsCString> contentType_;
    mozilla::Maybe<nsCString> contentLength_;
    uint32_t redirectFlags_;
    uint32_t classOfService_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ReplacementChannelConfigInit>
{
    typedef mozilla::dom::ReplacementChannelConfigInit paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union IPDLVariantValue|
//
namespace mozilla {
namespace dom {
class IPDLVariantValue final
{
public:
    enum Type {
        T__None,
        Tbool = 1,
        Tuint8_t,
        Tint16_t,
        Tuint16_t,
        Tint32_t,
        Tuint32_t,
        Tfloat,
        Tdouble,
        TnsID,
        TnsString,
        TnsCString,
        TnsIURI,
        TnsIPrincipal,
        T__Last = TnsIPrincipal
    };

private:
    typedef bool bool__tdef;
    typedef uint8_t uint8_t__tdef;
    typedef int16_t int16_t__tdef;
    typedef uint16_t uint16_t__tdef;
    typedef int32_t int32_t__tdef;
    typedef uint32_t uint32_t__tdef;
    typedef float float__tdef;
    typedef double double__tdef;
    typedef nsID nsID__tdef;
    typedef nsString nsString__tdef;
    typedef nsCString nsCString__tdef;
    typedef RefPtr<nsIURI> nsIURI__tdef;
    typedef RefPtr<nsIPrincipal> nsIPrincipal__tdef;

    union Value {
        mozilla::AlignedStorage2<bool> Vbool;
        mozilla::AlignedStorage2<uint8_t> Vuint8_t;
        mozilla::AlignedStorage2<int16_t> Vint16_t;
        mozilla::AlignedStorage2<uint16_t> Vuint16_t;
        mozilla::AlignedStorage2<int32_t> Vint32_t;
        mozilla::AlignedStorage2<uint32_t> Vuint32_t;
        mozilla::AlignedStorage2<float> Vfloat;
        mozilla::AlignedStorage2<double> Vdouble;
        mozilla::AlignedStorage2<nsID> VnsID;
        mozilla::AlignedStorage2<nsString> VnsString;
        mozilla::AlignedStorage2<nsCString> VnsCString;
        mozilla::AlignedStorage2<RefPtr<nsIURI>> VnsIURI;
        mozilla::AlignedStorage2<RefPtr<nsIPrincipal>> VnsIPrincipal;
    };

    bool*
    ptr_bool()
    {
        return ((mValue).Vbool).addr();
    }
    const bool*
    constptr_bool() const
    {
        return ((mValue).Vbool).addr();
    }
    uint8_t*
    ptr_uint8_t()
    {
        return ((mValue).Vuint8_t).addr();
    }
    const uint8_t*
    constptr_uint8_t() const
    {
        return ((mValue).Vuint8_t).addr();
    }
    int16_t*
    ptr_int16_t()
    {
        return ((mValue).Vint16_t).addr();
    }
    const int16_t*
    constptr_int16_t() const
    {
        return ((mValue).Vint16_t).addr();
    }
    uint16_t*
    ptr_uint16_t()
    {
        return ((mValue).Vuint16_t).addr();
    }
    const uint16_t*
    constptr_uint16_t() const
    {
        return ((mValue).Vuint16_t).addr();
    }
    int32_t*
    ptr_int32_t()
    {
        return ((mValue).Vint32_t).addr();
    }
    const int32_t*
    constptr_int32_t() const
    {
        return ((mValue).Vint32_t).addr();
    }
    uint32_t*
    ptr_uint32_t()
    {
        return ((mValue).Vuint32_t).addr();
    }
    const uint32_t*
    constptr_uint32_t() const
    {
        return ((mValue).Vuint32_t).addr();
    }
    float*
    ptr_float()
    {
        return ((mValue).Vfloat).addr();
    }
    const float*
    constptr_float() const
    {
        return ((mValue).Vfloat).addr();
    }
    double*
    ptr_double()
    {
        return ((mValue).Vdouble).addr();
    }
    const double*
    constptr_double() const
    {
        return ((mValue).Vdouble).addr();
    }
    nsID*
    ptr_nsID()
    {
        return ((mValue).VnsID).addr();
    }
    const nsID*
    constptr_nsID() const
    {
        return ((mValue).VnsID).addr();
    }
    nsString*
    ptr_nsString()
    {
        return ((mValue).VnsString).addr();
    }
    const nsString*
    constptr_nsString() const
    {
        return ((mValue).VnsString).addr();
    }
    nsCString*
    ptr_nsCString()
    {
        return ((mValue).VnsCString).addr();
    }
    const nsCString*
    constptr_nsCString() const
    {
        return ((mValue).VnsCString).addr();
    }
    RefPtr<nsIURI>*
    ptr_nsIURI()
    {
        return ((mValue).VnsIURI).addr();
    }
    const RefPtr<nsIURI>*
    constptr_nsIURI() const
    {
        return ((mValue).VnsIURI).addr();
    }
    RefPtr<nsIPrincipal>*
    ptr_nsIPrincipal()
    {
        return ((mValue).VnsIPrincipal).addr();
    }
    const RefPtr<nsIPrincipal>*
    constptr_nsIPrincipal() const
    {
        return ((mValue).VnsIPrincipal).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT IPDLVariantValue() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT IPDLVariantValue(const bool& aOther);

    MOZ_IMPLICIT IPDLVariantValue(bool&& aOther);

    MOZ_IMPLICIT IPDLVariantValue(const uint8_t& aOther);

    MOZ_IMPLICIT IPDLVariantValue(uint8_t&& aOther);

    MOZ_IMPLICIT IPDLVariantValue(const int16_t& aOther);

    MOZ_IMPLICIT IPDLVariantValue(int16_t&& aOther);

    MOZ_IMPLICIT IPDLVariantValue(const uint16_t& aOther);

    MOZ_IMPLICIT IPDLVariantValue(uint16_t&& aOther);

    MOZ_IMPLICIT IPDLVariantValue(const int32_t& aOther);

    MOZ_IMPLICIT IPDLVariantValue(int32_t&& aOther);

    MOZ_IMPLICIT IPDLVariantValue(const uint32_t& aOther);

    MOZ_IMPLICIT IPDLVariantValue(uint32_t&& aOther);

    MOZ_IMPLICIT IPDLVariantValue(const float& aOther);

    MOZ_IMPLICIT IPDLVariantValue(float&& aOther);

    MOZ_IMPLICIT IPDLVariantValue(const double& aOther);

    MOZ_IMPLICIT IPDLVariantValue(double&& aOther);

    MOZ_IMPLICIT IPDLVariantValue(const nsID& aOther);

    MOZ_IMPLICIT IPDLVariantValue(nsID&& aOther);

    MOZ_IMPLICIT IPDLVariantValue(const nsString& aOther);

    MOZ_IMPLICIT IPDLVariantValue(nsString&& aOther);

    MOZ_IMPLICIT IPDLVariantValue(const nsCString& aOther);

    MOZ_IMPLICIT IPDLVariantValue(nsCString&& aOther);

    MOZ_IMPLICIT IPDLVariantValue(nsIURI* aOther);

    MOZ_IMPLICIT IPDLVariantValue(RefPtr<nsIURI>&& aOther);

    MOZ_IMPLICIT IPDLVariantValue(nsIPrincipal* aOther);

    MOZ_IMPLICIT IPDLVariantValue(RefPtr<nsIPrincipal>&& aOther);

    MOZ_IMPLICIT IPDLVariantValue(const IPDLVariantValue& aOther);

    MOZ_IMPLICIT IPDLVariantValue(IPDLVariantValue&& aOther);

    ~IPDLVariantValue();

    Type
    type() const
    {
        return mType;
    }

    IPDLVariantValue&
    operator=(const bool& aRhs);

    IPDLVariantValue&
    operator=(bool&& aRhs);

    IPDLVariantValue&
    operator=(const uint8_t& aRhs);

    IPDLVariantValue&
    operator=(uint8_t&& aRhs);

    IPDLVariantValue&
    operator=(const int16_t& aRhs);

    IPDLVariantValue&
    operator=(int16_t&& aRhs);

    IPDLVariantValue&
    operator=(const uint16_t& aRhs);

    IPDLVariantValue&
    operator=(uint16_t&& aRhs);

    IPDLVariantValue&
    operator=(const int32_t& aRhs);

    IPDLVariantValue&
    operator=(int32_t&& aRhs);

    IPDLVariantValue&
    operator=(const uint32_t& aRhs);

    IPDLVariantValue&
    operator=(uint32_t&& aRhs);

    IPDLVariantValue&
    operator=(const float& aRhs);

    IPDLVariantValue&
    operator=(float&& aRhs);

    IPDLVariantValue&
    operator=(const double& aRhs);

    IPDLVariantValue&
    operator=(double&& aRhs);

    IPDLVariantValue&
    operator=(const nsID& aRhs);

    IPDLVariantValue&
    operator=(nsID&& aRhs);

    IPDLVariantValue&
    operator=(const nsString& aRhs);

    IPDLVariantValue&
    operator=(nsString&& aRhs);

    IPDLVariantValue&
    operator=(const nsCString& aRhs);

    IPDLVariantValue&
    operator=(nsCString&& aRhs);

    IPDLVariantValue&
    operator=(nsIURI* aRhs);

    IPDLVariantValue&
    operator=(RefPtr<nsIURI>&& aRhs);

    IPDLVariantValue&
    operator=(nsIPrincipal* aRhs);

    IPDLVariantValue&
    operator=(RefPtr<nsIPrincipal>&& aRhs);

    IPDLVariantValue&
    operator=(const IPDLVariantValue& aRhs);

    IPDLVariantValue&
    operator=(IPDLVariantValue&& aRhs);

    bool&
    get_bool()
    {
        AssertSanity(Tbool);
        return (*(ptr_bool()));
    }
    const bool&
    get_bool() const
    {
        AssertSanity(Tbool);
        return (*(constptr_bool()));
    }
    operator bool&()
    {
        return get_bool();
    }
    operator const bool&() const
    {
        return get_bool();
    }

    uint8_t&
    get_uint8_t()
    {
        AssertSanity(Tuint8_t);
        return (*(ptr_uint8_t()));
    }
    const uint8_t&
    get_uint8_t() const
    {
        AssertSanity(Tuint8_t);
        return (*(constptr_uint8_t()));
    }
    operator uint8_t&()
    {
        return get_uint8_t();
    }
    operator const uint8_t&() const
    {
        return get_uint8_t();
    }

    int16_t&
    get_int16_t()
    {
        AssertSanity(Tint16_t);
        return (*(ptr_int16_t()));
    }
    const int16_t&
    get_int16_t() const
    {
        AssertSanity(Tint16_t);
        return (*(constptr_int16_t()));
    }
    operator int16_t&()
    {
        return get_int16_t();
    }
    operator const int16_t&() const
    {
        return get_int16_t();
    }

    uint16_t&
    get_uint16_t()
    {
        AssertSanity(Tuint16_t);
        return (*(ptr_uint16_t()));
    }
    const uint16_t&
    get_uint16_t() const
    {
        AssertSanity(Tuint16_t);
        return (*(constptr_uint16_t()));
    }
    operator uint16_t&()
    {
        return get_uint16_t();
    }
    operator const uint16_t&() const
    {
        return get_uint16_t();
    }

    int32_t&
    get_int32_t()
    {
        AssertSanity(Tint32_t);
        return (*(ptr_int32_t()));
    }
    const int32_t&
    get_int32_t() const
    {
        AssertSanity(Tint32_t);
        return (*(constptr_int32_t()));
    }
    operator int32_t&()
    {
        return get_int32_t();
    }
    operator const int32_t&() const
    {
        return get_int32_t();
    }

    uint32_t&
    get_uint32_t()
    {
        AssertSanity(Tuint32_t);
        return (*(ptr_uint32_t()));
    }
    const uint32_t&
    get_uint32_t() const
    {
        AssertSanity(Tuint32_t);
        return (*(constptr_uint32_t()));
    }
    operator uint32_t&()
    {
        return get_uint32_t();
    }
    operator const uint32_t&() const
    {
        return get_uint32_t();
    }

    float&
    get_float()
    {
        AssertSanity(Tfloat);
        return (*(ptr_float()));
    }
    const float&
    get_float() const
    {
        AssertSanity(Tfloat);
        return (*(constptr_float()));
    }
    operator float&()
    {
        return get_float();
    }
    operator const float&() const
    {
        return get_float();
    }

    double&
    get_double()
    {
        AssertSanity(Tdouble);
        return (*(ptr_double()));
    }
    const double&
    get_double() const
    {
        AssertSanity(Tdouble);
        return (*(constptr_double()));
    }
    operator double&()
    {
        return get_double();
    }
    operator const double&() const
    {
        return get_double();
    }

    nsID&
    get_nsID()
    {
        AssertSanity(TnsID);
        return (*(ptr_nsID()));
    }
    const nsID&
    get_nsID() const
    {
        AssertSanity(TnsID);
        return (*(constptr_nsID()));
    }
    operator nsID&()
    {
        return get_nsID();
    }
    operator const nsID&() const
    {
        return get_nsID();
    }

    nsString&
    get_nsString()
    {
        AssertSanity(TnsString);
        return (*(ptr_nsString()));
    }
    const nsString&
    get_nsString() const
    {
        AssertSanity(TnsString);
        return (*(constptr_nsString()));
    }
    operator nsString&()
    {
        return get_nsString();
    }
    operator const nsString&() const
    {
        return get_nsString();
    }

    nsCString&
    get_nsCString()
    {
        AssertSanity(TnsCString);
        return (*(ptr_nsCString()));
    }
    const nsCString&
    get_nsCString() const
    {
        AssertSanity(TnsCString);
        return (*(constptr_nsCString()));
    }
    operator nsCString&()
    {
        return get_nsCString();
    }
    operator const nsCString&() const
    {
        return get_nsCString();
    }

    RefPtr<nsIURI>&
    get_nsIURI()
    {
        AssertSanity(TnsIURI);
        return (*(ptr_nsIURI()));
    }
    nsIURI*
    get_nsIURI() const
    {
        AssertSanity(TnsIURI);
        return (*(constptr_nsIURI()));
    }
    operator RefPtr<nsIURI>&()
    {
        return get_nsIURI();
    }
    operator nsIURI*() const
    {
        return get_nsIURI();
    }

    RefPtr<nsIPrincipal>&
    get_nsIPrincipal()
    {
        AssertSanity(TnsIPrincipal);
        return (*(ptr_nsIPrincipal()));
    }
    nsIPrincipal*
    get_nsIPrincipal() const
    {
        AssertSanity(TnsIPrincipal);
        return (*(constptr_nsIPrincipal()));
    }
    operator RefPtr<nsIPrincipal>&()
    {
        return get_nsIPrincipal();
    }
    operator nsIPrincipal*() const
    {
        return get_nsIPrincipal();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPDLVariantValue>
{
    typedef mozilla::dom::IPDLVariantValue paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct IDPLVariant|
//
namespace mozilla {
namespace dom {
class IDPLVariant final
{
private:
    typedef mozilla::dom::IPDLVariantValue IPDLVariantValue;

public:
    MOZ_IMPLICIT IDPLVariant() :
        data_(),
        type_()
    {
    }

    MOZ_IMPLICIT IDPLVariant(
            const uint32_t& _type,
            const IPDLVariantValue& _data) :
        data_(_data),
        type_(_type)
    {
    }

    uint32_t&
    type()
    {
        return type_;
    }
    const uint32_t&
    type() const
    {
        return type_;
    }

    IPDLVariantValue&
    data()
    {
        return data_;
    }
    const IPDLVariantValue&
    data() const
    {
        return data_;
    }

private:
    IPDLVariantValue data_;
    uint32_t type_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IDPLVariant>
{
    typedef mozilla::dom::IDPLVariant paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct IPDLProperty|
//
namespace mozilla {
namespace dom {
class IPDLProperty final
{
private:

public:
    MOZ_IMPLICIT IPDLProperty() :
        name_(),
        value_()
    {
    }

    MOZ_IMPLICIT IPDLProperty(
            const nsString& _name,
            nsIVariant* _value) :
        name_(_name),
        value_(_value)
    {
    }

    nsString&
    name()
    {
        return name_;
    }
    const nsString&
    name() const
    {
        return name_;
    }

    RefPtr<nsIVariant>&
    value()
    {
        return value_;
    }
    nsIVariant*
    value() const
    {
        return value_;
    }

private:
    nsString name_;
    RefPtr<nsIVariant> value_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPDLProperty>
{
    typedef mozilla::dom::IPDLProperty paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ParentShowInfo|
//
namespace mozilla {
namespace dom {
class ParentShowInfo final
{
private:

public:
    MOZ_IMPLICIT ParentShowInfo() :
        name_(),
        fakeShowInfo_(),
        isTransparent_(),
        defaultScale_(),
        dpi_(),
        widgetRounding_()
    {
    }

    MOZ_IMPLICIT ParentShowInfo(
            const nsString& _name,
            const bool& _fakeShowInfo,
            const bool& _isTransparent,
            const float& _dpi,
            const int32_t& _widgetRounding,
            const double& _defaultScale) :
        name_(_name),
        fakeShowInfo_(_fakeShowInfo),
        isTransparent_(_isTransparent),
        defaultScale_(_defaultScale),
        dpi_(_dpi),
        widgetRounding_(_widgetRounding)
    {
    }

    nsString&
    name()
    {
        return name_;
    }
    const nsString&
    name() const
    {
        return name_;
    }

    bool&
    fakeShowInfo()
    {
        return fakeShowInfo_;
    }
    const bool&
    fakeShowInfo() const
    {
        return fakeShowInfo_;
    }

    bool&
    isTransparent()
    {
        return isTransparent_;
    }
    const bool&
    isTransparent() const
    {
        return isTransparent_;
    }

    float&
    dpi()
    {
        return dpi_;
    }
    const float&
    dpi() const
    {
        return dpi_;
    }

    int32_t&
    widgetRounding()
    {
        return widgetRounding_;
    }
    const int32_t&
    widgetRounding() const
    {
        return widgetRounding_;
    }

    double&
    defaultScale()
    {
        return defaultScale_;
    }
    const double&
    defaultScale() const
    {
        return defaultScale_;
    }

private:
    void
    StaticAssertions() const;
    nsString name_;
    bool fakeShowInfo_;
    bool isTransparent_;
    double defaultScale_;
    float dpi_;
    int32_t widgetRounding_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ParentShowInfo>
{
    typedef mozilla::dom::ParentShowInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OwnerShowInfo|
//
namespace mozilla {
namespace dom {
class OwnerShowInfo final
{
private:

public:
    MOZ_IMPLICIT OwnerShowInfo() :
        size_(),
        scrollbarPreference_(),
        sizeMode_()
    {
    }

    MOZ_IMPLICIT OwnerShowInfo(
            const ScreenIntSize& _size,
            const ScrollbarPreference& _scrollbarPreference,
            const nsSizeMode& _sizeMode) :
        size_(_size),
        scrollbarPreference_(_scrollbarPreference),
        sizeMode_(_sizeMode)
    {
    }

    ScreenIntSize&
    size()
    {
        return size_;
    }
    const ScreenIntSize&
    size() const
    {
        return size_;
    }

    ScrollbarPreference&
    scrollbarPreference()
    {
        return scrollbarPreference_;
    }
    const ScrollbarPreference&
    scrollbarPreference() const
    {
        return scrollbarPreference_;
    }

    nsSizeMode&
    sizeMode()
    {
        return sizeMode_;
    }
    const nsSizeMode&
    sizeMode() const
    {
        return sizeMode_;
    }

private:
    ScreenIntSize size_;
    ScrollbarPreference scrollbarPreference_;
    nsSizeMode sizeMode_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::OwnerShowInfo>
{
    typedef mozilla::dom::OwnerShowInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

#endif // ifndef DOMTypes_h
