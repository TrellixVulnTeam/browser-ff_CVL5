//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef ServiceWorkerOpArgs_h
#define ServiceWorkerOpArgs_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "mozilla/dom/ServiceWorkerBinding.h"
#include "mozilla/ipc/ChannelInfo.h"
#include "mozilla/dom/ClientIPCTypes.h"
#include "mozilla/dom/DOMTypes.h"
#include "mozilla/dom/FetchTypes.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ServiceWorkerCheckScriptEvaluationOpArgs|
//
namespace mozilla {
namespace dom {
class ServiceWorkerCheckScriptEvaluationOpArgs final
{
private:

public:
    MOZ_IMPLICIT ServiceWorkerCheckScriptEvaluationOpArgs()
    {
    }

private:
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ServiceWorkerCheckScriptEvaluationOpArgs>
{
    typedef mozilla::dom::ServiceWorkerCheckScriptEvaluationOpArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ServiceWorkerUpdateStateOpArgs|
//
namespace mozilla {
namespace dom {
class ServiceWorkerUpdateStateOpArgs final
{
private:

public:
    MOZ_IMPLICIT ServiceWorkerUpdateStateOpArgs() :
        state_()
    {
    }

    MOZ_IMPLICIT ServiceWorkerUpdateStateOpArgs(const ServiceWorkerState& _state) :
        state_(_state)
    {
    }

    ServiceWorkerState&
    state()
    {
        return state_;
    }
    const ServiceWorkerState&
    state() const
    {
        return state_;
    }

private:
    ServiceWorkerState state_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ServiceWorkerUpdateStateOpArgs>
{
    typedef mozilla::dom::ServiceWorkerUpdateStateOpArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ServiceWorkerTerminateWorkerOpArgs|
//
namespace mozilla {
namespace dom {
class ServiceWorkerTerminateWorkerOpArgs final
{
private:

public:
    MOZ_IMPLICIT ServiceWorkerTerminateWorkerOpArgs() :
        shutdownStateId_()
    {
    }

    MOZ_IMPLICIT ServiceWorkerTerminateWorkerOpArgs(const uint32_t& _shutdownStateId) :
        shutdownStateId_(_shutdownStateId)
    {
    }

    uint32_t&
    shutdownStateId()
    {
        return shutdownStateId_;
    }
    const uint32_t&
    shutdownStateId() const
    {
        return shutdownStateId_;
    }

private:
    uint32_t shutdownStateId_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ServiceWorkerTerminateWorkerOpArgs>
{
    typedef mozilla::dom::ServiceWorkerTerminateWorkerOpArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ServiceWorkerLifeCycleEventOpArgs|
//
namespace mozilla {
namespace dom {
class ServiceWorkerLifeCycleEventOpArgs final
{
private:

public:
    MOZ_IMPLICIT ServiceWorkerLifeCycleEventOpArgs() :
        eventName_()
    {
    }

    MOZ_IMPLICIT ServiceWorkerLifeCycleEventOpArgs(const nsString& _eventName) :
        eventName_(_eventName)
    {
    }

    nsString&
    eventName()
    {
        return eventName_;
    }
    const nsString&
    eventName() const
    {
        return eventName_;
    }

private:
    nsString eventName_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ServiceWorkerLifeCycleEventOpArgs>
{
    typedef mozilla::dom::ServiceWorkerLifeCycleEventOpArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union OptionalPushData|
//
namespace mozilla {
namespace dom {
class OptionalPushData final
{
public:
    enum Type {
        T__None,
        Tvoid_t = 1,
        TArrayOfuint8_t,
        T__Last = TArrayOfuint8_t
    };

private:
    typedef mozilla::void_t void_t;
    typedef void_t void_t__tdef;
    typedef nsTArray<uint8_t> ArrayOfuint8_t__tdef;

    union Value {
        mozilla::AlignedStorage2<void_t> Vvoid_t;
        mozilla::AlignedStorage2<nsTArray<uint8_t>> VArrayOfuint8_t;
    };

    void_t*
    ptr_void_t()
    {
        return ((mValue).Vvoid_t).addr();
    }
    const void_t*
    constptr_void_t() const
    {
        return ((mValue).Vvoid_t).addr();
    }
    nsTArray<uint8_t>*
    ptr_ArrayOfuint8_t()
    {
        return ((mValue).VArrayOfuint8_t).addr();
    }
    const nsTArray<uint8_t>*
    constptr_ArrayOfuint8_t() const
    {
        return ((mValue).VArrayOfuint8_t).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT OptionalPushData() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT OptionalPushData(const void_t& aOther);

    MOZ_IMPLICIT OptionalPushData(void_t&& aOther);

    MOZ_IMPLICIT OptionalPushData(const nsTArray<uint8_t>& aOther);

    MOZ_IMPLICIT OptionalPushData(nsTArray<uint8_t>&& aOther);

    MOZ_IMPLICIT OptionalPushData(const OptionalPushData& aOther);

    MOZ_IMPLICIT OptionalPushData(OptionalPushData&& aOther);

    ~OptionalPushData();

    Type
    type() const
    {
        return mType;
    }

    OptionalPushData&
    operator=(const void_t& aRhs);

    OptionalPushData&
    operator=(void_t&& aRhs);

    OptionalPushData&
    operator=(const nsTArray<uint8_t>& aRhs);

    OptionalPushData&
    operator=(nsTArray<uint8_t>&& aRhs);

    OptionalPushData&
    operator=(const OptionalPushData& aRhs);

    OptionalPushData&
    operator=(OptionalPushData&& aRhs);

    void_t&
    get_void_t()
    {
        AssertSanity(Tvoid_t);
        return (*(ptr_void_t()));
    }
    const void_t&
    get_void_t() const
    {
        AssertSanity(Tvoid_t);
        return (*(constptr_void_t()));
    }
    operator void_t&()
    {
        return get_void_t();
    }
    operator const void_t&() const
    {
        return get_void_t();
    }

    nsTArray<uint8_t>&
    get_ArrayOfuint8_t()
    {
        AssertSanity(TArrayOfuint8_t);
        return (*(ptr_ArrayOfuint8_t()));
    }
    const nsTArray<uint8_t>&
    get_ArrayOfuint8_t() const
    {
        AssertSanity(TArrayOfuint8_t);
        return (*(constptr_ArrayOfuint8_t()));
    }
    operator nsTArray<uint8_t>&()
    {
        return get_ArrayOfuint8_t();
    }
    operator const nsTArray<uint8_t>&() const
    {
        return get_ArrayOfuint8_t();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::OptionalPushData>
{
    typedef mozilla::dom::OptionalPushData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ServiceWorkerPushEventOpArgs|
//
namespace mozilla {
namespace dom {
class ServiceWorkerPushEventOpArgs final
{
private:
    typedef mozilla::dom::OptionalPushData OptionalPushData;

public:
    MOZ_IMPLICIT ServiceWorkerPushEventOpArgs() :
        messageId_(),
        data_()
    {
    }

    MOZ_IMPLICIT ServiceWorkerPushEventOpArgs(
            const nsString& _messageId,
            const OptionalPushData& _data) :
        messageId_(_messageId),
        data_(_data)
    {
    }

    nsString&
    messageId()
    {
        return messageId_;
    }
    const nsString&
    messageId() const
    {
        return messageId_;
    }

    OptionalPushData&
    data()
    {
        return data_;
    }
    const OptionalPushData&
    data() const
    {
        return data_;
    }

private:
    nsString messageId_;
    OptionalPushData data_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ServiceWorkerPushEventOpArgs>
{
    typedef mozilla::dom::ServiceWorkerPushEventOpArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ServiceWorkerPushSubscriptionChangeEventOpArgs|
//
namespace mozilla {
namespace dom {
class ServiceWorkerPushSubscriptionChangeEventOpArgs final
{
private:

public:
    MOZ_IMPLICIT ServiceWorkerPushSubscriptionChangeEventOpArgs()
    {
    }

private:
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ServiceWorkerPushSubscriptionChangeEventOpArgs>
{
    typedef mozilla::dom::ServiceWorkerPushSubscriptionChangeEventOpArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ServiceWorkerNotificationEventOpArgs|
//
namespace mozilla {
namespace dom {
class ServiceWorkerNotificationEventOpArgs final
{
private:

public:
    MOZ_IMPLICIT ServiceWorkerNotificationEventOpArgs() :
        eventName_(),
        id_(),
        title_(),
        dir_(),
        lang_(),
        body_(),
        tag_(),
        icon_(),
        data_(),
        behavior_(),
        scope_(),
        disableOpenClickDelay_()
    {
    }

    MOZ_IMPLICIT ServiceWorkerNotificationEventOpArgs(
            const nsString& _eventName,
            const nsString& _id,
            const nsString& _title,
            const nsString& _dir,
            const nsString& _lang,
            const nsString& _body,
            const nsString& _tag,
            const nsString& _icon,
            const nsString& _data,
            const nsString& _behavior,
            const nsString& _scope,
            const uint32_t& _disableOpenClickDelay) :
        eventName_(_eventName),
        id_(_id),
        title_(_title),
        dir_(_dir),
        lang_(_lang),
        body_(_body),
        tag_(_tag),
        icon_(_icon),
        data_(_data),
        behavior_(_behavior),
        scope_(_scope),
        disableOpenClickDelay_(_disableOpenClickDelay)
    {
    }

    nsString&
    eventName()
    {
        return eventName_;
    }
    const nsString&
    eventName() const
    {
        return eventName_;
    }

    nsString&
    id()
    {
        return id_;
    }
    const nsString&
    id() const
    {
        return id_;
    }

    nsString&
    title()
    {
        return title_;
    }
    const nsString&
    title() const
    {
        return title_;
    }

    nsString&
    dir()
    {
        return dir_;
    }
    const nsString&
    dir() const
    {
        return dir_;
    }

    nsString&
    lang()
    {
        return lang_;
    }
    const nsString&
    lang() const
    {
        return lang_;
    }

    nsString&
    body()
    {
        return body_;
    }
    const nsString&
    body() const
    {
        return body_;
    }

    nsString&
    tag()
    {
        return tag_;
    }
    const nsString&
    tag() const
    {
        return tag_;
    }

    nsString&
    icon()
    {
        return icon_;
    }
    const nsString&
    icon() const
    {
        return icon_;
    }

    nsString&
    data()
    {
        return data_;
    }
    const nsString&
    data() const
    {
        return data_;
    }

    nsString&
    behavior()
    {
        return behavior_;
    }
    const nsString&
    behavior() const
    {
        return behavior_;
    }

    nsString&
    scope()
    {
        return scope_;
    }
    const nsString&
    scope() const
    {
        return scope_;
    }

    uint32_t&
    disableOpenClickDelay()
    {
        return disableOpenClickDelay_;
    }
    const uint32_t&
    disableOpenClickDelay() const
    {
        return disableOpenClickDelay_;
    }

private:
    nsString eventName_;
    nsString id_;
    nsString title_;
    nsString dir_;
    nsString lang_;
    nsString body_;
    nsString tag_;
    nsString icon_;
    nsString data_;
    nsString behavior_;
    nsString scope_;
    uint32_t disableOpenClickDelay_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ServiceWorkerNotificationEventOpArgs>
{
    typedef mozilla::dom::ServiceWorkerNotificationEventOpArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ServiceWorkerMessageEventOpArgs|
//
namespace mozilla {
namespace dom {
class ServiceWorkerMessageEventOpArgs final
{
private:
    typedef mozilla::dom::ClientInfoAndState ClientInfoAndState;
    typedef mozilla::dom::ClonedOrErrorMessageData ClonedOrErrorMessageData;

public:
    MOZ_IMPLICIT ServiceWorkerMessageEventOpArgs() :
        clientInfoAndState_(),
        clonedData_()
    {
    }

    MOZ_IMPLICIT ServiceWorkerMessageEventOpArgs(
            const ClientInfoAndState& _clientInfoAndState,
            ClonedOrErrorMessageData&& _clonedData) :
        clientInfoAndState_(_clientInfoAndState),
        clonedData_(std::move(_clonedData))
    {
    }

    ClientInfoAndState&
    clientInfoAndState()
    {
        return clientInfoAndState_;
    }
    const ClientInfoAndState&
    clientInfoAndState() const
    {
        return clientInfoAndState_;
    }

    ClonedOrErrorMessageData&
    clonedData()
    {
        return clonedData_;
    }
    const ClonedOrErrorMessageData&
    clonedData() const
    {
        return clonedData_;
    }

private:
    ClientInfoAndState clientInfoAndState_;
    ClonedOrErrorMessageData clonedData_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ServiceWorkerMessageEventOpArgs>
{
    typedef mozilla::dom::ServiceWorkerMessageEventOpArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ServiceWorkerFetchEventOpArgs|
//
namespace mozilla {
namespace dom {
class ServiceWorkerFetchEventOpArgs final
{
private:
    typedef mozilla::dom::IPCInternalRequest IPCInternalRequest;

public:
    MOZ_IMPLICIT ServiceWorkerFetchEventOpArgs() :
        workerScriptSpec_(),
        internalRequest_(),
        clientId_(),
        resultingClientId_(),
        isNonSubresourceRequest_()
    {
    }

    MOZ_IMPLICIT ServiceWorkerFetchEventOpArgs(
            const nsCString& _workerScriptSpec,
            const IPCInternalRequest& _internalRequest,
            const nsString& _clientId,
            const nsString& _resultingClientId,
            const bool& _isNonSubresourceRequest) :
        workerScriptSpec_(_workerScriptSpec),
        internalRequest_(_internalRequest),
        clientId_(_clientId),
        resultingClientId_(_resultingClientId),
        isNonSubresourceRequest_(_isNonSubresourceRequest)
    {
    }

    nsCString&
    workerScriptSpec()
    {
        return workerScriptSpec_;
    }
    const nsCString&
    workerScriptSpec() const
    {
        return workerScriptSpec_;
    }

    IPCInternalRequest&
    internalRequest()
    {
        return internalRequest_;
    }
    const IPCInternalRequest&
    internalRequest() const
    {
        return internalRequest_;
    }

    nsString&
    clientId()
    {
        return clientId_;
    }
    const nsString&
    clientId() const
    {
        return clientId_;
    }

    nsString&
    resultingClientId()
    {
        return resultingClientId_;
    }
    const nsString&
    resultingClientId() const
    {
        return resultingClientId_;
    }

    bool&
    isNonSubresourceRequest()
    {
        return isNonSubresourceRequest_;
    }
    const bool&
    isNonSubresourceRequest() const
    {
        return isNonSubresourceRequest_;
    }

private:
    nsCString workerScriptSpec_;
    IPCInternalRequest internalRequest_;
    nsString clientId_;
    nsString resultingClientId_;
    bool isNonSubresourceRequest_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ServiceWorkerFetchEventOpArgs>
{
    typedef mozilla::dom::ServiceWorkerFetchEventOpArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union ServiceWorkerOpArgs|
//
namespace mozilla {
namespace dom {
class ServiceWorkerOpArgs final
{
public:
    enum Type {
        T__None,
        TServiceWorkerCheckScriptEvaluationOpArgs = 1,
        TServiceWorkerUpdateStateOpArgs,
        TServiceWorkerTerminateWorkerOpArgs,
        TServiceWorkerLifeCycleEventOpArgs,
        TServiceWorkerPushEventOpArgs,
        TServiceWorkerPushSubscriptionChangeEventOpArgs,
        TServiceWorkerNotificationEventOpArgs,
        TServiceWorkerMessageEventOpArgs,
        TServiceWorkerFetchEventOpArgs,
        T__Last = TServiceWorkerFetchEventOpArgs
    };

private:
    typedef mozilla::dom::ServiceWorkerCheckScriptEvaluationOpArgs ServiceWorkerCheckScriptEvaluationOpArgs;
    typedef mozilla::dom::ServiceWorkerUpdateStateOpArgs ServiceWorkerUpdateStateOpArgs;
    typedef mozilla::dom::ServiceWorkerTerminateWorkerOpArgs ServiceWorkerTerminateWorkerOpArgs;
    typedef mozilla::dom::ServiceWorkerLifeCycleEventOpArgs ServiceWorkerLifeCycleEventOpArgs;
    typedef mozilla::dom::ServiceWorkerPushEventOpArgs ServiceWorkerPushEventOpArgs;
    typedef mozilla::dom::ServiceWorkerPushSubscriptionChangeEventOpArgs ServiceWorkerPushSubscriptionChangeEventOpArgs;
    typedef mozilla::dom::ServiceWorkerNotificationEventOpArgs ServiceWorkerNotificationEventOpArgs;
    typedef mozilla::dom::ServiceWorkerMessageEventOpArgs ServiceWorkerMessageEventOpArgs;
    typedef mozilla::dom::ServiceWorkerFetchEventOpArgs ServiceWorkerFetchEventOpArgs;
    typedef ServiceWorkerCheckScriptEvaluationOpArgs ServiceWorkerCheckScriptEvaluationOpArgs__tdef;
    typedef ServiceWorkerUpdateStateOpArgs ServiceWorkerUpdateStateOpArgs__tdef;
    typedef ServiceWorkerTerminateWorkerOpArgs ServiceWorkerTerminateWorkerOpArgs__tdef;
    typedef ServiceWorkerLifeCycleEventOpArgs ServiceWorkerLifeCycleEventOpArgs__tdef;
    typedef ServiceWorkerPushEventOpArgs ServiceWorkerPushEventOpArgs__tdef;
    typedef ServiceWorkerPushSubscriptionChangeEventOpArgs ServiceWorkerPushSubscriptionChangeEventOpArgs__tdef;
    typedef ServiceWorkerNotificationEventOpArgs ServiceWorkerNotificationEventOpArgs__tdef;
    typedef ServiceWorkerMessageEventOpArgs ServiceWorkerMessageEventOpArgs__tdef;
    typedef ServiceWorkerFetchEventOpArgs ServiceWorkerFetchEventOpArgs__tdef;

    union Value {
        mozilla::AlignedStorage2<ServiceWorkerCheckScriptEvaluationOpArgs> VServiceWorkerCheckScriptEvaluationOpArgs;
        mozilla::AlignedStorage2<ServiceWorkerUpdateStateOpArgs> VServiceWorkerUpdateStateOpArgs;
        mozilla::AlignedStorage2<ServiceWorkerTerminateWorkerOpArgs> VServiceWorkerTerminateWorkerOpArgs;
        mozilla::AlignedStorage2<ServiceWorkerLifeCycleEventOpArgs> VServiceWorkerLifeCycleEventOpArgs;
        mozilla::AlignedStorage2<ServiceWorkerPushEventOpArgs> VServiceWorkerPushEventOpArgs;
        mozilla::AlignedStorage2<ServiceWorkerPushSubscriptionChangeEventOpArgs> VServiceWorkerPushSubscriptionChangeEventOpArgs;
        mozilla::AlignedStorage2<ServiceWorkerNotificationEventOpArgs> VServiceWorkerNotificationEventOpArgs;
        mozilla::AlignedStorage2<ServiceWorkerMessageEventOpArgs> VServiceWorkerMessageEventOpArgs;
        mozilla::AlignedStorage2<ServiceWorkerFetchEventOpArgs> VServiceWorkerFetchEventOpArgs;
    };

    ServiceWorkerCheckScriptEvaluationOpArgs*
    ptr_ServiceWorkerCheckScriptEvaluationOpArgs()
    {
        return ((mValue).VServiceWorkerCheckScriptEvaluationOpArgs).addr();
    }
    const ServiceWorkerCheckScriptEvaluationOpArgs*
    constptr_ServiceWorkerCheckScriptEvaluationOpArgs() const
    {
        return ((mValue).VServiceWorkerCheckScriptEvaluationOpArgs).addr();
    }
    ServiceWorkerUpdateStateOpArgs*
    ptr_ServiceWorkerUpdateStateOpArgs()
    {
        return ((mValue).VServiceWorkerUpdateStateOpArgs).addr();
    }
    const ServiceWorkerUpdateStateOpArgs*
    constptr_ServiceWorkerUpdateStateOpArgs() const
    {
        return ((mValue).VServiceWorkerUpdateStateOpArgs).addr();
    }
    ServiceWorkerTerminateWorkerOpArgs*
    ptr_ServiceWorkerTerminateWorkerOpArgs()
    {
        return ((mValue).VServiceWorkerTerminateWorkerOpArgs).addr();
    }
    const ServiceWorkerTerminateWorkerOpArgs*
    constptr_ServiceWorkerTerminateWorkerOpArgs() const
    {
        return ((mValue).VServiceWorkerTerminateWorkerOpArgs).addr();
    }
    ServiceWorkerLifeCycleEventOpArgs*
    ptr_ServiceWorkerLifeCycleEventOpArgs()
    {
        return ((mValue).VServiceWorkerLifeCycleEventOpArgs).addr();
    }
    const ServiceWorkerLifeCycleEventOpArgs*
    constptr_ServiceWorkerLifeCycleEventOpArgs() const
    {
        return ((mValue).VServiceWorkerLifeCycleEventOpArgs).addr();
    }
    ServiceWorkerPushEventOpArgs*
    ptr_ServiceWorkerPushEventOpArgs()
    {
        return ((mValue).VServiceWorkerPushEventOpArgs).addr();
    }
    const ServiceWorkerPushEventOpArgs*
    constptr_ServiceWorkerPushEventOpArgs() const
    {
        return ((mValue).VServiceWorkerPushEventOpArgs).addr();
    }
    ServiceWorkerPushSubscriptionChangeEventOpArgs*
    ptr_ServiceWorkerPushSubscriptionChangeEventOpArgs()
    {
        return ((mValue).VServiceWorkerPushSubscriptionChangeEventOpArgs).addr();
    }
    const ServiceWorkerPushSubscriptionChangeEventOpArgs*
    constptr_ServiceWorkerPushSubscriptionChangeEventOpArgs() const
    {
        return ((mValue).VServiceWorkerPushSubscriptionChangeEventOpArgs).addr();
    }
    ServiceWorkerNotificationEventOpArgs*
    ptr_ServiceWorkerNotificationEventOpArgs()
    {
        return ((mValue).VServiceWorkerNotificationEventOpArgs).addr();
    }
    const ServiceWorkerNotificationEventOpArgs*
    constptr_ServiceWorkerNotificationEventOpArgs() const
    {
        return ((mValue).VServiceWorkerNotificationEventOpArgs).addr();
    }
    ServiceWorkerMessageEventOpArgs*
    ptr_ServiceWorkerMessageEventOpArgs()
    {
        return ((mValue).VServiceWorkerMessageEventOpArgs).addr();
    }
    const ServiceWorkerMessageEventOpArgs*
    constptr_ServiceWorkerMessageEventOpArgs() const
    {
        return ((mValue).VServiceWorkerMessageEventOpArgs).addr();
    }
    ServiceWorkerFetchEventOpArgs*
    ptr_ServiceWorkerFetchEventOpArgs()
    {
        return ((mValue).VServiceWorkerFetchEventOpArgs).addr();
    }
    const ServiceWorkerFetchEventOpArgs*
    constptr_ServiceWorkerFetchEventOpArgs() const
    {
        return ((mValue).VServiceWorkerFetchEventOpArgs).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT ServiceWorkerOpArgs() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT ServiceWorkerOpArgs(const ServiceWorkerCheckScriptEvaluationOpArgs& aOther);

    MOZ_IMPLICIT ServiceWorkerOpArgs(ServiceWorkerCheckScriptEvaluationOpArgs&& aOther);

    MOZ_IMPLICIT ServiceWorkerOpArgs(const ServiceWorkerUpdateStateOpArgs& aOther);

    MOZ_IMPLICIT ServiceWorkerOpArgs(ServiceWorkerUpdateStateOpArgs&& aOther);

    MOZ_IMPLICIT ServiceWorkerOpArgs(const ServiceWorkerTerminateWorkerOpArgs& aOther);

    MOZ_IMPLICIT ServiceWorkerOpArgs(ServiceWorkerTerminateWorkerOpArgs&& aOther);

    MOZ_IMPLICIT ServiceWorkerOpArgs(const ServiceWorkerLifeCycleEventOpArgs& aOther);

    MOZ_IMPLICIT ServiceWorkerOpArgs(ServiceWorkerLifeCycleEventOpArgs&& aOther);

    MOZ_IMPLICIT ServiceWorkerOpArgs(const ServiceWorkerPushEventOpArgs& aOther);

    MOZ_IMPLICIT ServiceWorkerOpArgs(ServiceWorkerPushEventOpArgs&& aOther);

    MOZ_IMPLICIT ServiceWorkerOpArgs(const ServiceWorkerPushSubscriptionChangeEventOpArgs& aOther);

    MOZ_IMPLICIT ServiceWorkerOpArgs(ServiceWorkerPushSubscriptionChangeEventOpArgs&& aOther);

    MOZ_IMPLICIT ServiceWorkerOpArgs(const ServiceWorkerNotificationEventOpArgs& aOther);

    MOZ_IMPLICIT ServiceWorkerOpArgs(ServiceWorkerNotificationEventOpArgs&& aOther);

    MOZ_IMPLICIT ServiceWorkerOpArgs(ServiceWorkerMessageEventOpArgs&& aOther);

    MOZ_IMPLICIT ServiceWorkerOpArgs(const ServiceWorkerFetchEventOpArgs& aOther);

    MOZ_IMPLICIT ServiceWorkerOpArgs(ServiceWorkerFetchEventOpArgs&& aOther);

    MOZ_IMPLICIT ServiceWorkerOpArgs(ServiceWorkerOpArgs&& aOther);

    ~ServiceWorkerOpArgs();

    Type
    type() const
    {
        return mType;
    }

    ServiceWorkerOpArgs&
    operator=(const ServiceWorkerCheckScriptEvaluationOpArgs& aRhs);

    ServiceWorkerOpArgs&
    operator=(ServiceWorkerCheckScriptEvaluationOpArgs&& aRhs);

    ServiceWorkerOpArgs&
    operator=(const ServiceWorkerUpdateStateOpArgs& aRhs);

    ServiceWorkerOpArgs&
    operator=(ServiceWorkerUpdateStateOpArgs&& aRhs);

    ServiceWorkerOpArgs&
    operator=(const ServiceWorkerTerminateWorkerOpArgs& aRhs);

    ServiceWorkerOpArgs&
    operator=(ServiceWorkerTerminateWorkerOpArgs&& aRhs);

    ServiceWorkerOpArgs&
    operator=(const ServiceWorkerLifeCycleEventOpArgs& aRhs);

    ServiceWorkerOpArgs&
    operator=(ServiceWorkerLifeCycleEventOpArgs&& aRhs);

    ServiceWorkerOpArgs&
    operator=(const ServiceWorkerPushEventOpArgs& aRhs);

    ServiceWorkerOpArgs&
    operator=(ServiceWorkerPushEventOpArgs&& aRhs);

    ServiceWorkerOpArgs&
    operator=(const ServiceWorkerPushSubscriptionChangeEventOpArgs& aRhs);

    ServiceWorkerOpArgs&
    operator=(ServiceWorkerPushSubscriptionChangeEventOpArgs&& aRhs);

    ServiceWorkerOpArgs&
    operator=(const ServiceWorkerNotificationEventOpArgs& aRhs);

    ServiceWorkerOpArgs&
    operator=(ServiceWorkerNotificationEventOpArgs&& aRhs);

    ServiceWorkerOpArgs&
    operator=(ServiceWorkerMessageEventOpArgs&& aRhs);

    ServiceWorkerOpArgs&
    operator=(const ServiceWorkerFetchEventOpArgs& aRhs);

    ServiceWorkerOpArgs&
    operator=(ServiceWorkerFetchEventOpArgs&& aRhs);

    ServiceWorkerOpArgs&
    operator=(ServiceWorkerOpArgs&& aRhs);

    ServiceWorkerCheckScriptEvaluationOpArgs&
    get_ServiceWorkerCheckScriptEvaluationOpArgs()
    {
        AssertSanity(TServiceWorkerCheckScriptEvaluationOpArgs);
        return (*(ptr_ServiceWorkerCheckScriptEvaluationOpArgs()));
    }
    const ServiceWorkerCheckScriptEvaluationOpArgs&
    get_ServiceWorkerCheckScriptEvaluationOpArgs() const
    {
        AssertSanity(TServiceWorkerCheckScriptEvaluationOpArgs);
        return (*(constptr_ServiceWorkerCheckScriptEvaluationOpArgs()));
    }
    operator ServiceWorkerCheckScriptEvaluationOpArgs&()
    {
        return get_ServiceWorkerCheckScriptEvaluationOpArgs();
    }
    operator const ServiceWorkerCheckScriptEvaluationOpArgs&() const
    {
        return get_ServiceWorkerCheckScriptEvaluationOpArgs();
    }

    ServiceWorkerUpdateStateOpArgs&
    get_ServiceWorkerUpdateStateOpArgs()
    {
        AssertSanity(TServiceWorkerUpdateStateOpArgs);
        return (*(ptr_ServiceWorkerUpdateStateOpArgs()));
    }
    const ServiceWorkerUpdateStateOpArgs&
    get_ServiceWorkerUpdateStateOpArgs() const
    {
        AssertSanity(TServiceWorkerUpdateStateOpArgs);
        return (*(constptr_ServiceWorkerUpdateStateOpArgs()));
    }
    operator ServiceWorkerUpdateStateOpArgs&()
    {
        return get_ServiceWorkerUpdateStateOpArgs();
    }
    operator const ServiceWorkerUpdateStateOpArgs&() const
    {
        return get_ServiceWorkerUpdateStateOpArgs();
    }

    ServiceWorkerTerminateWorkerOpArgs&
    get_ServiceWorkerTerminateWorkerOpArgs()
    {
        AssertSanity(TServiceWorkerTerminateWorkerOpArgs);
        return (*(ptr_ServiceWorkerTerminateWorkerOpArgs()));
    }
    const ServiceWorkerTerminateWorkerOpArgs&
    get_ServiceWorkerTerminateWorkerOpArgs() const
    {
        AssertSanity(TServiceWorkerTerminateWorkerOpArgs);
        return (*(constptr_ServiceWorkerTerminateWorkerOpArgs()));
    }
    operator ServiceWorkerTerminateWorkerOpArgs&()
    {
        return get_ServiceWorkerTerminateWorkerOpArgs();
    }
    operator const ServiceWorkerTerminateWorkerOpArgs&() const
    {
        return get_ServiceWorkerTerminateWorkerOpArgs();
    }

    ServiceWorkerLifeCycleEventOpArgs&
    get_ServiceWorkerLifeCycleEventOpArgs()
    {
        AssertSanity(TServiceWorkerLifeCycleEventOpArgs);
        return (*(ptr_ServiceWorkerLifeCycleEventOpArgs()));
    }
    const ServiceWorkerLifeCycleEventOpArgs&
    get_ServiceWorkerLifeCycleEventOpArgs() const
    {
        AssertSanity(TServiceWorkerLifeCycleEventOpArgs);
        return (*(constptr_ServiceWorkerLifeCycleEventOpArgs()));
    }
    operator ServiceWorkerLifeCycleEventOpArgs&()
    {
        return get_ServiceWorkerLifeCycleEventOpArgs();
    }
    operator const ServiceWorkerLifeCycleEventOpArgs&() const
    {
        return get_ServiceWorkerLifeCycleEventOpArgs();
    }

    ServiceWorkerPushEventOpArgs&
    get_ServiceWorkerPushEventOpArgs()
    {
        AssertSanity(TServiceWorkerPushEventOpArgs);
        return (*(ptr_ServiceWorkerPushEventOpArgs()));
    }
    const ServiceWorkerPushEventOpArgs&
    get_ServiceWorkerPushEventOpArgs() const
    {
        AssertSanity(TServiceWorkerPushEventOpArgs);
        return (*(constptr_ServiceWorkerPushEventOpArgs()));
    }
    operator ServiceWorkerPushEventOpArgs&()
    {
        return get_ServiceWorkerPushEventOpArgs();
    }
    operator const ServiceWorkerPushEventOpArgs&() const
    {
        return get_ServiceWorkerPushEventOpArgs();
    }

    ServiceWorkerPushSubscriptionChangeEventOpArgs&
    get_ServiceWorkerPushSubscriptionChangeEventOpArgs()
    {
        AssertSanity(TServiceWorkerPushSubscriptionChangeEventOpArgs);
        return (*(ptr_ServiceWorkerPushSubscriptionChangeEventOpArgs()));
    }
    const ServiceWorkerPushSubscriptionChangeEventOpArgs&
    get_ServiceWorkerPushSubscriptionChangeEventOpArgs() const
    {
        AssertSanity(TServiceWorkerPushSubscriptionChangeEventOpArgs);
        return (*(constptr_ServiceWorkerPushSubscriptionChangeEventOpArgs()));
    }
    operator ServiceWorkerPushSubscriptionChangeEventOpArgs&()
    {
        return get_ServiceWorkerPushSubscriptionChangeEventOpArgs();
    }
    operator const ServiceWorkerPushSubscriptionChangeEventOpArgs&() const
    {
        return get_ServiceWorkerPushSubscriptionChangeEventOpArgs();
    }

    ServiceWorkerNotificationEventOpArgs&
    get_ServiceWorkerNotificationEventOpArgs()
    {
        AssertSanity(TServiceWorkerNotificationEventOpArgs);
        return (*(ptr_ServiceWorkerNotificationEventOpArgs()));
    }
    const ServiceWorkerNotificationEventOpArgs&
    get_ServiceWorkerNotificationEventOpArgs() const
    {
        AssertSanity(TServiceWorkerNotificationEventOpArgs);
        return (*(constptr_ServiceWorkerNotificationEventOpArgs()));
    }
    operator ServiceWorkerNotificationEventOpArgs&()
    {
        return get_ServiceWorkerNotificationEventOpArgs();
    }
    operator const ServiceWorkerNotificationEventOpArgs&() const
    {
        return get_ServiceWorkerNotificationEventOpArgs();
    }

    ServiceWorkerMessageEventOpArgs&
    get_ServiceWorkerMessageEventOpArgs()
    {
        AssertSanity(TServiceWorkerMessageEventOpArgs);
        return (*(ptr_ServiceWorkerMessageEventOpArgs()));
    }
    const ServiceWorkerMessageEventOpArgs&
    get_ServiceWorkerMessageEventOpArgs() const
    {
        AssertSanity(TServiceWorkerMessageEventOpArgs);
        return (*(constptr_ServiceWorkerMessageEventOpArgs()));
    }
    operator ServiceWorkerMessageEventOpArgs&()
    {
        return get_ServiceWorkerMessageEventOpArgs();
    }
    operator const ServiceWorkerMessageEventOpArgs&() const
    {
        return get_ServiceWorkerMessageEventOpArgs();
    }

    ServiceWorkerFetchEventOpArgs&
    get_ServiceWorkerFetchEventOpArgs()
    {
        AssertSanity(TServiceWorkerFetchEventOpArgs);
        return (*(ptr_ServiceWorkerFetchEventOpArgs()));
    }
    const ServiceWorkerFetchEventOpArgs&
    get_ServiceWorkerFetchEventOpArgs() const
    {
        AssertSanity(TServiceWorkerFetchEventOpArgs);
        return (*(constptr_ServiceWorkerFetchEventOpArgs()));
    }
    operator ServiceWorkerFetchEventOpArgs&()
    {
        return get_ServiceWorkerFetchEventOpArgs();
    }
    operator const ServiceWorkerFetchEventOpArgs&() const
    {
        return get_ServiceWorkerFetchEventOpArgs();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ServiceWorkerOpArgs>
{
    typedef mozilla::dom::ServiceWorkerOpArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct FetchEventRespondWithClosure|
//
namespace mozilla {
namespace dom {
class FetchEventRespondWithClosure final
{
private:

public:
    MOZ_IMPLICIT FetchEventRespondWithClosure() :
        respondWithScriptSpec_(),
        respondWithLineNumber_(),
        respondWithColumnNumber_()
    {
    }

    MOZ_IMPLICIT FetchEventRespondWithClosure(
            const nsCString& _respondWithScriptSpec,
            const uint32_t& _respondWithLineNumber,
            const uint32_t& _respondWithColumnNumber) :
        respondWithScriptSpec_(_respondWithScriptSpec),
        respondWithLineNumber_(_respondWithLineNumber),
        respondWithColumnNumber_(_respondWithColumnNumber)
    {
    }

    nsCString&
    respondWithScriptSpec()
    {
        return respondWithScriptSpec_;
    }
    const nsCString&
    respondWithScriptSpec() const
    {
        return respondWithScriptSpec_;
    }

    uint32_t&
    respondWithLineNumber()
    {
        return respondWithLineNumber_;
    }
    const uint32_t&
    respondWithLineNumber() const
    {
        return respondWithLineNumber_;
    }

    uint32_t&
    respondWithColumnNumber()
    {
        return respondWithColumnNumber_;
    }
    const uint32_t&
    respondWithColumnNumber() const
    {
        return respondWithColumnNumber_;
    }

private:
    void
    StaticAssertions() const;
    nsCString respondWithScriptSpec_;
    uint32_t respondWithLineNumber_;
    uint32_t respondWithColumnNumber_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::FetchEventRespondWithClosure>
{
    typedef mozilla::dom::FetchEventRespondWithClosure paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct IPCSynthesizeResponseArgs|
//
namespace mozilla {
namespace dom {
class IPCSynthesizeResponseArgs final
{
private:
    typedef mozilla::dom::IPCInternalResponse IPCInternalResponse;
    typedef mozilla::dom::FetchEventRespondWithClosure FetchEventRespondWithClosure;

public:
    MOZ_IMPLICIT IPCSynthesizeResponseArgs() :
        internalResponse_(),
        closure_()
    {
    }

    MOZ_IMPLICIT IPCSynthesizeResponseArgs(
            const IPCInternalResponse& _internalResponse,
            const FetchEventRespondWithClosure& _closure) :
        internalResponse_(_internalResponse),
        closure_(_closure)
    {
    }

    IPCInternalResponse&
    internalResponse()
    {
        return internalResponse_;
    }
    const IPCInternalResponse&
    internalResponse() const
    {
        return internalResponse_;
    }

    FetchEventRespondWithClosure&
    closure()
    {
        return closure_;
    }
    const FetchEventRespondWithClosure&
    closure() const
    {
        return closure_;
    }

private:
    IPCInternalResponse internalResponse_;
    FetchEventRespondWithClosure closure_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPCSynthesizeResponseArgs>
{
    typedef mozilla::dom::IPCSynthesizeResponseArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ResetInterceptionArgs|
//
namespace mozilla {
namespace dom {
class ResetInterceptionArgs final
{
private:

public:
    MOZ_IMPLICIT ResetInterceptionArgs()
    {
    }

private:
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ResetInterceptionArgs>
{
    typedef mozilla::dom::ResetInterceptionArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CancelInterceptionArgs|
//
namespace mozilla {
namespace dom {
class CancelInterceptionArgs final
{
private:

public:
    MOZ_IMPLICIT CancelInterceptionArgs() :
        status_()
    {
    }

    MOZ_IMPLICIT CancelInterceptionArgs(const nsresult& _status) :
        status_(_status)
    {
    }

    nsresult&
    status()
    {
        return status_;
    }
    const nsresult&
    status() const
    {
        return status_;
    }

private:
    nsresult status_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::CancelInterceptionArgs>
{
    typedef mozilla::dom::CancelInterceptionArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union IPCFetchEventRespondWithResult|
//
namespace mozilla {
namespace dom {
class IPCFetchEventRespondWithResult final
{
public:
    enum Type {
        T__None,
        TIPCSynthesizeResponseArgs = 1,
        TResetInterceptionArgs,
        TCancelInterceptionArgs,
        T__Last = TCancelInterceptionArgs
    };

private:
    typedef mozilla::dom::IPCSynthesizeResponseArgs IPCSynthesizeResponseArgs;
    typedef mozilla::dom::ResetInterceptionArgs ResetInterceptionArgs;
    typedef mozilla::dom::CancelInterceptionArgs CancelInterceptionArgs;
    typedef IPCSynthesizeResponseArgs IPCSynthesizeResponseArgs__tdef;
    typedef ResetInterceptionArgs ResetInterceptionArgs__tdef;
    typedef CancelInterceptionArgs CancelInterceptionArgs__tdef;

    union Value {
        mozilla::AlignedStorage2<IPCSynthesizeResponseArgs> VIPCSynthesizeResponseArgs;
        mozilla::AlignedStorage2<ResetInterceptionArgs> VResetInterceptionArgs;
        mozilla::AlignedStorage2<CancelInterceptionArgs> VCancelInterceptionArgs;
    };

    IPCSynthesizeResponseArgs*
    ptr_IPCSynthesizeResponseArgs()
    {
        return ((mValue).VIPCSynthesizeResponseArgs).addr();
    }
    const IPCSynthesizeResponseArgs*
    constptr_IPCSynthesizeResponseArgs() const
    {
        return ((mValue).VIPCSynthesizeResponseArgs).addr();
    }
    ResetInterceptionArgs*
    ptr_ResetInterceptionArgs()
    {
        return ((mValue).VResetInterceptionArgs).addr();
    }
    const ResetInterceptionArgs*
    constptr_ResetInterceptionArgs() const
    {
        return ((mValue).VResetInterceptionArgs).addr();
    }
    CancelInterceptionArgs*
    ptr_CancelInterceptionArgs()
    {
        return ((mValue).VCancelInterceptionArgs).addr();
    }
    const CancelInterceptionArgs*
    constptr_CancelInterceptionArgs() const
    {
        return ((mValue).VCancelInterceptionArgs).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT IPCFetchEventRespondWithResult() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT IPCFetchEventRespondWithResult(const IPCSynthesizeResponseArgs& aOther);

    MOZ_IMPLICIT IPCFetchEventRespondWithResult(IPCSynthesizeResponseArgs&& aOther);

    MOZ_IMPLICIT IPCFetchEventRespondWithResult(const ResetInterceptionArgs& aOther);

    MOZ_IMPLICIT IPCFetchEventRespondWithResult(ResetInterceptionArgs&& aOther);

    MOZ_IMPLICIT IPCFetchEventRespondWithResult(const CancelInterceptionArgs& aOther);

    MOZ_IMPLICIT IPCFetchEventRespondWithResult(CancelInterceptionArgs&& aOther);

    MOZ_IMPLICIT IPCFetchEventRespondWithResult(const IPCFetchEventRespondWithResult& aOther);

    MOZ_IMPLICIT IPCFetchEventRespondWithResult(IPCFetchEventRespondWithResult&& aOther);

    ~IPCFetchEventRespondWithResult();

    Type
    type() const
    {
        return mType;
    }

    IPCFetchEventRespondWithResult&
    operator=(const IPCSynthesizeResponseArgs& aRhs);

    IPCFetchEventRespondWithResult&
    operator=(IPCSynthesizeResponseArgs&& aRhs);

    IPCFetchEventRespondWithResult&
    operator=(const ResetInterceptionArgs& aRhs);

    IPCFetchEventRespondWithResult&
    operator=(ResetInterceptionArgs&& aRhs);

    IPCFetchEventRespondWithResult&
    operator=(const CancelInterceptionArgs& aRhs);

    IPCFetchEventRespondWithResult&
    operator=(CancelInterceptionArgs&& aRhs);

    IPCFetchEventRespondWithResult&
    operator=(const IPCFetchEventRespondWithResult& aRhs);

    IPCFetchEventRespondWithResult&
    operator=(IPCFetchEventRespondWithResult&& aRhs);

    IPCSynthesizeResponseArgs&
    get_IPCSynthesizeResponseArgs()
    {
        AssertSanity(TIPCSynthesizeResponseArgs);
        return (*(ptr_IPCSynthesizeResponseArgs()));
    }
    const IPCSynthesizeResponseArgs&
    get_IPCSynthesizeResponseArgs() const
    {
        AssertSanity(TIPCSynthesizeResponseArgs);
        return (*(constptr_IPCSynthesizeResponseArgs()));
    }
    operator IPCSynthesizeResponseArgs&()
    {
        return get_IPCSynthesizeResponseArgs();
    }
    operator const IPCSynthesizeResponseArgs&() const
    {
        return get_IPCSynthesizeResponseArgs();
    }

    ResetInterceptionArgs&
    get_ResetInterceptionArgs()
    {
        AssertSanity(TResetInterceptionArgs);
        return (*(ptr_ResetInterceptionArgs()));
    }
    const ResetInterceptionArgs&
    get_ResetInterceptionArgs() const
    {
        AssertSanity(TResetInterceptionArgs);
        return (*(constptr_ResetInterceptionArgs()));
    }
    operator ResetInterceptionArgs&()
    {
        return get_ResetInterceptionArgs();
    }
    operator const ResetInterceptionArgs&() const
    {
        return get_ResetInterceptionArgs();
    }

    CancelInterceptionArgs&
    get_CancelInterceptionArgs()
    {
        AssertSanity(TCancelInterceptionArgs);
        return (*(ptr_CancelInterceptionArgs()));
    }
    const CancelInterceptionArgs&
    get_CancelInterceptionArgs() const
    {
        AssertSanity(TCancelInterceptionArgs);
        return (*(constptr_CancelInterceptionArgs()));
    }
    operator CancelInterceptionArgs&()
    {
        return get_CancelInterceptionArgs();
    }
    operator const CancelInterceptionArgs&() const
    {
        return get_CancelInterceptionArgs();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPCFetchEventRespondWithResult>
{
    typedef mozilla::dom::IPCFetchEventRespondWithResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ServiceWorkerCheckScriptEvaluationOpResult|
//
namespace mozilla {
namespace dom {
class ServiceWorkerCheckScriptEvaluationOpResult final
{
private:

public:
    MOZ_IMPLICIT ServiceWorkerCheckScriptEvaluationOpResult() :
        workerScriptExecutedSuccessfully_(),
        fetchHandlerWasAdded_()
    {
    }

    MOZ_IMPLICIT ServiceWorkerCheckScriptEvaluationOpResult(
            const bool& _workerScriptExecutedSuccessfully,
            const bool& _fetchHandlerWasAdded) :
        workerScriptExecutedSuccessfully_(_workerScriptExecutedSuccessfully),
        fetchHandlerWasAdded_(_fetchHandlerWasAdded)
    {
    }

    bool&
    workerScriptExecutedSuccessfully()
    {
        return workerScriptExecutedSuccessfully_;
    }
    const bool&
    workerScriptExecutedSuccessfully() const
    {
        return workerScriptExecutedSuccessfully_;
    }

    bool&
    fetchHandlerWasAdded()
    {
        return fetchHandlerWasAdded_;
    }
    const bool&
    fetchHandlerWasAdded() const
    {
        return fetchHandlerWasAdded_;
    }

private:
    bool workerScriptExecutedSuccessfully_;
    bool fetchHandlerWasAdded_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ServiceWorkerCheckScriptEvaluationOpResult>
{
    typedef mozilla::dom::ServiceWorkerCheckScriptEvaluationOpResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ServiceWorkerFetchEventOpResult|
//
namespace mozilla {
namespace dom {
class ServiceWorkerFetchEventOpResult final
{
private:

public:
    MOZ_IMPLICIT ServiceWorkerFetchEventOpResult() :
        rv_()
    {
    }

    MOZ_IMPLICIT ServiceWorkerFetchEventOpResult(const nsresult& _rv) :
        rv_(_rv)
    {
    }

    nsresult&
    rv()
    {
        return rv_;
    }
    const nsresult&
    rv() const
    {
        return rv_;
    }

private:
    nsresult rv_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ServiceWorkerFetchEventOpResult>
{
    typedef mozilla::dom::ServiceWorkerFetchEventOpResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union ServiceWorkerOpResult|
//
namespace mozilla {
namespace dom {
class ServiceWorkerOpResult final
{
public:
    enum Type {
        T__None,
        Tnsresult = 1,
        TServiceWorkerCheckScriptEvaluationOpResult,
        TServiceWorkerFetchEventOpResult,
        T__Last = TServiceWorkerFetchEventOpResult
    };

private:
    typedef mozilla::dom::ServiceWorkerCheckScriptEvaluationOpResult ServiceWorkerCheckScriptEvaluationOpResult;
    typedef mozilla::dom::ServiceWorkerFetchEventOpResult ServiceWorkerFetchEventOpResult;
    typedef nsresult nsresult__tdef;
    typedef ServiceWorkerCheckScriptEvaluationOpResult ServiceWorkerCheckScriptEvaluationOpResult__tdef;
    typedef ServiceWorkerFetchEventOpResult ServiceWorkerFetchEventOpResult__tdef;

    union Value {
        mozilla::AlignedStorage2<nsresult> Vnsresult;
        mozilla::AlignedStorage2<ServiceWorkerCheckScriptEvaluationOpResult> VServiceWorkerCheckScriptEvaluationOpResult;
        mozilla::AlignedStorage2<ServiceWorkerFetchEventOpResult> VServiceWorkerFetchEventOpResult;
    };

    nsresult*
    ptr_nsresult()
    {
        return ((mValue).Vnsresult).addr();
    }
    const nsresult*
    constptr_nsresult() const
    {
        return ((mValue).Vnsresult).addr();
    }
    ServiceWorkerCheckScriptEvaluationOpResult*
    ptr_ServiceWorkerCheckScriptEvaluationOpResult()
    {
        return ((mValue).VServiceWorkerCheckScriptEvaluationOpResult).addr();
    }
    const ServiceWorkerCheckScriptEvaluationOpResult*
    constptr_ServiceWorkerCheckScriptEvaluationOpResult() const
    {
        return ((mValue).VServiceWorkerCheckScriptEvaluationOpResult).addr();
    }
    ServiceWorkerFetchEventOpResult*
    ptr_ServiceWorkerFetchEventOpResult()
    {
        return ((mValue).VServiceWorkerFetchEventOpResult).addr();
    }
    const ServiceWorkerFetchEventOpResult*
    constptr_ServiceWorkerFetchEventOpResult() const
    {
        return ((mValue).VServiceWorkerFetchEventOpResult).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT ServiceWorkerOpResult() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT ServiceWorkerOpResult(const nsresult& aOther);

    MOZ_IMPLICIT ServiceWorkerOpResult(nsresult&& aOther);

    MOZ_IMPLICIT ServiceWorkerOpResult(const ServiceWorkerCheckScriptEvaluationOpResult& aOther);

    MOZ_IMPLICIT ServiceWorkerOpResult(ServiceWorkerCheckScriptEvaluationOpResult&& aOther);

    MOZ_IMPLICIT ServiceWorkerOpResult(const ServiceWorkerFetchEventOpResult& aOther);

    MOZ_IMPLICIT ServiceWorkerOpResult(ServiceWorkerFetchEventOpResult&& aOther);

    MOZ_IMPLICIT ServiceWorkerOpResult(const ServiceWorkerOpResult& aOther);

    MOZ_IMPLICIT ServiceWorkerOpResult(ServiceWorkerOpResult&& aOther);

    ~ServiceWorkerOpResult();

    Type
    type() const
    {
        return mType;
    }

    ServiceWorkerOpResult&
    operator=(const nsresult& aRhs);

    ServiceWorkerOpResult&
    operator=(nsresult&& aRhs);

    ServiceWorkerOpResult&
    operator=(const ServiceWorkerCheckScriptEvaluationOpResult& aRhs);

    ServiceWorkerOpResult&
    operator=(ServiceWorkerCheckScriptEvaluationOpResult&& aRhs);

    ServiceWorkerOpResult&
    operator=(const ServiceWorkerFetchEventOpResult& aRhs);

    ServiceWorkerOpResult&
    operator=(ServiceWorkerFetchEventOpResult&& aRhs);

    ServiceWorkerOpResult&
    operator=(const ServiceWorkerOpResult& aRhs);

    ServiceWorkerOpResult&
    operator=(ServiceWorkerOpResult&& aRhs);

    nsresult&
    get_nsresult()
    {
        AssertSanity(Tnsresult);
        return (*(ptr_nsresult()));
    }
    const nsresult&
    get_nsresult() const
    {
        AssertSanity(Tnsresult);
        return (*(constptr_nsresult()));
    }
    operator nsresult&()
    {
        return get_nsresult();
    }
    operator const nsresult&() const
    {
        return get_nsresult();
    }

    ServiceWorkerCheckScriptEvaluationOpResult&
    get_ServiceWorkerCheckScriptEvaluationOpResult()
    {
        AssertSanity(TServiceWorkerCheckScriptEvaluationOpResult);
        return (*(ptr_ServiceWorkerCheckScriptEvaluationOpResult()));
    }
    const ServiceWorkerCheckScriptEvaluationOpResult&
    get_ServiceWorkerCheckScriptEvaluationOpResult() const
    {
        AssertSanity(TServiceWorkerCheckScriptEvaluationOpResult);
        return (*(constptr_ServiceWorkerCheckScriptEvaluationOpResult()));
    }
    operator ServiceWorkerCheckScriptEvaluationOpResult&()
    {
        return get_ServiceWorkerCheckScriptEvaluationOpResult();
    }
    operator const ServiceWorkerCheckScriptEvaluationOpResult&() const
    {
        return get_ServiceWorkerCheckScriptEvaluationOpResult();
    }

    ServiceWorkerFetchEventOpResult&
    get_ServiceWorkerFetchEventOpResult()
    {
        AssertSanity(TServiceWorkerFetchEventOpResult);
        return (*(ptr_ServiceWorkerFetchEventOpResult()));
    }
    const ServiceWorkerFetchEventOpResult&
    get_ServiceWorkerFetchEventOpResult() const
    {
        AssertSanity(TServiceWorkerFetchEventOpResult);
        return (*(constptr_ServiceWorkerFetchEventOpResult()));
    }
    operator ServiceWorkerFetchEventOpResult&()
    {
        return get_ServiceWorkerFetchEventOpResult();
    }
    operator const ServiceWorkerFetchEventOpResult&() const
    {
        return get_ServiceWorkerFetchEventOpResult();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ServiceWorkerOpResult>
{
    typedef mozilla::dom::ServiceWorkerOpResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

#endif // ifndef ServiceWorkerOpArgs_h
