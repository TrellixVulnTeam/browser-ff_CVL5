//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef IPCServiceWorkerRegistrationDescriptor_h
#define IPCServiceWorkerRegistrationDescriptor_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "mozilla/ErrorResult.h"
#include "mozilla/dom/ServiceWorkerRegistrationBinding.h"
#include "mozilla/ipc/PBackgroundSharedTypes.h"
#include "mozilla/dom/IPCServiceWorkerDescriptor.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct IPCServiceWorkerRegistrationDescriptor|
//
namespace mozilla {
namespace dom {
class IPCServiceWorkerRegistrationDescriptor final
{
private:
    typedef mozilla::ipc::PrincipalInfo PrincipalInfo;
    typedef mozilla::dom::IPCServiceWorkerDescriptor IPCServiceWorkerDescriptor;

public:
    MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptor() :
        principalInfo_(),
        scope_(),
        updateViaCache_(),
        installing_(),
        waiting_(),
        active_(),
        id_(),
        version_()
    {
    }

    MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptor(
            const uint64_t& _id,
            const uint64_t& _version,
            const PrincipalInfo& _principalInfo,
            const nsCString& _scope,
            const ServiceWorkerUpdateViaCache& _updateViaCache,
            const mozilla::Maybe<IPCServiceWorkerDescriptor>& _installing,
            const mozilla::Maybe<IPCServiceWorkerDescriptor>& _waiting,
            const mozilla::Maybe<IPCServiceWorkerDescriptor>& _active) :
        principalInfo_(_principalInfo),
        scope_(_scope),
        updateViaCache_(_updateViaCache),
        installing_(_installing),
        waiting_(_waiting),
        active_(_active),
        id_(_id),
        version_(_version)
    {
    }

    bool
    operator==(const IPCServiceWorkerRegistrationDescriptor& _o) const;

    bool
    operator!=(const IPCServiceWorkerRegistrationDescriptor& _o) const;

    uint64_t&
    id()
    {
        return id_;
    }
    const uint64_t&
    id() const
    {
        return id_;
    }

    uint64_t&
    version()
    {
        return version_;
    }
    const uint64_t&
    version() const
    {
        return version_;
    }

    PrincipalInfo&
    principalInfo()
    {
        return principalInfo_;
    }
    const PrincipalInfo&
    principalInfo() const
    {
        return principalInfo_;
    }

    nsCString&
    scope()
    {
        return scope_;
    }
    const nsCString&
    scope() const
    {
        return scope_;
    }

    ServiceWorkerUpdateViaCache&
    updateViaCache()
    {
        return updateViaCache_;
    }
    const ServiceWorkerUpdateViaCache&
    updateViaCache() const
    {
        return updateViaCache_;
    }

    mozilla::Maybe<IPCServiceWorkerDescriptor>&
    installing()
    {
        return installing_;
    }
    const mozilla::Maybe<IPCServiceWorkerDescriptor>&
    installing() const
    {
        return installing_;
    }

    mozilla::Maybe<IPCServiceWorkerDescriptor>&
    waiting()
    {
        return waiting_;
    }
    const mozilla::Maybe<IPCServiceWorkerDescriptor>&
    waiting() const
    {
        return waiting_;
    }

    mozilla::Maybe<IPCServiceWorkerDescriptor>&
    active()
    {
        return active_;
    }
    const mozilla::Maybe<IPCServiceWorkerDescriptor>&
    active() const
    {
        return active_;
    }

private:
    void
    StaticAssertions() const;
    PrincipalInfo principalInfo_;
    nsCString scope_;
    ServiceWorkerUpdateViaCache updateViaCache_;
    mozilla::Maybe<IPCServiceWorkerDescriptor> installing_;
    mozilla::Maybe<IPCServiceWorkerDescriptor> waiting_;
    mozilla::Maybe<IPCServiceWorkerDescriptor> active_;
    uint64_t id_;
    uint64_t version_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPCServiceWorkerRegistrationDescriptor>
{
    typedef mozilla::dom::IPCServiceWorkerRegistrationDescriptor paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult|
//
namespace mozilla {
namespace dom {
class IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult final
{
public:
    enum Type {
        T__None,
        TIPCServiceWorkerRegistrationDescriptor = 1,
        TCopyableErrorResult,
        T__Last = TCopyableErrorResult
    };

private:
    typedef mozilla::dom::IPCServiceWorkerRegistrationDescriptor IPCServiceWorkerRegistrationDescriptor;
    typedef mozilla::CopyableErrorResult CopyableErrorResult;
    typedef IPCServiceWorkerRegistrationDescriptor IPCServiceWorkerRegistrationDescriptor__tdef;
    typedef CopyableErrorResult CopyableErrorResult__tdef;

    union Value {
        mozilla::AlignedStorage2<IPCServiceWorkerRegistrationDescriptor> VIPCServiceWorkerRegistrationDescriptor;
        mozilla::AlignedStorage2<CopyableErrorResult> VCopyableErrorResult;
    };

    IPCServiceWorkerRegistrationDescriptor*
    ptr_IPCServiceWorkerRegistrationDescriptor()
    {
        return ((mValue).VIPCServiceWorkerRegistrationDescriptor).addr();
    }
    const IPCServiceWorkerRegistrationDescriptor*
    constptr_IPCServiceWorkerRegistrationDescriptor() const
    {
        return ((mValue).VIPCServiceWorkerRegistrationDescriptor).addr();
    }
    CopyableErrorResult*
    ptr_CopyableErrorResult()
    {
        return ((mValue).VCopyableErrorResult).addr();
    }
    const CopyableErrorResult*
    constptr_CopyableErrorResult() const
    {
        return ((mValue).VCopyableErrorResult).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult(const IPCServiceWorkerRegistrationDescriptor& aOther);

    MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult(IPCServiceWorkerRegistrationDescriptor&& aOther);

    MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult(const CopyableErrorResult& aOther);

    MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult(CopyableErrorResult&& aOther);

    MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult(const IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult& aOther);

    MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult(IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult&& aOther);

    ~IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult();

    Type
    type() const
    {
        return mType;
    }

    IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult&
    operator=(const IPCServiceWorkerRegistrationDescriptor& aRhs);

    IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult&
    operator=(IPCServiceWorkerRegistrationDescriptor&& aRhs);

    IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult&
    operator=(const CopyableErrorResult& aRhs);

    IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult&
    operator=(CopyableErrorResult&& aRhs);

    IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult&
    operator=(const IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult& aRhs);

    IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult&
    operator=(IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult&& aRhs);

    IPCServiceWorkerRegistrationDescriptor&
    get_IPCServiceWorkerRegistrationDescriptor()
    {
        AssertSanity(TIPCServiceWorkerRegistrationDescriptor);
        return (*(ptr_IPCServiceWorkerRegistrationDescriptor()));
    }
    const IPCServiceWorkerRegistrationDescriptor&
    get_IPCServiceWorkerRegistrationDescriptor() const
    {
        AssertSanity(TIPCServiceWorkerRegistrationDescriptor);
        return (*(constptr_IPCServiceWorkerRegistrationDescriptor()));
    }
    operator IPCServiceWorkerRegistrationDescriptor&()
    {
        return get_IPCServiceWorkerRegistrationDescriptor();
    }
    operator const IPCServiceWorkerRegistrationDescriptor&() const
    {
        return get_IPCServiceWorkerRegistrationDescriptor();
    }

    CopyableErrorResult&
    get_CopyableErrorResult()
    {
        AssertSanity(TCopyableErrorResult);
        return (*(ptr_CopyableErrorResult()));
    }
    const CopyableErrorResult&
    get_CopyableErrorResult() const
    {
        AssertSanity(TCopyableErrorResult);
        return (*(constptr_CopyableErrorResult()));
    }
    operator CopyableErrorResult&()
    {
        return get_CopyableErrorResult();
    }
    operator const CopyableErrorResult&() const
    {
        return get_CopyableErrorResult();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult>
{
    typedef mozilla::dom::IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct IPCServiceWorkerRegistrationDescriptorList|
//
namespace mozilla {
namespace dom {
class IPCServiceWorkerRegistrationDescriptorList final
{
private:
    typedef mozilla::dom::IPCServiceWorkerRegistrationDescriptor IPCServiceWorkerRegistrationDescriptor;

public:
    MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorList() :
        values_()
    {
    }

    MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorList(const nsTArray<IPCServiceWorkerRegistrationDescriptor>& _values) :
        values_(_values)
    {
    }

    nsTArray<IPCServiceWorkerRegistrationDescriptor>&
    values()
    {
        return values_;
    }
    const nsTArray<IPCServiceWorkerRegistrationDescriptor>&
    values() const
    {
        return values_;
    }

private:
    CopyableTArray<IPCServiceWorkerRegistrationDescriptor> values_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPCServiceWorkerRegistrationDescriptorList>
{
    typedef mozilla::dom::IPCServiceWorkerRegistrationDescriptorList paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult|
//
namespace mozilla {
namespace dom {
class IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult final
{
public:
    enum Type {
        T__None,
        TIPCServiceWorkerRegistrationDescriptorList = 1,
        TCopyableErrorResult,
        T__Last = TCopyableErrorResult
    };

private:
    typedef mozilla::dom::IPCServiceWorkerRegistrationDescriptorList IPCServiceWorkerRegistrationDescriptorList;
    typedef mozilla::CopyableErrorResult CopyableErrorResult;
    typedef IPCServiceWorkerRegistrationDescriptorList IPCServiceWorkerRegistrationDescriptorList__tdef;
    typedef CopyableErrorResult CopyableErrorResult__tdef;

    union Value {
        mozilla::AlignedStorage2<IPCServiceWorkerRegistrationDescriptorList> VIPCServiceWorkerRegistrationDescriptorList;
        mozilla::AlignedStorage2<CopyableErrorResult> VCopyableErrorResult;
    };

    IPCServiceWorkerRegistrationDescriptorList*
    ptr_IPCServiceWorkerRegistrationDescriptorList()
    {
        return ((mValue).VIPCServiceWorkerRegistrationDescriptorList).addr();
    }
    const IPCServiceWorkerRegistrationDescriptorList*
    constptr_IPCServiceWorkerRegistrationDescriptorList() const
    {
        return ((mValue).VIPCServiceWorkerRegistrationDescriptorList).addr();
    }
    CopyableErrorResult*
    ptr_CopyableErrorResult()
    {
        return ((mValue).VCopyableErrorResult).addr();
    }
    const CopyableErrorResult*
    constptr_CopyableErrorResult() const
    {
        return ((mValue).VCopyableErrorResult).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult(const IPCServiceWorkerRegistrationDescriptorList& aOther);

    MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult(IPCServiceWorkerRegistrationDescriptorList&& aOther);

    MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult(const CopyableErrorResult& aOther);

    MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult(CopyableErrorResult&& aOther);

    MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult(const IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult& aOther);

    MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult(IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult&& aOther);

    ~IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult();

    Type
    type() const
    {
        return mType;
    }

    IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult&
    operator=(const IPCServiceWorkerRegistrationDescriptorList& aRhs);

    IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult&
    operator=(IPCServiceWorkerRegistrationDescriptorList&& aRhs);

    IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult&
    operator=(const CopyableErrorResult& aRhs);

    IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult&
    operator=(CopyableErrorResult&& aRhs);

    IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult&
    operator=(const IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult& aRhs);

    IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult&
    operator=(IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult&& aRhs);

    IPCServiceWorkerRegistrationDescriptorList&
    get_IPCServiceWorkerRegistrationDescriptorList()
    {
        AssertSanity(TIPCServiceWorkerRegistrationDescriptorList);
        return (*(ptr_IPCServiceWorkerRegistrationDescriptorList()));
    }
    const IPCServiceWorkerRegistrationDescriptorList&
    get_IPCServiceWorkerRegistrationDescriptorList() const
    {
        AssertSanity(TIPCServiceWorkerRegistrationDescriptorList);
        return (*(constptr_IPCServiceWorkerRegistrationDescriptorList()));
    }
    operator IPCServiceWorkerRegistrationDescriptorList&()
    {
        return get_IPCServiceWorkerRegistrationDescriptorList();
    }
    operator const IPCServiceWorkerRegistrationDescriptorList&() const
    {
        return get_IPCServiceWorkerRegistrationDescriptorList();
    }

    CopyableErrorResult&
    get_CopyableErrorResult()
    {
        AssertSanity(TCopyableErrorResult);
        return (*(ptr_CopyableErrorResult()));
    }
    const CopyableErrorResult&
    get_CopyableErrorResult() const
    {
        AssertSanity(TCopyableErrorResult);
        return (*(constptr_CopyableErrorResult()));
    }
    operator CopyableErrorResult&()
    {
        return get_CopyableErrorResult();
    }
    operator const CopyableErrorResult&() const
    {
        return get_CopyableErrorResult();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult>
{
    typedef mozilla::dom::IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

#endif // ifndef IPCServiceWorkerRegistrationDescriptor_h
