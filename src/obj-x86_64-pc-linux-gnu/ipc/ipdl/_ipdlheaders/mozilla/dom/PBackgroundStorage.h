//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PBackgroundStorage_h
#define PBackgroundStorage_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

namespace mozilla {
namespace dom {
class PBackgroundStorageParent;
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
class PBackgroundStorageChild;
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Code common to PBackgroundStorageChild and PBackgroundStorageParent
//
namespace mozilla {
namespace dom {
namespace PBackgroundStorage {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::dom::PBackgroundStorageParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::dom::PBackgroundStorageChild>* aChild);

enum MessageType {
    PBackgroundStorageStart = PBackgroundStorageMsgStart << 16,
    Msg_DeleteMe__ID,
    Msg_Preload__ID,
    Reply_Preload__ID,
    Msg_AsyncPreload__ID,
    Msg_AsyncGetUsage__ID,
    Msg_AsyncAddItem__ID,
    Msg_AsyncUpdateItem__ID,
    Msg_AsyncRemoveItem__ID,
    Msg_AsyncClear__ID,
    Msg_AsyncFlush__ID,
    Msg_Startup__ID,
    Msg_ClearAll__ID,
    Msg_ClearMatchingOrigin__ID,
    Msg_ClearMatchingOriginAttributes__ID,
    Msg___delete____ID,
    Reply___delete____ID,
    Msg_Observe__ID,
    Msg_OriginsHavingData__ID,
    Msg_LoadItem__ID,
    Msg_LoadDone__ID,
    Msg_LoadUsage__ID,
    Msg_Error__ID,
    PBackgroundStorageEnd
};

IPC::Message*
Msg_DeleteMe(int32_t routingId);

IPC::Message*
Msg_Preload(int32_t routingId);
IPC::Message*
Reply_Preload(int32_t routingId);

IPC::Message*
Msg_AsyncPreload(int32_t routingId);

IPC::Message*
Msg_AsyncGetUsage(int32_t routingId);

IPC::Message*
Msg_AsyncAddItem(int32_t routingId);

IPC::Message*
Msg_AsyncUpdateItem(int32_t routingId);

IPC::Message*
Msg_AsyncRemoveItem(int32_t routingId);

IPC::Message*
Msg_AsyncClear(int32_t routingId);

IPC::Message*
Msg_AsyncFlush(int32_t routingId);

IPC::Message*
Msg_Startup(int32_t routingId);

IPC::Message*
Msg_ClearAll(int32_t routingId);

IPC::Message*
Msg_ClearMatchingOrigin(int32_t routingId);

IPC::Message*
Msg_ClearMatchingOriginAttributes(int32_t routingId);

IPC::Message*
Msg___delete__(int32_t routingId);
IPC::Message*
Reply___delete__(int32_t routingId);

IPC::Message*
Msg_Observe(int32_t routingId);

IPC::Message*
Msg_OriginsHavingData(int32_t routingId);

IPC::Message*
Msg_LoadItem(int32_t routingId);

IPC::Message*
Msg_LoadDone(int32_t routingId);

IPC::Message*
Msg_LoadUsage(int32_t routingId);

IPC::Message*
Msg_Error(int32_t routingId);



} // namespace PBackgroundStorage
} // namespace dom
} // namespace mozilla

#endif // ifndef PBackgroundStorage_h
