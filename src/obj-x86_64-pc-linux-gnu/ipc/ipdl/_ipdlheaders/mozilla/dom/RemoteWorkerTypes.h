//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef RemoteWorkerTypes_h
#define RemoteWorkerTypes_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "mozilla/StorageAccess.h"
#include "mozilla/ipc/IPCCore.h"
#include "mozilla/dom/ClientIPCTypes.h"
#include "mozilla/dom/IPCServiceWorkerDescriptor.h"
#include "mozilla/dom/IPCServiceWorkerRegistrationDescriptor.h"
#include "mozilla/ipc/PBackgroundSharedTypes.h"
#include "mozilla/ipc/URIParams.h"
#include "mozilla/dom/DOMTypes.h"
#include "mozilla/net/NeckoChannelParams.h"
#include "mozilla/ipc/ProtocolTypes.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ServiceWorkerData|
//
namespace mozilla {
namespace dom {
class ServiceWorkerData final
{
private:
    typedef mozilla::dom::IPCServiceWorkerDescriptor IPCServiceWorkerDescriptor;
    typedef mozilla::dom::IPCServiceWorkerRegistrationDescriptor IPCServiceWorkerRegistrationDescriptor;

public:
    MOZ_IMPLICIT ServiceWorkerData() :
        descriptor_(),
        registrationDescriptor_(),
        cacheName_(),
        id_(),
        loadFlags_()
    {
    }

    MOZ_IMPLICIT ServiceWorkerData(
            const IPCServiceWorkerDescriptor& _descriptor,
            const IPCServiceWorkerRegistrationDescriptor& _registrationDescriptor,
            const nsString& _cacheName,
            const uint32_t& _loadFlags,
            const nsString& _id) :
        descriptor_(_descriptor),
        registrationDescriptor_(_registrationDescriptor),
        cacheName_(_cacheName),
        id_(_id),
        loadFlags_(_loadFlags)
    {
    }

    IPCServiceWorkerDescriptor&
    descriptor()
    {
        return descriptor_;
    }
    const IPCServiceWorkerDescriptor&
    descriptor() const
    {
        return descriptor_;
    }

    IPCServiceWorkerRegistrationDescriptor&
    registrationDescriptor()
    {
        return registrationDescriptor_;
    }
    const IPCServiceWorkerRegistrationDescriptor&
    registrationDescriptor() const
    {
        return registrationDescriptor_;
    }

    nsString&
    cacheName()
    {
        return cacheName_;
    }
    const nsString&
    cacheName() const
    {
        return cacheName_;
    }

    uint32_t&
    loadFlags()
    {
        return loadFlags_;
    }
    const uint32_t&
    loadFlags() const
    {
        return loadFlags_;
    }

    nsString&
    id()
    {
        return id_;
    }
    const nsString&
    id() const
    {
        return id_;
    }

private:
    IPCServiceWorkerDescriptor descriptor_;
    IPCServiceWorkerRegistrationDescriptor registrationDescriptor_;
    nsString cacheName_;
    nsString id_;
    uint32_t loadFlags_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ServiceWorkerData>
{
    typedef mozilla::dom::ServiceWorkerData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union OptionalServiceWorkerData|
//
namespace mozilla {
namespace dom {
class OptionalServiceWorkerData final
{
public:
    enum Type {
        T__None,
        Tvoid_t = 1,
        TServiceWorkerData,
        T__Last = TServiceWorkerData
    };

private:
    typedef mozilla::void_t void_t;
    typedef mozilla::dom::ServiceWorkerData ServiceWorkerData;
    typedef void_t void_t__tdef;
    typedef ServiceWorkerData ServiceWorkerData__tdef;

    union Value {
        mozilla::AlignedStorage2<void_t> Vvoid_t;
        mozilla::AlignedStorage2<ServiceWorkerData> VServiceWorkerData;
    };

    void_t*
    ptr_void_t()
    {
        return ((mValue).Vvoid_t).addr();
    }
    const void_t*
    constptr_void_t() const
    {
        return ((mValue).Vvoid_t).addr();
    }
    ServiceWorkerData*
    ptr_ServiceWorkerData()
    {
        return ((mValue).VServiceWorkerData).addr();
    }
    const ServiceWorkerData*
    constptr_ServiceWorkerData() const
    {
        return ((mValue).VServiceWorkerData).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT OptionalServiceWorkerData() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT OptionalServiceWorkerData(const void_t& aOther);

    MOZ_IMPLICIT OptionalServiceWorkerData(void_t&& aOther);

    MOZ_IMPLICIT OptionalServiceWorkerData(const ServiceWorkerData& aOther);

    MOZ_IMPLICIT OptionalServiceWorkerData(ServiceWorkerData&& aOther);

    MOZ_IMPLICIT OptionalServiceWorkerData(const OptionalServiceWorkerData& aOther);

    MOZ_IMPLICIT OptionalServiceWorkerData(OptionalServiceWorkerData&& aOther);

    ~OptionalServiceWorkerData();

    Type
    type() const
    {
        return mType;
    }

    OptionalServiceWorkerData&
    operator=(const void_t& aRhs);

    OptionalServiceWorkerData&
    operator=(void_t&& aRhs);

    OptionalServiceWorkerData&
    operator=(const ServiceWorkerData& aRhs);

    OptionalServiceWorkerData&
    operator=(ServiceWorkerData&& aRhs);

    OptionalServiceWorkerData&
    operator=(const OptionalServiceWorkerData& aRhs);

    OptionalServiceWorkerData&
    operator=(OptionalServiceWorkerData&& aRhs);

    void_t&
    get_void_t()
    {
        AssertSanity(Tvoid_t);
        return (*(ptr_void_t()));
    }
    const void_t&
    get_void_t() const
    {
        AssertSanity(Tvoid_t);
        return (*(constptr_void_t()));
    }
    operator void_t&()
    {
        return get_void_t();
    }
    operator const void_t&() const
    {
        return get_void_t();
    }

    ServiceWorkerData&
    get_ServiceWorkerData()
    {
        AssertSanity(TServiceWorkerData);
        return (*(ptr_ServiceWorkerData()));
    }
    const ServiceWorkerData&
    get_ServiceWorkerData() const
    {
        AssertSanity(TServiceWorkerData);
        return (*(constptr_ServiceWorkerData()));
    }
    operator ServiceWorkerData&()
    {
        return get_ServiceWorkerData();
    }
    operator const ServiceWorkerData&() const
    {
        return get_ServiceWorkerData();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::OptionalServiceWorkerData>
{
    typedef mozilla::dom::OptionalServiceWorkerData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct RemoteWorkerData|
//
namespace mozilla {
namespace dom {
class RemoteWorkerData final
{
private:
    typedef mozilla::ipc::URIParams URIParams;
    typedef mozilla::ipc::PrincipalInfo PrincipalInfo;
    typedef mozilla::net::CookieJarSettingsArgs CookieJarSettingsArgs;
    typedef mozilla::dom::IPCClientInfo IPCClientInfo;
    typedef mozilla::StorageAccess StorageAccess;
    typedef mozilla::dom::OptionalServiceWorkerData OptionalServiceWorkerData;

public:
    MOZ_IMPLICIT RemoteWorkerData() :
        originalScriptURL_(),
        baseScriptURL_(),
        resolvedScriptURL_(),
        name_(),
        loadingPrincipalInfo_(),
        principalInfo_(),
        partitionedPrincipalInfo_(),
        useRegularPrincipal_(),
        hasStorageAccessPermissionGranted_(),
        cookieJarSettings_(),
        domain_(),
        isSecureContext_(),
        clientInfo_(),
        referrerInfo_(),
        storageAccess_(),
        serviceWorkerData_(),
        agentClusterId_(),
        remoteType_()
    {
    }

    MOZ_IMPLICIT RemoteWorkerData(
            const nsString& _originalScriptURL,
            const URIParams& _baseScriptURL,
            const URIParams& _resolvedScriptURL,
            const nsString& _name,
            const PrincipalInfo& _loadingPrincipalInfo,
            const PrincipalInfo& _principalInfo,
            const PrincipalInfo& _partitionedPrincipalInfo,
            const bool& _useRegularPrincipal,
            const bool& _hasStorageAccessPermissionGranted,
            const CookieJarSettingsArgs& _cookieJarSettings,
            const nsCString& _domain,
            const bool& _isSecureContext,
            const mozilla::Maybe<IPCClientInfo>& _clientInfo,
            nsIReferrerInfo* _referrerInfo,
            const StorageAccess& _storageAccess,
            const OptionalServiceWorkerData& _serviceWorkerData,
            const nsID& _agentClusterId,
            const nsCString& _remoteType) :
        originalScriptURL_(_originalScriptURL),
        baseScriptURL_(_baseScriptURL),
        resolvedScriptURL_(_resolvedScriptURL),
        name_(_name),
        loadingPrincipalInfo_(_loadingPrincipalInfo),
        principalInfo_(_principalInfo),
        partitionedPrincipalInfo_(_partitionedPrincipalInfo),
        useRegularPrincipal_(_useRegularPrincipal),
        hasStorageAccessPermissionGranted_(_hasStorageAccessPermissionGranted),
        cookieJarSettings_(_cookieJarSettings),
        domain_(_domain),
        isSecureContext_(_isSecureContext),
        clientInfo_(_clientInfo),
        referrerInfo_(_referrerInfo),
        storageAccess_(_storageAccess),
        serviceWorkerData_(_serviceWorkerData),
        agentClusterId_(_agentClusterId),
        remoteType_(_remoteType)
    {
    }

    nsString&
    originalScriptURL()
    {
        return originalScriptURL_;
    }
    const nsString&
    originalScriptURL() const
    {
        return originalScriptURL_;
    }

    URIParams&
    baseScriptURL()
    {
        return baseScriptURL_;
    }
    const URIParams&
    baseScriptURL() const
    {
        return baseScriptURL_;
    }

    URIParams&
    resolvedScriptURL()
    {
        return resolvedScriptURL_;
    }
    const URIParams&
    resolvedScriptURL() const
    {
        return resolvedScriptURL_;
    }

    nsString&
    name()
    {
        return name_;
    }
    const nsString&
    name() const
    {
        return name_;
    }

    PrincipalInfo&
    loadingPrincipalInfo()
    {
        return loadingPrincipalInfo_;
    }
    const PrincipalInfo&
    loadingPrincipalInfo() const
    {
        return loadingPrincipalInfo_;
    }

    PrincipalInfo&
    principalInfo()
    {
        return principalInfo_;
    }
    const PrincipalInfo&
    principalInfo() const
    {
        return principalInfo_;
    }

    PrincipalInfo&
    partitionedPrincipalInfo()
    {
        return partitionedPrincipalInfo_;
    }
    const PrincipalInfo&
    partitionedPrincipalInfo() const
    {
        return partitionedPrincipalInfo_;
    }

    bool&
    useRegularPrincipal()
    {
        return useRegularPrincipal_;
    }
    const bool&
    useRegularPrincipal() const
    {
        return useRegularPrincipal_;
    }

    bool&
    hasStorageAccessPermissionGranted()
    {
        return hasStorageAccessPermissionGranted_;
    }
    const bool&
    hasStorageAccessPermissionGranted() const
    {
        return hasStorageAccessPermissionGranted_;
    }

    CookieJarSettingsArgs&
    cookieJarSettings()
    {
        return cookieJarSettings_;
    }
    const CookieJarSettingsArgs&
    cookieJarSettings() const
    {
        return cookieJarSettings_;
    }

    nsCString&
    domain()
    {
        return domain_;
    }
    const nsCString&
    domain() const
    {
        return domain_;
    }

    bool&
    isSecureContext()
    {
        return isSecureContext_;
    }
    const bool&
    isSecureContext() const
    {
        return isSecureContext_;
    }

    mozilla::Maybe<IPCClientInfo>&
    clientInfo()
    {
        return clientInfo_;
    }
    const mozilla::Maybe<IPCClientInfo>&
    clientInfo() const
    {
        return clientInfo_;
    }

    RefPtr<nsIReferrerInfo>&
    referrerInfo()
    {
        return referrerInfo_;
    }
    nsIReferrerInfo*
    referrerInfo() const
    {
        return referrerInfo_;
    }

    StorageAccess&
    storageAccess()
    {
        return storageAccess_;
    }
    const StorageAccess&
    storageAccess() const
    {
        return storageAccess_;
    }

    OptionalServiceWorkerData&
    serviceWorkerData()
    {
        return serviceWorkerData_;
    }
    const OptionalServiceWorkerData&
    serviceWorkerData() const
    {
        return serviceWorkerData_;
    }

    nsID&
    agentClusterId()
    {
        return agentClusterId_;
    }
    const nsID&
    agentClusterId() const
    {
        return agentClusterId_;
    }

    nsCString&
    remoteType()
    {
        return remoteType_;
    }
    const nsCString&
    remoteType() const
    {
        return remoteType_;
    }

private:
    nsString originalScriptURL_;
    URIParams baseScriptURL_;
    URIParams resolvedScriptURL_;
    nsString name_;
    PrincipalInfo loadingPrincipalInfo_;
    PrincipalInfo principalInfo_;
    PrincipalInfo partitionedPrincipalInfo_;
    bool useRegularPrincipal_;
    bool hasStorageAccessPermissionGranted_;
    CookieJarSettingsArgs cookieJarSettings_;
    nsCString domain_;
    bool isSecureContext_;
    mozilla::Maybe<IPCClientInfo> clientInfo_;
    RefPtr<nsIReferrerInfo> referrerInfo_;
    StorageAccess storageAccess_;
    OptionalServiceWorkerData serviceWorkerData_;
    nsID agentClusterId_;
    nsCString remoteType_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::RemoteWorkerData>
{
    typedef mozilla::dom::RemoteWorkerData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ErrorDataNote|
//
namespace mozilla {
namespace dom {
class ErrorDataNote final
{
private:

public:
    MOZ_IMPLICIT ErrorDataNote() :
        message_(),
        filename_(),
        lineNumber_(),
        columnNumber_()
    {
    }

    MOZ_IMPLICIT ErrorDataNote(
            const uint32_t& _lineNumber,
            const uint32_t& _columnNumber,
            const nsString& _message,
            const nsString& _filename) :
        message_(_message),
        filename_(_filename),
        lineNumber_(_lineNumber),
        columnNumber_(_columnNumber)
    {
    }

    uint32_t&
    lineNumber()
    {
        return lineNumber_;
    }
    const uint32_t&
    lineNumber() const
    {
        return lineNumber_;
    }

    uint32_t&
    columnNumber()
    {
        return columnNumber_;
    }
    const uint32_t&
    columnNumber() const
    {
        return columnNumber_;
    }

    nsString&
    message()
    {
        return message_;
    }
    const nsString&
    message() const
    {
        return message_;
    }

    nsString&
    filename()
    {
        return filename_;
    }
    const nsString&
    filename() const
    {
        return filename_;
    }

private:
    void
    StaticAssertions() const;
    nsString message_;
    nsString filename_;
    uint32_t lineNumber_;
    uint32_t columnNumber_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ErrorDataNote>
{
    typedef mozilla::dom::ErrorDataNote paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ErrorData|
//
namespace mozilla {
namespace dom {
class ErrorData final
{
private:
    typedef mozilla::dom::ErrorDataNote ErrorDataNote;

public:
    MOZ_IMPLICIT ErrorData() :
        isWarning_(),
        message_(),
        filename_(),
        line_(),
        notes_(),
        lineNumber_(),
        columnNumber_()
    {
    }

    MOZ_IMPLICIT ErrorData(
            const bool& _isWarning,
            const uint32_t& _lineNumber,
            const uint32_t& _columnNumber,
            const nsString& _message,
            const nsString& _filename,
            const nsString& _line,
            const nsTArray<ErrorDataNote>& _notes) :
        isWarning_(_isWarning),
        message_(_message),
        filename_(_filename),
        line_(_line),
        notes_(_notes),
        lineNumber_(_lineNumber),
        columnNumber_(_columnNumber)
    {
    }

    bool&
    isWarning()
    {
        return isWarning_;
    }
    const bool&
    isWarning() const
    {
        return isWarning_;
    }

    uint32_t&
    lineNumber()
    {
        return lineNumber_;
    }
    const uint32_t&
    lineNumber() const
    {
        return lineNumber_;
    }

    uint32_t&
    columnNumber()
    {
        return columnNumber_;
    }
    const uint32_t&
    columnNumber() const
    {
        return columnNumber_;
    }

    nsString&
    message()
    {
        return message_;
    }
    const nsString&
    message() const
    {
        return message_;
    }

    nsString&
    filename()
    {
        return filename_;
    }
    const nsString&
    filename() const
    {
        return filename_;
    }

    nsString&
    line()
    {
        return line_;
    }
    const nsString&
    line() const
    {
        return line_;
    }

    nsTArray<ErrorDataNote>&
    notes()
    {
        return notes_;
    }
    const nsTArray<ErrorDataNote>&
    notes() const
    {
        return notes_;
    }

private:
    void
    StaticAssertions() const;
    bool isWarning_;
    nsString message_;
    nsString filename_;
    nsString line_;
    CopyableTArray<ErrorDataNote> notes_;
    uint32_t lineNumber_;
    uint32_t columnNumber_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ErrorData>
{
    typedef mozilla::dom::ErrorData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union ErrorValue|
//
namespace mozilla {
namespace dom {
class ErrorValue final
{
public:
    enum Type {
        T__None,
        Tnsresult = 1,
        TErrorData,
        Tvoid_t,
        T__Last = Tvoid_t
    };

private:
    typedef mozilla::dom::ErrorData ErrorData;
    typedef mozilla::void_t void_t;
    typedef nsresult nsresult__tdef;
    typedef ErrorData ErrorData__tdef;
    typedef void_t void_t__tdef;

    union Value {
        mozilla::AlignedStorage2<nsresult> Vnsresult;
        mozilla::AlignedStorage2<ErrorData> VErrorData;
        mozilla::AlignedStorage2<void_t> Vvoid_t;
    };

    nsresult*
    ptr_nsresult()
    {
        return ((mValue).Vnsresult).addr();
    }
    const nsresult*
    constptr_nsresult() const
    {
        return ((mValue).Vnsresult).addr();
    }
    ErrorData*
    ptr_ErrorData()
    {
        return ((mValue).VErrorData).addr();
    }
    const ErrorData*
    constptr_ErrorData() const
    {
        return ((mValue).VErrorData).addr();
    }
    void_t*
    ptr_void_t()
    {
        return ((mValue).Vvoid_t).addr();
    }
    const void_t*
    constptr_void_t() const
    {
        return ((mValue).Vvoid_t).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT ErrorValue() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT ErrorValue(const nsresult& aOther);

    MOZ_IMPLICIT ErrorValue(nsresult&& aOther);

    MOZ_IMPLICIT ErrorValue(const ErrorData& aOther);

    MOZ_IMPLICIT ErrorValue(ErrorData&& aOther);

    MOZ_IMPLICIT ErrorValue(const void_t& aOther);

    MOZ_IMPLICIT ErrorValue(void_t&& aOther);

    MOZ_IMPLICIT ErrorValue(const ErrorValue& aOther);

    MOZ_IMPLICIT ErrorValue(ErrorValue&& aOther);

    ~ErrorValue();

    Type
    type() const
    {
        return mType;
    }

    ErrorValue&
    operator=(const nsresult& aRhs);

    ErrorValue&
    operator=(nsresult&& aRhs);

    ErrorValue&
    operator=(const ErrorData& aRhs);

    ErrorValue&
    operator=(ErrorData&& aRhs);

    ErrorValue&
    operator=(const void_t& aRhs);

    ErrorValue&
    operator=(void_t&& aRhs);

    ErrorValue&
    operator=(const ErrorValue& aRhs);

    ErrorValue&
    operator=(ErrorValue&& aRhs);

    nsresult&
    get_nsresult()
    {
        AssertSanity(Tnsresult);
        return (*(ptr_nsresult()));
    }
    const nsresult&
    get_nsresult() const
    {
        AssertSanity(Tnsresult);
        return (*(constptr_nsresult()));
    }
    operator nsresult&()
    {
        return get_nsresult();
    }
    operator const nsresult&() const
    {
        return get_nsresult();
    }

    ErrorData&
    get_ErrorData()
    {
        AssertSanity(TErrorData);
        return (*(ptr_ErrorData()));
    }
    const ErrorData&
    get_ErrorData() const
    {
        AssertSanity(TErrorData);
        return (*(constptr_ErrorData()));
    }
    operator ErrorData&()
    {
        return get_ErrorData();
    }
    operator const ErrorData&() const
    {
        return get_ErrorData();
    }

    void_t&
    get_void_t()
    {
        AssertSanity(Tvoid_t);
        return (*(ptr_void_t()));
    }
    const void_t&
    get_void_t() const
    {
        AssertSanity(Tvoid_t);
        return (*(constptr_void_t()));
    }
    operator void_t&()
    {
        return get_void_t();
    }
    operator const void_t&() const
    {
        return get_void_t();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ErrorValue>
{
    typedef mozilla::dom::ErrorValue paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

#endif // ifndef RemoteWorkerTypes_h
