//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PBackgroundIDBCursor_h
#define PBackgroundIDBCursor_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "mozilla/dom/indexedDB/Key.h"
#include "mozilla/ipc/IPCCore.h"
#include "mozilla/dom/indexedDB/PBackgroundIDBSharedTypes.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ContinueParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
class ContinueParams final
{
private:
    typedef mozilla::dom::indexedDB::Key Key;

public:
    MOZ_IMPLICIT ContinueParams() :
        key_()
    {
    }

    MOZ_IMPLICIT ContinueParams(const Key& _key) :
        key_(_key)
    {
    }

    Key&
    key()
    {
        return key_;
    }
    const Key&
    key() const
    {
        return key_;
    }

private:
    Key key_;
};
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::indexedDB::ContinueParams>
{
    typedef mozilla::dom::indexedDB::ContinueParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ContinuePrimaryKeyParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
class ContinuePrimaryKeyParams final
{
private:
    typedef mozilla::dom::indexedDB::Key Key;

public:
    MOZ_IMPLICIT ContinuePrimaryKeyParams() :
        key_(),
        primaryKey_()
    {
    }

    MOZ_IMPLICIT ContinuePrimaryKeyParams(
            const Key& _key,
            const Key& _primaryKey) :
        key_(_key),
        primaryKey_(_primaryKey)
    {
    }

    Key&
    key()
    {
        return key_;
    }
    const Key&
    key() const
    {
        return key_;
    }

    Key&
    primaryKey()
    {
        return primaryKey_;
    }
    const Key&
    primaryKey() const
    {
        return primaryKey_;
    }

private:
    Key key_;
    Key primaryKey_;
};
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::indexedDB::ContinuePrimaryKeyParams>
{
    typedef mozilla::dom::indexedDB::ContinuePrimaryKeyParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct AdvanceParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
class AdvanceParams final
{
private:

public:
    MOZ_IMPLICIT AdvanceParams() :
        count_()
    {
    }

    MOZ_IMPLICIT AdvanceParams(const uint32_t& _count) :
        count_(_count)
    {
    }

    uint32_t&
    count()
    {
        return count_;
    }
    const uint32_t&
    count() const
    {
        return count_;
    }

private:
    uint32_t count_;
};
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::indexedDB::AdvanceParams>
{
    typedef mozilla::dom::indexedDB::AdvanceParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union CursorRequestParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
class CursorRequestParams final
{
public:
    enum Type {
        T__None,
        TContinueParams = 1,
        TContinuePrimaryKeyParams,
        TAdvanceParams,
        T__Last = TAdvanceParams
    };

private:
    typedef mozilla::dom::indexedDB::ContinueParams ContinueParams;
    typedef mozilla::dom::indexedDB::ContinuePrimaryKeyParams ContinuePrimaryKeyParams;
    typedef mozilla::dom::indexedDB::AdvanceParams AdvanceParams;
    typedef ContinueParams ContinueParams__tdef;
    typedef ContinuePrimaryKeyParams ContinuePrimaryKeyParams__tdef;
    typedef AdvanceParams AdvanceParams__tdef;

    union Value {
        mozilla::AlignedStorage2<ContinueParams> VContinueParams;
        mozilla::AlignedStorage2<ContinuePrimaryKeyParams> VContinuePrimaryKeyParams;
        mozilla::AlignedStorage2<AdvanceParams> VAdvanceParams;
    };

    ContinueParams*
    ptr_ContinueParams()
    {
        return ((mValue).VContinueParams).addr();
    }
    const ContinueParams*
    constptr_ContinueParams() const
    {
        return ((mValue).VContinueParams).addr();
    }
    ContinuePrimaryKeyParams*
    ptr_ContinuePrimaryKeyParams()
    {
        return ((mValue).VContinuePrimaryKeyParams).addr();
    }
    const ContinuePrimaryKeyParams*
    constptr_ContinuePrimaryKeyParams() const
    {
        return ((mValue).VContinuePrimaryKeyParams).addr();
    }
    AdvanceParams*
    ptr_AdvanceParams()
    {
        return ((mValue).VAdvanceParams).addr();
    }
    const AdvanceParams*
    constptr_AdvanceParams() const
    {
        return ((mValue).VAdvanceParams).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT CursorRequestParams() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT CursorRequestParams(const ContinueParams& aOther);

    MOZ_IMPLICIT CursorRequestParams(ContinueParams&& aOther);

    MOZ_IMPLICIT CursorRequestParams(const ContinuePrimaryKeyParams& aOther);

    MOZ_IMPLICIT CursorRequestParams(ContinuePrimaryKeyParams&& aOther);

    MOZ_IMPLICIT CursorRequestParams(const AdvanceParams& aOther);

    MOZ_IMPLICIT CursorRequestParams(AdvanceParams&& aOther);

    MOZ_IMPLICIT CursorRequestParams(const CursorRequestParams& aOther);

    MOZ_IMPLICIT CursorRequestParams(CursorRequestParams&& aOther);

    ~CursorRequestParams();

    Type
    type() const
    {
        return mType;
    }

    CursorRequestParams&
    operator=(const ContinueParams& aRhs);

    CursorRequestParams&
    operator=(ContinueParams&& aRhs);

    CursorRequestParams&
    operator=(const ContinuePrimaryKeyParams& aRhs);

    CursorRequestParams&
    operator=(ContinuePrimaryKeyParams&& aRhs);

    CursorRequestParams&
    operator=(const AdvanceParams& aRhs);

    CursorRequestParams&
    operator=(AdvanceParams&& aRhs);

    CursorRequestParams&
    operator=(const CursorRequestParams& aRhs);

    CursorRequestParams&
    operator=(CursorRequestParams&& aRhs);

    ContinueParams&
    get_ContinueParams()
    {
        AssertSanity(TContinueParams);
        return (*(ptr_ContinueParams()));
    }
    const ContinueParams&
    get_ContinueParams() const
    {
        AssertSanity(TContinueParams);
        return (*(constptr_ContinueParams()));
    }
    operator ContinueParams&()
    {
        return get_ContinueParams();
    }
    operator const ContinueParams&() const
    {
        return get_ContinueParams();
    }

    ContinuePrimaryKeyParams&
    get_ContinuePrimaryKeyParams()
    {
        AssertSanity(TContinuePrimaryKeyParams);
        return (*(ptr_ContinuePrimaryKeyParams()));
    }
    const ContinuePrimaryKeyParams&
    get_ContinuePrimaryKeyParams() const
    {
        AssertSanity(TContinuePrimaryKeyParams);
        return (*(constptr_ContinuePrimaryKeyParams()));
    }
    operator ContinuePrimaryKeyParams&()
    {
        return get_ContinuePrimaryKeyParams();
    }
    operator const ContinuePrimaryKeyParams&() const
    {
        return get_ContinuePrimaryKeyParams();
    }

    AdvanceParams&
    get_AdvanceParams()
    {
        AssertSanity(TAdvanceParams);
        return (*(ptr_AdvanceParams()));
    }
    const AdvanceParams&
    get_AdvanceParams() const
    {
        AssertSanity(TAdvanceParams);
        return (*(constptr_AdvanceParams()));
    }
    operator AdvanceParams&()
    {
        return get_AdvanceParams();
    }
    operator const AdvanceParams&() const
    {
        return get_AdvanceParams();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::indexedDB::CursorRequestParams>
{
    typedef mozilla::dom::indexedDB::CursorRequestParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ObjectStoreCursorResponse|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
class ObjectStoreCursorResponse final
{
private:
    typedef mozilla::dom::indexedDB::Key Key;
    typedef mozilla::dom::indexedDB::SerializedStructuredCloneReadInfo SerializedStructuredCloneReadInfo;

public:
    MOZ_IMPLICIT ObjectStoreCursorResponse() :
        key_(),
        cloneInfo_()
    {
    }

    MOZ_IMPLICIT ObjectStoreCursorResponse(
            const Key& _key,
            SerializedStructuredCloneReadInfo&& _cloneInfo) :
        key_(_key),
        cloneInfo_(std::move(_cloneInfo))
    {
    }

    Key&
    key()
    {
        return key_;
    }
    const Key&
    key() const
    {
        return key_;
    }

    SerializedStructuredCloneReadInfo&
    cloneInfo()
    {
        return cloneInfo_;
    }
    const SerializedStructuredCloneReadInfo&
    cloneInfo() const
    {
        return cloneInfo_;
    }

private:
    Key key_;
    SerializedStructuredCloneReadInfo cloneInfo_;
};
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::indexedDB::ObjectStoreCursorResponse>
{
    typedef mozilla::dom::indexedDB::ObjectStoreCursorResponse paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ObjectStoreKeyCursorResponse|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
class ObjectStoreKeyCursorResponse final
{
private:
    typedef mozilla::dom::indexedDB::Key Key;

public:
    MOZ_IMPLICIT ObjectStoreKeyCursorResponse() :
        key_()
    {
    }

    MOZ_IMPLICIT ObjectStoreKeyCursorResponse(const Key& _key) :
        key_(_key)
    {
    }

    Key&
    key()
    {
        return key_;
    }
    const Key&
    key() const
    {
        return key_;
    }

private:
    Key key_;
};
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::indexedDB::ObjectStoreKeyCursorResponse>
{
    typedef mozilla::dom::indexedDB::ObjectStoreKeyCursorResponse paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct IndexCursorResponse|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
class IndexCursorResponse final
{
private:
    typedef mozilla::dom::indexedDB::Key Key;
    typedef mozilla::dom::indexedDB::SerializedStructuredCloneReadInfo SerializedStructuredCloneReadInfo;

public:
    MOZ_IMPLICIT IndexCursorResponse() :
        key_(),
        sortKey_(),
        objectKey_(),
        cloneInfo_()
    {
    }

    MOZ_IMPLICIT IndexCursorResponse(
            const Key& _key,
            const Key& _sortKey,
            const Key& _objectKey,
            SerializedStructuredCloneReadInfo&& _cloneInfo) :
        key_(_key),
        sortKey_(_sortKey),
        objectKey_(_objectKey),
        cloneInfo_(std::move(_cloneInfo))
    {
    }

    Key&
    key()
    {
        return key_;
    }
    const Key&
    key() const
    {
        return key_;
    }

    Key&
    sortKey()
    {
        return sortKey_;
    }
    const Key&
    sortKey() const
    {
        return sortKey_;
    }

    Key&
    objectKey()
    {
        return objectKey_;
    }
    const Key&
    objectKey() const
    {
        return objectKey_;
    }

    SerializedStructuredCloneReadInfo&
    cloneInfo()
    {
        return cloneInfo_;
    }
    const SerializedStructuredCloneReadInfo&
    cloneInfo() const
    {
        return cloneInfo_;
    }

private:
    Key key_;
    Key sortKey_;
    Key objectKey_;
    SerializedStructuredCloneReadInfo cloneInfo_;
};
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::indexedDB::IndexCursorResponse>
{
    typedef mozilla::dom::indexedDB::IndexCursorResponse paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct IndexKeyCursorResponse|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
class IndexKeyCursorResponse final
{
private:
    typedef mozilla::dom::indexedDB::Key Key;

public:
    MOZ_IMPLICIT IndexKeyCursorResponse() :
        key_(),
        sortKey_(),
        objectKey_()
    {
    }

    MOZ_IMPLICIT IndexKeyCursorResponse(
            const Key& _key,
            const Key& _sortKey,
            const Key& _objectKey) :
        key_(_key),
        sortKey_(_sortKey),
        objectKey_(_objectKey)
    {
    }

    Key&
    key()
    {
        return key_;
    }
    const Key&
    key() const
    {
        return key_;
    }

    Key&
    sortKey()
    {
        return sortKey_;
    }
    const Key&
    sortKey() const
    {
        return sortKey_;
    }

    Key&
    objectKey()
    {
        return objectKey_;
    }
    const Key&
    objectKey() const
    {
        return objectKey_;
    }

private:
    Key key_;
    Key sortKey_;
    Key objectKey_;
};
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::indexedDB::IndexKeyCursorResponse>
{
    typedef mozilla::dom::indexedDB::IndexKeyCursorResponse paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union CursorResponse|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
class CursorResponse final
{
public:
    enum Type {
        T__None,
        Tvoid_t = 1,
        Tnsresult,
        TArrayOfObjectStoreCursorResponse,
        TArrayOfObjectStoreKeyCursorResponse,
        TArrayOfIndexCursorResponse,
        TArrayOfIndexKeyCursorResponse,
        T__Last = TArrayOfIndexKeyCursorResponse
    };

private:
    typedef mozilla::void_t void_t;
    typedef mozilla::dom::indexedDB::ObjectStoreCursorResponse ObjectStoreCursorResponse;
    typedef mozilla::dom::indexedDB::ObjectStoreKeyCursorResponse ObjectStoreKeyCursorResponse;
    typedef mozilla::dom::indexedDB::IndexCursorResponse IndexCursorResponse;
    typedef mozilla::dom::indexedDB::IndexKeyCursorResponse IndexKeyCursorResponse;
    typedef void_t void_t__tdef;
    typedef nsresult nsresult__tdef;
    typedef nsTArray<ObjectStoreCursorResponse> ArrayOfObjectStoreCursorResponse__tdef;
    typedef nsTArray<ObjectStoreKeyCursorResponse> ArrayOfObjectStoreKeyCursorResponse__tdef;
    typedef nsTArray<IndexCursorResponse> ArrayOfIndexCursorResponse__tdef;
    typedef nsTArray<IndexKeyCursorResponse> ArrayOfIndexKeyCursorResponse__tdef;

    union Value {
        mozilla::AlignedStorage2<void_t> Vvoid_t;
        mozilla::AlignedStorage2<nsresult> Vnsresult;
        mozilla::AlignedStorage2<nsTArray<ObjectStoreCursorResponse>> VArrayOfObjectStoreCursorResponse;
        mozilla::AlignedStorage2<nsTArray<ObjectStoreKeyCursorResponse>> VArrayOfObjectStoreKeyCursorResponse;
        mozilla::AlignedStorage2<nsTArray<IndexCursorResponse>> VArrayOfIndexCursorResponse;
        mozilla::AlignedStorage2<nsTArray<IndexKeyCursorResponse>> VArrayOfIndexKeyCursorResponse;
    };

    void_t*
    ptr_void_t()
    {
        return ((mValue).Vvoid_t).addr();
    }
    const void_t*
    constptr_void_t() const
    {
        return ((mValue).Vvoid_t).addr();
    }
    nsresult*
    ptr_nsresult()
    {
        return ((mValue).Vnsresult).addr();
    }
    const nsresult*
    constptr_nsresult() const
    {
        return ((mValue).Vnsresult).addr();
    }
    nsTArray<ObjectStoreCursorResponse>*
    ptr_ArrayOfObjectStoreCursorResponse()
    {
        return ((mValue).VArrayOfObjectStoreCursorResponse).addr();
    }
    const nsTArray<ObjectStoreCursorResponse>*
    constptr_ArrayOfObjectStoreCursorResponse() const
    {
        return ((mValue).VArrayOfObjectStoreCursorResponse).addr();
    }
    nsTArray<ObjectStoreKeyCursorResponse>*
    ptr_ArrayOfObjectStoreKeyCursorResponse()
    {
        return ((mValue).VArrayOfObjectStoreKeyCursorResponse).addr();
    }
    const nsTArray<ObjectStoreKeyCursorResponse>*
    constptr_ArrayOfObjectStoreKeyCursorResponse() const
    {
        return ((mValue).VArrayOfObjectStoreKeyCursorResponse).addr();
    }
    nsTArray<IndexCursorResponse>*
    ptr_ArrayOfIndexCursorResponse()
    {
        return ((mValue).VArrayOfIndexCursorResponse).addr();
    }
    const nsTArray<IndexCursorResponse>*
    constptr_ArrayOfIndexCursorResponse() const
    {
        return ((mValue).VArrayOfIndexCursorResponse).addr();
    }
    nsTArray<IndexKeyCursorResponse>*
    ptr_ArrayOfIndexKeyCursorResponse()
    {
        return ((mValue).VArrayOfIndexKeyCursorResponse).addr();
    }
    const nsTArray<IndexKeyCursorResponse>*
    constptr_ArrayOfIndexKeyCursorResponse() const
    {
        return ((mValue).VArrayOfIndexKeyCursorResponse).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT CursorResponse() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT CursorResponse(const void_t& aOther);

    MOZ_IMPLICIT CursorResponse(void_t&& aOther);

    MOZ_IMPLICIT CursorResponse(const nsresult& aOther);

    MOZ_IMPLICIT CursorResponse(nsresult&& aOther);

    MOZ_IMPLICIT CursorResponse(nsTArray<ObjectStoreCursorResponse>&& aOther);

    MOZ_IMPLICIT CursorResponse(const nsTArray<ObjectStoreKeyCursorResponse>& aOther);

    MOZ_IMPLICIT CursorResponse(nsTArray<ObjectStoreKeyCursorResponse>&& aOther);

    MOZ_IMPLICIT CursorResponse(nsTArray<IndexCursorResponse>&& aOther);

    MOZ_IMPLICIT CursorResponse(const nsTArray<IndexKeyCursorResponse>& aOther);

    MOZ_IMPLICIT CursorResponse(nsTArray<IndexKeyCursorResponse>&& aOther);

    MOZ_IMPLICIT CursorResponse(CursorResponse&& aOther);

    ~CursorResponse();

    Type
    type() const
    {
        return mType;
    }

    CursorResponse&
    operator=(const void_t& aRhs);

    CursorResponse&
    operator=(void_t&& aRhs);

    CursorResponse&
    operator=(const nsresult& aRhs);

    CursorResponse&
    operator=(nsresult&& aRhs);

    CursorResponse&
    operator=(nsTArray<ObjectStoreCursorResponse>&& aRhs);

    CursorResponse&
    operator=(const nsTArray<ObjectStoreKeyCursorResponse>& aRhs);

    CursorResponse&
    operator=(nsTArray<ObjectStoreKeyCursorResponse>&& aRhs);

    CursorResponse&
    operator=(nsTArray<IndexCursorResponse>&& aRhs);

    CursorResponse&
    operator=(const nsTArray<IndexKeyCursorResponse>& aRhs);

    CursorResponse&
    operator=(nsTArray<IndexKeyCursorResponse>&& aRhs);

    CursorResponse&
    operator=(CursorResponse&& aRhs);

    void_t&
    get_void_t()
    {
        AssertSanity(Tvoid_t);
        return (*(ptr_void_t()));
    }
    const void_t&
    get_void_t() const
    {
        AssertSanity(Tvoid_t);
        return (*(constptr_void_t()));
    }
    operator void_t&()
    {
        return get_void_t();
    }
    operator const void_t&() const
    {
        return get_void_t();
    }

    nsresult&
    get_nsresult()
    {
        AssertSanity(Tnsresult);
        return (*(ptr_nsresult()));
    }
    const nsresult&
    get_nsresult() const
    {
        AssertSanity(Tnsresult);
        return (*(constptr_nsresult()));
    }
    operator nsresult&()
    {
        return get_nsresult();
    }
    operator const nsresult&() const
    {
        return get_nsresult();
    }

    nsTArray<ObjectStoreCursorResponse>&
    get_ArrayOfObjectStoreCursorResponse()
    {
        AssertSanity(TArrayOfObjectStoreCursorResponse);
        return (*(ptr_ArrayOfObjectStoreCursorResponse()));
    }
    const nsTArray<ObjectStoreCursorResponse>&
    get_ArrayOfObjectStoreCursorResponse() const
    {
        AssertSanity(TArrayOfObjectStoreCursorResponse);
        return (*(constptr_ArrayOfObjectStoreCursorResponse()));
    }
    operator nsTArray<ObjectStoreCursorResponse>&()
    {
        return get_ArrayOfObjectStoreCursorResponse();
    }
    operator const nsTArray<ObjectStoreCursorResponse>&() const
    {
        return get_ArrayOfObjectStoreCursorResponse();
    }

    nsTArray<ObjectStoreKeyCursorResponse>&
    get_ArrayOfObjectStoreKeyCursorResponse()
    {
        AssertSanity(TArrayOfObjectStoreKeyCursorResponse);
        return (*(ptr_ArrayOfObjectStoreKeyCursorResponse()));
    }
    const nsTArray<ObjectStoreKeyCursorResponse>&
    get_ArrayOfObjectStoreKeyCursorResponse() const
    {
        AssertSanity(TArrayOfObjectStoreKeyCursorResponse);
        return (*(constptr_ArrayOfObjectStoreKeyCursorResponse()));
    }
    operator nsTArray<ObjectStoreKeyCursorResponse>&()
    {
        return get_ArrayOfObjectStoreKeyCursorResponse();
    }
    operator const nsTArray<ObjectStoreKeyCursorResponse>&() const
    {
        return get_ArrayOfObjectStoreKeyCursorResponse();
    }

    nsTArray<IndexCursorResponse>&
    get_ArrayOfIndexCursorResponse()
    {
        AssertSanity(TArrayOfIndexCursorResponse);
        return (*(ptr_ArrayOfIndexCursorResponse()));
    }
    const nsTArray<IndexCursorResponse>&
    get_ArrayOfIndexCursorResponse() const
    {
        AssertSanity(TArrayOfIndexCursorResponse);
        return (*(constptr_ArrayOfIndexCursorResponse()));
    }
    operator nsTArray<IndexCursorResponse>&()
    {
        return get_ArrayOfIndexCursorResponse();
    }
    operator const nsTArray<IndexCursorResponse>&() const
    {
        return get_ArrayOfIndexCursorResponse();
    }

    nsTArray<IndexKeyCursorResponse>&
    get_ArrayOfIndexKeyCursorResponse()
    {
        AssertSanity(TArrayOfIndexKeyCursorResponse);
        return (*(ptr_ArrayOfIndexKeyCursorResponse()));
    }
    const nsTArray<IndexKeyCursorResponse>&
    get_ArrayOfIndexKeyCursorResponse() const
    {
        AssertSanity(TArrayOfIndexKeyCursorResponse);
        return (*(constptr_ArrayOfIndexKeyCursorResponse()));
    }
    operator nsTArray<IndexKeyCursorResponse>&()
    {
        return get_ArrayOfIndexKeyCursorResponse();
    }
    operator const nsTArray<IndexKeyCursorResponse>&() const
    {
        return get_ArrayOfIndexKeyCursorResponse();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::indexedDB::CursorResponse>
{
    typedef mozilla::dom::indexedDB::CursorResponse paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace dom {
namespace indexedDB {
class PBackgroundIDBCursorParent;
} // namespace indexedDB
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
namespace indexedDB {
class PBackgroundIDBCursorChild;
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Code common to PBackgroundIDBCursorChild and PBackgroundIDBCursorParent
//
namespace mozilla {
namespace dom {
namespace indexedDB {
namespace PBackgroundIDBCursor {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::dom::indexedDB::PBackgroundIDBCursorParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::dom::indexedDB::PBackgroundIDBCursorChild>* aChild);

enum MessageType {
    PBackgroundIDBCursorStart = PBackgroundIDBCursorMsgStart << 16,
    Msg_DeleteMe__ID,
    Msg_Continue__ID,
    Msg___delete____ID,
    Reply___delete____ID,
    Msg_Response__ID,
    PBackgroundIDBCursorEnd
};

IPC::Message*
Msg_DeleteMe(int32_t routingId);

IPC::Message*
Msg_Continue(int32_t routingId);

IPC::Message*
Msg___delete__(int32_t routingId);
IPC::Message*
Reply___delete__(int32_t routingId);

IPC::Message*
Msg_Response(int32_t routingId);



} // namespace PBackgroundIDBCursor
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

#endif // ifndef PBackgroundIDBCursor_h
