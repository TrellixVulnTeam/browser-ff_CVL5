//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef CacheTypes_h
#define CacheTypes_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "mozilla/dom/HeadersBinding.h"
#include "mozilla/dom/ReferrerPolicyBinding.h"
#include "mozilla/dom/RequestBinding.h"
#include "mozilla/dom/ResponseBinding.h"
#include "mozilla/dom/cache/Types.h"
#include "mozilla/ipc/IPCCore.h"
#include "nsIContentPolicy.h"
#include "nsID.h"
#include "nsILoadInfo.h"
#include "mozilla/ipc/IPCStream.h"
#include "mozilla/ipc/ChannelInfo.h"
#include "mozilla/ipc/PBackgroundSharedTypes.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CacheQueryParams|
//
namespace mozilla {
namespace dom {
namespace cache {
class CacheQueryParams final
{
private:

public:
    MOZ_IMPLICIT CacheQueryParams() :
        ignoreSearch_(),
        ignoreMethod_(),
        ignoreVary_(),
        cacheNameSet_(),
        cacheName_()
    {
    }

    MOZ_IMPLICIT CacheQueryParams(
            const bool& _ignoreSearch,
            const bool& _ignoreMethod,
            const bool& _ignoreVary,
            const bool& _cacheNameSet,
            const nsString& _cacheName) :
        ignoreSearch_(_ignoreSearch),
        ignoreMethod_(_ignoreMethod),
        ignoreVary_(_ignoreVary),
        cacheNameSet_(_cacheNameSet),
        cacheName_(_cacheName)
    {
    }

    bool&
    ignoreSearch()
    {
        return ignoreSearch_;
    }
    const bool&
    ignoreSearch() const
    {
        return ignoreSearch_;
    }

    bool&
    ignoreMethod()
    {
        return ignoreMethod_;
    }
    const bool&
    ignoreMethod() const
    {
        return ignoreMethod_;
    }

    bool&
    ignoreVary()
    {
        return ignoreVary_;
    }
    const bool&
    ignoreVary() const
    {
        return ignoreVary_;
    }

    bool&
    cacheNameSet()
    {
        return cacheNameSet_;
    }
    const bool&
    cacheNameSet() const
    {
        return cacheNameSet_;
    }

    nsString&
    cacheName()
    {
        return cacheName_;
    }
    const nsString&
    cacheName() const
    {
        return cacheName_;
    }

private:
    bool ignoreSearch_;
    bool ignoreMethod_;
    bool ignoreVary_;
    bool cacheNameSet_;
    nsString cacheName_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::CacheQueryParams>
{
    typedef mozilla::dom::cache::CacheQueryParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace dom {
namespace cache {
class PCacheStreamControlParent;
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {
namespace cache {
class PCacheStreamControlChild;
} // namespace cache
} // namespace dom
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CacheReadStream|
//
namespace mozilla {
namespace dom {
namespace cache {
class CacheReadStream final
{
private:
    typedef mozilla::dom::cache::PCacheStreamControlParent PCacheStreamControlParent;
    typedef mozilla::dom::cache::PCacheStreamControlChild PCacheStreamControlChild;
    typedef mozilla::ipc::IPCStream IPCStream;

public:
    MOZ_IMPLICIT CacheReadStream() :
        id_(),
        controlParent_(),
        controlChild_(),
        stream_()
    {
    }

    MOZ_IMPLICIT CacheReadStream(
            const nsID& _id,
            PCacheStreamControlParent* _controlParent,
            PCacheStreamControlChild* _controlChild,
            const mozilla::Maybe<IPCStream>& _stream) :
        id_(_id),
        controlParent_(_controlParent),
        controlChild_(_controlChild),
        stream_(_stream)
    {
    }

    nsID&
    id()
    {
        return id_;
    }
    const nsID&
    id() const
    {
        return id_;
    }

    PCacheStreamControlParent*&
    controlParent()
    {
        return controlParent_;
    }
    PCacheStreamControlParent*
    controlParent() const
    {
        return controlParent_;
    }

    PCacheStreamControlChild*&
    controlChild()
    {
        return controlChild_;
    }
    PCacheStreamControlChild*
    controlChild() const
    {
        return controlChild_;
    }

    mozilla::Maybe<IPCStream>&
    stream()
    {
        return stream_;
    }
    const mozilla::Maybe<IPCStream>&
    stream() const
    {
        return stream_;
    }

private:
    nsID id_;
    PCacheStreamControlParent* controlParent_;
    PCacheStreamControlChild* controlChild_;
    mozilla::Maybe<IPCStream> stream_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::CacheReadStream>
{
    typedef mozilla::dom::cache::CacheReadStream paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct HeadersEntry|
//
namespace mozilla {
namespace dom {
namespace cache {
class HeadersEntry final
{
private:

public:
    MOZ_IMPLICIT HeadersEntry() :
        name_(),
        value_()
    {
    }

    MOZ_IMPLICIT HeadersEntry(
            const nsCString& _name,
            const nsCString& _value) :
        name_(_name),
        value_(_value)
    {
    }

    nsCString&
    name()
    {
        return name_;
    }
    const nsCString&
    name() const
    {
        return name_;
    }

    nsCString&
    value()
    {
        return value_;
    }
    const nsCString&
    value() const
    {
        return value_;
    }

private:
    nsCString name_;
    nsCString value_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::HeadersEntry>
{
    typedef mozilla::dom::cache::HeadersEntry paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CacheRequest|
//
namespace mozilla {
namespace dom {
namespace cache {
class CacheRequest final
{
private:
    typedef mozilla::dom::cache::HeadersEntry HeadersEntry;
    typedef mozilla::dom::cache::CacheReadStream CacheReadStream;
    typedef nsILoadInfo::CrossOriginEmbedderPolicy CrossOriginEmbedderPolicy;
    typedef mozilla::ipc::PrincipalInfo PrincipalInfo;

public:
    MOZ_IMPLICIT CacheRequest() :
        method_(),
        urlWithoutQuery_(),
        urlQuery_(),
        urlFragment_(),
        headers_(),
        headersGuard_(),
        referrer_(),
        referrerPolicy_(),
        mode_(),
        credentials_(),
        body_(),
        contentPolicyType_(),
        requestCache_(),
        requestRedirect_(),
        integrity_(),
        loadingEmbedderPolicy_(),
        principalInfo_()
    {
    }

    MOZ_IMPLICIT CacheRequest(
            const nsCString& _method,
            const nsCString& _urlWithoutQuery,
            const nsCString& _urlQuery,
            const nsCString& _urlFragment,
            const nsTArray<HeadersEntry>& _headers,
            const HeadersGuardEnum& _headersGuard,
            const nsString& _referrer,
            const ReferrerPolicy& _referrerPolicy,
            const RequestMode& _mode,
            const RequestCredentials& _credentials,
            const mozilla::Maybe<CacheReadStream>& _body,
            const nsContentPolicyType& _contentPolicyType,
            const RequestCache& _requestCache,
            const RequestRedirect& _requestRedirect,
            const nsString& _integrity,
            const CrossOriginEmbedderPolicy& _loadingEmbedderPolicy,
            const mozilla::Maybe<PrincipalInfo>& _principalInfo) :
        method_(_method),
        urlWithoutQuery_(_urlWithoutQuery),
        urlQuery_(_urlQuery),
        urlFragment_(_urlFragment),
        headers_(_headers),
        headersGuard_(_headersGuard),
        referrer_(_referrer),
        referrerPolicy_(_referrerPolicy),
        mode_(_mode),
        credentials_(_credentials),
        body_(_body),
        contentPolicyType_(_contentPolicyType),
        requestCache_(_requestCache),
        requestRedirect_(_requestRedirect),
        integrity_(_integrity),
        loadingEmbedderPolicy_(_loadingEmbedderPolicy),
        principalInfo_(_principalInfo)
    {
    }

    nsCString&
    method()
    {
        return method_;
    }
    const nsCString&
    method() const
    {
        return method_;
    }

    nsCString&
    urlWithoutQuery()
    {
        return urlWithoutQuery_;
    }
    const nsCString&
    urlWithoutQuery() const
    {
        return urlWithoutQuery_;
    }

    nsCString&
    urlQuery()
    {
        return urlQuery_;
    }
    const nsCString&
    urlQuery() const
    {
        return urlQuery_;
    }

    nsCString&
    urlFragment()
    {
        return urlFragment_;
    }
    const nsCString&
    urlFragment() const
    {
        return urlFragment_;
    }

    nsTArray<HeadersEntry>&
    headers()
    {
        return headers_;
    }
    const nsTArray<HeadersEntry>&
    headers() const
    {
        return headers_;
    }

    HeadersGuardEnum&
    headersGuard()
    {
        return headersGuard_;
    }
    const HeadersGuardEnum&
    headersGuard() const
    {
        return headersGuard_;
    }

    nsString&
    referrer()
    {
        return referrer_;
    }
    const nsString&
    referrer() const
    {
        return referrer_;
    }

    ReferrerPolicy&
    referrerPolicy()
    {
        return referrerPolicy_;
    }
    const ReferrerPolicy&
    referrerPolicy() const
    {
        return referrerPolicy_;
    }

    RequestMode&
    mode()
    {
        return mode_;
    }
    const RequestMode&
    mode() const
    {
        return mode_;
    }

    RequestCredentials&
    credentials()
    {
        return credentials_;
    }
    const RequestCredentials&
    credentials() const
    {
        return credentials_;
    }

    mozilla::Maybe<CacheReadStream>&
    body()
    {
        return body_;
    }
    const mozilla::Maybe<CacheReadStream>&
    body() const
    {
        return body_;
    }

    nsContentPolicyType&
    contentPolicyType()
    {
        return contentPolicyType_;
    }
    const nsContentPolicyType&
    contentPolicyType() const
    {
        return contentPolicyType_;
    }

    RequestCache&
    requestCache()
    {
        return requestCache_;
    }
    const RequestCache&
    requestCache() const
    {
        return requestCache_;
    }

    RequestRedirect&
    requestRedirect()
    {
        return requestRedirect_;
    }
    const RequestRedirect&
    requestRedirect() const
    {
        return requestRedirect_;
    }

    nsString&
    integrity()
    {
        return integrity_;
    }
    const nsString&
    integrity() const
    {
        return integrity_;
    }

    CrossOriginEmbedderPolicy&
    loadingEmbedderPolicy()
    {
        return loadingEmbedderPolicy_;
    }
    const CrossOriginEmbedderPolicy&
    loadingEmbedderPolicy() const
    {
        return loadingEmbedderPolicy_;
    }

    mozilla::Maybe<PrincipalInfo>&
    principalInfo()
    {
        return principalInfo_;
    }
    const mozilla::Maybe<PrincipalInfo>&
    principalInfo() const
    {
        return principalInfo_;
    }

private:
    nsCString method_;
    nsCString urlWithoutQuery_;
    nsCString urlQuery_;
    nsCString urlFragment_;
    CopyableTArray<HeadersEntry> headers_;
    HeadersGuardEnum headersGuard_;
    nsString referrer_;
    ReferrerPolicy referrerPolicy_;
    RequestMode mode_;
    RequestCredentials credentials_;
    mozilla::Maybe<CacheReadStream> body_;
    nsContentPolicyType contentPolicyType_;
    RequestCache requestCache_;
    RequestRedirect requestRedirect_;
    nsString integrity_;
    CrossOriginEmbedderPolicy loadingEmbedderPolicy_;
    mozilla::Maybe<PrincipalInfo> principalInfo_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::CacheRequest>
{
    typedef mozilla::dom::cache::CacheRequest paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CacheResponse|
//
namespace mozilla {
namespace dom {
namespace cache {
class CacheResponse final
{
private:
    typedef mozilla::dom::cache::HeadersEntry HeadersEntry;
    typedef mozilla::dom::cache::CacheReadStream CacheReadStream;
    typedef mozilla::ipc::IPCChannelInfo IPCChannelInfo;
    typedef mozilla::ipc::PrincipalInfo PrincipalInfo;

public:
    MOZ_IMPLICIT CacheResponse() :
        type_(),
        urlList_(),
        statusText_(),
        headers_(),
        headersGuard_(),
        body_(),
        channelInfo_(),
        principalInfo_(),
        paddingSize_(),
        status_(),
        paddingInfo_()
    {
    }

    MOZ_IMPLICIT CacheResponse(
            const ResponseType& _type,
            const nsTArray<nsCString>& _urlList,
            const uint32_t& _status,
            const nsCString& _statusText,
            const nsTArray<HeadersEntry>& _headers,
            const HeadersGuardEnum& _headersGuard,
            const mozilla::Maybe<CacheReadStream>& _body,
            const IPCChannelInfo& _channelInfo,
            const mozilla::Maybe<PrincipalInfo>& _principalInfo,
            const uint32_t& _paddingInfo,
            const int64_t& _paddingSize) :
        type_(_type),
        urlList_(_urlList),
        statusText_(_statusText),
        headers_(_headers),
        headersGuard_(_headersGuard),
        body_(_body),
        channelInfo_(_channelInfo),
        principalInfo_(_principalInfo),
        paddingSize_(_paddingSize),
        status_(_status),
        paddingInfo_(_paddingInfo)
    {
    }

    ResponseType&
    type()
    {
        return type_;
    }
    const ResponseType&
    type() const
    {
        return type_;
    }

    nsTArray<nsCString>&
    urlList()
    {
        return urlList_;
    }
    const nsTArray<nsCString>&
    urlList() const
    {
        return urlList_;
    }

    uint32_t&
    status()
    {
        return status_;
    }
    const uint32_t&
    status() const
    {
        return status_;
    }

    nsCString&
    statusText()
    {
        return statusText_;
    }
    const nsCString&
    statusText() const
    {
        return statusText_;
    }

    nsTArray<HeadersEntry>&
    headers()
    {
        return headers_;
    }
    const nsTArray<HeadersEntry>&
    headers() const
    {
        return headers_;
    }

    HeadersGuardEnum&
    headersGuard()
    {
        return headersGuard_;
    }
    const HeadersGuardEnum&
    headersGuard() const
    {
        return headersGuard_;
    }

    mozilla::Maybe<CacheReadStream>&
    body()
    {
        return body_;
    }
    const mozilla::Maybe<CacheReadStream>&
    body() const
    {
        return body_;
    }

    IPCChannelInfo&
    channelInfo()
    {
        return channelInfo_;
    }
    const IPCChannelInfo&
    channelInfo() const
    {
        return channelInfo_;
    }

    mozilla::Maybe<PrincipalInfo>&
    principalInfo()
    {
        return principalInfo_;
    }
    const mozilla::Maybe<PrincipalInfo>&
    principalInfo() const
    {
        return principalInfo_;
    }

    uint32_t&
    paddingInfo()
    {
        return paddingInfo_;
    }
    const uint32_t&
    paddingInfo() const
    {
        return paddingInfo_;
    }

    int64_t&
    paddingSize()
    {
        return paddingSize_;
    }
    const int64_t&
    paddingSize() const
    {
        return paddingSize_;
    }

private:
    void
    StaticAssertions() const;
    ResponseType type_;
    CopyableTArray<nsCString> urlList_;
    nsCString statusText_;
    CopyableTArray<HeadersEntry> headers_;
    HeadersGuardEnum headersGuard_;
    mozilla::Maybe<CacheReadStream> body_;
    IPCChannelInfo channelInfo_;
    mozilla::Maybe<PrincipalInfo> principalInfo_;
    int64_t paddingSize_;
    uint32_t status_;
    uint32_t paddingInfo_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::CacheResponse>
{
    typedef mozilla::dom::cache::CacheResponse paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CacheRequestResponse|
//
namespace mozilla {
namespace dom {
namespace cache {
class CacheRequestResponse final
{
private:
    typedef mozilla::dom::cache::CacheRequest CacheRequest;
    typedef mozilla::dom::cache::CacheResponse CacheResponse;

public:
    MOZ_IMPLICIT CacheRequestResponse() :
        request_(),
        response_()
    {
    }

    MOZ_IMPLICIT CacheRequestResponse(
            const CacheRequest& _request,
            const CacheResponse& _response) :
        request_(_request),
        response_(_response)
    {
    }

    CacheRequest&
    request()
    {
        return request_;
    }
    const CacheRequest&
    request() const
    {
        return request_;
    }

    CacheResponse&
    response()
    {
        return response_;
    }
    const CacheResponse&
    response() const
    {
        return response_;
    }

private:
    CacheRequest request_;
    CacheResponse response_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::CacheRequestResponse>
{
    typedef mozilla::dom::cache::CacheRequestResponse paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CacheMatchArgs|
//
namespace mozilla {
namespace dom {
namespace cache {
class CacheMatchArgs final
{
private:
    typedef mozilla::dom::cache::CacheRequest CacheRequest;
    typedef mozilla::dom::cache::CacheQueryParams CacheQueryParams;

public:
    MOZ_IMPLICIT CacheMatchArgs() :
        request_(),
        params_(),
        openMode_()
    {
    }

    MOZ_IMPLICIT CacheMatchArgs(
            const CacheRequest& _request,
            const CacheQueryParams& _params,
            const OpenMode& _openMode) :
        request_(_request),
        params_(_params),
        openMode_(_openMode)
    {
    }

    CacheRequest&
    request()
    {
        return request_;
    }
    const CacheRequest&
    request() const
    {
        return request_;
    }

    CacheQueryParams&
    params()
    {
        return params_;
    }
    const CacheQueryParams&
    params() const
    {
        return params_;
    }

    OpenMode&
    openMode()
    {
        return openMode_;
    }
    const OpenMode&
    openMode() const
    {
        return openMode_;
    }

private:
    CacheRequest request_;
    CacheQueryParams params_;
    OpenMode openMode_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::CacheMatchArgs>
{
    typedef mozilla::dom::cache::CacheMatchArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CacheMatchAllArgs|
//
namespace mozilla {
namespace dom {
namespace cache {
class CacheMatchAllArgs final
{
private:
    typedef mozilla::dom::cache::CacheRequest CacheRequest;
    typedef mozilla::dom::cache::CacheQueryParams CacheQueryParams;

public:
    MOZ_IMPLICIT CacheMatchAllArgs() :
        maybeRequest_(),
        params_(),
        openMode_()
    {
    }

    MOZ_IMPLICIT CacheMatchAllArgs(
            const mozilla::Maybe<CacheRequest>& _maybeRequest,
            const CacheQueryParams& _params,
            const OpenMode& _openMode) :
        maybeRequest_(_maybeRequest),
        params_(_params),
        openMode_(_openMode)
    {
    }

    mozilla::Maybe<CacheRequest>&
    maybeRequest()
    {
        return maybeRequest_;
    }
    const mozilla::Maybe<CacheRequest>&
    maybeRequest() const
    {
        return maybeRequest_;
    }

    CacheQueryParams&
    params()
    {
        return params_;
    }
    const CacheQueryParams&
    params() const
    {
        return params_;
    }

    OpenMode&
    openMode()
    {
        return openMode_;
    }
    const OpenMode&
    openMode() const
    {
        return openMode_;
    }

private:
    mozilla::Maybe<CacheRequest> maybeRequest_;
    CacheQueryParams params_;
    OpenMode openMode_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::CacheMatchAllArgs>
{
    typedef mozilla::dom::cache::CacheMatchAllArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CachePutAllArgs|
//
namespace mozilla {
namespace dom {
namespace cache {
class CachePutAllArgs final
{
private:
    typedef mozilla::dom::cache::CacheRequestResponse CacheRequestResponse;

public:
    MOZ_IMPLICIT CachePutAllArgs() :
        requestResponseList_()
    {
    }

    MOZ_IMPLICIT CachePutAllArgs(const nsTArray<CacheRequestResponse>& _requestResponseList) :
        requestResponseList_(_requestResponseList)
    {
    }

    nsTArray<CacheRequestResponse>&
    requestResponseList()
    {
        return requestResponseList_;
    }
    const nsTArray<CacheRequestResponse>&
    requestResponseList() const
    {
        return requestResponseList_;
    }

private:
    CopyableTArray<CacheRequestResponse> requestResponseList_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::CachePutAllArgs>
{
    typedef mozilla::dom::cache::CachePutAllArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CacheDeleteArgs|
//
namespace mozilla {
namespace dom {
namespace cache {
class CacheDeleteArgs final
{
private:
    typedef mozilla::dom::cache::CacheRequest CacheRequest;
    typedef mozilla::dom::cache::CacheQueryParams CacheQueryParams;

public:
    MOZ_IMPLICIT CacheDeleteArgs() :
        request_(),
        params_()
    {
    }

    MOZ_IMPLICIT CacheDeleteArgs(
            const CacheRequest& _request,
            const CacheQueryParams& _params) :
        request_(_request),
        params_(_params)
    {
    }

    CacheRequest&
    request()
    {
        return request_;
    }
    const CacheRequest&
    request() const
    {
        return request_;
    }

    CacheQueryParams&
    params()
    {
        return params_;
    }
    const CacheQueryParams&
    params() const
    {
        return params_;
    }

private:
    CacheRequest request_;
    CacheQueryParams params_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::CacheDeleteArgs>
{
    typedef mozilla::dom::cache::CacheDeleteArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CacheKeysArgs|
//
namespace mozilla {
namespace dom {
namespace cache {
class CacheKeysArgs final
{
private:
    typedef mozilla::dom::cache::CacheRequest CacheRequest;
    typedef mozilla::dom::cache::CacheQueryParams CacheQueryParams;

public:
    MOZ_IMPLICIT CacheKeysArgs() :
        maybeRequest_(),
        params_(),
        openMode_()
    {
    }

    MOZ_IMPLICIT CacheKeysArgs(
            const mozilla::Maybe<CacheRequest>& _maybeRequest,
            const CacheQueryParams& _params,
            const OpenMode& _openMode) :
        maybeRequest_(_maybeRequest),
        params_(_params),
        openMode_(_openMode)
    {
    }

    mozilla::Maybe<CacheRequest>&
    maybeRequest()
    {
        return maybeRequest_;
    }
    const mozilla::Maybe<CacheRequest>&
    maybeRequest() const
    {
        return maybeRequest_;
    }

    CacheQueryParams&
    params()
    {
        return params_;
    }
    const CacheQueryParams&
    params() const
    {
        return params_;
    }

    OpenMode&
    openMode()
    {
        return openMode_;
    }
    const OpenMode&
    openMode() const
    {
        return openMode_;
    }

private:
    mozilla::Maybe<CacheRequest> maybeRequest_;
    CacheQueryParams params_;
    OpenMode openMode_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::CacheKeysArgs>
{
    typedef mozilla::dom::cache::CacheKeysArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct StorageMatchArgs|
//
namespace mozilla {
namespace dom {
namespace cache {
class StorageMatchArgs final
{
private:
    typedef mozilla::dom::cache::CacheRequest CacheRequest;
    typedef mozilla::dom::cache::CacheQueryParams CacheQueryParams;

public:
    MOZ_IMPLICIT StorageMatchArgs() :
        request_(),
        params_(),
        openMode_()
    {
    }

    MOZ_IMPLICIT StorageMatchArgs(
            const CacheRequest& _request,
            const CacheQueryParams& _params,
            const OpenMode& _openMode) :
        request_(_request),
        params_(_params),
        openMode_(_openMode)
    {
    }

    CacheRequest&
    request()
    {
        return request_;
    }
    const CacheRequest&
    request() const
    {
        return request_;
    }

    CacheQueryParams&
    params()
    {
        return params_;
    }
    const CacheQueryParams&
    params() const
    {
        return params_;
    }

    OpenMode&
    openMode()
    {
        return openMode_;
    }
    const OpenMode&
    openMode() const
    {
        return openMode_;
    }

private:
    CacheRequest request_;
    CacheQueryParams params_;
    OpenMode openMode_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::StorageMatchArgs>
{
    typedef mozilla::dom::cache::StorageMatchArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct StorageHasArgs|
//
namespace mozilla {
namespace dom {
namespace cache {
class StorageHasArgs final
{
private:

public:
    MOZ_IMPLICIT StorageHasArgs() :
        key_()
    {
    }

    MOZ_IMPLICIT StorageHasArgs(const nsString& _key) :
        key_(_key)
    {
    }

    nsString&
    key()
    {
        return key_;
    }
    const nsString&
    key() const
    {
        return key_;
    }

private:
    nsString key_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::StorageHasArgs>
{
    typedef mozilla::dom::cache::StorageHasArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct StorageOpenArgs|
//
namespace mozilla {
namespace dom {
namespace cache {
class StorageOpenArgs final
{
private:

public:
    MOZ_IMPLICIT StorageOpenArgs() :
        key_()
    {
    }

    MOZ_IMPLICIT StorageOpenArgs(const nsString& _key) :
        key_(_key)
    {
    }

    nsString&
    key()
    {
        return key_;
    }
    const nsString&
    key() const
    {
        return key_;
    }

private:
    nsString key_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::StorageOpenArgs>
{
    typedef mozilla::dom::cache::StorageOpenArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct StorageDeleteArgs|
//
namespace mozilla {
namespace dom {
namespace cache {
class StorageDeleteArgs final
{
private:

public:
    MOZ_IMPLICIT StorageDeleteArgs() :
        key_()
    {
    }

    MOZ_IMPLICIT StorageDeleteArgs(const nsString& _key) :
        key_(_key)
    {
    }

    nsString&
    key()
    {
        return key_;
    }
    const nsString&
    key() const
    {
        return key_;
    }

private:
    nsString key_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::StorageDeleteArgs>
{
    typedef mozilla::dom::cache::StorageDeleteArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct StorageKeysArgs|
//
namespace mozilla {
namespace dom {
namespace cache {
class StorageKeysArgs final
{
private:

public:
    MOZ_IMPLICIT StorageKeysArgs()
    {
    }

private:
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::StorageKeysArgs>
{
    typedef mozilla::dom::cache::StorageKeysArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union CacheOpArgs|
//
namespace mozilla {
namespace dom {
namespace cache {
class CacheOpArgs final
{
public:
    enum Type {
        T__None,
        TCacheMatchArgs = 1,
        TCacheMatchAllArgs,
        TCachePutAllArgs,
        TCacheDeleteArgs,
        TCacheKeysArgs,
        TStorageMatchArgs,
        TStorageHasArgs,
        TStorageOpenArgs,
        TStorageDeleteArgs,
        TStorageKeysArgs,
        T__Last = TStorageKeysArgs
    };

private:
    typedef mozilla::dom::cache::CacheMatchArgs CacheMatchArgs;
    typedef mozilla::dom::cache::CacheMatchAllArgs CacheMatchAllArgs;
    typedef mozilla::dom::cache::CachePutAllArgs CachePutAllArgs;
    typedef mozilla::dom::cache::CacheDeleteArgs CacheDeleteArgs;
    typedef mozilla::dom::cache::CacheKeysArgs CacheKeysArgs;
    typedef mozilla::dom::cache::StorageMatchArgs StorageMatchArgs;
    typedef mozilla::dom::cache::StorageHasArgs StorageHasArgs;
    typedef mozilla::dom::cache::StorageOpenArgs StorageOpenArgs;
    typedef mozilla::dom::cache::StorageDeleteArgs StorageDeleteArgs;
    typedef mozilla::dom::cache::StorageKeysArgs StorageKeysArgs;
    typedef CacheMatchArgs CacheMatchArgs__tdef;
    typedef CacheMatchAllArgs CacheMatchAllArgs__tdef;
    typedef CachePutAllArgs CachePutAllArgs__tdef;
    typedef CacheDeleteArgs CacheDeleteArgs__tdef;
    typedef CacheKeysArgs CacheKeysArgs__tdef;
    typedef StorageMatchArgs StorageMatchArgs__tdef;
    typedef StorageHasArgs StorageHasArgs__tdef;
    typedef StorageOpenArgs StorageOpenArgs__tdef;
    typedef StorageDeleteArgs StorageDeleteArgs__tdef;
    typedef StorageKeysArgs StorageKeysArgs__tdef;

    union Value {
        mozilla::AlignedStorage2<CacheMatchArgs> VCacheMatchArgs;
        mozilla::AlignedStorage2<CacheMatchAllArgs> VCacheMatchAllArgs;
        mozilla::AlignedStorage2<CachePutAllArgs> VCachePutAllArgs;
        mozilla::AlignedStorage2<CacheDeleteArgs> VCacheDeleteArgs;
        mozilla::AlignedStorage2<CacheKeysArgs> VCacheKeysArgs;
        mozilla::AlignedStorage2<StorageMatchArgs> VStorageMatchArgs;
        mozilla::AlignedStorage2<StorageHasArgs> VStorageHasArgs;
        mozilla::AlignedStorage2<StorageOpenArgs> VStorageOpenArgs;
        mozilla::AlignedStorage2<StorageDeleteArgs> VStorageDeleteArgs;
        mozilla::AlignedStorage2<StorageKeysArgs> VStorageKeysArgs;
    };

    CacheMatchArgs*
    ptr_CacheMatchArgs()
    {
        return ((mValue).VCacheMatchArgs).addr();
    }
    const CacheMatchArgs*
    constptr_CacheMatchArgs() const
    {
        return ((mValue).VCacheMatchArgs).addr();
    }
    CacheMatchAllArgs*
    ptr_CacheMatchAllArgs()
    {
        return ((mValue).VCacheMatchAllArgs).addr();
    }
    const CacheMatchAllArgs*
    constptr_CacheMatchAllArgs() const
    {
        return ((mValue).VCacheMatchAllArgs).addr();
    }
    CachePutAllArgs*
    ptr_CachePutAllArgs()
    {
        return ((mValue).VCachePutAllArgs).addr();
    }
    const CachePutAllArgs*
    constptr_CachePutAllArgs() const
    {
        return ((mValue).VCachePutAllArgs).addr();
    }
    CacheDeleteArgs*
    ptr_CacheDeleteArgs()
    {
        return ((mValue).VCacheDeleteArgs).addr();
    }
    const CacheDeleteArgs*
    constptr_CacheDeleteArgs() const
    {
        return ((mValue).VCacheDeleteArgs).addr();
    }
    CacheKeysArgs*
    ptr_CacheKeysArgs()
    {
        return ((mValue).VCacheKeysArgs).addr();
    }
    const CacheKeysArgs*
    constptr_CacheKeysArgs() const
    {
        return ((mValue).VCacheKeysArgs).addr();
    }
    StorageMatchArgs*
    ptr_StorageMatchArgs()
    {
        return ((mValue).VStorageMatchArgs).addr();
    }
    const StorageMatchArgs*
    constptr_StorageMatchArgs() const
    {
        return ((mValue).VStorageMatchArgs).addr();
    }
    StorageHasArgs*
    ptr_StorageHasArgs()
    {
        return ((mValue).VStorageHasArgs).addr();
    }
    const StorageHasArgs*
    constptr_StorageHasArgs() const
    {
        return ((mValue).VStorageHasArgs).addr();
    }
    StorageOpenArgs*
    ptr_StorageOpenArgs()
    {
        return ((mValue).VStorageOpenArgs).addr();
    }
    const StorageOpenArgs*
    constptr_StorageOpenArgs() const
    {
        return ((mValue).VStorageOpenArgs).addr();
    }
    StorageDeleteArgs*
    ptr_StorageDeleteArgs()
    {
        return ((mValue).VStorageDeleteArgs).addr();
    }
    const StorageDeleteArgs*
    constptr_StorageDeleteArgs() const
    {
        return ((mValue).VStorageDeleteArgs).addr();
    }
    StorageKeysArgs*
    ptr_StorageKeysArgs()
    {
        return ((mValue).VStorageKeysArgs).addr();
    }
    const StorageKeysArgs*
    constptr_StorageKeysArgs() const
    {
        return ((mValue).VStorageKeysArgs).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT CacheOpArgs() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT CacheOpArgs(const CacheMatchArgs& aOther);

    MOZ_IMPLICIT CacheOpArgs(CacheMatchArgs&& aOther);

    MOZ_IMPLICIT CacheOpArgs(const CacheMatchAllArgs& aOther);

    MOZ_IMPLICIT CacheOpArgs(CacheMatchAllArgs&& aOther);

    MOZ_IMPLICIT CacheOpArgs(const CachePutAllArgs& aOther);

    MOZ_IMPLICIT CacheOpArgs(CachePutAllArgs&& aOther);

    MOZ_IMPLICIT CacheOpArgs(const CacheDeleteArgs& aOther);

    MOZ_IMPLICIT CacheOpArgs(CacheDeleteArgs&& aOther);

    MOZ_IMPLICIT CacheOpArgs(const CacheKeysArgs& aOther);

    MOZ_IMPLICIT CacheOpArgs(CacheKeysArgs&& aOther);

    MOZ_IMPLICIT CacheOpArgs(const StorageMatchArgs& aOther);

    MOZ_IMPLICIT CacheOpArgs(StorageMatchArgs&& aOther);

    MOZ_IMPLICIT CacheOpArgs(const StorageHasArgs& aOther);

    MOZ_IMPLICIT CacheOpArgs(StorageHasArgs&& aOther);

    MOZ_IMPLICIT CacheOpArgs(const StorageOpenArgs& aOther);

    MOZ_IMPLICIT CacheOpArgs(StorageOpenArgs&& aOther);

    MOZ_IMPLICIT CacheOpArgs(const StorageDeleteArgs& aOther);

    MOZ_IMPLICIT CacheOpArgs(StorageDeleteArgs&& aOther);

    MOZ_IMPLICIT CacheOpArgs(const StorageKeysArgs& aOther);

    MOZ_IMPLICIT CacheOpArgs(StorageKeysArgs&& aOther);

    MOZ_IMPLICIT CacheOpArgs(const CacheOpArgs& aOther);

    MOZ_IMPLICIT CacheOpArgs(CacheOpArgs&& aOther);

    ~CacheOpArgs();

    Type
    type() const
    {
        return mType;
    }

    CacheOpArgs&
    operator=(const CacheMatchArgs& aRhs);

    CacheOpArgs&
    operator=(CacheMatchArgs&& aRhs);

    CacheOpArgs&
    operator=(const CacheMatchAllArgs& aRhs);

    CacheOpArgs&
    operator=(CacheMatchAllArgs&& aRhs);

    CacheOpArgs&
    operator=(const CachePutAllArgs& aRhs);

    CacheOpArgs&
    operator=(CachePutAllArgs&& aRhs);

    CacheOpArgs&
    operator=(const CacheDeleteArgs& aRhs);

    CacheOpArgs&
    operator=(CacheDeleteArgs&& aRhs);

    CacheOpArgs&
    operator=(const CacheKeysArgs& aRhs);

    CacheOpArgs&
    operator=(CacheKeysArgs&& aRhs);

    CacheOpArgs&
    operator=(const StorageMatchArgs& aRhs);

    CacheOpArgs&
    operator=(StorageMatchArgs&& aRhs);

    CacheOpArgs&
    operator=(const StorageHasArgs& aRhs);

    CacheOpArgs&
    operator=(StorageHasArgs&& aRhs);

    CacheOpArgs&
    operator=(const StorageOpenArgs& aRhs);

    CacheOpArgs&
    operator=(StorageOpenArgs&& aRhs);

    CacheOpArgs&
    operator=(const StorageDeleteArgs& aRhs);

    CacheOpArgs&
    operator=(StorageDeleteArgs&& aRhs);

    CacheOpArgs&
    operator=(const StorageKeysArgs& aRhs);

    CacheOpArgs&
    operator=(StorageKeysArgs&& aRhs);

    CacheOpArgs&
    operator=(const CacheOpArgs& aRhs);

    CacheOpArgs&
    operator=(CacheOpArgs&& aRhs);

    CacheMatchArgs&
    get_CacheMatchArgs()
    {
        AssertSanity(TCacheMatchArgs);
        return (*(ptr_CacheMatchArgs()));
    }
    const CacheMatchArgs&
    get_CacheMatchArgs() const
    {
        AssertSanity(TCacheMatchArgs);
        return (*(constptr_CacheMatchArgs()));
    }
    operator CacheMatchArgs&()
    {
        return get_CacheMatchArgs();
    }
    operator const CacheMatchArgs&() const
    {
        return get_CacheMatchArgs();
    }

    CacheMatchAllArgs&
    get_CacheMatchAllArgs()
    {
        AssertSanity(TCacheMatchAllArgs);
        return (*(ptr_CacheMatchAllArgs()));
    }
    const CacheMatchAllArgs&
    get_CacheMatchAllArgs() const
    {
        AssertSanity(TCacheMatchAllArgs);
        return (*(constptr_CacheMatchAllArgs()));
    }
    operator CacheMatchAllArgs&()
    {
        return get_CacheMatchAllArgs();
    }
    operator const CacheMatchAllArgs&() const
    {
        return get_CacheMatchAllArgs();
    }

    CachePutAllArgs&
    get_CachePutAllArgs()
    {
        AssertSanity(TCachePutAllArgs);
        return (*(ptr_CachePutAllArgs()));
    }
    const CachePutAllArgs&
    get_CachePutAllArgs() const
    {
        AssertSanity(TCachePutAllArgs);
        return (*(constptr_CachePutAllArgs()));
    }
    operator CachePutAllArgs&()
    {
        return get_CachePutAllArgs();
    }
    operator const CachePutAllArgs&() const
    {
        return get_CachePutAllArgs();
    }

    CacheDeleteArgs&
    get_CacheDeleteArgs()
    {
        AssertSanity(TCacheDeleteArgs);
        return (*(ptr_CacheDeleteArgs()));
    }
    const CacheDeleteArgs&
    get_CacheDeleteArgs() const
    {
        AssertSanity(TCacheDeleteArgs);
        return (*(constptr_CacheDeleteArgs()));
    }
    operator CacheDeleteArgs&()
    {
        return get_CacheDeleteArgs();
    }
    operator const CacheDeleteArgs&() const
    {
        return get_CacheDeleteArgs();
    }

    CacheKeysArgs&
    get_CacheKeysArgs()
    {
        AssertSanity(TCacheKeysArgs);
        return (*(ptr_CacheKeysArgs()));
    }
    const CacheKeysArgs&
    get_CacheKeysArgs() const
    {
        AssertSanity(TCacheKeysArgs);
        return (*(constptr_CacheKeysArgs()));
    }
    operator CacheKeysArgs&()
    {
        return get_CacheKeysArgs();
    }
    operator const CacheKeysArgs&() const
    {
        return get_CacheKeysArgs();
    }

    StorageMatchArgs&
    get_StorageMatchArgs()
    {
        AssertSanity(TStorageMatchArgs);
        return (*(ptr_StorageMatchArgs()));
    }
    const StorageMatchArgs&
    get_StorageMatchArgs() const
    {
        AssertSanity(TStorageMatchArgs);
        return (*(constptr_StorageMatchArgs()));
    }
    operator StorageMatchArgs&()
    {
        return get_StorageMatchArgs();
    }
    operator const StorageMatchArgs&() const
    {
        return get_StorageMatchArgs();
    }

    StorageHasArgs&
    get_StorageHasArgs()
    {
        AssertSanity(TStorageHasArgs);
        return (*(ptr_StorageHasArgs()));
    }
    const StorageHasArgs&
    get_StorageHasArgs() const
    {
        AssertSanity(TStorageHasArgs);
        return (*(constptr_StorageHasArgs()));
    }
    operator StorageHasArgs&()
    {
        return get_StorageHasArgs();
    }
    operator const StorageHasArgs&() const
    {
        return get_StorageHasArgs();
    }

    StorageOpenArgs&
    get_StorageOpenArgs()
    {
        AssertSanity(TStorageOpenArgs);
        return (*(ptr_StorageOpenArgs()));
    }
    const StorageOpenArgs&
    get_StorageOpenArgs() const
    {
        AssertSanity(TStorageOpenArgs);
        return (*(constptr_StorageOpenArgs()));
    }
    operator StorageOpenArgs&()
    {
        return get_StorageOpenArgs();
    }
    operator const StorageOpenArgs&() const
    {
        return get_StorageOpenArgs();
    }

    StorageDeleteArgs&
    get_StorageDeleteArgs()
    {
        AssertSanity(TStorageDeleteArgs);
        return (*(ptr_StorageDeleteArgs()));
    }
    const StorageDeleteArgs&
    get_StorageDeleteArgs() const
    {
        AssertSanity(TStorageDeleteArgs);
        return (*(constptr_StorageDeleteArgs()));
    }
    operator StorageDeleteArgs&()
    {
        return get_StorageDeleteArgs();
    }
    operator const StorageDeleteArgs&() const
    {
        return get_StorageDeleteArgs();
    }

    StorageKeysArgs&
    get_StorageKeysArgs()
    {
        AssertSanity(TStorageKeysArgs);
        return (*(ptr_StorageKeysArgs()));
    }
    const StorageKeysArgs&
    get_StorageKeysArgs() const
    {
        AssertSanity(TStorageKeysArgs);
        return (*(constptr_StorageKeysArgs()));
    }
    operator StorageKeysArgs&()
    {
        return get_StorageKeysArgs();
    }
    operator const StorageKeysArgs&() const
    {
        return get_StorageKeysArgs();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::CacheOpArgs>
{
    typedef mozilla::dom::cache::CacheOpArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CacheMatchResult|
//
namespace mozilla {
namespace dom {
namespace cache {
class CacheMatchResult final
{
private:
    typedef mozilla::dom::cache::CacheResponse CacheResponse;

public:
    MOZ_IMPLICIT CacheMatchResult() :
        maybeResponse_()
    {
    }

    MOZ_IMPLICIT CacheMatchResult(const mozilla::Maybe<CacheResponse>& _maybeResponse) :
        maybeResponse_(_maybeResponse)
    {
    }

    mozilla::Maybe<CacheResponse>&
    maybeResponse()
    {
        return maybeResponse_;
    }
    const mozilla::Maybe<CacheResponse>&
    maybeResponse() const
    {
        return maybeResponse_;
    }

private:
    mozilla::Maybe<CacheResponse> maybeResponse_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::CacheMatchResult>
{
    typedef mozilla::dom::cache::CacheMatchResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CacheMatchAllResult|
//
namespace mozilla {
namespace dom {
namespace cache {
class CacheMatchAllResult final
{
private:
    typedef mozilla::dom::cache::CacheResponse CacheResponse;

public:
    MOZ_IMPLICIT CacheMatchAllResult() :
        responseList_()
    {
    }

    MOZ_IMPLICIT CacheMatchAllResult(const nsTArray<CacheResponse>& _responseList) :
        responseList_(_responseList)
    {
    }

    nsTArray<CacheResponse>&
    responseList()
    {
        return responseList_;
    }
    const nsTArray<CacheResponse>&
    responseList() const
    {
        return responseList_;
    }

private:
    CopyableTArray<CacheResponse> responseList_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::CacheMatchAllResult>
{
    typedef mozilla::dom::cache::CacheMatchAllResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CachePutAllResult|
//
namespace mozilla {
namespace dom {
namespace cache {
class CachePutAllResult final
{
private:

public:
    MOZ_IMPLICIT CachePutAllResult()
    {
    }

private:
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::CachePutAllResult>
{
    typedef mozilla::dom::cache::CachePutAllResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CacheDeleteResult|
//
namespace mozilla {
namespace dom {
namespace cache {
class CacheDeleteResult final
{
private:

public:
    MOZ_IMPLICIT CacheDeleteResult() :
        success_()
    {
    }

    MOZ_IMPLICIT CacheDeleteResult(const bool& _success) :
        success_(_success)
    {
    }

    bool&
    success()
    {
        return success_;
    }
    const bool&
    success() const
    {
        return success_;
    }

private:
    bool success_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::CacheDeleteResult>
{
    typedef mozilla::dom::cache::CacheDeleteResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CacheKeysResult|
//
namespace mozilla {
namespace dom {
namespace cache {
class CacheKeysResult final
{
private:
    typedef mozilla::dom::cache::CacheRequest CacheRequest;

public:
    MOZ_IMPLICIT CacheKeysResult() :
        requestList_()
    {
    }

    MOZ_IMPLICIT CacheKeysResult(const nsTArray<CacheRequest>& _requestList) :
        requestList_(_requestList)
    {
    }

    nsTArray<CacheRequest>&
    requestList()
    {
        return requestList_;
    }
    const nsTArray<CacheRequest>&
    requestList() const
    {
        return requestList_;
    }

private:
    CopyableTArray<CacheRequest> requestList_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::CacheKeysResult>
{
    typedef mozilla::dom::cache::CacheKeysResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct StorageMatchResult|
//
namespace mozilla {
namespace dom {
namespace cache {
class StorageMatchResult final
{
private:
    typedef mozilla::dom::cache::CacheResponse CacheResponse;

public:
    MOZ_IMPLICIT StorageMatchResult() :
        maybeResponse_()
    {
    }

    MOZ_IMPLICIT StorageMatchResult(const mozilla::Maybe<CacheResponse>& _maybeResponse) :
        maybeResponse_(_maybeResponse)
    {
    }

    mozilla::Maybe<CacheResponse>&
    maybeResponse()
    {
        return maybeResponse_;
    }
    const mozilla::Maybe<CacheResponse>&
    maybeResponse() const
    {
        return maybeResponse_;
    }

private:
    mozilla::Maybe<CacheResponse> maybeResponse_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::StorageMatchResult>
{
    typedef mozilla::dom::cache::StorageMatchResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct StorageHasResult|
//
namespace mozilla {
namespace dom {
namespace cache {
class StorageHasResult final
{
private:

public:
    MOZ_IMPLICIT StorageHasResult() :
        success_()
    {
    }

    MOZ_IMPLICIT StorageHasResult(const bool& _success) :
        success_(_success)
    {
    }

    bool&
    success()
    {
        return success_;
    }
    const bool&
    success() const
    {
        return success_;
    }

private:
    bool success_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::StorageHasResult>
{
    typedef mozilla::dom::cache::StorageHasResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace dom {
namespace cache {
class PCacheParent;
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {
namespace cache {
class PCacheChild;
} // namespace cache
} // namespace dom
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct StorageOpenResult|
//
namespace mozilla {
namespace dom {
namespace cache {
class StorageOpenResult final
{
private:
    typedef mozilla::dom::cache::PCacheParent PCacheParent;
    typedef mozilla::dom::cache::PCacheChild PCacheChild;

public:
    MOZ_IMPLICIT StorageOpenResult() :
        actorParent_(),
        actorChild_(),
        ns_()
    {
    }

    MOZ_IMPLICIT StorageOpenResult(
            PCacheParent* _actorParent,
            PCacheChild* _actorChild,
            const Namespace& _ns) :
        actorParent_(_actorParent),
        actorChild_(_actorChild),
        ns_(_ns)
    {
    }

    PCacheParent*&
    actorParent()
    {
        return actorParent_;
    }
    PCacheParent*
    actorParent() const
    {
        return actorParent_;
    }

    PCacheChild*&
    actorChild()
    {
        return actorChild_;
    }
    PCacheChild*
    actorChild() const
    {
        return actorChild_;
    }

    Namespace&
    ns()
    {
        return ns_;
    }
    const Namespace&
    ns() const
    {
        return ns_;
    }

private:
    PCacheParent* actorParent_;
    PCacheChild* actorChild_;
    Namespace ns_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::StorageOpenResult>
{
    typedef mozilla::dom::cache::StorageOpenResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct StorageDeleteResult|
//
namespace mozilla {
namespace dom {
namespace cache {
class StorageDeleteResult final
{
private:

public:
    MOZ_IMPLICIT StorageDeleteResult() :
        success_()
    {
    }

    MOZ_IMPLICIT StorageDeleteResult(const bool& _success) :
        success_(_success)
    {
    }

    bool&
    success()
    {
        return success_;
    }
    const bool&
    success() const
    {
        return success_;
    }

private:
    bool success_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::StorageDeleteResult>
{
    typedef mozilla::dom::cache::StorageDeleteResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct StorageKeysResult|
//
namespace mozilla {
namespace dom {
namespace cache {
class StorageKeysResult final
{
private:

public:
    MOZ_IMPLICIT StorageKeysResult() :
        keyList_()
    {
    }

    MOZ_IMPLICIT StorageKeysResult(const nsTArray<nsString>& _keyList) :
        keyList_(_keyList)
    {
    }

    nsTArray<nsString>&
    keyList()
    {
        return keyList_;
    }
    const nsTArray<nsString>&
    keyList() const
    {
        return keyList_;
    }

private:
    CopyableTArray<nsString> keyList_;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::StorageKeysResult>
{
    typedef mozilla::dom::cache::StorageKeysResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union CacheOpResult|
//
namespace mozilla {
namespace dom {
namespace cache {
class CacheOpResult final
{
public:
    enum Type {
        T__None,
        Tvoid_t = 1,
        TCacheMatchResult,
        TCacheMatchAllResult,
        TCachePutAllResult,
        TCacheDeleteResult,
        TCacheKeysResult,
        TStorageMatchResult,
        TStorageHasResult,
        TStorageOpenResult,
        TStorageDeleteResult,
        TStorageKeysResult,
        T__Last = TStorageKeysResult
    };

private:
    typedef mozilla::void_t void_t;
    typedef mozilla::dom::cache::CacheMatchResult CacheMatchResult;
    typedef mozilla::dom::cache::CacheMatchAllResult CacheMatchAllResult;
    typedef mozilla::dom::cache::CachePutAllResult CachePutAllResult;
    typedef mozilla::dom::cache::CacheDeleteResult CacheDeleteResult;
    typedef mozilla::dom::cache::CacheKeysResult CacheKeysResult;
    typedef mozilla::dom::cache::StorageMatchResult StorageMatchResult;
    typedef mozilla::dom::cache::StorageHasResult StorageHasResult;
    typedef mozilla::dom::cache::StorageOpenResult StorageOpenResult;
    typedef mozilla::dom::cache::StorageDeleteResult StorageDeleteResult;
    typedef mozilla::dom::cache::StorageKeysResult StorageKeysResult;
    typedef void_t void_t__tdef;
    typedef CacheMatchResult CacheMatchResult__tdef;
    typedef CacheMatchAllResult CacheMatchAllResult__tdef;
    typedef CachePutAllResult CachePutAllResult__tdef;
    typedef CacheDeleteResult CacheDeleteResult__tdef;
    typedef CacheKeysResult CacheKeysResult__tdef;
    typedef StorageMatchResult StorageMatchResult__tdef;
    typedef StorageHasResult StorageHasResult__tdef;
    typedef StorageOpenResult StorageOpenResult__tdef;
    typedef StorageDeleteResult StorageDeleteResult__tdef;
    typedef StorageKeysResult StorageKeysResult__tdef;

    union Value {
        mozilla::AlignedStorage2<void_t> Vvoid_t;
        mozilla::AlignedStorage2<CacheMatchResult> VCacheMatchResult;
        mozilla::AlignedStorage2<CacheMatchAllResult> VCacheMatchAllResult;
        mozilla::AlignedStorage2<CachePutAllResult> VCachePutAllResult;
        mozilla::AlignedStorage2<CacheDeleteResult> VCacheDeleteResult;
        mozilla::AlignedStorage2<CacheKeysResult> VCacheKeysResult;
        mozilla::AlignedStorage2<StorageMatchResult> VStorageMatchResult;
        mozilla::AlignedStorage2<StorageHasResult> VStorageHasResult;
        mozilla::AlignedStorage2<StorageOpenResult> VStorageOpenResult;
        mozilla::AlignedStorage2<StorageDeleteResult> VStorageDeleteResult;
        mozilla::AlignedStorage2<StorageKeysResult> VStorageKeysResult;
    };

    void_t*
    ptr_void_t()
    {
        return ((mValue).Vvoid_t).addr();
    }
    const void_t*
    constptr_void_t() const
    {
        return ((mValue).Vvoid_t).addr();
    }
    CacheMatchResult*
    ptr_CacheMatchResult()
    {
        return ((mValue).VCacheMatchResult).addr();
    }
    const CacheMatchResult*
    constptr_CacheMatchResult() const
    {
        return ((mValue).VCacheMatchResult).addr();
    }
    CacheMatchAllResult*
    ptr_CacheMatchAllResult()
    {
        return ((mValue).VCacheMatchAllResult).addr();
    }
    const CacheMatchAllResult*
    constptr_CacheMatchAllResult() const
    {
        return ((mValue).VCacheMatchAllResult).addr();
    }
    CachePutAllResult*
    ptr_CachePutAllResult()
    {
        return ((mValue).VCachePutAllResult).addr();
    }
    const CachePutAllResult*
    constptr_CachePutAllResult() const
    {
        return ((mValue).VCachePutAllResult).addr();
    }
    CacheDeleteResult*
    ptr_CacheDeleteResult()
    {
        return ((mValue).VCacheDeleteResult).addr();
    }
    const CacheDeleteResult*
    constptr_CacheDeleteResult() const
    {
        return ((mValue).VCacheDeleteResult).addr();
    }
    CacheKeysResult*
    ptr_CacheKeysResult()
    {
        return ((mValue).VCacheKeysResult).addr();
    }
    const CacheKeysResult*
    constptr_CacheKeysResult() const
    {
        return ((mValue).VCacheKeysResult).addr();
    }
    StorageMatchResult*
    ptr_StorageMatchResult()
    {
        return ((mValue).VStorageMatchResult).addr();
    }
    const StorageMatchResult*
    constptr_StorageMatchResult() const
    {
        return ((mValue).VStorageMatchResult).addr();
    }
    StorageHasResult*
    ptr_StorageHasResult()
    {
        return ((mValue).VStorageHasResult).addr();
    }
    const StorageHasResult*
    constptr_StorageHasResult() const
    {
        return ((mValue).VStorageHasResult).addr();
    }
    StorageOpenResult*
    ptr_StorageOpenResult()
    {
        return ((mValue).VStorageOpenResult).addr();
    }
    const StorageOpenResult*
    constptr_StorageOpenResult() const
    {
        return ((mValue).VStorageOpenResult).addr();
    }
    StorageDeleteResult*
    ptr_StorageDeleteResult()
    {
        return ((mValue).VStorageDeleteResult).addr();
    }
    const StorageDeleteResult*
    constptr_StorageDeleteResult() const
    {
        return ((mValue).VStorageDeleteResult).addr();
    }
    StorageKeysResult*
    ptr_StorageKeysResult()
    {
        return ((mValue).VStorageKeysResult).addr();
    }
    const StorageKeysResult*
    constptr_StorageKeysResult() const
    {
        return ((mValue).VStorageKeysResult).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT CacheOpResult() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT CacheOpResult(const void_t& aOther);

    MOZ_IMPLICIT CacheOpResult(void_t&& aOther);

    MOZ_IMPLICIT CacheOpResult(const CacheMatchResult& aOther);

    MOZ_IMPLICIT CacheOpResult(CacheMatchResult&& aOther);

    MOZ_IMPLICIT CacheOpResult(const CacheMatchAllResult& aOther);

    MOZ_IMPLICIT CacheOpResult(CacheMatchAllResult&& aOther);

    MOZ_IMPLICIT CacheOpResult(const CachePutAllResult& aOther);

    MOZ_IMPLICIT CacheOpResult(CachePutAllResult&& aOther);

    MOZ_IMPLICIT CacheOpResult(const CacheDeleteResult& aOther);

    MOZ_IMPLICIT CacheOpResult(CacheDeleteResult&& aOther);

    MOZ_IMPLICIT CacheOpResult(const CacheKeysResult& aOther);

    MOZ_IMPLICIT CacheOpResult(CacheKeysResult&& aOther);

    MOZ_IMPLICIT CacheOpResult(const StorageMatchResult& aOther);

    MOZ_IMPLICIT CacheOpResult(StorageMatchResult&& aOther);

    MOZ_IMPLICIT CacheOpResult(const StorageHasResult& aOther);

    MOZ_IMPLICIT CacheOpResult(StorageHasResult&& aOther);

    MOZ_IMPLICIT CacheOpResult(const StorageOpenResult& aOther);

    MOZ_IMPLICIT CacheOpResult(StorageOpenResult&& aOther);

    MOZ_IMPLICIT CacheOpResult(const StorageDeleteResult& aOther);

    MOZ_IMPLICIT CacheOpResult(StorageDeleteResult&& aOther);

    MOZ_IMPLICIT CacheOpResult(const StorageKeysResult& aOther);

    MOZ_IMPLICIT CacheOpResult(StorageKeysResult&& aOther);

    MOZ_IMPLICIT CacheOpResult(const CacheOpResult& aOther);

    MOZ_IMPLICIT CacheOpResult(CacheOpResult&& aOther);

    ~CacheOpResult();

    Type
    type() const
    {
        return mType;
    }

    CacheOpResult&
    operator=(const void_t& aRhs);

    CacheOpResult&
    operator=(void_t&& aRhs);

    CacheOpResult&
    operator=(const CacheMatchResult& aRhs);

    CacheOpResult&
    operator=(CacheMatchResult&& aRhs);

    CacheOpResult&
    operator=(const CacheMatchAllResult& aRhs);

    CacheOpResult&
    operator=(CacheMatchAllResult&& aRhs);

    CacheOpResult&
    operator=(const CachePutAllResult& aRhs);

    CacheOpResult&
    operator=(CachePutAllResult&& aRhs);

    CacheOpResult&
    operator=(const CacheDeleteResult& aRhs);

    CacheOpResult&
    operator=(CacheDeleteResult&& aRhs);

    CacheOpResult&
    operator=(const CacheKeysResult& aRhs);

    CacheOpResult&
    operator=(CacheKeysResult&& aRhs);

    CacheOpResult&
    operator=(const StorageMatchResult& aRhs);

    CacheOpResult&
    operator=(StorageMatchResult&& aRhs);

    CacheOpResult&
    operator=(const StorageHasResult& aRhs);

    CacheOpResult&
    operator=(StorageHasResult&& aRhs);

    CacheOpResult&
    operator=(const StorageOpenResult& aRhs);

    CacheOpResult&
    operator=(StorageOpenResult&& aRhs);

    CacheOpResult&
    operator=(const StorageDeleteResult& aRhs);

    CacheOpResult&
    operator=(StorageDeleteResult&& aRhs);

    CacheOpResult&
    operator=(const StorageKeysResult& aRhs);

    CacheOpResult&
    operator=(StorageKeysResult&& aRhs);

    CacheOpResult&
    operator=(const CacheOpResult& aRhs);

    CacheOpResult&
    operator=(CacheOpResult&& aRhs);

    void_t&
    get_void_t()
    {
        AssertSanity(Tvoid_t);
        return (*(ptr_void_t()));
    }
    const void_t&
    get_void_t() const
    {
        AssertSanity(Tvoid_t);
        return (*(constptr_void_t()));
    }
    operator void_t&()
    {
        return get_void_t();
    }
    operator const void_t&() const
    {
        return get_void_t();
    }

    CacheMatchResult&
    get_CacheMatchResult()
    {
        AssertSanity(TCacheMatchResult);
        return (*(ptr_CacheMatchResult()));
    }
    const CacheMatchResult&
    get_CacheMatchResult() const
    {
        AssertSanity(TCacheMatchResult);
        return (*(constptr_CacheMatchResult()));
    }
    operator CacheMatchResult&()
    {
        return get_CacheMatchResult();
    }
    operator const CacheMatchResult&() const
    {
        return get_CacheMatchResult();
    }

    CacheMatchAllResult&
    get_CacheMatchAllResult()
    {
        AssertSanity(TCacheMatchAllResult);
        return (*(ptr_CacheMatchAllResult()));
    }
    const CacheMatchAllResult&
    get_CacheMatchAllResult() const
    {
        AssertSanity(TCacheMatchAllResult);
        return (*(constptr_CacheMatchAllResult()));
    }
    operator CacheMatchAllResult&()
    {
        return get_CacheMatchAllResult();
    }
    operator const CacheMatchAllResult&() const
    {
        return get_CacheMatchAllResult();
    }

    CachePutAllResult&
    get_CachePutAllResult()
    {
        AssertSanity(TCachePutAllResult);
        return (*(ptr_CachePutAllResult()));
    }
    const CachePutAllResult&
    get_CachePutAllResult() const
    {
        AssertSanity(TCachePutAllResult);
        return (*(constptr_CachePutAllResult()));
    }
    operator CachePutAllResult&()
    {
        return get_CachePutAllResult();
    }
    operator const CachePutAllResult&() const
    {
        return get_CachePutAllResult();
    }

    CacheDeleteResult&
    get_CacheDeleteResult()
    {
        AssertSanity(TCacheDeleteResult);
        return (*(ptr_CacheDeleteResult()));
    }
    const CacheDeleteResult&
    get_CacheDeleteResult() const
    {
        AssertSanity(TCacheDeleteResult);
        return (*(constptr_CacheDeleteResult()));
    }
    operator CacheDeleteResult&()
    {
        return get_CacheDeleteResult();
    }
    operator const CacheDeleteResult&() const
    {
        return get_CacheDeleteResult();
    }

    CacheKeysResult&
    get_CacheKeysResult()
    {
        AssertSanity(TCacheKeysResult);
        return (*(ptr_CacheKeysResult()));
    }
    const CacheKeysResult&
    get_CacheKeysResult() const
    {
        AssertSanity(TCacheKeysResult);
        return (*(constptr_CacheKeysResult()));
    }
    operator CacheKeysResult&()
    {
        return get_CacheKeysResult();
    }
    operator const CacheKeysResult&() const
    {
        return get_CacheKeysResult();
    }

    StorageMatchResult&
    get_StorageMatchResult()
    {
        AssertSanity(TStorageMatchResult);
        return (*(ptr_StorageMatchResult()));
    }
    const StorageMatchResult&
    get_StorageMatchResult() const
    {
        AssertSanity(TStorageMatchResult);
        return (*(constptr_StorageMatchResult()));
    }
    operator StorageMatchResult&()
    {
        return get_StorageMatchResult();
    }
    operator const StorageMatchResult&() const
    {
        return get_StorageMatchResult();
    }

    StorageHasResult&
    get_StorageHasResult()
    {
        AssertSanity(TStorageHasResult);
        return (*(ptr_StorageHasResult()));
    }
    const StorageHasResult&
    get_StorageHasResult() const
    {
        AssertSanity(TStorageHasResult);
        return (*(constptr_StorageHasResult()));
    }
    operator StorageHasResult&()
    {
        return get_StorageHasResult();
    }
    operator const StorageHasResult&() const
    {
        return get_StorageHasResult();
    }

    StorageOpenResult&
    get_StorageOpenResult()
    {
        AssertSanity(TStorageOpenResult);
        return (*(ptr_StorageOpenResult()));
    }
    const StorageOpenResult&
    get_StorageOpenResult() const
    {
        AssertSanity(TStorageOpenResult);
        return (*(constptr_StorageOpenResult()));
    }
    operator StorageOpenResult&()
    {
        return get_StorageOpenResult();
    }
    operator const StorageOpenResult&() const
    {
        return get_StorageOpenResult();
    }

    StorageDeleteResult&
    get_StorageDeleteResult()
    {
        AssertSanity(TStorageDeleteResult);
        return (*(ptr_StorageDeleteResult()));
    }
    const StorageDeleteResult&
    get_StorageDeleteResult() const
    {
        AssertSanity(TStorageDeleteResult);
        return (*(constptr_StorageDeleteResult()));
    }
    operator StorageDeleteResult&()
    {
        return get_StorageDeleteResult();
    }
    operator const StorageDeleteResult&() const
    {
        return get_StorageDeleteResult();
    }

    StorageKeysResult&
    get_StorageKeysResult()
    {
        AssertSanity(TStorageKeysResult);
        return (*(ptr_StorageKeysResult()));
    }
    const StorageKeysResult&
    get_StorageKeysResult() const
    {
        AssertSanity(TStorageKeysResult);
        return (*(constptr_StorageKeysResult()));
    }
    operator StorageKeysResult&()
    {
        return get_StorageKeysResult();
    }
    operator const StorageKeysResult&() const
    {
        return get_StorageKeysResult();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace cache
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::cache::CacheOpResult>
{
    typedef mozilla::dom::cache::CacheOpResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

#endif // ifndef CacheTypes_h
