//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef GamepadEventTypes_h
#define GamepadEventTypes_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "mozilla/dom/GamepadBinding.h"
#include "mozilla/dom/GamepadHandle.h"
#include "mozilla/dom/GamepadLightIndicatorBinding.h"
#include "mozilla/dom/GamepadPoseState.h"
#include "mozilla/dom/GamepadTouchState.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct GamepadAdded|
//
namespace mozilla {
namespace dom {
class GamepadAdded final
{
private:
    typedef mozilla::dom::GamepadMappingType GamepadMappingType;
    typedef mozilla::dom::GamepadHand GamepadHand;

public:
    MOZ_IMPLICIT GamepadAdded() :
        id_(),
        mapping_(),
        hand_(),
        display_id_(),
        num_buttons_(),
        num_axes_(),
        num_haptics_(),
        num_lights_(),
        num_touches_()
    {
    }

    MOZ_IMPLICIT GamepadAdded(
            const nsString& _id,
            const GamepadMappingType& _mapping,
            const GamepadHand& _hand,
            const uint32_t& _display_id,
            const uint32_t& _num_buttons,
            const uint32_t& _num_axes,
            const uint32_t& _num_haptics,
            const uint32_t& _num_lights,
            const uint32_t& _num_touches) :
        id_(_id),
        mapping_(_mapping),
        hand_(_hand),
        display_id_(_display_id),
        num_buttons_(_num_buttons),
        num_axes_(_num_axes),
        num_haptics_(_num_haptics),
        num_lights_(_num_lights),
        num_touches_(_num_touches)
    {
    }

    nsString&
    id()
    {
        return id_;
    }
    const nsString&
    id() const
    {
        return id_;
    }

    GamepadMappingType&
    mapping()
    {
        return mapping_;
    }
    const GamepadMappingType&
    mapping() const
    {
        return mapping_;
    }

    GamepadHand&
    hand()
    {
        return hand_;
    }
    const GamepadHand&
    hand() const
    {
        return hand_;
    }

    uint32_t&
    display_id()
    {
        return display_id_;
    }
    const uint32_t&
    display_id() const
    {
        return display_id_;
    }

    uint32_t&
    num_buttons()
    {
        return num_buttons_;
    }
    const uint32_t&
    num_buttons() const
    {
        return num_buttons_;
    }

    uint32_t&
    num_axes()
    {
        return num_axes_;
    }
    const uint32_t&
    num_axes() const
    {
        return num_axes_;
    }

    uint32_t&
    num_haptics()
    {
        return num_haptics_;
    }
    const uint32_t&
    num_haptics() const
    {
        return num_haptics_;
    }

    uint32_t&
    num_lights()
    {
        return num_lights_;
    }
    const uint32_t&
    num_lights() const
    {
        return num_lights_;
    }

    uint32_t&
    num_touches()
    {
        return num_touches_;
    }
    const uint32_t&
    num_touches() const
    {
        return num_touches_;
    }

private:
    void
    StaticAssertions() const;
    nsString id_;
    GamepadMappingType mapping_;
    GamepadHand hand_;
    uint32_t display_id_;
    uint32_t num_buttons_;
    uint32_t num_axes_;
    uint32_t num_haptics_;
    uint32_t num_lights_;
    uint32_t num_touches_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::GamepadAdded>
{
    typedef mozilla::dom::GamepadAdded paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct GamepadRemoved|
//
namespace mozilla {
namespace dom {
class GamepadRemoved final
{
private:

public:
    MOZ_IMPLICIT GamepadRemoved()
    {
    }

private:
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::GamepadRemoved>
{
    typedef mozilla::dom::GamepadRemoved paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct GamepadAxisInformation|
//
namespace mozilla {
namespace dom {
class GamepadAxisInformation final
{
private:

public:
    MOZ_IMPLICIT GamepadAxisInformation() :
        value_(),
        axis_()
    {
    }

    MOZ_IMPLICIT GamepadAxisInformation(
            const uint32_t& _axis,
            const double& _value) :
        value_(_value),
        axis_(_axis)
    {
    }

    uint32_t&
    axis()
    {
        return axis_;
    }
    const uint32_t&
    axis() const
    {
        return axis_;
    }

    double&
    value()
    {
        return value_;
    }
    const double&
    value() const
    {
        return value_;
    }

private:
    double value_;
    uint32_t axis_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::GamepadAxisInformation>
{
    typedef mozilla::dom::GamepadAxisInformation paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct GamepadButtonInformation|
//
namespace mozilla {
namespace dom {
class GamepadButtonInformation final
{
private:

public:
    MOZ_IMPLICIT GamepadButtonInformation() :
        pressed_(),
        touched_(),
        value_(),
        button_()
    {
    }

    MOZ_IMPLICIT GamepadButtonInformation(
            const uint32_t& _button,
            const double& _value,
            const bool& _pressed,
            const bool& _touched) :
        pressed_(_pressed),
        touched_(_touched),
        value_(_value),
        button_(_button)
    {
    }

    uint32_t&
    button()
    {
        return button_;
    }
    const uint32_t&
    button() const
    {
        return button_;
    }

    double&
    value()
    {
        return value_;
    }
    const double&
    value() const
    {
        return value_;
    }

    bool&
    pressed()
    {
        return pressed_;
    }
    const bool&
    pressed() const
    {
        return pressed_;
    }

    bool&
    touched()
    {
        return touched_;
    }
    const bool&
    touched() const
    {
        return touched_;
    }

private:
    bool pressed_;
    bool touched_;
    double value_;
    uint32_t button_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::GamepadButtonInformation>
{
    typedef mozilla::dom::GamepadButtonInformation paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct GamepadPoseInformation|
//
namespace mozilla {
namespace dom {
class GamepadPoseInformation final
{
private:
    typedef mozilla::dom::GamepadPoseState GamepadPoseState;

public:
    MOZ_IMPLICIT GamepadPoseInformation() :
        pose_state_()
    {
    }

    MOZ_IMPLICIT GamepadPoseInformation(const GamepadPoseState& _pose_state) :
        pose_state_(_pose_state)
    {
    }

    GamepadPoseState&
    pose_state()
    {
        return pose_state_;
    }
    const GamepadPoseState&
    pose_state() const
    {
        return pose_state_;
    }

private:
    GamepadPoseState pose_state_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::GamepadPoseInformation>
{
    typedef mozilla::dom::GamepadPoseInformation paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct GamepadLightIndicatorTypeInformation|
//
namespace mozilla {
namespace dom {
class GamepadLightIndicatorTypeInformation final
{
private:
    typedef mozilla::dom::GamepadLightIndicatorType GamepadLightIndicatorType;

public:
    MOZ_IMPLICIT GamepadLightIndicatorTypeInformation() :
        type_(),
        light_()
    {
    }

    MOZ_IMPLICIT GamepadLightIndicatorTypeInformation(
            const uint32_t& _light,
            const GamepadLightIndicatorType& _type) :
        type_(_type),
        light_(_light)
    {
    }

    uint32_t&
    light()
    {
        return light_;
    }
    const uint32_t&
    light() const
    {
        return light_;
    }

    GamepadLightIndicatorType&
    type()
    {
        return type_;
    }
    const GamepadLightIndicatorType&
    type() const
    {
        return type_;
    }

private:
    GamepadLightIndicatorType type_;
    uint32_t light_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::GamepadLightIndicatorTypeInformation>
{
    typedef mozilla::dom::GamepadLightIndicatorTypeInformation paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct GamepadHandInformation|
//
namespace mozilla {
namespace dom {
class GamepadHandInformation final
{
private:
    typedef mozilla::dom::GamepadHand GamepadHand;

public:
    MOZ_IMPLICIT GamepadHandInformation() :
        hand_()
    {
    }

    MOZ_IMPLICIT GamepadHandInformation(const GamepadHand& _hand) :
        hand_(_hand)
    {
    }

    GamepadHand&
    hand()
    {
        return hand_;
    }
    const GamepadHand&
    hand() const
    {
        return hand_;
    }

private:
    GamepadHand hand_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::GamepadHandInformation>
{
    typedef mozilla::dom::GamepadHandInformation paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct GamepadTouchInformation|
//
namespace mozilla {
namespace dom {
class GamepadTouchInformation final
{
private:
    typedef mozilla::dom::GamepadTouchState GamepadTouchState;

public:
    MOZ_IMPLICIT GamepadTouchInformation() :
        touch_state_(),
        index_()
    {
    }

    MOZ_IMPLICIT GamepadTouchInformation(
            const uint32_t& _index,
            const GamepadTouchState& _touch_state) :
        touch_state_(_touch_state),
        index_(_index)
    {
    }

    uint32_t&
    index()
    {
        return index_;
    }
    const uint32_t&
    index() const
    {
        return index_;
    }

    GamepadTouchState&
    touch_state()
    {
        return touch_state_;
    }
    const GamepadTouchState&
    touch_state() const
    {
        return touch_state_;
    }

private:
    GamepadTouchState touch_state_;
    uint32_t index_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::GamepadTouchInformation>
{
    typedef mozilla::dom::GamepadTouchInformation paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union GamepadChangeEventBody|
//
namespace mozilla {
namespace dom {
class GamepadChangeEventBody final
{
public:
    enum Type {
        T__None,
        TGamepadAdded = 1,
        TGamepadRemoved,
        TGamepadAxisInformation,
        TGamepadButtonInformation,
        TGamepadHandInformation,
        TGamepadLightIndicatorTypeInformation,
        TGamepadPoseInformation,
        TGamepadTouchInformation,
        T__Last = TGamepadTouchInformation
    };

private:
    typedef mozilla::dom::GamepadAdded GamepadAdded;
    typedef mozilla::dom::GamepadRemoved GamepadRemoved;
    typedef mozilla::dom::GamepadAxisInformation GamepadAxisInformation;
    typedef mozilla::dom::GamepadButtonInformation GamepadButtonInformation;
    typedef mozilla::dom::GamepadHandInformation GamepadHandInformation;
    typedef mozilla::dom::GamepadLightIndicatorTypeInformation GamepadLightIndicatorTypeInformation;
    typedef mozilla::dom::GamepadPoseInformation GamepadPoseInformation;
    typedef mozilla::dom::GamepadTouchInformation GamepadTouchInformation;
    typedef GamepadAdded GamepadAdded__tdef;
    typedef GamepadRemoved GamepadRemoved__tdef;
    typedef GamepadAxisInformation GamepadAxisInformation__tdef;
    typedef GamepadButtonInformation GamepadButtonInformation__tdef;
    typedef GamepadHandInformation GamepadHandInformation__tdef;
    typedef GamepadLightIndicatorTypeInformation GamepadLightIndicatorTypeInformation__tdef;
    typedef GamepadPoseInformation GamepadPoseInformation__tdef;
    typedef GamepadTouchInformation GamepadTouchInformation__tdef;

    union Value {
        mozilla::AlignedStorage2<GamepadAdded> VGamepadAdded;
        mozilla::AlignedStorage2<GamepadRemoved> VGamepadRemoved;
        mozilla::AlignedStorage2<GamepadAxisInformation> VGamepadAxisInformation;
        mozilla::AlignedStorage2<GamepadButtonInformation> VGamepadButtonInformation;
        mozilla::AlignedStorage2<GamepadHandInformation> VGamepadHandInformation;
        mozilla::AlignedStorage2<GamepadLightIndicatorTypeInformation> VGamepadLightIndicatorTypeInformation;
        mozilla::AlignedStorage2<GamepadPoseInformation> VGamepadPoseInformation;
        mozilla::AlignedStorage2<GamepadTouchInformation> VGamepadTouchInformation;
    };

    GamepadAdded*
    ptr_GamepadAdded()
    {
        return ((mValue).VGamepadAdded).addr();
    }
    const GamepadAdded*
    constptr_GamepadAdded() const
    {
        return ((mValue).VGamepadAdded).addr();
    }
    GamepadRemoved*
    ptr_GamepadRemoved()
    {
        return ((mValue).VGamepadRemoved).addr();
    }
    const GamepadRemoved*
    constptr_GamepadRemoved() const
    {
        return ((mValue).VGamepadRemoved).addr();
    }
    GamepadAxisInformation*
    ptr_GamepadAxisInformation()
    {
        return ((mValue).VGamepadAxisInformation).addr();
    }
    const GamepadAxisInformation*
    constptr_GamepadAxisInformation() const
    {
        return ((mValue).VGamepadAxisInformation).addr();
    }
    GamepadButtonInformation*
    ptr_GamepadButtonInformation()
    {
        return ((mValue).VGamepadButtonInformation).addr();
    }
    const GamepadButtonInformation*
    constptr_GamepadButtonInformation() const
    {
        return ((mValue).VGamepadButtonInformation).addr();
    }
    GamepadHandInformation*
    ptr_GamepadHandInformation()
    {
        return ((mValue).VGamepadHandInformation).addr();
    }
    const GamepadHandInformation*
    constptr_GamepadHandInformation() const
    {
        return ((mValue).VGamepadHandInformation).addr();
    }
    GamepadLightIndicatorTypeInformation*
    ptr_GamepadLightIndicatorTypeInformation()
    {
        return ((mValue).VGamepadLightIndicatorTypeInformation).addr();
    }
    const GamepadLightIndicatorTypeInformation*
    constptr_GamepadLightIndicatorTypeInformation() const
    {
        return ((mValue).VGamepadLightIndicatorTypeInformation).addr();
    }
    GamepadPoseInformation*
    ptr_GamepadPoseInformation()
    {
        return ((mValue).VGamepadPoseInformation).addr();
    }
    const GamepadPoseInformation*
    constptr_GamepadPoseInformation() const
    {
        return ((mValue).VGamepadPoseInformation).addr();
    }
    GamepadTouchInformation*
    ptr_GamepadTouchInformation()
    {
        return ((mValue).VGamepadTouchInformation).addr();
    }
    const GamepadTouchInformation*
    constptr_GamepadTouchInformation() const
    {
        return ((mValue).VGamepadTouchInformation).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT GamepadChangeEventBody() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT GamepadChangeEventBody(const GamepadAdded& aOther);

    MOZ_IMPLICIT GamepadChangeEventBody(GamepadAdded&& aOther);

    MOZ_IMPLICIT GamepadChangeEventBody(const GamepadRemoved& aOther);

    MOZ_IMPLICIT GamepadChangeEventBody(GamepadRemoved&& aOther);

    MOZ_IMPLICIT GamepadChangeEventBody(const GamepadAxisInformation& aOther);

    MOZ_IMPLICIT GamepadChangeEventBody(GamepadAxisInformation&& aOther);

    MOZ_IMPLICIT GamepadChangeEventBody(const GamepadButtonInformation& aOther);

    MOZ_IMPLICIT GamepadChangeEventBody(GamepadButtonInformation&& aOther);

    MOZ_IMPLICIT GamepadChangeEventBody(const GamepadHandInformation& aOther);

    MOZ_IMPLICIT GamepadChangeEventBody(GamepadHandInformation&& aOther);

    MOZ_IMPLICIT GamepadChangeEventBody(const GamepadLightIndicatorTypeInformation& aOther);

    MOZ_IMPLICIT GamepadChangeEventBody(GamepadLightIndicatorTypeInformation&& aOther);

    MOZ_IMPLICIT GamepadChangeEventBody(const GamepadPoseInformation& aOther);

    MOZ_IMPLICIT GamepadChangeEventBody(GamepadPoseInformation&& aOther);

    MOZ_IMPLICIT GamepadChangeEventBody(const GamepadTouchInformation& aOther);

    MOZ_IMPLICIT GamepadChangeEventBody(GamepadTouchInformation&& aOther);

    MOZ_IMPLICIT GamepadChangeEventBody(const GamepadChangeEventBody& aOther);

    MOZ_IMPLICIT GamepadChangeEventBody(GamepadChangeEventBody&& aOther);

    ~GamepadChangeEventBody();

    Type
    type() const
    {
        return mType;
    }

    GamepadChangeEventBody&
    operator=(const GamepadAdded& aRhs);

    GamepadChangeEventBody&
    operator=(GamepadAdded&& aRhs);

    GamepadChangeEventBody&
    operator=(const GamepadRemoved& aRhs);

    GamepadChangeEventBody&
    operator=(GamepadRemoved&& aRhs);

    GamepadChangeEventBody&
    operator=(const GamepadAxisInformation& aRhs);

    GamepadChangeEventBody&
    operator=(GamepadAxisInformation&& aRhs);

    GamepadChangeEventBody&
    operator=(const GamepadButtonInformation& aRhs);

    GamepadChangeEventBody&
    operator=(GamepadButtonInformation&& aRhs);

    GamepadChangeEventBody&
    operator=(const GamepadHandInformation& aRhs);

    GamepadChangeEventBody&
    operator=(GamepadHandInformation&& aRhs);

    GamepadChangeEventBody&
    operator=(const GamepadLightIndicatorTypeInformation& aRhs);

    GamepadChangeEventBody&
    operator=(GamepadLightIndicatorTypeInformation&& aRhs);

    GamepadChangeEventBody&
    operator=(const GamepadPoseInformation& aRhs);

    GamepadChangeEventBody&
    operator=(GamepadPoseInformation&& aRhs);

    GamepadChangeEventBody&
    operator=(const GamepadTouchInformation& aRhs);

    GamepadChangeEventBody&
    operator=(GamepadTouchInformation&& aRhs);

    GamepadChangeEventBody&
    operator=(const GamepadChangeEventBody& aRhs);

    GamepadChangeEventBody&
    operator=(GamepadChangeEventBody&& aRhs);

    GamepadAdded&
    get_GamepadAdded()
    {
        AssertSanity(TGamepadAdded);
        return (*(ptr_GamepadAdded()));
    }
    const GamepadAdded&
    get_GamepadAdded() const
    {
        AssertSanity(TGamepadAdded);
        return (*(constptr_GamepadAdded()));
    }
    operator GamepadAdded&()
    {
        return get_GamepadAdded();
    }
    operator const GamepadAdded&() const
    {
        return get_GamepadAdded();
    }

    GamepadRemoved&
    get_GamepadRemoved()
    {
        AssertSanity(TGamepadRemoved);
        return (*(ptr_GamepadRemoved()));
    }
    const GamepadRemoved&
    get_GamepadRemoved() const
    {
        AssertSanity(TGamepadRemoved);
        return (*(constptr_GamepadRemoved()));
    }
    operator GamepadRemoved&()
    {
        return get_GamepadRemoved();
    }
    operator const GamepadRemoved&() const
    {
        return get_GamepadRemoved();
    }

    GamepadAxisInformation&
    get_GamepadAxisInformation()
    {
        AssertSanity(TGamepadAxisInformation);
        return (*(ptr_GamepadAxisInformation()));
    }
    const GamepadAxisInformation&
    get_GamepadAxisInformation() const
    {
        AssertSanity(TGamepadAxisInformation);
        return (*(constptr_GamepadAxisInformation()));
    }
    operator GamepadAxisInformation&()
    {
        return get_GamepadAxisInformation();
    }
    operator const GamepadAxisInformation&() const
    {
        return get_GamepadAxisInformation();
    }

    GamepadButtonInformation&
    get_GamepadButtonInformation()
    {
        AssertSanity(TGamepadButtonInformation);
        return (*(ptr_GamepadButtonInformation()));
    }
    const GamepadButtonInformation&
    get_GamepadButtonInformation() const
    {
        AssertSanity(TGamepadButtonInformation);
        return (*(constptr_GamepadButtonInformation()));
    }
    operator GamepadButtonInformation&()
    {
        return get_GamepadButtonInformation();
    }
    operator const GamepadButtonInformation&() const
    {
        return get_GamepadButtonInformation();
    }

    GamepadHandInformation&
    get_GamepadHandInformation()
    {
        AssertSanity(TGamepadHandInformation);
        return (*(ptr_GamepadHandInformation()));
    }
    const GamepadHandInformation&
    get_GamepadHandInformation() const
    {
        AssertSanity(TGamepadHandInformation);
        return (*(constptr_GamepadHandInformation()));
    }
    operator GamepadHandInformation&()
    {
        return get_GamepadHandInformation();
    }
    operator const GamepadHandInformation&() const
    {
        return get_GamepadHandInformation();
    }

    GamepadLightIndicatorTypeInformation&
    get_GamepadLightIndicatorTypeInformation()
    {
        AssertSanity(TGamepadLightIndicatorTypeInformation);
        return (*(ptr_GamepadLightIndicatorTypeInformation()));
    }
    const GamepadLightIndicatorTypeInformation&
    get_GamepadLightIndicatorTypeInformation() const
    {
        AssertSanity(TGamepadLightIndicatorTypeInformation);
        return (*(constptr_GamepadLightIndicatorTypeInformation()));
    }
    operator GamepadLightIndicatorTypeInformation&()
    {
        return get_GamepadLightIndicatorTypeInformation();
    }
    operator const GamepadLightIndicatorTypeInformation&() const
    {
        return get_GamepadLightIndicatorTypeInformation();
    }

    GamepadPoseInformation&
    get_GamepadPoseInformation()
    {
        AssertSanity(TGamepadPoseInformation);
        return (*(ptr_GamepadPoseInformation()));
    }
    const GamepadPoseInformation&
    get_GamepadPoseInformation() const
    {
        AssertSanity(TGamepadPoseInformation);
        return (*(constptr_GamepadPoseInformation()));
    }
    operator GamepadPoseInformation&()
    {
        return get_GamepadPoseInformation();
    }
    operator const GamepadPoseInformation&() const
    {
        return get_GamepadPoseInformation();
    }

    GamepadTouchInformation&
    get_GamepadTouchInformation()
    {
        AssertSanity(TGamepadTouchInformation);
        return (*(ptr_GamepadTouchInformation()));
    }
    const GamepadTouchInformation&
    get_GamepadTouchInformation() const
    {
        AssertSanity(TGamepadTouchInformation);
        return (*(constptr_GamepadTouchInformation()));
    }
    operator GamepadTouchInformation&()
    {
        return get_GamepadTouchInformation();
    }
    operator const GamepadTouchInformation&() const
    {
        return get_GamepadTouchInformation();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::GamepadChangeEventBody>
{
    typedef mozilla::dom::GamepadChangeEventBody paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct GamepadChangeEvent|
//
namespace mozilla {
namespace dom {
class GamepadChangeEvent final
{
private:
    typedef mozilla::dom::GamepadHandle GamepadHandle;
    typedef mozilla::dom::GamepadChangeEventBody GamepadChangeEventBody;

public:
    MOZ_IMPLICIT GamepadChangeEvent() :
        handle_(),
        body_()
    {
    }

    MOZ_IMPLICIT GamepadChangeEvent(
            const GamepadHandle& _handle,
            const GamepadChangeEventBody& _body) :
        handle_(_handle),
        body_(_body)
    {
    }

    GamepadHandle&
    handle()
    {
        return handle_;
    }
    const GamepadHandle&
    handle() const
    {
        return handle_;
    }

    GamepadChangeEventBody&
    body()
    {
        return body_;
    }
    const GamepadChangeEventBody&
    body() const
    {
        return body_;
    }

private:
    GamepadHandle handle_;
    GamepadChangeEventBody body_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::GamepadChangeEvent>
{
    typedef mozilla::dom::GamepadChangeEvent paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

#endif // ifndef GamepadEventTypes_h
