//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef ClientIPCTypes_h
#define ClientIPCTypes_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "mozilla/ErrorResult.h"
#include "mozilla/StorageAccess.h"
#include "mozilla/TimeStamp.h"
#include "mozilla/dom/BindingDeclarations.h"
#include "mozilla/dom/ClientBinding.h"
#include "mozilla/dom/ClientsBinding.h"
#include "mozilla/dom/DocumentBinding.h"
#include "mozilla/dom/DOMTypes.h"
#include "mozilla/ipc/PBackgroundSharedTypes.h"
#include "mozilla/dom/IPCServiceWorkerDescriptor.h"
#include "mozilla/ipc/ProtocolTypes.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ClientSourceConstructorArgs|
//
namespace mozilla {
namespace dom {
class ClientSourceConstructorArgs final
{
private:
    typedef mozilla::ipc::PrincipalInfo PrincipalInfo;
    typedef mozilla::TimeStamp TimeStamp;

public:
    MOZ_IMPLICIT ClientSourceConstructorArgs() :
        id_(),
        type_(),
        principalInfo_(),
        creationTime_()
    {
    }

    MOZ_IMPLICIT ClientSourceConstructorArgs(
            const nsID& _id,
            const ClientType& _type,
            const PrincipalInfo& _principalInfo,
            const TimeStamp& _creationTime) :
        id_(_id),
        type_(_type),
        principalInfo_(_principalInfo),
        creationTime_(_creationTime)
    {
    }

    nsID&
    id()
    {
        return id_;
    }
    const nsID&
    id() const
    {
        return id_;
    }

    ClientType&
    type()
    {
        return type_;
    }
    const ClientType&
    type() const
    {
        return type_;
    }

    PrincipalInfo&
    principalInfo()
    {
        return principalInfo_;
    }
    const PrincipalInfo&
    principalInfo() const
    {
        return principalInfo_;
    }

    TimeStamp&
    creationTime()
    {
        return creationTime_;
    }
    const TimeStamp&
    creationTime() const
    {
        return creationTime_;
    }

private:
    nsID id_;
    ClientType type_;
    PrincipalInfo principalInfo_;
    TimeStamp creationTime_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ClientSourceConstructorArgs>
{
    typedef mozilla::dom::ClientSourceConstructorArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct IPCClientInfo|
//
namespace mozilla {
namespace dom {
class IPCClientInfo final
{
private:
    typedef mozilla::ipc::PrincipalInfo PrincipalInfo;
    typedef mozilla::TimeStamp TimeStamp;
    typedef mozilla::ipc::CSPInfo CSPInfo;

public:
    MOZ_IMPLICIT IPCClientInfo() :
        id_(),
        agentClusterId_(),
        type_(),
        principalInfo_(),
        creationTime_(),
        url_(),
        frameType_(),
        cspInfo_(),
        preloadCspInfo_()
    {
    }

    MOZ_IMPLICIT IPCClientInfo(
            const nsID& _id,
            const mozilla::Maybe<nsID>& _agentClusterId,
            const ClientType& _type,
            const PrincipalInfo& _principalInfo,
            const TimeStamp& _creationTime,
            const nsCString& _url,
            const FrameType& _frameType,
            const mozilla::Maybe<CSPInfo>& _cspInfo,
            const mozilla::Maybe<CSPInfo>& _preloadCspInfo) :
        id_(_id),
        agentClusterId_(_agentClusterId),
        type_(_type),
        principalInfo_(_principalInfo),
        creationTime_(_creationTime),
        url_(_url),
        frameType_(_frameType),
        cspInfo_(_cspInfo),
        preloadCspInfo_(_preloadCspInfo)
    {
    }

    bool
    operator==(const IPCClientInfo& _o) const;

    bool
    operator!=(const IPCClientInfo& _o) const;

    nsID&
    id()
    {
        return id_;
    }
    const nsID&
    id() const
    {
        return id_;
    }

    mozilla::Maybe<nsID>&
    agentClusterId()
    {
        return agentClusterId_;
    }
    const mozilla::Maybe<nsID>&
    agentClusterId() const
    {
        return agentClusterId_;
    }

    ClientType&
    type()
    {
        return type_;
    }
    const ClientType&
    type() const
    {
        return type_;
    }

    PrincipalInfo&
    principalInfo()
    {
        return principalInfo_;
    }
    const PrincipalInfo&
    principalInfo() const
    {
        return principalInfo_;
    }

    TimeStamp&
    creationTime()
    {
        return creationTime_;
    }
    const TimeStamp&
    creationTime() const
    {
        return creationTime_;
    }

    nsCString&
    url()
    {
        return url_;
    }
    const nsCString&
    url() const
    {
        return url_;
    }

    FrameType&
    frameType()
    {
        return frameType_;
    }
    const FrameType&
    frameType() const
    {
        return frameType_;
    }

    mozilla::Maybe<CSPInfo>&
    cspInfo()
    {
        return cspInfo_;
    }
    const mozilla::Maybe<CSPInfo>&
    cspInfo() const
    {
        return cspInfo_;
    }

    mozilla::Maybe<CSPInfo>&
    preloadCspInfo()
    {
        return preloadCspInfo_;
    }
    const mozilla::Maybe<CSPInfo>&
    preloadCspInfo() const
    {
        return preloadCspInfo_;
    }

private:
    nsID id_;
    mozilla::Maybe<nsID> agentClusterId_;
    ClientType type_;
    PrincipalInfo principalInfo_;
    TimeStamp creationTime_;
    nsCString url_;
    FrameType frameType_;
    mozilla::Maybe<CSPInfo> cspInfo_;
    mozilla::Maybe<CSPInfo> preloadCspInfo_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPCClientInfo>
{
    typedef mozilla::dom::IPCClientInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct IPCClientWindowState|
//
namespace mozilla {
namespace dom {
class IPCClientWindowState final
{
private:
    typedef mozilla::TimeStamp TimeStamp;
    typedef mozilla::StorageAccess StorageAccess;

public:
    MOZ_IMPLICIT IPCClientWindowState() :
        visibilityState_(),
        lastFocusTime_(),
        storageAccess_(),
        focused_()
    {
    }

    MOZ_IMPLICIT IPCClientWindowState(
            const VisibilityState& _visibilityState,
            const TimeStamp& _lastFocusTime,
            const StorageAccess& _storageAccess,
            const bool& _focused) :
        visibilityState_(_visibilityState),
        lastFocusTime_(_lastFocusTime),
        storageAccess_(_storageAccess),
        focused_(_focused)
    {
    }

    VisibilityState&
    visibilityState()
    {
        return visibilityState_;
    }
    const VisibilityState&
    visibilityState() const
    {
        return visibilityState_;
    }

    TimeStamp&
    lastFocusTime()
    {
        return lastFocusTime_;
    }
    const TimeStamp&
    lastFocusTime() const
    {
        return lastFocusTime_;
    }

    StorageAccess&
    storageAccess()
    {
        return storageAccess_;
    }
    const StorageAccess&
    storageAccess() const
    {
        return storageAccess_;
    }

    bool&
    focused()
    {
        return focused_;
    }
    const bool&
    focused() const
    {
        return focused_;
    }

private:
    VisibilityState visibilityState_;
    TimeStamp lastFocusTime_;
    StorageAccess storageAccess_;
    bool focused_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPCClientWindowState>
{
    typedef mozilla::dom::IPCClientWindowState paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct IPCClientWorkerState|
//
namespace mozilla {
namespace dom {
class IPCClientWorkerState final
{
private:
    typedef mozilla::StorageAccess StorageAccess;

public:
    MOZ_IMPLICIT IPCClientWorkerState() :
        storageAccess_()
    {
    }

    MOZ_IMPLICIT IPCClientWorkerState(const StorageAccess& _storageAccess) :
        storageAccess_(_storageAccess)
    {
    }

    StorageAccess&
    storageAccess()
    {
        return storageAccess_;
    }
    const StorageAccess&
    storageAccess() const
    {
        return storageAccess_;
    }

private:
    StorageAccess storageAccess_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPCClientWorkerState>
{
    typedef mozilla::dom::IPCClientWorkerState paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union IPCClientState|
//
namespace mozilla {
namespace dom {
class IPCClientState final
{
public:
    enum Type {
        T__None,
        TIPCClientWindowState = 1,
        TIPCClientWorkerState,
        T__Last = TIPCClientWorkerState
    };

private:
    typedef mozilla::dom::IPCClientWindowState IPCClientWindowState;
    typedef mozilla::dom::IPCClientWorkerState IPCClientWorkerState;
    typedef IPCClientWindowState IPCClientWindowState__tdef;
    typedef IPCClientWorkerState IPCClientWorkerState__tdef;

    union Value {
        mozilla::AlignedStorage2<IPCClientWindowState> VIPCClientWindowState;
        mozilla::AlignedStorage2<IPCClientWorkerState> VIPCClientWorkerState;
    };

    IPCClientWindowState*
    ptr_IPCClientWindowState()
    {
        return ((mValue).VIPCClientWindowState).addr();
    }
    const IPCClientWindowState*
    constptr_IPCClientWindowState() const
    {
        return ((mValue).VIPCClientWindowState).addr();
    }
    IPCClientWorkerState*
    ptr_IPCClientWorkerState()
    {
        return ((mValue).VIPCClientWorkerState).addr();
    }
    const IPCClientWorkerState*
    constptr_IPCClientWorkerState() const
    {
        return ((mValue).VIPCClientWorkerState).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT IPCClientState() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT IPCClientState(const IPCClientWindowState& aOther);

    MOZ_IMPLICIT IPCClientState(IPCClientWindowState&& aOther);

    MOZ_IMPLICIT IPCClientState(const IPCClientWorkerState& aOther);

    MOZ_IMPLICIT IPCClientState(IPCClientWorkerState&& aOther);

    MOZ_IMPLICIT IPCClientState(const IPCClientState& aOther);

    MOZ_IMPLICIT IPCClientState(IPCClientState&& aOther);

    ~IPCClientState();

    Type
    type() const
    {
        return mType;
    }

    IPCClientState&
    operator=(const IPCClientWindowState& aRhs);

    IPCClientState&
    operator=(IPCClientWindowState&& aRhs);

    IPCClientState&
    operator=(const IPCClientWorkerState& aRhs);

    IPCClientState&
    operator=(IPCClientWorkerState&& aRhs);

    IPCClientState&
    operator=(const IPCClientState& aRhs);

    IPCClientState&
    operator=(IPCClientState&& aRhs);

    IPCClientWindowState&
    get_IPCClientWindowState()
    {
        AssertSanity(TIPCClientWindowState);
        return (*(ptr_IPCClientWindowState()));
    }
    const IPCClientWindowState&
    get_IPCClientWindowState() const
    {
        AssertSanity(TIPCClientWindowState);
        return (*(constptr_IPCClientWindowState()));
    }
    operator IPCClientWindowState&()
    {
        return get_IPCClientWindowState();
    }
    operator const IPCClientWindowState&() const
    {
        return get_IPCClientWindowState();
    }

    IPCClientWorkerState&
    get_IPCClientWorkerState()
    {
        AssertSanity(TIPCClientWorkerState);
        return (*(ptr_IPCClientWorkerState()));
    }
    const IPCClientWorkerState&
    get_IPCClientWorkerState() const
    {
        AssertSanity(TIPCClientWorkerState);
        return (*(constptr_IPCClientWorkerState()));
    }
    operator IPCClientWorkerState&()
    {
        return get_IPCClientWorkerState();
    }
    operator const IPCClientWorkerState&() const
    {
        return get_IPCClientWorkerState();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPCClientState>
{
    typedef mozilla::dom::IPCClientState paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ClientInfoAndState|
//
namespace mozilla {
namespace dom {
class ClientInfoAndState final
{
private:
    typedef mozilla::dom::IPCClientInfo IPCClientInfo;
    typedef mozilla::dom::IPCClientState IPCClientState;

public:
    MOZ_IMPLICIT ClientInfoAndState() :
        info_(),
        state_()
    {
    }

    MOZ_IMPLICIT ClientInfoAndState(
            const IPCClientInfo& _info,
            const IPCClientState& _state) :
        info_(_info),
        state_(_state)
    {
    }

    IPCClientInfo&
    info()
    {
        return info_;
    }
    const IPCClientInfo&
    info() const
    {
        return info_;
    }

    IPCClientState&
    state()
    {
        return state_;
    }
    const IPCClientState&
    state() const
    {
        return state_;
    }

private:
    IPCClientInfo info_;
    IPCClientState state_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ClientInfoAndState>
{
    typedef mozilla::dom::ClientInfoAndState paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ClientSourceExecutionReadyArgs|
//
namespace mozilla {
namespace dom {
class ClientSourceExecutionReadyArgs final
{
private:

public:
    MOZ_IMPLICIT ClientSourceExecutionReadyArgs() :
        url_(),
        frameType_()
    {
    }

    MOZ_IMPLICIT ClientSourceExecutionReadyArgs(
            const nsCString& _url,
            const FrameType& _frameType) :
        url_(_url),
        frameType_(_frameType)
    {
    }

    nsCString&
    url()
    {
        return url_;
    }
    const nsCString&
    url() const
    {
        return url_;
    }

    FrameType&
    frameType()
    {
        return frameType_;
    }
    const FrameType&
    frameType() const
    {
        return frameType_;
    }

private:
    nsCString url_;
    FrameType frameType_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ClientSourceExecutionReadyArgs>
{
    typedef mozilla::dom::ClientSourceExecutionReadyArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ClientControlledArgs|
//
namespace mozilla {
namespace dom {
class ClientControlledArgs final
{
private:
    typedef mozilla::dom::IPCServiceWorkerDescriptor IPCServiceWorkerDescriptor;

public:
    MOZ_IMPLICIT ClientControlledArgs() :
        serviceWorker_()
    {
    }

    MOZ_IMPLICIT ClientControlledArgs(const IPCServiceWorkerDescriptor& _serviceWorker) :
        serviceWorker_(_serviceWorker)
    {
    }

    IPCServiceWorkerDescriptor&
    serviceWorker()
    {
        return serviceWorker_;
    }
    const IPCServiceWorkerDescriptor&
    serviceWorker() const
    {
        return serviceWorker_;
    }

private:
    IPCServiceWorkerDescriptor serviceWorker_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ClientControlledArgs>
{
    typedef mozilla::dom::ClientControlledArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ClientFocusArgs|
//
namespace mozilla {
namespace dom {
class ClientFocusArgs final
{
private:

public:
    MOZ_IMPLICIT ClientFocusArgs() :
        callerType_()
    {
    }

    MOZ_IMPLICIT ClientFocusArgs(const CallerType& _callerType) :
        callerType_(_callerType)
    {
    }

    CallerType&
    callerType()
    {
        return callerType_;
    }
    const CallerType&
    callerType() const
    {
        return callerType_;
    }

private:
    CallerType callerType_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ClientFocusArgs>
{
    typedef mozilla::dom::ClientFocusArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ClientNavigateArgs|
//
namespace mozilla {
namespace dom {
class ClientNavigateArgs final
{
private:
    typedef mozilla::dom::IPCClientInfo IPCClientInfo;
    typedef mozilla::dom::IPCServiceWorkerDescriptor IPCServiceWorkerDescriptor;

public:
    MOZ_IMPLICIT ClientNavigateArgs() :
        target_(),
        url_(),
        baseURL_(),
        serviceWorker_()
    {
    }

    MOZ_IMPLICIT ClientNavigateArgs(
            const IPCClientInfo& _target,
            const nsCString& _url,
            const nsCString& _baseURL,
            const IPCServiceWorkerDescriptor& _serviceWorker) :
        target_(_target),
        url_(_url),
        baseURL_(_baseURL),
        serviceWorker_(_serviceWorker)
    {
    }

    IPCClientInfo&
    target()
    {
        return target_;
    }
    const IPCClientInfo&
    target() const
    {
        return target_;
    }

    nsCString&
    url()
    {
        return url_;
    }
    const nsCString&
    url() const
    {
        return url_;
    }

    nsCString&
    baseURL()
    {
        return baseURL_;
    }
    const nsCString&
    baseURL() const
    {
        return baseURL_;
    }

    IPCServiceWorkerDescriptor&
    serviceWorker()
    {
        return serviceWorker_;
    }
    const IPCServiceWorkerDescriptor&
    serviceWorker() const
    {
        return serviceWorker_;
    }

private:
    IPCClientInfo target_;
    nsCString url_;
    nsCString baseURL_;
    IPCServiceWorkerDescriptor serviceWorker_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ClientNavigateArgs>
{
    typedef mozilla::dom::ClientNavigateArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ClientPostMessageArgs|
//
namespace mozilla {
namespace dom {
class ClientPostMessageArgs final
{
private:
    typedef mozilla::dom::ClonedMessageData ClonedMessageData;
    typedef mozilla::dom::IPCServiceWorkerDescriptor IPCServiceWorkerDescriptor;

public:
    MOZ_IMPLICIT ClientPostMessageArgs() :
        clonedData_(),
        serviceWorker_()
    {
    }

    MOZ_IMPLICIT ClientPostMessageArgs(
            ClonedMessageData&& _clonedData,
            const IPCServiceWorkerDescriptor& _serviceWorker) :
        clonedData_(std::move(_clonedData)),
        serviceWorker_(_serviceWorker)
    {
    }

    ClonedMessageData&
    clonedData()
    {
        return clonedData_;
    }
    const ClonedMessageData&
    clonedData() const
    {
        return clonedData_;
    }

    IPCServiceWorkerDescriptor&
    serviceWorker()
    {
        return serviceWorker_;
    }
    const IPCServiceWorkerDescriptor&
    serviceWorker() const
    {
        return serviceWorker_;
    }

private:
    ClonedMessageData clonedData_;
    IPCServiceWorkerDescriptor serviceWorker_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ClientPostMessageArgs>
{
    typedef mozilla::dom::ClientPostMessageArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ClientMatchAllArgs|
//
namespace mozilla {
namespace dom {
class ClientMatchAllArgs final
{
private:
    typedef mozilla::dom::IPCServiceWorkerDescriptor IPCServiceWorkerDescriptor;

public:
    MOZ_IMPLICIT ClientMatchAllArgs() :
        serviceWorker_(),
        type_(),
        includeUncontrolled_()
    {
    }

    MOZ_IMPLICIT ClientMatchAllArgs(
            const IPCServiceWorkerDescriptor& _serviceWorker,
            const ClientType& _type,
            const bool& _includeUncontrolled) :
        serviceWorker_(_serviceWorker),
        type_(_type),
        includeUncontrolled_(_includeUncontrolled)
    {
    }

    IPCServiceWorkerDescriptor&
    serviceWorker()
    {
        return serviceWorker_;
    }
    const IPCServiceWorkerDescriptor&
    serviceWorker() const
    {
        return serviceWorker_;
    }

    ClientType&
    type()
    {
        return type_;
    }
    const ClientType&
    type() const
    {
        return type_;
    }

    bool&
    includeUncontrolled()
    {
        return includeUncontrolled_;
    }
    const bool&
    includeUncontrolled() const
    {
        return includeUncontrolled_;
    }

private:
    IPCServiceWorkerDescriptor serviceWorker_;
    ClientType type_;
    bool includeUncontrolled_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ClientMatchAllArgs>
{
    typedef mozilla::dom::ClientMatchAllArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ClientClaimArgs|
//
namespace mozilla {
namespace dom {
class ClientClaimArgs final
{
private:
    typedef mozilla::dom::IPCServiceWorkerDescriptor IPCServiceWorkerDescriptor;

public:
    MOZ_IMPLICIT ClientClaimArgs() :
        serviceWorker_()
    {
    }

    MOZ_IMPLICIT ClientClaimArgs(const IPCServiceWorkerDescriptor& _serviceWorker) :
        serviceWorker_(_serviceWorker)
    {
    }

    IPCServiceWorkerDescriptor&
    serviceWorker()
    {
        return serviceWorker_;
    }
    const IPCServiceWorkerDescriptor&
    serviceWorker() const
    {
        return serviceWorker_;
    }

private:
    IPCServiceWorkerDescriptor serviceWorker_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ClientClaimArgs>
{
    typedef mozilla::dom::ClientClaimArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ClientGetInfoAndStateArgs|
//
namespace mozilla {
namespace dom {
class ClientGetInfoAndStateArgs final
{
private:
    typedef mozilla::ipc::PrincipalInfo PrincipalInfo;

public:
    MOZ_IMPLICIT ClientGetInfoAndStateArgs() :
        id_(),
        principalInfo_()
    {
    }

    MOZ_IMPLICIT ClientGetInfoAndStateArgs(
            const nsID& _id,
            const PrincipalInfo& _principalInfo) :
        id_(_id),
        principalInfo_(_principalInfo)
    {
    }

    nsID&
    id()
    {
        return id_;
    }
    const nsID&
    id() const
    {
        return id_;
    }

    PrincipalInfo&
    principalInfo()
    {
        return principalInfo_;
    }
    const PrincipalInfo&
    principalInfo() const
    {
        return principalInfo_;
    }

private:
    nsID id_;
    PrincipalInfo principalInfo_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ClientGetInfoAndStateArgs>
{
    typedef mozilla::dom::ClientGetInfoAndStateArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ClientOpenWindowArgs|
//
namespace mozilla {
namespace dom {
class ClientOpenWindowArgs final
{
private:
    typedef mozilla::ipc::PrincipalInfo PrincipalInfo;
    typedef mozilla::ipc::CSPInfo CSPInfo;

public:
    MOZ_IMPLICIT ClientOpenWindowArgs() :
        principalInfo_(),
        cspInfo_(),
        url_(),
        baseURL_()
    {
    }

    MOZ_IMPLICIT ClientOpenWindowArgs(
            const PrincipalInfo& _principalInfo,
            const mozilla::Maybe<CSPInfo>& _cspInfo,
            const nsCString& _url,
            const nsCString& _baseURL) :
        principalInfo_(_principalInfo),
        cspInfo_(_cspInfo),
        url_(_url),
        baseURL_(_baseURL)
    {
    }

    PrincipalInfo&
    principalInfo()
    {
        return principalInfo_;
    }
    const PrincipalInfo&
    principalInfo() const
    {
        return principalInfo_;
    }

    mozilla::Maybe<CSPInfo>&
    cspInfo()
    {
        return cspInfo_;
    }
    const mozilla::Maybe<CSPInfo>&
    cspInfo() const
    {
        return cspInfo_;
    }

    nsCString&
    url()
    {
        return url_;
    }
    const nsCString&
    url() const
    {
        return url_;
    }

    nsCString&
    baseURL()
    {
        return baseURL_;
    }
    const nsCString&
    baseURL() const
    {
        return baseURL_;
    }

private:
    PrincipalInfo principalInfo_;
    mozilla::Maybe<CSPInfo> cspInfo_;
    nsCString url_;
    nsCString baseURL_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ClientOpenWindowArgs>
{
    typedef mozilla::dom::ClientOpenWindowArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union ClientOpConstructorArgs|
//
namespace mozilla {
namespace dom {
class ClientOpConstructorArgs final
{
public:
    enum Type {
        T__None,
        TClientControlledArgs = 1,
        TClientFocusArgs,
        TClientNavigateArgs,
        TClientPostMessageArgs,
        TClientMatchAllArgs,
        TClientClaimArgs,
        TClientGetInfoAndStateArgs,
        TClientOpenWindowArgs,
        T__Last = TClientOpenWindowArgs
    };

private:
    typedef mozilla::dom::ClientControlledArgs ClientControlledArgs;
    typedef mozilla::dom::ClientFocusArgs ClientFocusArgs;
    typedef mozilla::dom::ClientNavigateArgs ClientNavigateArgs;
    typedef mozilla::dom::ClientPostMessageArgs ClientPostMessageArgs;
    typedef mozilla::dom::ClientMatchAllArgs ClientMatchAllArgs;
    typedef mozilla::dom::ClientClaimArgs ClientClaimArgs;
    typedef mozilla::dom::ClientGetInfoAndStateArgs ClientGetInfoAndStateArgs;
    typedef mozilla::dom::ClientOpenWindowArgs ClientOpenWindowArgs;
    typedef ClientControlledArgs ClientControlledArgs__tdef;
    typedef ClientFocusArgs ClientFocusArgs__tdef;
    typedef ClientNavigateArgs ClientNavigateArgs__tdef;
    typedef ClientPostMessageArgs ClientPostMessageArgs__tdef;
    typedef ClientMatchAllArgs ClientMatchAllArgs__tdef;
    typedef ClientClaimArgs ClientClaimArgs__tdef;
    typedef ClientGetInfoAndStateArgs ClientGetInfoAndStateArgs__tdef;
    typedef ClientOpenWindowArgs ClientOpenWindowArgs__tdef;

    union Value {
        mozilla::AlignedStorage2<ClientControlledArgs> VClientControlledArgs;
        mozilla::AlignedStorage2<ClientFocusArgs> VClientFocusArgs;
        mozilla::AlignedStorage2<ClientNavigateArgs> VClientNavigateArgs;
        mozilla::AlignedStorage2<ClientPostMessageArgs> VClientPostMessageArgs;
        mozilla::AlignedStorage2<ClientMatchAllArgs> VClientMatchAllArgs;
        mozilla::AlignedStorage2<ClientClaimArgs> VClientClaimArgs;
        mozilla::AlignedStorage2<ClientGetInfoAndStateArgs> VClientGetInfoAndStateArgs;
        mozilla::AlignedStorage2<ClientOpenWindowArgs> VClientOpenWindowArgs;
    };

    ClientControlledArgs*
    ptr_ClientControlledArgs()
    {
        return ((mValue).VClientControlledArgs).addr();
    }
    const ClientControlledArgs*
    constptr_ClientControlledArgs() const
    {
        return ((mValue).VClientControlledArgs).addr();
    }
    ClientFocusArgs*
    ptr_ClientFocusArgs()
    {
        return ((mValue).VClientFocusArgs).addr();
    }
    const ClientFocusArgs*
    constptr_ClientFocusArgs() const
    {
        return ((mValue).VClientFocusArgs).addr();
    }
    ClientNavigateArgs*
    ptr_ClientNavigateArgs()
    {
        return ((mValue).VClientNavigateArgs).addr();
    }
    const ClientNavigateArgs*
    constptr_ClientNavigateArgs() const
    {
        return ((mValue).VClientNavigateArgs).addr();
    }
    ClientPostMessageArgs*
    ptr_ClientPostMessageArgs()
    {
        return ((mValue).VClientPostMessageArgs).addr();
    }
    const ClientPostMessageArgs*
    constptr_ClientPostMessageArgs() const
    {
        return ((mValue).VClientPostMessageArgs).addr();
    }
    ClientMatchAllArgs*
    ptr_ClientMatchAllArgs()
    {
        return ((mValue).VClientMatchAllArgs).addr();
    }
    const ClientMatchAllArgs*
    constptr_ClientMatchAllArgs() const
    {
        return ((mValue).VClientMatchAllArgs).addr();
    }
    ClientClaimArgs*
    ptr_ClientClaimArgs()
    {
        return ((mValue).VClientClaimArgs).addr();
    }
    const ClientClaimArgs*
    constptr_ClientClaimArgs() const
    {
        return ((mValue).VClientClaimArgs).addr();
    }
    ClientGetInfoAndStateArgs*
    ptr_ClientGetInfoAndStateArgs()
    {
        return ((mValue).VClientGetInfoAndStateArgs).addr();
    }
    const ClientGetInfoAndStateArgs*
    constptr_ClientGetInfoAndStateArgs() const
    {
        return ((mValue).VClientGetInfoAndStateArgs).addr();
    }
    ClientOpenWindowArgs*
    ptr_ClientOpenWindowArgs()
    {
        return ((mValue).VClientOpenWindowArgs).addr();
    }
    const ClientOpenWindowArgs*
    constptr_ClientOpenWindowArgs() const
    {
        return ((mValue).VClientOpenWindowArgs).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT ClientOpConstructorArgs() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT ClientOpConstructorArgs(const ClientControlledArgs& aOther);

    MOZ_IMPLICIT ClientOpConstructorArgs(ClientControlledArgs&& aOther);

    MOZ_IMPLICIT ClientOpConstructorArgs(const ClientFocusArgs& aOther);

    MOZ_IMPLICIT ClientOpConstructorArgs(ClientFocusArgs&& aOther);

    MOZ_IMPLICIT ClientOpConstructorArgs(const ClientNavigateArgs& aOther);

    MOZ_IMPLICIT ClientOpConstructorArgs(ClientNavigateArgs&& aOther);

    MOZ_IMPLICIT ClientOpConstructorArgs(ClientPostMessageArgs&& aOther);

    MOZ_IMPLICIT ClientOpConstructorArgs(const ClientMatchAllArgs& aOther);

    MOZ_IMPLICIT ClientOpConstructorArgs(ClientMatchAllArgs&& aOther);

    MOZ_IMPLICIT ClientOpConstructorArgs(const ClientClaimArgs& aOther);

    MOZ_IMPLICIT ClientOpConstructorArgs(ClientClaimArgs&& aOther);

    MOZ_IMPLICIT ClientOpConstructorArgs(const ClientGetInfoAndStateArgs& aOther);

    MOZ_IMPLICIT ClientOpConstructorArgs(ClientGetInfoAndStateArgs&& aOther);

    MOZ_IMPLICIT ClientOpConstructorArgs(const ClientOpenWindowArgs& aOther);

    MOZ_IMPLICIT ClientOpConstructorArgs(ClientOpenWindowArgs&& aOther);

    MOZ_IMPLICIT ClientOpConstructorArgs(ClientOpConstructorArgs&& aOther);

    ~ClientOpConstructorArgs();

    Type
    type() const
    {
        return mType;
    }

    ClientOpConstructorArgs&
    operator=(const ClientControlledArgs& aRhs);

    ClientOpConstructorArgs&
    operator=(ClientControlledArgs&& aRhs);

    ClientOpConstructorArgs&
    operator=(const ClientFocusArgs& aRhs);

    ClientOpConstructorArgs&
    operator=(ClientFocusArgs&& aRhs);

    ClientOpConstructorArgs&
    operator=(const ClientNavigateArgs& aRhs);

    ClientOpConstructorArgs&
    operator=(ClientNavigateArgs&& aRhs);

    ClientOpConstructorArgs&
    operator=(ClientPostMessageArgs&& aRhs);

    ClientOpConstructorArgs&
    operator=(const ClientMatchAllArgs& aRhs);

    ClientOpConstructorArgs&
    operator=(ClientMatchAllArgs&& aRhs);

    ClientOpConstructorArgs&
    operator=(const ClientClaimArgs& aRhs);

    ClientOpConstructorArgs&
    operator=(ClientClaimArgs&& aRhs);

    ClientOpConstructorArgs&
    operator=(const ClientGetInfoAndStateArgs& aRhs);

    ClientOpConstructorArgs&
    operator=(ClientGetInfoAndStateArgs&& aRhs);

    ClientOpConstructorArgs&
    operator=(const ClientOpenWindowArgs& aRhs);

    ClientOpConstructorArgs&
    operator=(ClientOpenWindowArgs&& aRhs);

    ClientOpConstructorArgs&
    operator=(ClientOpConstructorArgs&& aRhs);

    ClientControlledArgs&
    get_ClientControlledArgs()
    {
        AssertSanity(TClientControlledArgs);
        return (*(ptr_ClientControlledArgs()));
    }
    const ClientControlledArgs&
    get_ClientControlledArgs() const
    {
        AssertSanity(TClientControlledArgs);
        return (*(constptr_ClientControlledArgs()));
    }
    operator ClientControlledArgs&()
    {
        return get_ClientControlledArgs();
    }
    operator const ClientControlledArgs&() const
    {
        return get_ClientControlledArgs();
    }

    ClientFocusArgs&
    get_ClientFocusArgs()
    {
        AssertSanity(TClientFocusArgs);
        return (*(ptr_ClientFocusArgs()));
    }
    const ClientFocusArgs&
    get_ClientFocusArgs() const
    {
        AssertSanity(TClientFocusArgs);
        return (*(constptr_ClientFocusArgs()));
    }
    operator ClientFocusArgs&()
    {
        return get_ClientFocusArgs();
    }
    operator const ClientFocusArgs&() const
    {
        return get_ClientFocusArgs();
    }

    ClientNavigateArgs&
    get_ClientNavigateArgs()
    {
        AssertSanity(TClientNavigateArgs);
        return (*(ptr_ClientNavigateArgs()));
    }
    const ClientNavigateArgs&
    get_ClientNavigateArgs() const
    {
        AssertSanity(TClientNavigateArgs);
        return (*(constptr_ClientNavigateArgs()));
    }
    operator ClientNavigateArgs&()
    {
        return get_ClientNavigateArgs();
    }
    operator const ClientNavigateArgs&() const
    {
        return get_ClientNavigateArgs();
    }

    ClientPostMessageArgs&
    get_ClientPostMessageArgs()
    {
        AssertSanity(TClientPostMessageArgs);
        return (*(ptr_ClientPostMessageArgs()));
    }
    const ClientPostMessageArgs&
    get_ClientPostMessageArgs() const
    {
        AssertSanity(TClientPostMessageArgs);
        return (*(constptr_ClientPostMessageArgs()));
    }
    operator ClientPostMessageArgs&()
    {
        return get_ClientPostMessageArgs();
    }
    operator const ClientPostMessageArgs&() const
    {
        return get_ClientPostMessageArgs();
    }

    ClientMatchAllArgs&
    get_ClientMatchAllArgs()
    {
        AssertSanity(TClientMatchAllArgs);
        return (*(ptr_ClientMatchAllArgs()));
    }
    const ClientMatchAllArgs&
    get_ClientMatchAllArgs() const
    {
        AssertSanity(TClientMatchAllArgs);
        return (*(constptr_ClientMatchAllArgs()));
    }
    operator ClientMatchAllArgs&()
    {
        return get_ClientMatchAllArgs();
    }
    operator const ClientMatchAllArgs&() const
    {
        return get_ClientMatchAllArgs();
    }

    ClientClaimArgs&
    get_ClientClaimArgs()
    {
        AssertSanity(TClientClaimArgs);
        return (*(ptr_ClientClaimArgs()));
    }
    const ClientClaimArgs&
    get_ClientClaimArgs() const
    {
        AssertSanity(TClientClaimArgs);
        return (*(constptr_ClientClaimArgs()));
    }
    operator ClientClaimArgs&()
    {
        return get_ClientClaimArgs();
    }
    operator const ClientClaimArgs&() const
    {
        return get_ClientClaimArgs();
    }

    ClientGetInfoAndStateArgs&
    get_ClientGetInfoAndStateArgs()
    {
        AssertSanity(TClientGetInfoAndStateArgs);
        return (*(ptr_ClientGetInfoAndStateArgs()));
    }
    const ClientGetInfoAndStateArgs&
    get_ClientGetInfoAndStateArgs() const
    {
        AssertSanity(TClientGetInfoAndStateArgs);
        return (*(constptr_ClientGetInfoAndStateArgs()));
    }
    operator ClientGetInfoAndStateArgs&()
    {
        return get_ClientGetInfoAndStateArgs();
    }
    operator const ClientGetInfoAndStateArgs&() const
    {
        return get_ClientGetInfoAndStateArgs();
    }

    ClientOpenWindowArgs&
    get_ClientOpenWindowArgs()
    {
        AssertSanity(TClientOpenWindowArgs);
        return (*(ptr_ClientOpenWindowArgs()));
    }
    const ClientOpenWindowArgs&
    get_ClientOpenWindowArgs() const
    {
        AssertSanity(TClientOpenWindowArgs);
        return (*(constptr_ClientOpenWindowArgs()));
    }
    operator ClientOpenWindowArgs&()
    {
        return get_ClientOpenWindowArgs();
    }
    operator const ClientOpenWindowArgs&() const
    {
        return get_ClientOpenWindowArgs();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ClientOpConstructorArgs>
{
    typedef mozilla::dom::ClientOpConstructorArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ClientList|
//
namespace mozilla {
namespace dom {
class ClientList final
{
private:
    typedef mozilla::dom::ClientInfoAndState ClientInfoAndState;

public:
    MOZ_IMPLICIT ClientList() :
        values_()
    {
    }

    MOZ_IMPLICIT ClientList(const nsTArray<ClientInfoAndState>& _values) :
        values_(_values)
    {
    }

    nsTArray<ClientInfoAndState>&
    values()
    {
        return values_;
    }
    const nsTArray<ClientInfoAndState>&
    values() const
    {
        return values_;
    }

private:
    CopyableTArray<ClientInfoAndState> values_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ClientList>
{
    typedef mozilla::dom::ClientList paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace dom {
class PClientSourceParent;
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {
class PClientSourceChild;
} // namespace dom
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ClientNavigateOpConstructorArgs|
//
namespace mozilla {
namespace dom {
class ClientNavigateOpConstructorArgs final
{
private:
    typedef mozilla::dom::PClientSourceParent PClientSourceParent;
    typedef mozilla::dom::PClientSourceChild PClientSourceChild;

public:
    MOZ_IMPLICIT ClientNavigateOpConstructorArgs() :
        targetParent_(),
        targetChild_(),
        url_(),
        baseURL_()
    {
    }

    MOZ_IMPLICIT ClientNavigateOpConstructorArgs(
            PClientSourceParent* _targetParent,
            PClientSourceChild* _targetChild,
            const nsCString& _url,
            const nsCString& _baseURL) :
        targetParent_(_targetParent),
        targetChild_(_targetChild),
        url_(_url),
        baseURL_(_baseURL)
    {
    }

    PClientSourceParent*&
    targetParent()
    {
        return targetParent_;
    }
    PClientSourceParent*
    targetParent() const
    {
        return targetParent_;
    }

    PClientSourceChild*&
    targetChild()
    {
        return targetChild_;
    }
    PClientSourceChild*
    targetChild() const
    {
        return targetChild_;
    }

    nsCString&
    url()
    {
        return url_;
    }
    const nsCString&
    url() const
    {
        return url_;
    }

    nsCString&
    baseURL()
    {
        return baseURL_;
    }
    const nsCString&
    baseURL() const
    {
        return baseURL_;
    }

private:
    PClientSourceParent* targetParent_;
    PClientSourceChild* targetChild_;
    nsCString url_;
    nsCString baseURL_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ClientNavigateOpConstructorArgs>
{
    typedef mozilla::dom::ClientNavigateOpConstructorArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union ClientOpResult|
//
namespace mozilla {
namespace dom {
class ClientOpResult final
{
public:
    enum Type {
        T__None,
        TCopyableErrorResult = 1,
        TIPCClientState,
        TClientInfoAndState,
        TClientList,
        T__Last = TClientList
    };

private:
    typedef mozilla::CopyableErrorResult CopyableErrorResult;
    typedef mozilla::dom::IPCClientState IPCClientState;
    typedef mozilla::dom::ClientInfoAndState ClientInfoAndState;
    typedef mozilla::dom::ClientList ClientList;
    typedef CopyableErrorResult CopyableErrorResult__tdef;
    typedef IPCClientState IPCClientState__tdef;
    typedef ClientInfoAndState ClientInfoAndState__tdef;
    typedef ClientList ClientList__tdef;

    union Value {
        mozilla::AlignedStorage2<CopyableErrorResult> VCopyableErrorResult;
        mozilla::AlignedStorage2<IPCClientState> VIPCClientState;
        mozilla::AlignedStorage2<ClientInfoAndState> VClientInfoAndState;
        mozilla::AlignedStorage2<ClientList> VClientList;
    };

    CopyableErrorResult*
    ptr_CopyableErrorResult()
    {
        return ((mValue).VCopyableErrorResult).addr();
    }
    const CopyableErrorResult*
    constptr_CopyableErrorResult() const
    {
        return ((mValue).VCopyableErrorResult).addr();
    }
    IPCClientState*
    ptr_IPCClientState()
    {
        return ((mValue).VIPCClientState).addr();
    }
    const IPCClientState*
    constptr_IPCClientState() const
    {
        return ((mValue).VIPCClientState).addr();
    }
    ClientInfoAndState*
    ptr_ClientInfoAndState()
    {
        return ((mValue).VClientInfoAndState).addr();
    }
    const ClientInfoAndState*
    constptr_ClientInfoAndState() const
    {
        return ((mValue).VClientInfoAndState).addr();
    }
    ClientList*
    ptr_ClientList()
    {
        return ((mValue).VClientList).addr();
    }
    const ClientList*
    constptr_ClientList() const
    {
        return ((mValue).VClientList).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT ClientOpResult() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT ClientOpResult(const CopyableErrorResult& aOther);

    MOZ_IMPLICIT ClientOpResult(CopyableErrorResult&& aOther);

    MOZ_IMPLICIT ClientOpResult(const IPCClientState& aOther);

    MOZ_IMPLICIT ClientOpResult(IPCClientState&& aOther);

    MOZ_IMPLICIT ClientOpResult(const ClientInfoAndState& aOther);

    MOZ_IMPLICIT ClientOpResult(ClientInfoAndState&& aOther);

    MOZ_IMPLICIT ClientOpResult(const ClientList& aOther);

    MOZ_IMPLICIT ClientOpResult(ClientList&& aOther);

    MOZ_IMPLICIT ClientOpResult(const ClientOpResult& aOther);

    MOZ_IMPLICIT ClientOpResult(ClientOpResult&& aOther);

    ~ClientOpResult();

    Type
    type() const
    {
        return mType;
    }

    ClientOpResult&
    operator=(const CopyableErrorResult& aRhs);

    ClientOpResult&
    operator=(CopyableErrorResult&& aRhs);

    ClientOpResult&
    operator=(const IPCClientState& aRhs);

    ClientOpResult&
    operator=(IPCClientState&& aRhs);

    ClientOpResult&
    operator=(const ClientInfoAndState& aRhs);

    ClientOpResult&
    operator=(ClientInfoAndState&& aRhs);

    ClientOpResult&
    operator=(const ClientList& aRhs);

    ClientOpResult&
    operator=(ClientList&& aRhs);

    ClientOpResult&
    operator=(const ClientOpResult& aRhs);

    ClientOpResult&
    operator=(ClientOpResult&& aRhs);

    CopyableErrorResult&
    get_CopyableErrorResult()
    {
        AssertSanity(TCopyableErrorResult);
        return (*(ptr_CopyableErrorResult()));
    }
    const CopyableErrorResult&
    get_CopyableErrorResult() const
    {
        AssertSanity(TCopyableErrorResult);
        return (*(constptr_CopyableErrorResult()));
    }
    operator CopyableErrorResult&()
    {
        return get_CopyableErrorResult();
    }
    operator const CopyableErrorResult&() const
    {
        return get_CopyableErrorResult();
    }

    IPCClientState&
    get_IPCClientState()
    {
        AssertSanity(TIPCClientState);
        return (*(ptr_IPCClientState()));
    }
    const IPCClientState&
    get_IPCClientState() const
    {
        AssertSanity(TIPCClientState);
        return (*(constptr_IPCClientState()));
    }
    operator IPCClientState&()
    {
        return get_IPCClientState();
    }
    operator const IPCClientState&() const
    {
        return get_IPCClientState();
    }

    ClientInfoAndState&
    get_ClientInfoAndState()
    {
        AssertSanity(TClientInfoAndState);
        return (*(ptr_ClientInfoAndState()));
    }
    const ClientInfoAndState&
    get_ClientInfoAndState() const
    {
        AssertSanity(TClientInfoAndState);
        return (*(constptr_ClientInfoAndState()));
    }
    operator ClientInfoAndState&()
    {
        return get_ClientInfoAndState();
    }
    operator const ClientInfoAndState&() const
    {
        return get_ClientInfoAndState();
    }

    ClientList&
    get_ClientList()
    {
        AssertSanity(TClientList);
        return (*(ptr_ClientList()));
    }
    const ClientList&
    get_ClientList() const
    {
        AssertSanity(TClientList);
        return (*(constptr_ClientList()));
    }
    operator ClientList&()
    {
        return get_ClientList();
    }
    operator const ClientList&() const
    {
        return get_ClientList();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ClientOpResult>
{
    typedef mozilla::dom::ClientOpResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

#endif // ifndef ClientIPCTypes_h
