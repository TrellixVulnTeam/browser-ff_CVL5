//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PContent_h
#define PContent_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "mozilla/TelemetryComms.h"
#include "mozilla/chrome/RegistryMessageUtils.h"
#include "mozilla/dom/BrowsingContext.h"
#include "mozilla/dom/DOMTypes.h"
#include "mozilla/dom/WindowGlobalTypes.h"
#include "mozilla/dom/IPCBlob.h"
#include "mozilla/ipc/IPCStream.h"
#include "mozilla/dom/PTabContext.h"
#include "mozilla/plugins/PluginTypes.h"
#include "mozilla/ipc/ProtocolTypes.h"
#include "mozilla/ipc/PBackgroundSharedTypes.h"
#include "mozilla/dom/PContentPermission.h"
#include "mozilla/dom/ServiceWorkerConfiguration.h"
#include "mozilla/gfx/GraphicsMessages.h"
#include "mozilla/dom/MemoryReportTypes.h"
#include "mozilla/dom/ClientIPCTypes.h"
#include "mozilla/HangTypes.h"
#include "mozilla/dom/PrefsTypes.h"
#include "mozilla/net/NeckoChannelParams.h"
#include "mozilla/psm/PSMIPCTypes.h"
#include "mozilla/widget/LookAndFeelTypes.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union ChromeRegistryItem|
//
class ChromeRegistryItem final
{
public:
    enum Type {
        T__None,
        TChromePackage = 1,
        TOverrideMapping,
        TSubstitutionMapping,
        T__Last = TSubstitutionMapping
    };

private:
    typedef ChromePackage ChromePackage__tdef;
    typedef OverrideMapping OverrideMapping__tdef;
    typedef SubstitutionMapping SubstitutionMapping__tdef;

    union Value {
        mozilla::AlignedStorage2<ChromePackage> VChromePackage;
        mozilla::AlignedStorage2<OverrideMapping> VOverrideMapping;
        mozilla::AlignedStorage2<SubstitutionMapping> VSubstitutionMapping;
    };

    ChromePackage*
    ptr_ChromePackage()
    {
        return ((mValue).VChromePackage).addr();
    }
    const ChromePackage*
    constptr_ChromePackage() const
    {
        return ((mValue).VChromePackage).addr();
    }
    OverrideMapping*
    ptr_OverrideMapping()
    {
        return ((mValue).VOverrideMapping).addr();
    }
    const OverrideMapping*
    constptr_OverrideMapping() const
    {
        return ((mValue).VOverrideMapping).addr();
    }
    SubstitutionMapping*
    ptr_SubstitutionMapping()
    {
        return ((mValue).VSubstitutionMapping).addr();
    }
    const SubstitutionMapping*
    constptr_SubstitutionMapping() const
    {
        return ((mValue).VSubstitutionMapping).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT ChromeRegistryItem() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT ChromeRegistryItem(const ChromePackage& aOther);

    MOZ_IMPLICIT ChromeRegistryItem(ChromePackage&& aOther);

    MOZ_IMPLICIT ChromeRegistryItem(const OverrideMapping& aOther);

    MOZ_IMPLICIT ChromeRegistryItem(OverrideMapping&& aOther);

    MOZ_IMPLICIT ChromeRegistryItem(const SubstitutionMapping& aOther);

    MOZ_IMPLICIT ChromeRegistryItem(SubstitutionMapping&& aOther);

    MOZ_IMPLICIT ChromeRegistryItem(const ChromeRegistryItem& aOther);

    MOZ_IMPLICIT ChromeRegistryItem(ChromeRegistryItem&& aOther);

    ~ChromeRegistryItem();

    Type
    type() const
    {
        return mType;
    }

    ChromeRegistryItem&
    operator=(const ChromePackage& aRhs);

    ChromeRegistryItem&
    operator=(ChromePackage&& aRhs);

    ChromeRegistryItem&
    operator=(const OverrideMapping& aRhs);

    ChromeRegistryItem&
    operator=(OverrideMapping&& aRhs);

    ChromeRegistryItem&
    operator=(const SubstitutionMapping& aRhs);

    ChromeRegistryItem&
    operator=(SubstitutionMapping&& aRhs);

    ChromeRegistryItem&
    operator=(const ChromeRegistryItem& aRhs);

    ChromeRegistryItem&
    operator=(ChromeRegistryItem&& aRhs);

    ChromePackage&
    get_ChromePackage()
    {
        AssertSanity(TChromePackage);
        return (*(ptr_ChromePackage()));
    }
    const ChromePackage&
    get_ChromePackage() const
    {
        AssertSanity(TChromePackage);
        return (*(constptr_ChromePackage()));
    }
    operator ChromePackage&()
    {
        return get_ChromePackage();
    }
    operator const ChromePackage&() const
    {
        return get_ChromePackage();
    }

    OverrideMapping&
    get_OverrideMapping()
    {
        AssertSanity(TOverrideMapping);
        return (*(ptr_OverrideMapping()));
    }
    const OverrideMapping&
    get_OverrideMapping() const
    {
        AssertSanity(TOverrideMapping);
        return (*(constptr_OverrideMapping()));
    }
    operator OverrideMapping&()
    {
        return get_OverrideMapping();
    }
    operator const OverrideMapping&() const
    {
        return get_OverrideMapping();
    }

    SubstitutionMapping&
    get_SubstitutionMapping()
    {
        AssertSanity(TSubstitutionMapping);
        return (*(ptr_SubstitutionMapping()));
    }
    const SubstitutionMapping&
    get_SubstitutionMapping() const
    {
        AssertSanity(TSubstitutionMapping);
        return (*(constptr_SubstitutionMapping()));
    }
    operator SubstitutionMapping&()
    {
        return get_SubstitutionMapping();
    }
    operator const SubstitutionMapping&() const
    {
        return get_SubstitutionMapping();
    }

private:
    Value mValue;
    Type mType;
};

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <ChromeRegistryItem>
{
    typedef ChromeRegistryItem paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SystemFontListEntry|
//
namespace mozilla {
namespace dom {
class SystemFontListEntry final
{
private:

public:
    MOZ_IMPLICIT SystemFontListEntry() :
        pattern_(),
        appFontFamily_()
    {
    }

    MOZ_IMPLICIT SystemFontListEntry(
            const nsCString& _pattern,
            const bool& _appFontFamily) :
        pattern_(_pattern),
        appFontFamily_(_appFontFamily)
    {
    }

    nsCString&
    pattern()
    {
        return pattern_;
    }
    const nsCString&
    pattern() const
    {
        return pattern_;
    }

    bool&
    appFontFamily()
    {
        return appFontFamily_;
    }
    const bool&
    appFontFamily() const
    {
        return appFontFamily_;
    }

private:
    nsCString pattern_;
    bool appFontFamily_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::SystemFontListEntry>
{
    typedef mozilla::dom::SystemFontListEntry paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union SystemParameterValue|
//
namespace mozilla {
namespace dom {
class SystemParameterValue final
{
public:
    enum Type {
        T__None,
        Tbool = 1,
        Tfloat,
        T__Last = Tfloat
    };

private:
    typedef bool bool__tdef;
    typedef float float__tdef;

    union Value {
        mozilla::AlignedStorage2<bool> Vbool;
        mozilla::AlignedStorage2<float> Vfloat;
    };

    bool*
    ptr_bool()
    {
        return ((mValue).Vbool).addr();
    }
    const bool*
    constptr_bool() const
    {
        return ((mValue).Vbool).addr();
    }
    float*
    ptr_float()
    {
        return ((mValue).Vfloat).addr();
    }
    const float*
    constptr_float() const
    {
        return ((mValue).Vfloat).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT SystemParameterValue() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT SystemParameterValue(const bool& aOther);

    MOZ_IMPLICIT SystemParameterValue(bool&& aOther);

    MOZ_IMPLICIT SystemParameterValue(const float& aOther);

    MOZ_IMPLICIT SystemParameterValue(float&& aOther);

    MOZ_IMPLICIT SystemParameterValue(const SystemParameterValue& aOther);

    MOZ_IMPLICIT SystemParameterValue(SystemParameterValue&& aOther);

    ~SystemParameterValue();

    Type
    type() const
    {
        return mType;
    }

    SystemParameterValue&
    operator=(const bool& aRhs);

    SystemParameterValue&
    operator=(bool&& aRhs);

    SystemParameterValue&
    operator=(const float& aRhs);

    SystemParameterValue&
    operator=(float&& aRhs);

    SystemParameterValue&
    operator=(const SystemParameterValue& aRhs);

    SystemParameterValue&
    operator=(SystemParameterValue&& aRhs);

    bool&
    get_bool()
    {
        AssertSanity(Tbool);
        return (*(ptr_bool()));
    }
    const bool&
    get_bool() const
    {
        AssertSanity(Tbool);
        return (*(constptr_bool()));
    }
    operator bool&()
    {
        return get_bool();
    }
    operator const bool&() const
    {
        return get_bool();
    }

    float&
    get_float()
    {
        AssertSanity(Tfloat);
        return (*(ptr_float()));
    }
    const float&
    get_float() const
    {
        AssertSanity(Tfloat);
        return (*(constptr_float()));
    }
    operator float&()
    {
        return get_float();
    }
    operator const float&() const
    {
        return get_float();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::SystemParameterValue>
{
    typedef mozilla::dom::SystemParameterValue paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SystemParameterKVPair|
//
namespace mozilla {
namespace dom {
class SystemParameterKVPair final
{
private:
    typedef mozilla::dom::SystemParameterValue SystemParameterValue;

public:
    MOZ_IMPLICIT SystemParameterKVPair() :
        value_(),
        id_()
    {
    }

    MOZ_IMPLICIT SystemParameterKVPair(
            const uint8_t& _id,
            const SystemParameterValue& _value) :
        value_(_value),
        id_(_id)
    {
    }

    uint8_t&
    id()
    {
        return id_;
    }
    const uint8_t&
    id() const
    {
        return id_;
    }

    SystemParameterValue&
    value()
    {
        return value_;
    }
    const SystemParameterValue&
    value() const
    {
        return value_;
    }

private:
    SystemParameterValue value_;
    uint8_t id_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::SystemParameterKVPair>
{
    typedef mozilla::dom::SystemParameterKVPair paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ClipboardCapabilities|
//
namespace mozilla {
namespace dom {
class ClipboardCapabilities final
{
private:

public:
    MOZ_IMPLICIT ClipboardCapabilities() :
        supportsSelectionClipboard_(),
        supportsFindClipboard_()
    {
    }

    MOZ_IMPLICIT ClipboardCapabilities(
            const bool& _supportsSelectionClipboard,
            const bool& _supportsFindClipboard) :
        supportsSelectionClipboard_(_supportsSelectionClipboard),
        supportsFindClipboard_(_supportsFindClipboard)
    {
    }

    bool&
    supportsSelectionClipboard()
    {
        return supportsSelectionClipboard_;
    }
    const bool&
    supportsSelectionClipboard() const
    {
        return supportsSelectionClipboard_;
    }

    bool&
    supportsFindClipboard()
    {
        return supportsFindClipboard_;
    }
    const bool&
    supportsFindClipboard() const
    {
        return supportsFindClipboard_;
    }

private:
    bool supportsSelectionClipboard_;
    bool supportsFindClipboard_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ClipboardCapabilities>
{
    typedef mozilla::dom::ClipboardCapabilities paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union FileDescOrError|
//
namespace mozilla {
namespace dom {
class FileDescOrError final
{
public:
    enum Type {
        T__None,
        TFileDescriptor = 1,
        Tnsresult,
        T__Last = Tnsresult
    };

private:
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef FileDescriptor FileDescriptor__tdef;
    typedef nsresult nsresult__tdef;

    union Value {
        mozilla::AlignedStorage2<FileDescriptor> VFileDescriptor;
        mozilla::AlignedStorage2<nsresult> Vnsresult;
    };

    FileDescriptor*
    ptr_FileDescriptor()
    {
        return ((mValue).VFileDescriptor).addr();
    }
    const FileDescriptor*
    constptr_FileDescriptor() const
    {
        return ((mValue).VFileDescriptor).addr();
    }
    nsresult*
    ptr_nsresult()
    {
        return ((mValue).Vnsresult).addr();
    }
    const nsresult*
    constptr_nsresult() const
    {
        return ((mValue).Vnsresult).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT FileDescOrError() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT FileDescOrError(const FileDescriptor& aOther);

    MOZ_IMPLICIT FileDescOrError(FileDescriptor&& aOther);

    MOZ_IMPLICIT FileDescOrError(const nsresult& aOther);

    MOZ_IMPLICIT FileDescOrError(nsresult&& aOther);

    MOZ_IMPLICIT FileDescOrError(const FileDescOrError& aOther);

    MOZ_IMPLICIT FileDescOrError(FileDescOrError&& aOther);

    ~FileDescOrError();

    Type
    type() const
    {
        return mType;
    }

    FileDescOrError&
    operator=(const FileDescriptor& aRhs);

    FileDescOrError&
    operator=(FileDescriptor&& aRhs);

    FileDescOrError&
    operator=(const nsresult& aRhs);

    FileDescOrError&
    operator=(nsresult&& aRhs);

    FileDescOrError&
    operator=(const FileDescOrError& aRhs);

    FileDescOrError&
    operator=(FileDescOrError&& aRhs);

    FileDescriptor&
    get_FileDescriptor()
    {
        AssertSanity(TFileDescriptor);
        return (*(ptr_FileDescriptor()));
    }
    const FileDescriptor&
    get_FileDescriptor() const
    {
        AssertSanity(TFileDescriptor);
        return const_cast<FileDescriptor&>((*(constptr_FileDescriptor())));
    }
    operator FileDescriptor&()
    {
        return get_FileDescriptor();
    }
    operator const FileDescriptor&() const
    {
        return get_FileDescriptor();
    }

    nsresult&
    get_nsresult()
    {
        AssertSanity(Tnsresult);
        return (*(ptr_nsresult()));
    }
    const nsresult&
    get_nsresult() const
    {
        AssertSanity(Tnsresult);
        return (*(constptr_nsresult()));
    }
    operator nsresult&()
    {
        return get_nsresult();
    }
    operator const nsresult&() const
    {
        return get_nsresult();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::FileDescOrError>
{
    typedef mozilla::dom::FileDescOrError paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct DomainPolicyClone|
//
namespace mozilla {
namespace dom {
class DomainPolicyClone final
{
private:

public:
    MOZ_IMPLICIT DomainPolicyClone() :
        active_(),
        blocklist_(),
        allowlist_(),
        superBlocklist_(),
        superAllowlist_()
    {
    }

    MOZ_IMPLICIT DomainPolicyClone(
            const bool& _active,
            const nsTArray<RefPtr<nsIURI>>& _blocklist,
            const nsTArray<RefPtr<nsIURI>>& _allowlist,
            const nsTArray<RefPtr<nsIURI>>& _superBlocklist,
            const nsTArray<RefPtr<nsIURI>>& _superAllowlist) :
        active_(_active),
        blocklist_(_blocklist),
        allowlist_(_allowlist),
        superBlocklist_(_superBlocklist),
        superAllowlist_(_superAllowlist)
    {
    }

    bool&
    active()
    {
        return active_;
    }
    const bool&
    active() const
    {
        return active_;
    }

    nsTArray<RefPtr<nsIURI>>&
    blocklist()
    {
        return blocklist_;
    }
    const nsTArray<RefPtr<nsIURI>>&
    blocklist() const
    {
        return blocklist_;
    }

    nsTArray<RefPtr<nsIURI>>&
    allowlist()
    {
        return allowlist_;
    }
    const nsTArray<RefPtr<nsIURI>>&
    allowlist() const
    {
        return allowlist_;
    }

    nsTArray<RefPtr<nsIURI>>&
    superBlocklist()
    {
        return superBlocklist_;
    }
    const nsTArray<RefPtr<nsIURI>>&
    superBlocklist() const
    {
        return superBlocklist_;
    }

    nsTArray<RefPtr<nsIURI>>&
    superAllowlist()
    {
        return superAllowlist_;
    }
    const nsTArray<RefPtr<nsIURI>>&
    superAllowlist() const
    {
        return superAllowlist_;
    }

private:
    bool active_;
    CopyableTArray<RefPtr<nsIURI>> blocklist_;
    CopyableTArray<RefPtr<nsIURI>> allowlist_;
    CopyableTArray<RefPtr<nsIURI>> superBlocklist_;
    CopyableTArray<RefPtr<nsIURI>> superAllowlist_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::DomainPolicyClone>
{
    typedef mozilla::dom::DomainPolicyClone paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct AndroidSystemInfo|
//
namespace mozilla {
namespace dom {
class AndroidSystemInfo final
{
private:

public:
    MOZ_IMPLICIT AndroidSystemInfo() :
        device_(),
        manufacturer_(),
        release_version_(),
        hardware_(),
        isTablet_(),
        sdk_version_()
    {
    }

    MOZ_IMPLICIT AndroidSystemInfo(
            const nsString& _device,
            const nsString& _manufacturer,
            const nsString& _release_version,
            const nsString& _hardware,
            const uint32_t& _sdk_version,
            const bool& _isTablet) :
        device_(_device),
        manufacturer_(_manufacturer),
        release_version_(_release_version),
        hardware_(_hardware),
        isTablet_(_isTablet),
        sdk_version_(_sdk_version)
    {
    }

    nsString&
    device()
    {
        return device_;
    }
    const nsString&
    device() const
    {
        return device_;
    }

    nsString&
    manufacturer()
    {
        return manufacturer_;
    }
    const nsString&
    manufacturer() const
    {
        return manufacturer_;
    }

    nsString&
    release_version()
    {
        return release_version_;
    }
    const nsString&
    release_version() const
    {
        return release_version_;
    }

    nsString&
    hardware()
    {
        return hardware_;
    }
    const nsString&
    hardware() const
    {
        return hardware_;
    }

    uint32_t&
    sdk_version()
    {
        return sdk_version_;
    }
    const uint32_t&
    sdk_version() const
    {
        return sdk_version_;
    }

    bool&
    isTablet()
    {
        return isTablet_;
    }
    const bool&
    isTablet() const
    {
        return isTablet_;
    }

private:
    nsString device_;
    nsString manufacturer_;
    nsString release_version_;
    nsString hardware_;
    bool isTablet_;
    uint32_t sdk_version_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::AndroidSystemInfo>
{
    typedef mozilla::dom::AndroidSystemInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct GetFilesResponseSuccess|
//
namespace mozilla {
namespace dom {
class GetFilesResponseSuccess final
{
private:
    typedef mozilla::dom::IPCBlob IPCBlob;

public:
    MOZ_IMPLICIT GetFilesResponseSuccess() :
        blobs_()
    {
    }

    MOZ_IMPLICIT GetFilesResponseSuccess(const nsTArray<IPCBlob>& _blobs) :
        blobs_(_blobs)
    {
    }

    nsTArray<IPCBlob>&
    blobs()
    {
        return blobs_;
    }
    const nsTArray<IPCBlob>&
    blobs() const
    {
        return blobs_;
    }

private:
    CopyableTArray<IPCBlob> blobs_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::GetFilesResponseSuccess>
{
    typedef mozilla::dom::GetFilesResponseSuccess paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct GetFilesResponseFailure|
//
namespace mozilla {
namespace dom {
class GetFilesResponseFailure final
{
private:

public:
    MOZ_IMPLICIT GetFilesResponseFailure() :
        errorCode_()
    {
    }

    MOZ_IMPLICIT GetFilesResponseFailure(const nsresult& _errorCode) :
        errorCode_(_errorCode)
    {
    }

    nsresult&
    errorCode()
    {
        return errorCode_;
    }
    const nsresult&
    errorCode() const
    {
        return errorCode_;
    }

private:
    nsresult errorCode_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::GetFilesResponseFailure>
{
    typedef mozilla::dom::GetFilesResponseFailure paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union GetFilesResponseResult|
//
namespace mozilla {
namespace dom {
class GetFilesResponseResult final
{
public:
    enum Type {
        T__None,
        TGetFilesResponseSuccess = 1,
        TGetFilesResponseFailure,
        T__Last = TGetFilesResponseFailure
    };

private:
    typedef mozilla::dom::GetFilesResponseSuccess GetFilesResponseSuccess;
    typedef mozilla::dom::GetFilesResponseFailure GetFilesResponseFailure;
    typedef GetFilesResponseSuccess GetFilesResponseSuccess__tdef;
    typedef GetFilesResponseFailure GetFilesResponseFailure__tdef;

    union Value {
        mozilla::AlignedStorage2<GetFilesResponseSuccess> VGetFilesResponseSuccess;
        mozilla::AlignedStorage2<GetFilesResponseFailure> VGetFilesResponseFailure;
    };

    GetFilesResponseSuccess*
    ptr_GetFilesResponseSuccess()
    {
        return ((mValue).VGetFilesResponseSuccess).addr();
    }
    const GetFilesResponseSuccess*
    constptr_GetFilesResponseSuccess() const
    {
        return ((mValue).VGetFilesResponseSuccess).addr();
    }
    GetFilesResponseFailure*
    ptr_GetFilesResponseFailure()
    {
        return ((mValue).VGetFilesResponseFailure).addr();
    }
    const GetFilesResponseFailure*
    constptr_GetFilesResponseFailure() const
    {
        return ((mValue).VGetFilesResponseFailure).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT GetFilesResponseResult() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT GetFilesResponseResult(const GetFilesResponseSuccess& aOther);

    MOZ_IMPLICIT GetFilesResponseResult(GetFilesResponseSuccess&& aOther);

    MOZ_IMPLICIT GetFilesResponseResult(const GetFilesResponseFailure& aOther);

    MOZ_IMPLICIT GetFilesResponseResult(GetFilesResponseFailure&& aOther);

    MOZ_IMPLICIT GetFilesResponseResult(const GetFilesResponseResult& aOther);

    MOZ_IMPLICIT GetFilesResponseResult(GetFilesResponseResult&& aOther);

    ~GetFilesResponseResult();

    Type
    type() const
    {
        return mType;
    }

    GetFilesResponseResult&
    operator=(const GetFilesResponseSuccess& aRhs);

    GetFilesResponseResult&
    operator=(GetFilesResponseSuccess&& aRhs);

    GetFilesResponseResult&
    operator=(const GetFilesResponseFailure& aRhs);

    GetFilesResponseResult&
    operator=(GetFilesResponseFailure&& aRhs);

    GetFilesResponseResult&
    operator=(const GetFilesResponseResult& aRhs);

    GetFilesResponseResult&
    operator=(GetFilesResponseResult&& aRhs);

    GetFilesResponseSuccess&
    get_GetFilesResponseSuccess()
    {
        AssertSanity(TGetFilesResponseSuccess);
        return (*(ptr_GetFilesResponseSuccess()));
    }
    const GetFilesResponseSuccess&
    get_GetFilesResponseSuccess() const
    {
        AssertSanity(TGetFilesResponseSuccess);
        return (*(constptr_GetFilesResponseSuccess()));
    }
    operator GetFilesResponseSuccess&()
    {
        return get_GetFilesResponseSuccess();
    }
    operator const GetFilesResponseSuccess&() const
    {
        return get_GetFilesResponseSuccess();
    }

    GetFilesResponseFailure&
    get_GetFilesResponseFailure()
    {
        AssertSanity(TGetFilesResponseFailure);
        return (*(ptr_GetFilesResponseFailure()));
    }
    const GetFilesResponseFailure&
    get_GetFilesResponseFailure() const
    {
        AssertSanity(TGetFilesResponseFailure);
        return (*(constptr_GetFilesResponseFailure()));
    }
    operator GetFilesResponseFailure&()
    {
        return get_GetFilesResponseFailure();
    }
    operator const GetFilesResponseFailure&() const
    {
        return get_GetFilesResponseFailure();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::GetFilesResponseResult>
{
    typedef mozilla::dom::GetFilesResponseResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct BlobURLRegistrationData|
//
namespace mozilla {
namespace dom {
class BlobURLRegistrationData final
{
private:
    typedef mozilla::dom::IPCBlob IPCBlob;

public:
    MOZ_IMPLICIT BlobURLRegistrationData() :
        url_(),
        blob_(),
        principal_(),
        agentClusterId_(),
        revoked_()
    {
    }

    MOZ_IMPLICIT BlobURLRegistrationData(
            const nsCString& _url,
            const IPCBlob& _blob,
            nsIPrincipal* _principal,
            const mozilla::Maybe<nsID>& _agentClusterId,
            const bool& _revoked) :
        url_(_url),
        blob_(_blob),
        principal_(_principal),
        agentClusterId_(_agentClusterId),
        revoked_(_revoked)
    {
    }

    nsCString&
    url()
    {
        return url_;
    }
    const nsCString&
    url() const
    {
        return url_;
    }

    IPCBlob&
    blob()
    {
        return blob_;
    }
    const IPCBlob&
    blob() const
    {
        return blob_;
    }

    RefPtr<nsIPrincipal>&
    principal()
    {
        return principal_;
    }
    nsIPrincipal*
    principal() const
    {
        return principal_;
    }

    mozilla::Maybe<nsID>&
    agentClusterId()
    {
        return agentClusterId_;
    }
    const mozilla::Maybe<nsID>&
    agentClusterId() const
    {
        return agentClusterId_;
    }

    bool&
    revoked()
    {
        return revoked_;
    }
    const bool&
    revoked() const
    {
        return revoked_;
    }

private:
    nsCString url_;
    IPCBlob blob_;
    RefPtr<nsIPrincipal> principal_;
    mozilla::Maybe<nsID> agentClusterId_;
    bool revoked_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::BlobURLRegistrationData>
{
    typedef mozilla::dom::BlobURLRegistrationData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct JSWindowActorEventDecl|
//
namespace mozilla {
namespace dom {
class JSWindowActorEventDecl final
{
private:

public:
    MOZ_IMPLICIT JSWindowActorEventDecl() :
        name_(),
        capture_(),
        systemGroup_(),
        allowUntrusted_(),
        passive_()
    {
    }

    MOZ_IMPLICIT JSWindowActorEventDecl(
            const nsString& _name,
            const bool& _capture,
            const bool& _systemGroup,
            const bool& _allowUntrusted,
            const mozilla::Maybe<bool>& _passive) :
        name_(_name),
        capture_(_capture),
        systemGroup_(_systemGroup),
        allowUntrusted_(_allowUntrusted),
        passive_(_passive)
    {
    }

    nsString&
    name()
    {
        return name_;
    }
    const nsString&
    name() const
    {
        return name_;
    }

    bool&
    capture()
    {
        return capture_;
    }
    const bool&
    capture() const
    {
        return capture_;
    }

    bool&
    systemGroup()
    {
        return systemGroup_;
    }
    const bool&
    systemGroup() const
    {
        return systemGroup_;
    }

    bool&
    allowUntrusted()
    {
        return allowUntrusted_;
    }
    const bool&
    allowUntrusted() const
    {
        return allowUntrusted_;
    }

    mozilla::Maybe<bool>&
    passive()
    {
        return passive_;
    }
    const mozilla::Maybe<bool>&
    passive() const
    {
        return passive_;
    }

private:
    nsString name_;
    bool capture_;
    bool systemGroup_;
    bool allowUntrusted_;
    mozilla::Maybe<bool> passive_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::JSWindowActorEventDecl>
{
    typedef mozilla::dom::JSWindowActorEventDecl paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct JSWindowActorInfo|
//
namespace mozilla {
namespace dom {
class JSWindowActorInfo final
{
private:
    typedef mozilla::dom::JSWindowActorEventDecl JSWindowActorEventDecl;

public:
    MOZ_IMPLICIT JSWindowActorInfo() :
        name_(),
        allFrames_(),
        url_(),
        events_(),
        observers_(),
        matches_(),
        remoteTypes_(),
        messageManagerGroups_()
    {
    }

    MOZ_IMPLICIT JSWindowActorInfo(
            const nsCString& _name,
            const bool& _allFrames,
            const mozilla::Maybe<nsCString>& _url,
            const nsTArray<JSWindowActorEventDecl>& _events,
            const nsTArray<nsCString>& _observers,
            const nsTArray<nsString>& _matches,
            const nsTArray<nsCString>& _remoteTypes,
            const nsTArray<nsString>& _messageManagerGroups) :
        name_(_name),
        allFrames_(_allFrames),
        url_(_url),
        events_(_events),
        observers_(_observers),
        matches_(_matches),
        remoteTypes_(_remoteTypes),
        messageManagerGroups_(_messageManagerGroups)
    {
    }

    nsCString&
    name()
    {
        return name_;
    }
    const nsCString&
    name() const
    {
        return name_;
    }

    bool&
    allFrames()
    {
        return allFrames_;
    }
    const bool&
    allFrames() const
    {
        return allFrames_;
    }

    mozilla::Maybe<nsCString>&
    url()
    {
        return url_;
    }
    const mozilla::Maybe<nsCString>&
    url() const
    {
        return url_;
    }

    nsTArray<JSWindowActorEventDecl>&
    events()
    {
        return events_;
    }
    const nsTArray<JSWindowActorEventDecl>&
    events() const
    {
        return events_;
    }

    nsTArray<nsCString>&
    observers()
    {
        return observers_;
    }
    const nsTArray<nsCString>&
    observers() const
    {
        return observers_;
    }

    nsTArray<nsString>&
    matches()
    {
        return matches_;
    }
    const nsTArray<nsString>&
    matches() const
    {
        return matches_;
    }

    nsTArray<nsCString>&
    remoteTypes()
    {
        return remoteTypes_;
    }
    const nsTArray<nsCString>&
    remoteTypes() const
    {
        return remoteTypes_;
    }

    nsTArray<nsString>&
    messageManagerGroups()
    {
        return messageManagerGroups_;
    }
    const nsTArray<nsString>&
    messageManagerGroups() const
    {
        return messageManagerGroups_;
    }

private:
    nsCString name_;
    bool allFrames_;
    mozilla::Maybe<nsCString> url_;
    CopyableTArray<JSWindowActorEventDecl> events_;
    CopyableTArray<nsCString> observers_;
    CopyableTArray<nsString> matches_;
    CopyableTArray<nsCString> remoteTypes_;
    CopyableTArray<nsString> messageManagerGroups_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::JSWindowActorInfo>
{
    typedef mozilla::dom::JSWindowActorInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct JSProcessActorInfo|
//
namespace mozilla {
namespace dom {
class JSProcessActorInfo final
{
private:

public:
    MOZ_IMPLICIT JSProcessActorInfo() :
        name_(),
        url_(),
        observers_(),
        remoteTypes_()
    {
    }

    MOZ_IMPLICIT JSProcessActorInfo(
            const nsCString& _name,
            const mozilla::Maybe<nsCString>& _url,
            const nsTArray<nsCString>& _observers,
            const nsTArray<nsCString>& _remoteTypes) :
        name_(_name),
        url_(_url),
        observers_(_observers),
        remoteTypes_(_remoteTypes)
    {
    }

    nsCString&
    name()
    {
        return name_;
    }
    const nsCString&
    name() const
    {
        return name_;
    }

    mozilla::Maybe<nsCString>&
    url()
    {
        return url_;
    }
    const mozilla::Maybe<nsCString>&
    url() const
    {
        return url_;
    }

    nsTArray<nsCString>&
    observers()
    {
        return observers_;
    }
    const nsTArray<nsCString>&
    observers() const
    {
        return observers_;
    }

    nsTArray<nsCString>&
    remoteTypes()
    {
        return remoteTypes_;
    }
    const nsTArray<nsCString>&
    remoteTypes() const
    {
        return remoteTypes_;
    }

private:
    nsCString name_;
    mozilla::Maybe<nsCString> url_;
    CopyableTArray<nsCString> observers_;
    CopyableTArray<nsCString> remoteTypes_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::JSProcessActorInfo>
{
    typedef mozilla::dom::JSProcessActorInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct GMPAPITags|
//
namespace mozilla {
namespace dom {
class GMPAPITags final
{
private:

public:
    MOZ_IMPLICIT GMPAPITags() :
        api_(),
        tags_()
    {
    }

    MOZ_IMPLICIT GMPAPITags(
            const nsCString& _api,
            const nsTArray<nsCString>& _tags) :
        api_(_api),
        tags_(_tags)
    {
    }

    nsCString&
    api()
    {
        return api_;
    }
    const nsCString&
    api() const
    {
        return api_;
    }

    nsTArray<nsCString>&
    tags()
    {
        return tags_;
    }
    const nsTArray<nsCString>&
    tags() const
    {
        return tags_;
    }

private:
    nsCString api_;
    CopyableTArray<nsCString> tags_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::GMPAPITags>
{
    typedef mozilla::dom::GMPAPITags paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct GMPCapabilityData|
//
namespace mozilla {
namespace dom {
class GMPCapabilityData final
{
private:
    typedef mozilla::dom::GMPAPITags GMPAPITags;

public:
    MOZ_IMPLICIT GMPCapabilityData() :
        name_(),
        version_(),
        capabilities_()
    {
    }

    MOZ_IMPLICIT GMPCapabilityData(
            const nsCString& _name,
            const nsCString& _version,
            const nsTArray<GMPAPITags>& _capabilities) :
        name_(_name),
        version_(_version),
        capabilities_(_capabilities)
    {
    }

    nsCString&
    name()
    {
        return name_;
    }
    const nsCString&
    name() const
    {
        return name_;
    }

    nsCString&
    version()
    {
        return version_;
    }
    const nsCString&
    version() const
    {
        return version_;
    }

    nsTArray<GMPAPITags>&
    capabilities()
    {
        return capabilities_;
    }
    const nsTArray<GMPAPITags>&
    capabilities() const
    {
        return capabilities_;
    }

private:
    nsCString name_;
    nsCString version_;
    CopyableTArray<GMPAPITags> capabilities_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::GMPCapabilityData>
{
    typedef mozilla::dom::GMPCapabilityData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct XPCOMInitData|
//
namespace mozilla {
namespace dom {
class XPCOMInitData final
{
private:
    typedef mozilla::dom::ClipboardCapabilities ClipboardCapabilities;
    typedef mozilla::dom::DomainPolicyClone DomainPolicyClone;
    typedef mozilla::gfx::GfxVarUpdate GfxVarUpdate;
    typedef mozilla::gfx::ContentDeviceData ContentDeviceData;
    typedef mozilla::gfx::GfxInfoFeatureStatus GfxInfoFeatureStatus;
    typedef mozilla::psm::DataStorageEntry DataStorageEntry;
    typedef mozilla::Telemetry::DynamicScalarDefinition DynamicScalarDefinition;
    typedef mozilla::dom::SystemParameterKVPair SystemParameterKVPair;

public:
    MOZ_IMPLICIT XPCOMInitData() :
        isOffline_(),
        isConnected_(),
        isLangRTL_(),
        haveBidiKeyboards_(),
        dictionaries_(),
        clipboardCaps_(),
        domainPolicy_(),
        userContentSheetURL_(),
        gfxNonDefaultVarUpdates_(),
        contentDeviceData_(),
        gfxFeatureStatus_(),
        dataStorage_(),
        appLocales_(),
        requestedLocales_(),
        dynamicScalarDefs_(),
        systemParameters_(),
        captivePortalState_()
    {
    }

    MOZ_IMPLICIT XPCOMInitData(
            const bool& _isOffline,
            const bool& _isConnected,
            const int32_t& _captivePortalState,
            const bool& _isLangRTL,
            const bool& _haveBidiKeyboards,
            const nsTArray<nsCString>& _dictionaries,
            const ClipboardCapabilities& _clipboardCaps,
            const DomainPolicyClone& _domainPolicy,
            nsIURI* _userContentSheetURL,
            const nsTArray<GfxVarUpdate>& _gfxNonDefaultVarUpdates,
            const ContentDeviceData& _contentDeviceData,
            const nsTArray<GfxInfoFeatureStatus>& _gfxFeatureStatus,
            const nsTArray<DataStorageEntry>& _dataStorage,
            const nsTArray<nsCString>& _appLocales,
            const nsTArray<nsCString>& _requestedLocales,
            const nsTArray<DynamicScalarDefinition>& _dynamicScalarDefs,
            const nsTArray<SystemParameterKVPair>& _systemParameters) :
        isOffline_(_isOffline),
        isConnected_(_isConnected),
        isLangRTL_(_isLangRTL),
        haveBidiKeyboards_(_haveBidiKeyboards),
        dictionaries_(_dictionaries),
        clipboardCaps_(_clipboardCaps),
        domainPolicy_(_domainPolicy),
        userContentSheetURL_(_userContentSheetURL),
        gfxNonDefaultVarUpdates_(_gfxNonDefaultVarUpdates),
        contentDeviceData_(_contentDeviceData),
        gfxFeatureStatus_(_gfxFeatureStatus),
        dataStorage_(_dataStorage),
        appLocales_(_appLocales),
        requestedLocales_(_requestedLocales),
        dynamicScalarDefs_(_dynamicScalarDefs),
        systemParameters_(_systemParameters),
        captivePortalState_(_captivePortalState)
    {
    }

    bool&
    isOffline()
    {
        return isOffline_;
    }
    const bool&
    isOffline() const
    {
        return isOffline_;
    }

    bool&
    isConnected()
    {
        return isConnected_;
    }
    const bool&
    isConnected() const
    {
        return isConnected_;
    }

    int32_t&
    captivePortalState()
    {
        return captivePortalState_;
    }
    const int32_t&
    captivePortalState() const
    {
        return captivePortalState_;
    }

    bool&
    isLangRTL()
    {
        return isLangRTL_;
    }
    const bool&
    isLangRTL() const
    {
        return isLangRTL_;
    }

    bool&
    haveBidiKeyboards()
    {
        return haveBidiKeyboards_;
    }
    const bool&
    haveBidiKeyboards() const
    {
        return haveBidiKeyboards_;
    }

    nsTArray<nsCString>&
    dictionaries()
    {
        return dictionaries_;
    }
    const nsTArray<nsCString>&
    dictionaries() const
    {
        return dictionaries_;
    }

    ClipboardCapabilities&
    clipboardCaps()
    {
        return clipboardCaps_;
    }
    const ClipboardCapabilities&
    clipboardCaps() const
    {
        return clipboardCaps_;
    }

    DomainPolicyClone&
    domainPolicy()
    {
        return domainPolicy_;
    }
    const DomainPolicyClone&
    domainPolicy() const
    {
        return domainPolicy_;
    }

    RefPtr<nsIURI>&
    userContentSheetURL()
    {
        return userContentSheetURL_;
    }
    nsIURI*
    userContentSheetURL() const
    {
        return userContentSheetURL_;
    }

    nsTArray<GfxVarUpdate>&
    gfxNonDefaultVarUpdates()
    {
        return gfxNonDefaultVarUpdates_;
    }
    const nsTArray<GfxVarUpdate>&
    gfxNonDefaultVarUpdates() const
    {
        return gfxNonDefaultVarUpdates_;
    }

    ContentDeviceData&
    contentDeviceData()
    {
        return contentDeviceData_;
    }
    const ContentDeviceData&
    contentDeviceData() const
    {
        return contentDeviceData_;
    }

    nsTArray<GfxInfoFeatureStatus>&
    gfxFeatureStatus()
    {
        return gfxFeatureStatus_;
    }
    const nsTArray<GfxInfoFeatureStatus>&
    gfxFeatureStatus() const
    {
        return gfxFeatureStatus_;
    }

    nsTArray<DataStorageEntry>&
    dataStorage()
    {
        return dataStorage_;
    }
    const nsTArray<DataStorageEntry>&
    dataStorage() const
    {
        return dataStorage_;
    }

    nsTArray<nsCString>&
    appLocales()
    {
        return appLocales_;
    }
    const nsTArray<nsCString>&
    appLocales() const
    {
        return appLocales_;
    }

    nsTArray<nsCString>&
    requestedLocales()
    {
        return requestedLocales_;
    }
    const nsTArray<nsCString>&
    requestedLocales() const
    {
        return requestedLocales_;
    }

    nsTArray<DynamicScalarDefinition>&
    dynamicScalarDefs()
    {
        return dynamicScalarDefs_;
    }
    const nsTArray<DynamicScalarDefinition>&
    dynamicScalarDefs() const
    {
        return dynamicScalarDefs_;
    }

    nsTArray<SystemParameterKVPair>&
    systemParameters()
    {
        return systemParameters_;
    }
    const nsTArray<SystemParameterKVPair>&
    systemParameters() const
    {
        return systemParameters_;
    }

private:
    bool isOffline_;
    bool isConnected_;
    bool isLangRTL_;
    bool haveBidiKeyboards_;
    CopyableTArray<nsCString> dictionaries_;
    ClipboardCapabilities clipboardCaps_;
    DomainPolicyClone domainPolicy_;
    RefPtr<nsIURI> userContentSheetURL_;
    CopyableTArray<GfxVarUpdate> gfxNonDefaultVarUpdates_;
    ContentDeviceData contentDeviceData_;
    CopyableTArray<GfxInfoFeatureStatus> gfxFeatureStatus_;
    CopyableTArray<DataStorageEntry> dataStorage_;
    CopyableTArray<nsCString> appLocales_;
    CopyableTArray<nsCString> requestedLocales_;
    CopyableTArray<DynamicScalarDefinition> dynamicScalarDefs_;
    CopyableTArray<SystemParameterKVPair> systemParameters_;
    int32_t captivePortalState_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::XPCOMInitData>
{
    typedef mozilla::dom::XPCOMInitData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct VisitedQueryResult|
//
namespace mozilla {
namespace dom {
class VisitedQueryResult final
{
private:

public:
    MOZ_IMPLICIT VisitedQueryResult() :
        uri_(),
        visited_()
    {
    }

    MOZ_IMPLICIT VisitedQueryResult(
            nsIURI* _uri,
            const bool& _visited) :
        uri_(_uri),
        visited_(_visited)
    {
    }

    RefPtr<nsIURI>&
    uri()
    {
        return uri_;
    }
    nsIURI*
    uri() const
    {
        return uri_;
    }

    bool&
    visited()
    {
        return visited_;
    }
    const bool&
    visited() const
    {
        return visited_;
    }

private:
    RefPtr<nsIURI> uri_;
    bool visited_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::VisitedQueryResult>
{
    typedef mozilla::dom::VisitedQueryResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct StringBundleDescriptor|
//
namespace mozilla {
namespace dom {
class StringBundleDescriptor final
{
private:
    typedef mozilla::ipc::FileDescriptor FileDescriptor;

public:
    MOZ_IMPLICIT StringBundleDescriptor() :
        bundleURL_(),
        mapFile_(),
        mapSize_()
    {
    }

    MOZ_IMPLICIT StringBundleDescriptor(
            const nsCString& _bundleURL,
            const FileDescriptor& _mapFile,
            const uint32_t& _mapSize) :
        bundleURL_(_bundleURL),
        mapFile_(_mapFile),
        mapSize_(_mapSize)
    {
    }

    nsCString&
    bundleURL()
    {
        return bundleURL_;
    }
    const nsCString&
    bundleURL() const
    {
        return bundleURL_;
    }

    FileDescriptor&
    mapFile()
    {
        return mapFile_;
    }
    const FileDescriptor&
    mapFile() const
    {
        return const_cast<FileDescriptor&>(mapFile_);
    }

    uint32_t&
    mapSize()
    {
        return mapSize_;
    }
    const uint32_t&
    mapSize() const
    {
        return mapSize_;
    }

private:
    nsCString bundleURL_;
    FileDescriptor mapFile_;
    uint32_t mapSize_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::StringBundleDescriptor>
{
    typedef mozilla::dom::StringBundleDescriptor paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct IPCURLClassifierFeature|
//
namespace mozilla {
namespace dom {
class IPCURLClassifierFeature final
{
private:

public:
    MOZ_IMPLICIT IPCURLClassifierFeature() :
        featureName_(),
        tables_(),
        exceptionHostList_()
    {
    }

    MOZ_IMPLICIT IPCURLClassifierFeature(
            const nsCString& _featureName,
            const nsTArray<nsCString>& _tables,
            const nsCString& _exceptionHostList) :
        featureName_(_featureName),
        tables_(_tables),
        exceptionHostList_(_exceptionHostList)
    {
    }

    nsCString&
    featureName()
    {
        return featureName_;
    }
    const nsCString&
    featureName() const
    {
        return featureName_;
    }

    nsTArray<nsCString>&
    tables()
    {
        return tables_;
    }
    const nsTArray<nsCString>&
    tables() const
    {
        return tables_;
    }

    nsCString&
    exceptionHostList()
    {
        return exceptionHostList_;
    }
    const nsCString&
    exceptionHostList() const
    {
        return exceptionHostList_;
    }

private:
    nsCString featureName_;
    CopyableTArray<nsCString> tables_;
    nsCString exceptionHostList_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPCURLClassifierFeature>
{
    typedef mozilla::dom::IPCURLClassifierFeature paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct NotificationEventData|
//
namespace mozilla {
namespace dom {
class NotificationEventData final
{
private:

public:
    MOZ_IMPLICIT NotificationEventData() :
        originSuffix_(),
        scope_(),
        ID_(),
        title_(),
        dir_(),
        lang_(),
        body_(),
        tag_(),
        icon_(),
        data_(),
        behavior_()
    {
    }

    MOZ_IMPLICIT NotificationEventData(
            const nsCString& _originSuffix,
            const nsCString& _scope,
            const nsString& _ID,
            const nsString& _title,
            const nsString& _dir,
            const nsString& _lang,
            const nsString& _body,
            const nsString& _tag,
            const nsString& _icon,
            const nsString& _data,
            const nsString& _behavior) :
        originSuffix_(_originSuffix),
        scope_(_scope),
        ID_(_ID),
        title_(_title),
        dir_(_dir),
        lang_(_lang),
        body_(_body),
        tag_(_tag),
        icon_(_icon),
        data_(_data),
        behavior_(_behavior)
    {
    }

    nsCString&
    originSuffix()
    {
        return originSuffix_;
    }
    const nsCString&
    originSuffix() const
    {
        return originSuffix_;
    }

    nsCString&
    scope()
    {
        return scope_;
    }
    const nsCString&
    scope() const
    {
        return scope_;
    }

    nsString&
    ID()
    {
        return ID_;
    }
    const nsString&
    ID() const
    {
        return ID_;
    }

    nsString&
    title()
    {
        return title_;
    }
    const nsString&
    title() const
    {
        return title_;
    }

    nsString&
    dir()
    {
        return dir_;
    }
    const nsString&
    dir() const
    {
        return dir_;
    }

    nsString&
    lang()
    {
        return lang_;
    }
    const nsString&
    lang() const
    {
        return lang_;
    }

    nsString&
    body()
    {
        return body_;
    }
    const nsString&
    body() const
    {
        return body_;
    }

    nsString&
    tag()
    {
        return tag_;
    }
    const nsString&
    tag() const
    {
        return tag_;
    }

    nsString&
    icon()
    {
        return icon_;
    }
    const nsString&
    icon() const
    {
        return icon_;
    }

    nsString&
    data()
    {
        return data_;
    }
    const nsString&
    data() const
    {
        return data_;
    }

    nsString&
    behavior()
    {
        return behavior_;
    }
    const nsString&
    behavior() const
    {
        return behavior_;
    }

private:
    nsCString originSuffix_;
    nsCString scope_;
    nsString ID_;
    nsString title_;
    nsString dir_;
    nsString lang_;
    nsString body_;
    nsString tag_;
    nsString icon_;
    nsString data_;
    nsString behavior_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::NotificationEventData>
{
    typedef mozilla::dom::NotificationEventData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct PostMessageData|
//
namespace mozilla {
namespace dom {
class PostMessageData final
{
private:
    typedef mozilla::dom::MaybeDiscardedBrowsingContext MaybeDiscardedBrowsingContext;

public:
    MOZ_IMPLICIT PostMessageData() :
        source_(),
        origin_(),
        targetOrigin_(),
        targetOriginURI_(),
        callerPrincipal_(),
        subjectPrincipal_(),
        callerURI_(),
        isFromPrivateWindow_(),
        scriptLocation_(),
        innerWindowId_()
    {
    }

    MOZ_IMPLICIT PostMessageData(
            const MaybeDiscardedBrowsingContext& _source,
            const nsString& _origin,
            const nsString& _targetOrigin,
            nsIURI* _targetOriginURI,
            nsIPrincipal* _callerPrincipal,
            nsIPrincipal* _subjectPrincipal,
            nsIURI* _callerURI,
            const bool& _isFromPrivateWindow,
            const nsCString& _scriptLocation,
            const uint64_t& _innerWindowId) :
        source_(_source),
        origin_(_origin),
        targetOrigin_(_targetOrigin),
        targetOriginURI_(_targetOriginURI),
        callerPrincipal_(_callerPrincipal),
        subjectPrincipal_(_subjectPrincipal),
        callerURI_(_callerURI),
        isFromPrivateWindow_(_isFromPrivateWindow),
        scriptLocation_(_scriptLocation),
        innerWindowId_(_innerWindowId)
    {
    }

    MaybeDiscardedBrowsingContext&
    source()
    {
        return source_;
    }
    const MaybeDiscardedBrowsingContext&
    source() const
    {
        return source_;
    }

    nsString&
    origin()
    {
        return origin_;
    }
    const nsString&
    origin() const
    {
        return origin_;
    }

    nsString&
    targetOrigin()
    {
        return targetOrigin_;
    }
    const nsString&
    targetOrigin() const
    {
        return targetOrigin_;
    }

    RefPtr<nsIURI>&
    targetOriginURI()
    {
        return targetOriginURI_;
    }
    nsIURI*
    targetOriginURI() const
    {
        return targetOriginURI_;
    }

    RefPtr<nsIPrincipal>&
    callerPrincipal()
    {
        return callerPrincipal_;
    }
    nsIPrincipal*
    callerPrincipal() const
    {
        return callerPrincipal_;
    }

    RefPtr<nsIPrincipal>&
    subjectPrincipal()
    {
        return subjectPrincipal_;
    }
    nsIPrincipal*
    subjectPrincipal() const
    {
        return subjectPrincipal_;
    }

    RefPtr<nsIURI>&
    callerURI()
    {
        return callerURI_;
    }
    nsIURI*
    callerURI() const
    {
        return callerURI_;
    }

    bool&
    isFromPrivateWindow()
    {
        return isFromPrivateWindow_;
    }
    const bool&
    isFromPrivateWindow() const
    {
        return isFromPrivateWindow_;
    }

    nsCString&
    scriptLocation()
    {
        return scriptLocation_;
    }
    const nsCString&
    scriptLocation() const
    {
        return scriptLocation_;
    }

    uint64_t&
    innerWindowId()
    {
        return innerWindowId_;
    }
    const uint64_t&
    innerWindowId() const
    {
        return innerWindowId_;
    }

private:
    MaybeDiscardedBrowsingContext source_;
    nsString origin_;
    nsString targetOrigin_;
    RefPtr<nsIURI> targetOriginURI_;
    RefPtr<nsIPrincipal> callerPrincipal_;
    RefPtr<nsIPrincipal> subjectPrincipal_;
    RefPtr<nsIURI> callerURI_;
    bool isFromPrivateWindow_;
    nsCString scriptLocation_;
    uint64_t innerWindowId_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::PostMessageData>
{
    typedef mozilla::dom::PostMessageData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union SyncedContextInitializer|
//
namespace mozilla {
namespace dom {
class SyncedContextInitializer final
{
public:
    enum Type {
        T__None,
        TBrowsingContextInitializer = 1,
        TWindowContextInitializer,
        T__Last = TWindowContextInitializer
    };

private:
    typedef mozilla::dom::BrowsingContextInitializer BrowsingContextInitializer;
    typedef mozilla::dom::WindowContextInitializer WindowContextInitializer;
    typedef BrowsingContextInitializer BrowsingContextInitializer__tdef;
    typedef WindowContextInitializer WindowContextInitializer__tdef;

    union Value {
        mozilla::AlignedStorage2<BrowsingContextInitializer> VBrowsingContextInitializer;
        mozilla::AlignedStorage2<WindowContextInitializer> VWindowContextInitializer;
    };

    BrowsingContextInitializer*
    ptr_BrowsingContextInitializer()
    {
        return ((mValue).VBrowsingContextInitializer).addr();
    }
    const BrowsingContextInitializer*
    constptr_BrowsingContextInitializer() const
    {
        return ((mValue).VBrowsingContextInitializer).addr();
    }
    WindowContextInitializer*
    ptr_WindowContextInitializer()
    {
        return ((mValue).VWindowContextInitializer).addr();
    }
    const WindowContextInitializer*
    constptr_WindowContextInitializer() const
    {
        return ((mValue).VWindowContextInitializer).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT SyncedContextInitializer() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT SyncedContextInitializer(const BrowsingContextInitializer& aOther);

    MOZ_IMPLICIT SyncedContextInitializer(BrowsingContextInitializer&& aOther);

    MOZ_IMPLICIT SyncedContextInitializer(const WindowContextInitializer& aOther);

    MOZ_IMPLICIT SyncedContextInitializer(WindowContextInitializer&& aOther);

    MOZ_IMPLICIT SyncedContextInitializer(const SyncedContextInitializer& aOther);

    MOZ_IMPLICIT SyncedContextInitializer(SyncedContextInitializer&& aOther);

    ~SyncedContextInitializer();

    Type
    type() const
    {
        return mType;
    }

    SyncedContextInitializer&
    operator=(const BrowsingContextInitializer& aRhs);

    SyncedContextInitializer&
    operator=(BrowsingContextInitializer&& aRhs);

    SyncedContextInitializer&
    operator=(const WindowContextInitializer& aRhs);

    SyncedContextInitializer&
    operator=(WindowContextInitializer&& aRhs);

    SyncedContextInitializer&
    operator=(const SyncedContextInitializer& aRhs);

    SyncedContextInitializer&
    operator=(SyncedContextInitializer&& aRhs);

    BrowsingContextInitializer&
    get_BrowsingContextInitializer()
    {
        AssertSanity(TBrowsingContextInitializer);
        return (*(ptr_BrowsingContextInitializer()));
    }
    const BrowsingContextInitializer&
    get_BrowsingContextInitializer() const
    {
        AssertSanity(TBrowsingContextInitializer);
        return (*(constptr_BrowsingContextInitializer()));
    }
    operator BrowsingContextInitializer&()
    {
        return get_BrowsingContextInitializer();
    }
    operator const BrowsingContextInitializer&() const
    {
        return get_BrowsingContextInitializer();
    }

    WindowContextInitializer&
    get_WindowContextInitializer()
    {
        AssertSanity(TWindowContextInitializer);
        return (*(ptr_WindowContextInitializer()));
    }
    const WindowContextInitializer&
    get_WindowContextInitializer() const
    {
        AssertSanity(TWindowContextInitializer);
        return (*(constptr_WindowContextInitializer()));
    }
    operator WindowContextInitializer&()
    {
        return get_WindowContextInitializer();
    }
    operator const WindowContextInitializer&() const
    {
        return get_WindowContextInitializer();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::SyncedContextInitializer>
{
    typedef mozilla::dom::SyncedContextInitializer paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union BlobURLDataRequestResult|
//
namespace mozilla {
namespace dom {
class BlobURLDataRequestResult final
{
public:
    enum Type {
        T__None,
        TIPCBlob = 1,
        Tnsresult,
        T__Last = Tnsresult
    };

private:
    typedef mozilla::dom::IPCBlob IPCBlob;
    typedef IPCBlob IPCBlob__tdef;
    typedef nsresult nsresult__tdef;

    union Value {
        mozilla::AlignedStorage2<IPCBlob> VIPCBlob;
        mozilla::AlignedStorage2<nsresult> Vnsresult;
    };

    IPCBlob*
    ptr_IPCBlob()
    {
        return ((mValue).VIPCBlob).addr();
    }
    const IPCBlob*
    constptr_IPCBlob() const
    {
        return ((mValue).VIPCBlob).addr();
    }
    nsresult*
    ptr_nsresult()
    {
        return ((mValue).Vnsresult).addr();
    }
    const nsresult*
    constptr_nsresult() const
    {
        return ((mValue).Vnsresult).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT BlobURLDataRequestResult() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT BlobURLDataRequestResult(const IPCBlob& aOther);

    MOZ_IMPLICIT BlobURLDataRequestResult(IPCBlob&& aOther);

    MOZ_IMPLICIT BlobURLDataRequestResult(const nsresult& aOther);

    MOZ_IMPLICIT BlobURLDataRequestResult(nsresult&& aOther);

    MOZ_IMPLICIT BlobURLDataRequestResult(const BlobURLDataRequestResult& aOther);

    MOZ_IMPLICIT BlobURLDataRequestResult(BlobURLDataRequestResult&& aOther);

    ~BlobURLDataRequestResult();

    Type
    type() const
    {
        return mType;
    }

    BlobURLDataRequestResult&
    operator=(const IPCBlob& aRhs);

    BlobURLDataRequestResult&
    operator=(IPCBlob&& aRhs);

    BlobURLDataRequestResult&
    operator=(const nsresult& aRhs);

    BlobURLDataRequestResult&
    operator=(nsresult&& aRhs);

    BlobURLDataRequestResult&
    operator=(const BlobURLDataRequestResult& aRhs);

    BlobURLDataRequestResult&
    operator=(BlobURLDataRequestResult&& aRhs);

    IPCBlob&
    get_IPCBlob()
    {
        AssertSanity(TIPCBlob);
        return (*(ptr_IPCBlob()));
    }
    const IPCBlob&
    get_IPCBlob() const
    {
        AssertSanity(TIPCBlob);
        return (*(constptr_IPCBlob()));
    }
    operator IPCBlob&()
    {
        return get_IPCBlob();
    }
    operator const IPCBlob&() const
    {
        return get_IPCBlob();
    }

    nsresult&
    get_nsresult()
    {
        AssertSanity(Tnsresult);
        return (*(ptr_nsresult()));
    }
    const nsresult&
    get_nsresult() const
    {
        AssertSanity(Tnsresult);
        return (*(constptr_nsresult()));
    }
    operator nsresult&()
    {
        return get_nsresult();
    }
    operator const nsresult&() const
    {
        return get_nsresult();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::BlobURLDataRequestResult>
{
    typedef mozilla::dom::BlobURLDataRequestResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace dom {
class PContentParent;
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
class PContentChild;
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Code common to PContentChild and PContentParent
//
namespace mozilla {
namespace dom {
namespace PContent {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::dom::PContentParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::dom::PContentChild>* aChild);

enum MessageType {
    PContentStart = PContentMsgStart << 16,
    Msg_ConstructPopupBrowser__ID,
    Msg_CloneDocumentTreeInto__ID,
    Msg_ConstructBrowser__ID,
    Msg_PFileDescriptorSetConstructor__ID,
    Reply_PFileDescriptorSetConstructor__ID,
    Msg_PWebBrowserPersistDocumentConstructor__ID,
    Reply_PWebBrowserPersistDocumentConstructor__ID,
    Msg_RawMessage__ID,
    Msg_InitGMPService__ID,
    Msg_InitProcessHangMonitor__ID,
    Msg_InitProfiler__ID,
    Msg_InitRendering__ID,
    Msg_ReinitRendering__ID,
    Msg_NetworkLinkTypeChange__ID,
    Msg_ReinitRenderingForDeviceReset__ID,
    Msg_SetProcessSandbox__ID,
    Msg_RequestMemoryReport__ID,
    Reply_RequestMemoryReport__ID,
    Msg_RequestPerformanceMetrics__ID,
    Msg_GetUntrustedModulesData__ID,
    Reply_GetUntrustedModulesData__ID,
    Msg_BidiKeyboardNotify__ID,
    Msg_PCycleCollectWithLogsConstructor__ID,
    Reply_PCycleCollectWithLogsConstructor__ID,
    Msg_PTestShellConstructor__ID,
    Reply_PTestShellConstructor__ID,
    Msg_PScriptCacheConstructor__ID,
    Reply_PScriptCacheConstructor__ID,
    Msg_RegisterChrome__ID,
    Msg_RegisterChromeItem__ID,
    Msg_ClearImageCache__ID,
    Msg_ClearStyleSheetCache__ID,
    Msg_SetOffline__ID,
    Msg_SetConnectivity__ID,
    Msg_SetCaptivePortalState__ID,
    Msg_NotifyVisited__ID,
    Msg_ThemeChanged__ID,
    Msg_UpdateSystemParameters__ID,
    Msg_PreferenceUpdate__ID,
    Msg_VarUpdate__ID,
    Msg_UpdatePerfStatsCollectionMask__ID,
    Msg_CollectPerfStatsJSON__ID,
    Reply_CollectPerfStatsJSON__ID,
    Msg_DataStoragePut__ID,
    Msg_DataStorageRemove__ID,
    Msg_DataStorageClear__ID,
    Msg_NotifyAlertsObserver__ID,
    Msg_GeolocationUpdate__ID,
    Msg_GeolocationError__ID,
    Msg_UpdateDictionaryList__ID,
    Msg_UpdateFontList__ID,
    Msg_RebuildFontList__ID,
    Msg_FontListChanged__ID,
    Msg_UpdateAppLocales__ID,
    Msg_UpdateRequestedLocales__ID,
    Msg_RegisterStringBundles__ID,
    Msg_UpdateSharedData__ID,
    Msg_AddPermission__ID,
    Msg_RemoveAllPermissions__ID,
    Msg_FlushMemory__ID,
    Msg_ApplicationBackground__ID,
    Msg_ApplicationForeground__ID,
    Msg_GarbageCollect__ID,
    Msg_CycleCollect__ID,
    Msg_UnlinkGhosts__ID,
    Msg_ActivateA11y__ID,
    Msg_ShutdownA11y__ID,
    Msg_AppInfo__ID,
    Msg_RemoteType__ID,
    Msg_InitServiceWorkers__ID,
    Msg_InitBlobURLs__ID,
    Msg_InitJSActorInfos__ID,
    Msg_UnregisterJSWindowActor__ID,
    Msg_UnregisterJSProcessActor__ID,
    Msg_SetXPCOMProcessAttributes__ID,
    Msg_LastPrivateDocShellDestroyed__ID,
    Msg_NotifyProcessPriorityChanged__ID,
    Msg_MinimizeMemoryUsage__ID,
    Msg_LoadAndRegisterSheet__ID,
    Msg_UnregisterSheet__ID,
    Msg_NotifyIdleObserver__ID,
    Msg_InvokeDragSession__ID,
    Msg_EndDragSession__ID,
    Msg_DomainSetChanged__ID,
    Msg_Shutdown__ID,
    Msg_LoadProcessScript__ID,
    Msg_UpdateWindow__ID,
    Msg_NotifyPresentationReceiverLaunched__ID,
    Msg_NotifyPresentationReceiverCleanUp__ID,
    Msg_NotifyEmptyHTTPCache__ID,
    Msg_Push__ID,
    Msg_PushWithData__ID,
    Msg_PushSubscriptionChange__ID,
    Msg_GetFilesResponse__ID,
    Msg_BlobURLRegistration__ID,
    Msg_BlobURLUnregistration__ID,
    Msg_GMPsChanged__ID,
    Msg_PParentToChildStreamConstructor__ID,
    Reply_PParentToChildStreamConstructor__ID,
    Msg_ProvideAnonymousTemporaryFile__ID,
    Msg_SetPermissionsWithKey__ID,
    Msg_RefreshScreens__ID,
    Msg_PRemoteLazyInputStreamConstructor__ID,
    Reply_PRemoteLazyInputStreamConstructor__ID,
    Msg_SetPluginList__ID,
    Msg_ShareCodeCoverageMutex__ID,
    Msg_FlushCodeCoverageCounters__ID,
    Reply_FlushCodeCoverageCounters__ID,
    Msg_SetInputEventQueueEnabled__ID,
    Msg_FlushInputEventQueue__ID,
    Msg_ResumeInputEventQueue__ID,
    Msg_SuspendInputEventQueue__ID,
    Msg_AddDynamicScalars__ID,
    Msg_CrossProcessRedirect__ID,
    Reply_CrossProcessRedirect__ID,
    Msg_StartDelayedAutoplayMediaComponents__ID,
    Msg_UpdateMediaControlAction__ID,
    Msg_RegisterBrowsingContextGroup__ID,
    Msg_LoadURI__ID,
    Reply_LoadURI__ID,
    Msg_InternalLoad__ID,
    Msg_DisplayLoadError__ID,
    Msg_GoBack__ID,
    Msg_GoForward__ID,
    Msg_GoToIndex__ID,
    Msg_Reload__ID,
    Msg_StopLoad__ID,
    Msg_OnAllowAccessFor__ID,
    Msg_OnContentBlockingDecision__ID,
    Msg_AbortOrientationPendingPromises__ID,
    Msg_HistoryCommitIndexAndLength__ID,
    Msg_DispatchLocationChangeEvent__ID,
    Msg_DispatchBeforeUnloadToSubtree__ID,
    Reply_DispatchBeforeUnloadToSubtree__ID,
    Msg_UpdateMediaCodecsSupported__ID,
    Msg_SessionHistoryUpdate__ID,
    Msg_SynchronizeLayoutHistoryState__ID,
    Msg_SessionHistoryEntryTitle__ID,
    Msg_SessionHistoryEntryScrollRestorationIsManual__ID,
    Msg_SessionHistoryEntryCacheKey__ID,
    Msg_SessionHistoryEntryStoreWindowNameInContiguousEntries__ID,
    Msg_GetLoadingSessionHistoryInfoFromParent__ID,
    Reply_GetLoadingSessionHistoryInfoFromParent__ID,
    Msg_InitBackground__ID,
    Msg_CreateGMPService__ID,
    Msg_InitStreamFilter__ID,
    Reply_InitStreamFilter__ID,
    Msg_LoadPlugin__ID,
    Reply_LoadPlugin__ID,
    Msg_ConnectPluginBridge__ID,
    Reply_ConnectPluginBridge__ID,
    Msg_PRemoteSpellcheckEngineConstructor__ID,
    Reply_PRemoteSpellcheckEngineConstructor__ID,
    Msg_InitCrashReporter__ID,
    Msg_IsSecureURI__ID,
    Reply_IsSecureURI__ID,
    Msg_AccumulateMixedContentHSTS__ID,
    Msg_PHalConstructor__ID,
    Reply_PHalConstructor__ID,
    Msg_PHeapSnapshotTempFileHelperConstructor__ID,
    Reply_PHeapSnapshotTempFileHelperConstructor__ID,
    Msg_PNeckoConstructor__ID,
    Reply_PNeckoConstructor__ID,
    Msg_PPrintingConstructor__ID,
    Reply_PPrintingConstructor__ID,
    Msg_PChildToParentStreamConstructor__ID,
    Reply_PChildToParentStreamConstructor__ID,
    Msg_PSpeechSynthesisConstructor__ID,
    Reply_PSpeechSynthesisConstructor__ID,
    Msg_PMediaConstructor__ID,
    Reply_PMediaConstructor__ID,
    Msg_PWebrtcGlobalConstructor__ID,
    Reply_PWebrtcGlobalConstructor__ID,
    Msg_PPresentationConstructor__ID,
    Reply_PPresentationConstructor__ID,
    Msg_CreateAudioIPCConnection__ID,
    Reply_CreateAudioIPCConnection__ID,
    Msg_PURLClassifierConstructor__ID,
    Reply_PURLClassifierConstructor__ID,
    Msg_PURLClassifierLocalConstructor__ID,
    Reply_PURLClassifierLocalConstructor__ID,
    Msg_PLoginReputationConstructor__ID,
    Reply_PLoginReputationConstructor__ID,
    Msg_PSessionStorageObserverConstructor__ID,
    Reply_PSessionStorageObserverConstructor__ID,
    Msg_PBenchmarkStorageConstructor__ID,
    Reply_PBenchmarkStorageConstructor__ID,
    Msg_StartVisitedQueries__ID,
    Msg_SetURITitle__ID,
    Msg_LoadURIExternal__ID,
    Msg_ExtProtocolChannelConnectParent__ID,
    Msg_GetGfxVars__ID,
    Reply_GetGfxVars__ID,
    Msg_SyncMessage__ID,
    Reply_SyncMessage__ID,
    Msg_ShowAlert__ID,
    Msg_CloseAlert__ID,
    Msg_DisableNotifications__ID,
    Msg_OpenNotificationSettings__ID,
    Msg_AddSecurityState__ID,
    Msg_NotificationEvent__ID,
    Msg_PExternalHelperAppConstructor__ID,
    Reply_PExternalHelperAppConstructor__ID,
    Msg_PHandlerServiceConstructor__ID,
    Reply_PHandlerServiceConstructor__ID,
    Msg_AddGeolocationListener__ID,
    Msg_RemoveGeolocationListener__ID,
    Msg_SetGeolocationHigherAccuracy__ID,
    Msg_ConsoleMessage__ID,
    Msg_ScriptErrorWithStack__ID,
    Msg_SetClipboard__ID,
    Msg_GetClipboard__ID,
    Reply_GetClipboard__ID,
    Msg_GetExternalClipboardFormats__ID,
    Reply_GetExternalClipboardFormats__ID,
    Msg_EmptyClipboard__ID,
    Msg_ClipboardHasType__ID,
    Reply_ClipboardHasType__ID,
    Msg_PlaySound__ID,
    Msg_Beep__ID,
    Msg_PlayEventSound__ID,
    Msg_GetIconForExtension__ID,
    Reply_GetIconForExtension__ID,
    Msg_PrivateDocShellsExist__ID,
    Msg_FirstIdle__ID,
    Msg_DeviceReset__ID,
    Msg_CopyFavicon__ID,
    Msg_RecordingDeviceEvents__ID,
    Msg_GraphicsError__ID,
    Msg_BeginDriverCrashGuard__ID,
    Reply_BeginDriverCrashGuard__ID,
    Msg_EndDriverCrashGuard__ID,
    Reply_EndDriverCrashGuard__ID,
    Msg_AddIdleObserver__ID,
    Msg_RemoveIdleObserver__ID,
    Msg_BackUpXResources__ID,
    Msg_RequestAnonymousTemporaryFile__ID,
    Msg_POfflineCacheUpdateConstructor__ID,
    Reply_POfflineCacheUpdateConstructor__ID,
    Msg_SetOfflinePermission__ID,
    Msg_FinishShutdown__ID,
    Msg_UpdateDropEffect__ID,
    Msg_PContentPermissionRequestConstructor__ID,
    Reply_PContentPermissionRequestConstructor__ID,
    Msg_ShutdownProfile__ID,
    Msg_GetGraphicsDeviceInitData__ID,
    Reply_GetGraphicsDeviceInitData__ID,
    Msg_GetOutputColorProfileData__ID,
    Reply_GetOutputColorProfileData__ID,
    Msg_GetFontListShmBlock__ID,
    Reply_GetFontListShmBlock__ID,
    Msg_InitializeFamily__ID,
    Reply_InitializeFamily__ID,
    Msg_SetCharacterMap__ID,
    Msg_SetupFamilyCharMap__ID,
    Msg_InitOtherFamilyNames__ID,
    Reply_InitOtherFamilyNames__ID,
    Msg_StartCmapLoading__ID,
    Msg_GetHyphDict__ID,
    Reply_GetHyphDict__ID,
    Msg_CreateWindow__ID,
    Reply_CreateWindow__ID,
    Msg_CreateWindowInDifferentProcess__ID,
    Msg_UngrabPointer__ID,
    Reply_UngrabPointer__ID,
    Msg_RemovePermission__ID,
    Reply_RemovePermission__ID,
    Msg_NotifyBenchmarkResult__ID,
    Msg_NotifyPushObservers__ID,
    Msg_NotifyPushObserversWithData__ID,
    Msg_NotifyPushSubscriptionChangeObservers__ID,
    Msg_GetFilesRequest__ID,
    Msg_DeleteGetFilesRequest__ID,
    Msg_StoreAndBroadcastBlobURLRegistration__ID,
    Msg_UnstoreAndBroadcastBlobURLUnregistration__ID,
    Msg_AccumulateChildHistograms__ID,
    Msg_AccumulateChildKeyedHistograms__ID,
    Msg_UpdateChildScalars__ID,
    Msg_UpdateChildKeyedScalars__ID,
    Msg_RecordChildEvents__ID,
    Msg_RecordDiscardedData__ID,
    Msg_GetA11yContentId__ID,
    Reply_GetA11yContentId__ID,
    Msg_A11yHandlerControl__ID,
    Msg_AddMemoryReport__ID,
    Msg_MaybeReloadPlugins__ID,
    Msg_BHRThreadHang__ID,
    Msg_AddPerformanceMetrics__ID,
    Msg_AddCertException__ID,
    Reply_AddCertException__ID,
    Msg_AutomaticStorageAccessPermissionCanBeGranted__ID,
    Reply_AutomaticStorageAccessPermissionCanBeGranted__ID,
    Msg_StorageAccessPermissionGrantedForOrigin__ID,
    Reply_StorageAccessPermissionGrantedForOrigin__ID,
    Msg_CompleteAllowAccessFor__ID,
    Reply_CompleteAllowAccessFor__ID,
    Msg_StoreUserInteractionAsPermission__ID,
    Msg_NotifyMediaPlaybackChanged__ID,
    Msg_NotifyMediaAudibleChanged__ID,
    Msg_NotifyPictureInPictureModeChanged__ID,
    Msg_NotifyMediaSessionUpdated__ID,
    Msg_NotifyUpdateMediaMetadata__ID,
    Msg_NotifyMediaSessionPlaybackStateChanged__ID,
    Msg_NotifyMediaSessionSupportedActionChanged__ID,
    Msg_NotifyMediaFullScreenState__ID,
    Msg_NotifyPositionStateChanged__ID,
    Msg_GetModulesTrust__ID,
    Reply_GetModulesTrust__ID,
    Msg_ReportServiceWorkerShutdownProgress__ID,
    Msg_AbortOtherOrientationPendingPromises__ID,
    Msg_HistoryReload__ID,
    Msg_NotifyOnHistoryReload__ID,
    Reply_NotifyOnHistoryReload__ID,
    Msg_HistoryCommit__ID,
    Msg_HistoryGo__ID,
    Reply_HistoryGo__ID,
    Msg_BlobURLDataRequest__ID,
    Reply_BlobURLDataRequest__ID,
    Msg_SetActiveSessionHistoryEntry__ID,
    Msg_ReplaceActiveSessionHistoryEntry__ID,
    Msg_RemoveDynEntriesFromActiveSessionHistoryEntry__ID,
    Msg_RemoveFromSessionHistory__ID,
    Msg_ScriptError__ID,
    Msg_ReportFrameTimingData__ID,
    Msg_CommitBrowsingContextTransaction__ID,
    Msg_AsyncMessage__ID,
    Msg_NotifyPushSubscriptionModifiedObservers__ID,
    Msg_PushError__ID,
    Msg_CreateBrowsingContext__ID,
    Msg_DiscardBrowsingContext__ID,
    Reply_DiscardBrowsingContext__ID,
    Msg_AdjustWindowFocus__ID,
    Msg_WindowClose__ID,
    Msg_WindowFocus__ID,
    Msg_WindowBlur__ID,
    Msg_RaiseWindow__ID,
    Msg_ClearFocus__ID,
    Msg_SetFocusedBrowsingContext__ID,
    Msg_SetActiveBrowsingContext__ID,
    Msg_UnsetActiveBrowsingContext__ID,
    Msg_SetFocusedElement__ID,
    Msg_FinalizeFocusOuter__ID,
    Msg_InsertNewFocusActionId__ID,
    Msg_BlurToParent__ID,
    Msg_BlurToChild__ID,
    Msg_SetupFocusedAndActive__ID,
    Msg_ReviseActiveBrowsingContext__ID,
    Msg_MaybeExitFullscreen__ID,
    Msg_WindowPostMessage__ID,
    Msg_CommitWindowContextTransaction__ID,
    Msg_CreateWindowContext__ID,
    Msg_DiscardWindowContext__ID,
    Reply_DiscardWindowContext__ID,
    Msg_FOGData__ID,
    Msg_FlushFOGData__ID,
    Reply_FlushFOGData__ID,
    Msg_SetContainerFeaturePolicy__ID,
    PContentEnd
};

IPC::Message*
Msg_ConstructPopupBrowser(int32_t routingId);

IPC::Message*
Msg_CloneDocumentTreeInto(int32_t routingId);

IPC::Message*
Msg_ConstructBrowser(int32_t routingId);

IPC::Message*
Msg_PFileDescriptorSetConstructor(int32_t routingId);
IPC::Message*
Reply_PFileDescriptorSetConstructor(int32_t routingId);

IPC::Message*
Msg_PWebBrowserPersistDocumentConstructor(int32_t routingId);
IPC::Message*
Reply_PWebBrowserPersistDocumentConstructor(int32_t routingId);

IPC::Message*
Msg_RawMessage(int32_t routingId);

IPC::Message*
Msg_InitGMPService(int32_t routingId);

IPC::Message*
Msg_InitProcessHangMonitor(int32_t routingId);

IPC::Message*
Msg_InitProfiler(int32_t routingId);

IPC::Message*
Msg_InitRendering(int32_t routingId);

IPC::Message*
Msg_ReinitRendering(int32_t routingId);

IPC::Message*
Msg_NetworkLinkTypeChange(int32_t routingId);

IPC::Message*
Msg_ReinitRenderingForDeviceReset(int32_t routingId);

IPC::Message*
Msg_SetProcessSandbox(int32_t routingId);

IPC::Message*
Msg_RequestMemoryReport(int32_t routingId);
IPC::Message*
Reply_RequestMemoryReport(int32_t routingId);

IPC::Message*
Msg_RequestPerformanceMetrics(int32_t routingId);

IPC::Message*
Msg_GetUntrustedModulesData(int32_t routingId);
IPC::Message*
Reply_GetUntrustedModulesData(int32_t routingId);

IPC::Message*
Msg_BidiKeyboardNotify(int32_t routingId);

IPC::Message*
Msg_PCycleCollectWithLogsConstructor(int32_t routingId);
IPC::Message*
Reply_PCycleCollectWithLogsConstructor(int32_t routingId);

IPC::Message*
Msg_PTestShellConstructor(int32_t routingId);
IPC::Message*
Reply_PTestShellConstructor(int32_t routingId);

IPC::Message*
Msg_PScriptCacheConstructor(int32_t routingId);
IPC::Message*
Reply_PScriptCacheConstructor(int32_t routingId);

IPC::Message*
Msg_RegisterChrome(int32_t routingId);

IPC::Message*
Msg_RegisterChromeItem(int32_t routingId);

IPC::Message*
Msg_ClearImageCache(int32_t routingId);

IPC::Message*
Msg_ClearStyleSheetCache(int32_t routingId);

IPC::Message*
Msg_SetOffline(int32_t routingId);

IPC::Message*
Msg_SetConnectivity(int32_t routingId);

IPC::Message*
Msg_SetCaptivePortalState(int32_t routingId);

IPC::Message*
Msg_NotifyVisited(int32_t routingId);

IPC::Message*
Msg_ThemeChanged(int32_t routingId);

IPC::Message*
Msg_UpdateSystemParameters(int32_t routingId);

IPC::Message*
Msg_PreferenceUpdate(int32_t routingId);

IPC::Message*
Msg_VarUpdate(int32_t routingId);

IPC::Message*
Msg_UpdatePerfStatsCollectionMask(int32_t routingId);

IPC::Message*
Msg_CollectPerfStatsJSON(int32_t routingId);
IPC::Message*
Reply_CollectPerfStatsJSON(int32_t routingId);

IPC::Message*
Msg_DataStoragePut(int32_t routingId);

IPC::Message*
Msg_DataStorageRemove(int32_t routingId);

IPC::Message*
Msg_DataStorageClear(int32_t routingId);

IPC::Message*
Msg_NotifyAlertsObserver(int32_t routingId);

IPC::Message*
Msg_GeolocationUpdate(int32_t routingId);

IPC::Message*
Msg_GeolocationError(int32_t routingId);

IPC::Message*
Msg_UpdateDictionaryList(int32_t routingId);

IPC::Message*
Msg_UpdateFontList(int32_t routingId);

IPC::Message*
Msg_RebuildFontList(int32_t routingId);

IPC::Message*
Msg_FontListChanged(int32_t routingId);

IPC::Message*
Msg_UpdateAppLocales(int32_t routingId);

IPC::Message*
Msg_UpdateRequestedLocales(int32_t routingId);

IPC::Message*
Msg_RegisterStringBundles(int32_t routingId);

IPC::Message*
Msg_UpdateSharedData(int32_t routingId);

IPC::Message*
Msg_AddPermission(int32_t routingId);

IPC::Message*
Msg_RemoveAllPermissions(int32_t routingId);

IPC::Message*
Msg_FlushMemory(int32_t routingId);

IPC::Message*
Msg_ApplicationBackground(int32_t routingId);

IPC::Message*
Msg_ApplicationForeground(int32_t routingId);

IPC::Message*
Msg_GarbageCollect(int32_t routingId);

IPC::Message*
Msg_CycleCollect(int32_t routingId);

IPC::Message*
Msg_UnlinkGhosts(int32_t routingId);

IPC::Message*
Msg_ActivateA11y(int32_t routingId);

IPC::Message*
Msg_ShutdownA11y(int32_t routingId);

IPC::Message*
Msg_AppInfo(int32_t routingId);

IPC::Message*
Msg_RemoteType(int32_t routingId);

IPC::Message*
Msg_InitServiceWorkers(int32_t routingId);

IPC::Message*
Msg_InitBlobURLs(int32_t routingId);

IPC::Message*
Msg_InitJSActorInfos(int32_t routingId);

IPC::Message*
Msg_UnregisterJSWindowActor(int32_t routingId);

IPC::Message*
Msg_UnregisterJSProcessActor(int32_t routingId);

IPC::Message*
Msg_SetXPCOMProcessAttributes(int32_t routingId);

IPC::Message*
Msg_LastPrivateDocShellDestroyed(int32_t routingId);

IPC::Message*
Msg_NotifyProcessPriorityChanged(int32_t routingId);

IPC::Message*
Msg_MinimizeMemoryUsage(int32_t routingId);

IPC::Message*
Msg_LoadAndRegisterSheet(int32_t routingId);

IPC::Message*
Msg_UnregisterSheet(int32_t routingId);

IPC::Message*
Msg_NotifyIdleObserver(int32_t routingId);

IPC::Message*
Msg_InvokeDragSession(int32_t routingId);

IPC::Message*
Msg_EndDragSession(int32_t routingId);

IPC::Message*
Msg_DomainSetChanged(int32_t routingId);

IPC::Message*
Msg_Shutdown(int32_t routingId);

IPC::Message*
Msg_LoadProcessScript(int32_t routingId);

IPC::Message*
Msg_UpdateWindow(int32_t routingId);

IPC::Message*
Msg_NotifyPresentationReceiverLaunched(int32_t routingId);

IPC::Message*
Msg_NotifyPresentationReceiverCleanUp(int32_t routingId);

IPC::Message*
Msg_NotifyEmptyHTTPCache(int32_t routingId);

IPC::Message*
Msg_Push(int32_t routingId);

IPC::Message*
Msg_PushWithData(int32_t routingId);

IPC::Message*
Msg_PushSubscriptionChange(int32_t routingId);

IPC::Message*
Msg_GetFilesResponse(int32_t routingId);

IPC::Message*
Msg_BlobURLRegistration(int32_t routingId);

IPC::Message*
Msg_BlobURLUnregistration(int32_t routingId);

IPC::Message*
Msg_GMPsChanged(int32_t routingId);

IPC::Message*
Msg_PParentToChildStreamConstructor(int32_t routingId);
IPC::Message*
Reply_PParentToChildStreamConstructor(int32_t routingId);

IPC::Message*
Msg_ProvideAnonymousTemporaryFile(int32_t routingId);

IPC::Message*
Msg_SetPermissionsWithKey(int32_t routingId);

IPC::Message*
Msg_RefreshScreens(int32_t routingId);

IPC::Message*
Msg_PRemoteLazyInputStreamConstructor(int32_t routingId);
IPC::Message*
Reply_PRemoteLazyInputStreamConstructor(int32_t routingId);

IPC::Message*
Msg_SetPluginList(int32_t routingId);

IPC::Message*
Msg_ShareCodeCoverageMutex(int32_t routingId);

IPC::Message*
Msg_FlushCodeCoverageCounters(int32_t routingId);
IPC::Message*
Reply_FlushCodeCoverageCounters(int32_t routingId);

IPC::Message*
Msg_SetInputEventQueueEnabled(int32_t routingId);

IPC::Message*
Msg_FlushInputEventQueue(int32_t routingId);

IPC::Message*
Msg_ResumeInputEventQueue(int32_t routingId);

IPC::Message*
Msg_SuspendInputEventQueue(int32_t routingId);

IPC::Message*
Msg_AddDynamicScalars(int32_t routingId);

IPC::Message*
Msg_CrossProcessRedirect(int32_t routingId);
IPC::Message*
Reply_CrossProcessRedirect(int32_t routingId);

IPC::Message*
Msg_StartDelayedAutoplayMediaComponents(int32_t routingId);

IPC::Message*
Msg_UpdateMediaControlAction(int32_t routingId);

IPC::Message*
Msg_RegisterBrowsingContextGroup(int32_t routingId);

IPC::Message*
Msg_LoadURI(int32_t routingId);
IPC::Message*
Reply_LoadURI(int32_t routingId);

IPC::Message*
Msg_InternalLoad(int32_t routingId);

IPC::Message*
Msg_DisplayLoadError(int32_t routingId);

IPC::Message*
Msg_GoBack(int32_t routingId);

IPC::Message*
Msg_GoForward(int32_t routingId);

IPC::Message*
Msg_GoToIndex(int32_t routingId);

IPC::Message*
Msg_Reload(int32_t routingId);

IPC::Message*
Msg_StopLoad(int32_t routingId);

IPC::Message*
Msg_OnAllowAccessFor(int32_t routingId);

IPC::Message*
Msg_OnContentBlockingDecision(int32_t routingId);

IPC::Message*
Msg_AbortOrientationPendingPromises(int32_t routingId);

IPC::Message*
Msg_HistoryCommitIndexAndLength(int32_t routingId);

IPC::Message*
Msg_DispatchLocationChangeEvent(int32_t routingId);

IPC::Message*
Msg_DispatchBeforeUnloadToSubtree(int32_t routingId);
IPC::Message*
Reply_DispatchBeforeUnloadToSubtree(int32_t routingId);

IPC::Message*
Msg_UpdateMediaCodecsSupported(int32_t routingId);

IPC::Message*
Msg_SessionHistoryUpdate(int32_t routingId);

IPC::Message*
Msg_SynchronizeLayoutHistoryState(int32_t routingId);

IPC::Message*
Msg_SessionHistoryEntryTitle(int32_t routingId);

IPC::Message*
Msg_SessionHistoryEntryScrollRestorationIsManual(int32_t routingId);

IPC::Message*
Msg_SessionHistoryEntryCacheKey(int32_t routingId);

IPC::Message*
Msg_SessionHistoryEntryStoreWindowNameInContiguousEntries(int32_t routingId);

IPC::Message*
Msg_GetLoadingSessionHistoryInfoFromParent(int32_t routingId);
IPC::Message*
Reply_GetLoadingSessionHistoryInfoFromParent(int32_t routingId);

IPC::Message*
Msg_InitBackground(int32_t routingId);

IPC::Message*
Msg_CreateGMPService(int32_t routingId);

IPC::Message*
Msg_InitStreamFilter(int32_t routingId);
IPC::Message*
Reply_InitStreamFilter(int32_t routingId);

IPC::Message*
Msg_LoadPlugin(int32_t routingId);
IPC::Message*
Reply_LoadPlugin(int32_t routingId);

IPC::Message*
Msg_ConnectPluginBridge(int32_t routingId);
IPC::Message*
Reply_ConnectPluginBridge(int32_t routingId);

IPC::Message*
Msg_PRemoteSpellcheckEngineConstructor(int32_t routingId);
IPC::Message*
Reply_PRemoteSpellcheckEngineConstructor(int32_t routingId);

IPC::Message*
Msg_InitCrashReporter(int32_t routingId);

IPC::Message*
Msg_IsSecureURI(int32_t routingId);
IPC::Message*
Reply_IsSecureURI(int32_t routingId);

IPC::Message*
Msg_AccumulateMixedContentHSTS(int32_t routingId);

IPC::Message*
Msg_PHalConstructor(int32_t routingId);
IPC::Message*
Reply_PHalConstructor(int32_t routingId);

IPC::Message*
Msg_PHeapSnapshotTempFileHelperConstructor(int32_t routingId);
IPC::Message*
Reply_PHeapSnapshotTempFileHelperConstructor(int32_t routingId);

IPC::Message*
Msg_PNeckoConstructor(int32_t routingId);
IPC::Message*
Reply_PNeckoConstructor(int32_t routingId);

IPC::Message*
Msg_PPrintingConstructor(int32_t routingId);
IPC::Message*
Reply_PPrintingConstructor(int32_t routingId);

IPC::Message*
Msg_PChildToParentStreamConstructor(int32_t routingId);
IPC::Message*
Reply_PChildToParentStreamConstructor(int32_t routingId);

IPC::Message*
Msg_PSpeechSynthesisConstructor(int32_t routingId);
IPC::Message*
Reply_PSpeechSynthesisConstructor(int32_t routingId);

IPC::Message*
Msg_PMediaConstructor(int32_t routingId);
IPC::Message*
Reply_PMediaConstructor(int32_t routingId);

IPC::Message*
Msg_PWebrtcGlobalConstructor(int32_t routingId);
IPC::Message*
Reply_PWebrtcGlobalConstructor(int32_t routingId);

IPC::Message*
Msg_PPresentationConstructor(int32_t routingId);
IPC::Message*
Reply_PPresentationConstructor(int32_t routingId);

IPC::Message*
Msg_CreateAudioIPCConnection(int32_t routingId);
IPC::Message*
Reply_CreateAudioIPCConnection(int32_t routingId);

IPC::Message*
Msg_PURLClassifierConstructor(int32_t routingId);
IPC::Message*
Reply_PURLClassifierConstructor(int32_t routingId);

IPC::Message*
Msg_PURLClassifierLocalConstructor(int32_t routingId);
IPC::Message*
Reply_PURLClassifierLocalConstructor(int32_t routingId);

IPC::Message*
Msg_PLoginReputationConstructor(int32_t routingId);
IPC::Message*
Reply_PLoginReputationConstructor(int32_t routingId);

IPC::Message*
Msg_PSessionStorageObserverConstructor(int32_t routingId);
IPC::Message*
Reply_PSessionStorageObserverConstructor(int32_t routingId);

IPC::Message*
Msg_PBenchmarkStorageConstructor(int32_t routingId);
IPC::Message*
Reply_PBenchmarkStorageConstructor(int32_t routingId);

IPC::Message*
Msg_StartVisitedQueries(int32_t routingId);

IPC::Message*
Msg_SetURITitle(int32_t routingId);

IPC::Message*
Msg_LoadURIExternal(int32_t routingId);

IPC::Message*
Msg_ExtProtocolChannelConnectParent(int32_t routingId);

IPC::Message*
Msg_GetGfxVars(int32_t routingId);
IPC::Message*
Reply_GetGfxVars(int32_t routingId);

IPC::Message*
Msg_SyncMessage(int32_t routingId);
IPC::Message*
Reply_SyncMessage(int32_t routingId);

IPC::Message*
Msg_ShowAlert(int32_t routingId);

IPC::Message*
Msg_CloseAlert(int32_t routingId);

IPC::Message*
Msg_DisableNotifications(int32_t routingId);

IPC::Message*
Msg_OpenNotificationSettings(int32_t routingId);

IPC::Message*
Msg_AddSecurityState(int32_t routingId);

IPC::Message*
Msg_NotificationEvent(int32_t routingId);

IPC::Message*
Msg_PExternalHelperAppConstructor(int32_t routingId);
IPC::Message*
Reply_PExternalHelperAppConstructor(int32_t routingId);

IPC::Message*
Msg_PHandlerServiceConstructor(int32_t routingId);
IPC::Message*
Reply_PHandlerServiceConstructor(int32_t routingId);

IPC::Message*
Msg_AddGeolocationListener(int32_t routingId);

IPC::Message*
Msg_RemoveGeolocationListener(int32_t routingId);

IPC::Message*
Msg_SetGeolocationHigherAccuracy(int32_t routingId);

IPC::Message*
Msg_ConsoleMessage(int32_t routingId);

IPC::Message*
Msg_ScriptErrorWithStack(int32_t routingId);

IPC::Message*
Msg_SetClipboard(int32_t routingId);

IPC::Message*
Msg_GetClipboard(int32_t routingId);
IPC::Message*
Reply_GetClipboard(int32_t routingId);

IPC::Message*
Msg_GetExternalClipboardFormats(int32_t routingId);
IPC::Message*
Reply_GetExternalClipboardFormats(int32_t routingId);

IPC::Message*
Msg_EmptyClipboard(int32_t routingId);

IPC::Message*
Msg_ClipboardHasType(int32_t routingId);
IPC::Message*
Reply_ClipboardHasType(int32_t routingId);

IPC::Message*
Msg_PlaySound(int32_t routingId);

IPC::Message*
Msg_Beep(int32_t routingId);

IPC::Message*
Msg_PlayEventSound(int32_t routingId);

IPC::Message*
Msg_GetIconForExtension(int32_t routingId);
IPC::Message*
Reply_GetIconForExtension(int32_t routingId);

IPC::Message*
Msg_PrivateDocShellsExist(int32_t routingId);

IPC::Message*
Msg_FirstIdle(int32_t routingId);

IPC::Message*
Msg_DeviceReset(int32_t routingId);

IPC::Message*
Msg_CopyFavicon(int32_t routingId);

IPC::Message*
Msg_RecordingDeviceEvents(int32_t routingId);

IPC::Message*
Msg_GraphicsError(int32_t routingId);

IPC::Message*
Msg_BeginDriverCrashGuard(int32_t routingId);
IPC::Message*
Reply_BeginDriverCrashGuard(int32_t routingId);

IPC::Message*
Msg_EndDriverCrashGuard(int32_t routingId);
IPC::Message*
Reply_EndDriverCrashGuard(int32_t routingId);

IPC::Message*
Msg_AddIdleObserver(int32_t routingId);

IPC::Message*
Msg_RemoveIdleObserver(int32_t routingId);

IPC::Message*
Msg_BackUpXResources(int32_t routingId);

IPC::Message*
Msg_RequestAnonymousTemporaryFile(int32_t routingId);

IPC::Message*
Msg_POfflineCacheUpdateConstructor(int32_t routingId);
IPC::Message*
Reply_POfflineCacheUpdateConstructor(int32_t routingId);

IPC::Message*
Msg_SetOfflinePermission(int32_t routingId);

IPC::Message*
Msg_FinishShutdown(int32_t routingId);

IPC::Message*
Msg_UpdateDropEffect(int32_t routingId);

IPC::Message*
Msg_PContentPermissionRequestConstructor(int32_t routingId);
IPC::Message*
Reply_PContentPermissionRequestConstructor(int32_t routingId);

IPC::Message*
Msg_ShutdownProfile(int32_t routingId);

IPC::Message*
Msg_GetGraphicsDeviceInitData(int32_t routingId);
IPC::Message*
Reply_GetGraphicsDeviceInitData(int32_t routingId);

IPC::Message*
Msg_GetOutputColorProfileData(int32_t routingId);
IPC::Message*
Reply_GetOutputColorProfileData(int32_t routingId);

IPC::Message*
Msg_GetFontListShmBlock(int32_t routingId);
IPC::Message*
Reply_GetFontListShmBlock(int32_t routingId);

IPC::Message*
Msg_InitializeFamily(int32_t routingId);
IPC::Message*
Reply_InitializeFamily(int32_t routingId);

IPC::Message*
Msg_SetCharacterMap(int32_t routingId);

IPC::Message*
Msg_SetupFamilyCharMap(int32_t routingId);

IPC::Message*
Msg_InitOtherFamilyNames(int32_t routingId);
IPC::Message*
Reply_InitOtherFamilyNames(int32_t routingId);

IPC::Message*
Msg_StartCmapLoading(int32_t routingId);

IPC::Message*
Msg_GetHyphDict(int32_t routingId);
IPC::Message*
Reply_GetHyphDict(int32_t routingId);

IPC::Message*
Msg_CreateWindow(int32_t routingId);
IPC::Message*
Reply_CreateWindow(int32_t routingId);

IPC::Message*
Msg_CreateWindowInDifferentProcess(int32_t routingId);

IPC::Message*
Msg_UngrabPointer(int32_t routingId);
IPC::Message*
Reply_UngrabPointer(int32_t routingId);

IPC::Message*
Msg_RemovePermission(int32_t routingId);
IPC::Message*
Reply_RemovePermission(int32_t routingId);

IPC::Message*
Msg_NotifyBenchmarkResult(int32_t routingId);

IPC::Message*
Msg_NotifyPushObservers(int32_t routingId);

IPC::Message*
Msg_NotifyPushObserversWithData(int32_t routingId);

IPC::Message*
Msg_NotifyPushSubscriptionChangeObservers(int32_t routingId);

IPC::Message*
Msg_GetFilesRequest(int32_t routingId);

IPC::Message*
Msg_DeleteGetFilesRequest(int32_t routingId);

IPC::Message*
Msg_StoreAndBroadcastBlobURLRegistration(int32_t routingId);

IPC::Message*
Msg_UnstoreAndBroadcastBlobURLUnregistration(int32_t routingId);

IPC::Message*
Msg_AccumulateChildHistograms(int32_t routingId);

IPC::Message*
Msg_AccumulateChildKeyedHistograms(int32_t routingId);

IPC::Message*
Msg_UpdateChildScalars(int32_t routingId);

IPC::Message*
Msg_UpdateChildKeyedScalars(int32_t routingId);

IPC::Message*
Msg_RecordChildEvents(int32_t routingId);

IPC::Message*
Msg_RecordDiscardedData(int32_t routingId);

IPC::Message*
Msg_GetA11yContentId(int32_t routingId);
IPC::Message*
Reply_GetA11yContentId(int32_t routingId);

IPC::Message*
Msg_A11yHandlerControl(int32_t routingId);

IPC::Message*
Msg_AddMemoryReport(int32_t routingId);

IPC::Message*
Msg_MaybeReloadPlugins(int32_t routingId);

IPC::Message*
Msg_BHRThreadHang(int32_t routingId);

IPC::Message*
Msg_AddPerformanceMetrics(int32_t routingId);

IPC::Message*
Msg_AddCertException(int32_t routingId);
IPC::Message*
Reply_AddCertException(int32_t routingId);

IPC::Message*
Msg_AutomaticStorageAccessPermissionCanBeGranted(int32_t routingId);
IPC::Message*
Reply_AutomaticStorageAccessPermissionCanBeGranted(int32_t routingId);

IPC::Message*
Msg_StorageAccessPermissionGrantedForOrigin(int32_t routingId);
IPC::Message*
Reply_StorageAccessPermissionGrantedForOrigin(int32_t routingId);

IPC::Message*
Msg_CompleteAllowAccessFor(int32_t routingId);
IPC::Message*
Reply_CompleteAllowAccessFor(int32_t routingId);

IPC::Message*
Msg_StoreUserInteractionAsPermission(int32_t routingId);

IPC::Message*
Msg_NotifyMediaPlaybackChanged(int32_t routingId);

IPC::Message*
Msg_NotifyMediaAudibleChanged(int32_t routingId);

IPC::Message*
Msg_NotifyPictureInPictureModeChanged(int32_t routingId);

IPC::Message*
Msg_NotifyMediaSessionUpdated(int32_t routingId);

IPC::Message*
Msg_NotifyUpdateMediaMetadata(int32_t routingId);

IPC::Message*
Msg_NotifyMediaSessionPlaybackStateChanged(int32_t routingId);

IPC::Message*
Msg_NotifyMediaSessionSupportedActionChanged(int32_t routingId);

IPC::Message*
Msg_NotifyMediaFullScreenState(int32_t routingId);

IPC::Message*
Msg_NotifyPositionStateChanged(int32_t routingId);

IPC::Message*
Msg_GetModulesTrust(int32_t routingId);
IPC::Message*
Reply_GetModulesTrust(int32_t routingId);

IPC::Message*
Msg_ReportServiceWorkerShutdownProgress(int32_t routingId);

IPC::Message*
Msg_AbortOtherOrientationPendingPromises(int32_t routingId);

IPC::Message*
Msg_HistoryReload(int32_t routingId);

IPC::Message*
Msg_NotifyOnHistoryReload(int32_t routingId);
IPC::Message*
Reply_NotifyOnHistoryReload(int32_t routingId);

IPC::Message*
Msg_HistoryCommit(int32_t routingId);

IPC::Message*
Msg_HistoryGo(int32_t routingId);
IPC::Message*
Reply_HistoryGo(int32_t routingId);

IPC::Message*
Msg_BlobURLDataRequest(int32_t routingId);
IPC::Message*
Reply_BlobURLDataRequest(int32_t routingId);

IPC::Message*
Msg_SetActiveSessionHistoryEntry(int32_t routingId);

IPC::Message*
Msg_ReplaceActiveSessionHistoryEntry(int32_t routingId);

IPC::Message*
Msg_RemoveDynEntriesFromActiveSessionHistoryEntry(int32_t routingId);

IPC::Message*
Msg_RemoveFromSessionHistory(int32_t routingId);

IPC::Message*
Msg_ScriptError(int32_t routingId);

IPC::Message*
Msg_ReportFrameTimingData(int32_t routingId);

IPC::Message*
Msg_CommitBrowsingContextTransaction(int32_t routingId);

IPC::Message*
Msg_AsyncMessage(int32_t routingId);

IPC::Message*
Msg_NotifyPushSubscriptionModifiedObservers(int32_t routingId);

IPC::Message*
Msg_PushError(int32_t routingId);

IPC::Message*
Msg_CreateBrowsingContext(int32_t routingId);

IPC::Message*
Msg_DiscardBrowsingContext(int32_t routingId);
IPC::Message*
Reply_DiscardBrowsingContext(int32_t routingId);

IPC::Message*
Msg_AdjustWindowFocus(int32_t routingId);

IPC::Message*
Msg_WindowClose(int32_t routingId);

IPC::Message*
Msg_WindowFocus(int32_t routingId);

IPC::Message*
Msg_WindowBlur(int32_t routingId);

IPC::Message*
Msg_RaiseWindow(int32_t routingId);

IPC::Message*
Msg_ClearFocus(int32_t routingId);

IPC::Message*
Msg_SetFocusedBrowsingContext(int32_t routingId);

IPC::Message*
Msg_SetActiveBrowsingContext(int32_t routingId);

IPC::Message*
Msg_UnsetActiveBrowsingContext(int32_t routingId);

IPC::Message*
Msg_SetFocusedElement(int32_t routingId);

IPC::Message*
Msg_FinalizeFocusOuter(int32_t routingId);

IPC::Message*
Msg_InsertNewFocusActionId(int32_t routingId);

IPC::Message*
Msg_BlurToParent(int32_t routingId);

IPC::Message*
Msg_BlurToChild(int32_t routingId);

IPC::Message*
Msg_SetupFocusedAndActive(int32_t routingId);

IPC::Message*
Msg_ReviseActiveBrowsingContext(int32_t routingId);

IPC::Message*
Msg_MaybeExitFullscreen(int32_t routingId);

IPC::Message*
Msg_WindowPostMessage(int32_t routingId);

IPC::Message*
Msg_CommitWindowContextTransaction(int32_t routingId);

IPC::Message*
Msg_CreateWindowContext(int32_t routingId);

IPC::Message*
Msg_DiscardWindowContext(int32_t routingId);
IPC::Message*
Reply_DiscardWindowContext(int32_t routingId);

IPC::Message*
Msg_FOGData(int32_t routingId);

IPC::Message*
Msg_FlushFOGData(int32_t routingId);
IPC::Message*
Reply_FlushFOGData(int32_t routingId);

IPC::Message*
Msg_SetContainerFeaturePolicy(int32_t routingId);



} // namespace PContent
} // namespace dom
} // namespace mozilla

#endif // ifndef PContent_h
