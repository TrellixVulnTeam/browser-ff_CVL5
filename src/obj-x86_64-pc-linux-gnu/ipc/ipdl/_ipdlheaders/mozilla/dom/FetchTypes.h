//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef FetchTypes_h
#define FetchTypes_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "mozilla/dom/HeadersBinding.h"
#include "mozilla/dom/ReferrerPolicyBinding.h"
#include "mozilla/dom/RequestBinding.h"
#include "mozilla/dom/ResponseBinding.h"
#include "nsID.h"
#include "mozilla/ipc/IPCStream.h"
#include "mozilla/ipc/ChannelInfo.h"
#include "mozilla/ipc/PBackgroundSharedTypes.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct HeadersEntry|
//
namespace mozilla {
namespace dom {
class HeadersEntry final
{
private:

public:
    MOZ_IMPLICIT HeadersEntry() :
        name_(),
        value_()
    {
    }

    MOZ_IMPLICIT HeadersEntry(
            const nsCString& _name,
            const nsCString& _value) :
        name_(_name),
        value_(_value)
    {
    }

    nsCString&
    name()
    {
        return name_;
    }
    const nsCString&
    name() const
    {
        return name_;
    }

    nsCString&
    value()
    {
        return value_;
    }
    const nsCString&
    value() const
    {
        return value_;
    }

private:
    nsCString name_;
    nsCString value_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::HeadersEntry>
{
    typedef mozilla::dom::HeadersEntry paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ParentToParentStream|
//
namespace mozilla {
namespace dom {
class ParentToParentStream final
{
private:

public:
    MOZ_IMPLICIT ParentToParentStream() :
        uuid_()
    {
    }

    MOZ_IMPLICIT ParentToParentStream(const nsID& _uuid) :
        uuid_(_uuid)
    {
    }

    nsID&
    uuid()
    {
        return uuid_;
    }
    const nsID&
    uuid() const
    {
        return uuid_;
    }

private:
    nsID uuid_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ParentToParentStream>
{
    typedef mozilla::dom::ParentToParentStream paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
class PRemoteLazyInputStreamParent;
} // namespace mozilla

namespace mozilla {
class PRemoteLazyInputStreamChild;
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ParentToChildStream|
//
namespace mozilla {
namespace dom {
class ParentToChildStream final
{
private:
    typedef mozilla::PRemoteLazyInputStreamParent PRemoteLazyInputStreamParent;
    typedef mozilla::PRemoteLazyInputStreamChild PRemoteLazyInputStreamChild;

public:
    MOZ_IMPLICIT ParentToChildStream() :
        actorParent_(),
        actorChild_()
    {
    }

    MOZ_IMPLICIT ParentToChildStream(
            PRemoteLazyInputStreamParent* _actorParent,
            PRemoteLazyInputStreamChild* _actorChild) :
        actorParent_(_actorParent),
        actorChild_(_actorChild)
    {
    }

    PRemoteLazyInputStreamParent*&
    actorParent()
    {
        return actorParent_;
    }
    PRemoteLazyInputStreamParent*
    actorParent() const
    {
        return actorParent_;
    }

    PRemoteLazyInputStreamChild*&
    actorChild()
    {
        return actorChild_;
    }
    PRemoteLazyInputStreamChild*
    actorChild() const
    {
        return actorChild_;
    }

private:
    PRemoteLazyInputStreamParent* actorParent_;
    PRemoteLazyInputStreamChild* actorChild_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ParentToChildStream>
{
    typedef mozilla::dom::ParentToChildStream paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ChildToParentStream|
//
namespace mozilla {
namespace dom {
class ChildToParentStream final
{
private:
    typedef mozilla::ipc::IPCStream IPCStream;

public:
    MOZ_IMPLICIT ChildToParentStream() :
        stream_()
    {
    }

    MOZ_IMPLICIT ChildToParentStream(const IPCStream& _stream) :
        stream_(_stream)
    {
    }

    IPCStream&
    stream()
    {
        return stream_;
    }
    const IPCStream&
    stream() const
    {
        return stream_;
    }

private:
    IPCStream stream_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::ChildToParentStream>
{
    typedef mozilla::dom::ChildToParentStream paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union BodyStreamVariant|
//
namespace mozilla {
namespace dom {
class BodyStreamVariant final
{
public:
    enum Type {
        T__None,
        TParentToParentStream = 1,
        TParentToChildStream,
        TChildToParentStream,
        T__Last = TChildToParentStream
    };

private:
    typedef mozilla::dom::ParentToParentStream ParentToParentStream;
    typedef mozilla::dom::ParentToChildStream ParentToChildStream;
    typedef mozilla::dom::ChildToParentStream ChildToParentStream;
    typedef ParentToParentStream ParentToParentStream__tdef;
    typedef ParentToChildStream ParentToChildStream__tdef;
    typedef ChildToParentStream ChildToParentStream__tdef;

    union Value {
        mozilla::AlignedStorage2<ParentToParentStream> VParentToParentStream;
        mozilla::AlignedStorage2<ParentToChildStream> VParentToChildStream;
        mozilla::AlignedStorage2<ChildToParentStream> VChildToParentStream;
    };

    ParentToParentStream*
    ptr_ParentToParentStream()
    {
        return ((mValue).VParentToParentStream).addr();
    }
    const ParentToParentStream*
    constptr_ParentToParentStream() const
    {
        return ((mValue).VParentToParentStream).addr();
    }
    ParentToChildStream*
    ptr_ParentToChildStream()
    {
        return ((mValue).VParentToChildStream).addr();
    }
    const ParentToChildStream*
    constptr_ParentToChildStream() const
    {
        return ((mValue).VParentToChildStream).addr();
    }
    ChildToParentStream*
    ptr_ChildToParentStream()
    {
        return ((mValue).VChildToParentStream).addr();
    }
    const ChildToParentStream*
    constptr_ChildToParentStream() const
    {
        return ((mValue).VChildToParentStream).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT BodyStreamVariant() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT BodyStreamVariant(const ParentToParentStream& aOther);

    MOZ_IMPLICIT BodyStreamVariant(ParentToParentStream&& aOther);

    MOZ_IMPLICIT BodyStreamVariant(const ParentToChildStream& aOther);

    MOZ_IMPLICIT BodyStreamVariant(ParentToChildStream&& aOther);

    MOZ_IMPLICIT BodyStreamVariant(const ChildToParentStream& aOther);

    MOZ_IMPLICIT BodyStreamVariant(ChildToParentStream&& aOther);

    MOZ_IMPLICIT BodyStreamVariant(const BodyStreamVariant& aOther);

    MOZ_IMPLICIT BodyStreamVariant(BodyStreamVariant&& aOther);

    ~BodyStreamVariant();

    Type
    type() const
    {
        return mType;
    }

    BodyStreamVariant&
    operator=(const ParentToParentStream& aRhs);

    BodyStreamVariant&
    operator=(ParentToParentStream&& aRhs);

    BodyStreamVariant&
    operator=(const ParentToChildStream& aRhs);

    BodyStreamVariant&
    operator=(ParentToChildStream&& aRhs);

    BodyStreamVariant&
    operator=(const ChildToParentStream& aRhs);

    BodyStreamVariant&
    operator=(ChildToParentStream&& aRhs);

    BodyStreamVariant&
    operator=(const BodyStreamVariant& aRhs);

    BodyStreamVariant&
    operator=(BodyStreamVariant&& aRhs);

    ParentToParentStream&
    get_ParentToParentStream()
    {
        AssertSanity(TParentToParentStream);
        return (*(ptr_ParentToParentStream()));
    }
    const ParentToParentStream&
    get_ParentToParentStream() const
    {
        AssertSanity(TParentToParentStream);
        return (*(constptr_ParentToParentStream()));
    }
    operator ParentToParentStream&()
    {
        return get_ParentToParentStream();
    }
    operator const ParentToParentStream&() const
    {
        return get_ParentToParentStream();
    }

    ParentToChildStream&
    get_ParentToChildStream()
    {
        AssertSanity(TParentToChildStream);
        return (*(ptr_ParentToChildStream()));
    }
    const ParentToChildStream&
    get_ParentToChildStream() const
    {
        AssertSanity(TParentToChildStream);
        return (*(constptr_ParentToChildStream()));
    }
    operator ParentToChildStream&()
    {
        return get_ParentToChildStream();
    }
    operator const ParentToChildStream&() const
    {
        return get_ParentToChildStream();
    }

    ChildToParentStream&
    get_ChildToParentStream()
    {
        AssertSanity(TChildToParentStream);
        return (*(ptr_ChildToParentStream()));
    }
    const ChildToParentStream&
    get_ChildToParentStream() const
    {
        AssertSanity(TChildToParentStream);
        return (*(constptr_ChildToParentStream()));
    }
    operator ChildToParentStream&()
    {
        return get_ChildToParentStream();
    }
    operator const ChildToParentStream&() const
    {
        return get_ChildToParentStream();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::BodyStreamVariant>
{
    typedef mozilla::dom::BodyStreamVariant paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct IPCInternalRequest|
//
namespace mozilla {
namespace dom {
class IPCInternalRequest final
{
private:
    typedef mozilla::dom::HeadersEntry HeadersEntry;
    typedef mozilla::dom::BodyStreamVariant BodyStreamVariant;
    typedef mozilla::ipc::PrincipalInfo PrincipalInfo;

public:
    MOZ_IMPLICIT IPCInternalRequest() :
        method_(),
        urlList_(),
        headersGuard_(),
        headers_(),
        body_(),
        preferredAlternativeDataType_(),
        referrer_(),
        referrerPolicy_(),
        requestMode_(),
        requestCredentials_(),
        cacheMode_(),
        requestRedirect_(),
        integrity_(),
        fragment_(),
        principalInfo_(),
        bodySize_(),
        contentPolicyType_()
    {
    }

    MOZ_IMPLICIT IPCInternalRequest(
            const nsCString& _method,
            const nsTArray<nsCString>& _urlList,
            const HeadersGuardEnum& _headersGuard,
            const nsTArray<HeadersEntry>& _headers,
            const mozilla::Maybe<BodyStreamVariant>& _body,
            const int64_t& _bodySize,
            const nsCString& _preferredAlternativeDataType,
            const uint32_t& _contentPolicyType,
            const nsString& _referrer,
            const ReferrerPolicy& _referrerPolicy,
            const RequestMode& _requestMode,
            const RequestCredentials& _requestCredentials,
            const RequestCache& _cacheMode,
            const RequestRedirect& _requestRedirect,
            const nsString& _integrity,
            const nsCString& _fragment,
            const mozilla::Maybe<PrincipalInfo>& _principalInfo) :
        method_(_method),
        urlList_(_urlList),
        headersGuard_(_headersGuard),
        headers_(_headers),
        body_(_body),
        preferredAlternativeDataType_(_preferredAlternativeDataType),
        referrer_(_referrer),
        referrerPolicy_(_referrerPolicy),
        requestMode_(_requestMode),
        requestCredentials_(_requestCredentials),
        cacheMode_(_cacheMode),
        requestRedirect_(_requestRedirect),
        integrity_(_integrity),
        fragment_(_fragment),
        principalInfo_(_principalInfo),
        bodySize_(_bodySize),
        contentPolicyType_(_contentPolicyType)
    {
    }

    nsCString&
    method()
    {
        return method_;
    }
    const nsCString&
    method() const
    {
        return method_;
    }

    nsTArray<nsCString>&
    urlList()
    {
        return urlList_;
    }
    const nsTArray<nsCString>&
    urlList() const
    {
        return urlList_;
    }

    HeadersGuardEnum&
    headersGuard()
    {
        return headersGuard_;
    }
    const HeadersGuardEnum&
    headersGuard() const
    {
        return headersGuard_;
    }

    nsTArray<HeadersEntry>&
    headers()
    {
        return headers_;
    }
    const nsTArray<HeadersEntry>&
    headers() const
    {
        return headers_;
    }

    mozilla::Maybe<BodyStreamVariant>&
    body()
    {
        return body_;
    }
    const mozilla::Maybe<BodyStreamVariant>&
    body() const
    {
        return body_;
    }

    int64_t&
    bodySize()
    {
        return bodySize_;
    }
    const int64_t&
    bodySize() const
    {
        return bodySize_;
    }

    nsCString&
    preferredAlternativeDataType()
    {
        return preferredAlternativeDataType_;
    }
    const nsCString&
    preferredAlternativeDataType() const
    {
        return preferredAlternativeDataType_;
    }

    uint32_t&
    contentPolicyType()
    {
        return contentPolicyType_;
    }
    const uint32_t&
    contentPolicyType() const
    {
        return contentPolicyType_;
    }

    nsString&
    referrer()
    {
        return referrer_;
    }
    const nsString&
    referrer() const
    {
        return referrer_;
    }

    ReferrerPolicy&
    referrerPolicy()
    {
        return referrerPolicy_;
    }
    const ReferrerPolicy&
    referrerPolicy() const
    {
        return referrerPolicy_;
    }

    RequestMode&
    requestMode()
    {
        return requestMode_;
    }
    const RequestMode&
    requestMode() const
    {
        return requestMode_;
    }

    RequestCredentials&
    requestCredentials()
    {
        return requestCredentials_;
    }
    const RequestCredentials&
    requestCredentials() const
    {
        return requestCredentials_;
    }

    RequestCache&
    cacheMode()
    {
        return cacheMode_;
    }
    const RequestCache&
    cacheMode() const
    {
        return cacheMode_;
    }

    RequestRedirect&
    requestRedirect()
    {
        return requestRedirect_;
    }
    const RequestRedirect&
    requestRedirect() const
    {
        return requestRedirect_;
    }

    nsString&
    integrity()
    {
        return integrity_;
    }
    const nsString&
    integrity() const
    {
        return integrity_;
    }

    nsCString&
    fragment()
    {
        return fragment_;
    }
    const nsCString&
    fragment() const
    {
        return fragment_;
    }

    mozilla::Maybe<PrincipalInfo>&
    principalInfo()
    {
        return principalInfo_;
    }
    const mozilla::Maybe<PrincipalInfo>&
    principalInfo() const
    {
        return principalInfo_;
    }

private:
    nsCString method_;
    CopyableTArray<nsCString> urlList_;
    HeadersGuardEnum headersGuard_;
    CopyableTArray<HeadersEntry> headers_;
    mozilla::Maybe<BodyStreamVariant> body_;
    nsCString preferredAlternativeDataType_;
    nsString referrer_;
    ReferrerPolicy referrerPolicy_;
    RequestMode requestMode_;
    RequestCredentials requestCredentials_;
    RequestCache cacheMode_;
    RequestRedirect requestRedirect_;
    nsString integrity_;
    nsCString fragment_;
    mozilla::Maybe<PrincipalInfo> principalInfo_;
    int64_t bodySize_;
    uint32_t contentPolicyType_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPCInternalRequest>
{
    typedef mozilla::dom::IPCInternalRequest paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct IPCInternalResponse|
//
namespace mozilla {
namespace dom {
class IPCInternalResponse final
{
private:
    typedef mozilla::dom::HeadersEntry HeadersEntry;
    typedef mozilla::dom::BodyStreamVariant BodyStreamVariant;
    typedef mozilla::ipc::IPCChannelInfo IPCChannelInfo;
    typedef mozilla::ipc::PrincipalInfo PrincipalInfo;

public:
    MOZ_IMPLICIT IPCInternalResponse() :
        type_(),
        urlList_(),
        statusText_(),
        headersGuard_(),
        headers_(),
        body_(),
        errorCode_(),
        alternativeDataType_(),
        alternativeBody_(),
        channelInfo_(),
        principalInfo_(),
        bodySize_(),
        status_()
    {
    }

    MOZ_IMPLICIT IPCInternalResponse(
            const ResponseType& _type,
            const nsTArray<nsCString>& _urlList,
            const uint16_t& _status,
            const nsCString& _statusText,
            const HeadersGuardEnum& _headersGuard,
            const nsTArray<HeadersEntry>& _headers,
            const mozilla::Maybe<BodyStreamVariant>& _body,
            const int64_t& _bodySize,
            const nsresult& _errorCode,
            const nsCString& _alternativeDataType,
            const mozilla::Maybe<BodyStreamVariant>& _alternativeBody,
            const IPCChannelInfo& _channelInfo,
            const mozilla::Maybe<PrincipalInfo>& _principalInfo) :
        type_(_type),
        urlList_(_urlList),
        statusText_(_statusText),
        headersGuard_(_headersGuard),
        headers_(_headers),
        body_(_body),
        errorCode_(_errorCode),
        alternativeDataType_(_alternativeDataType),
        alternativeBody_(_alternativeBody),
        channelInfo_(_channelInfo),
        principalInfo_(_principalInfo),
        bodySize_(_bodySize),
        status_(_status)
    {
    }

    ResponseType&
    type()
    {
        return type_;
    }
    const ResponseType&
    type() const
    {
        return type_;
    }

    nsTArray<nsCString>&
    urlList()
    {
        return urlList_;
    }
    const nsTArray<nsCString>&
    urlList() const
    {
        return urlList_;
    }

    uint16_t&
    status()
    {
        return status_;
    }
    const uint16_t&
    status() const
    {
        return status_;
    }

    nsCString&
    statusText()
    {
        return statusText_;
    }
    const nsCString&
    statusText() const
    {
        return statusText_;
    }

    HeadersGuardEnum&
    headersGuard()
    {
        return headersGuard_;
    }
    const HeadersGuardEnum&
    headersGuard() const
    {
        return headersGuard_;
    }

    nsTArray<HeadersEntry>&
    headers()
    {
        return headers_;
    }
    const nsTArray<HeadersEntry>&
    headers() const
    {
        return headers_;
    }

    mozilla::Maybe<BodyStreamVariant>&
    body()
    {
        return body_;
    }
    const mozilla::Maybe<BodyStreamVariant>&
    body() const
    {
        return body_;
    }

    int64_t&
    bodySize()
    {
        return bodySize_;
    }
    const int64_t&
    bodySize() const
    {
        return bodySize_;
    }

    nsresult&
    errorCode()
    {
        return errorCode_;
    }
    const nsresult&
    errorCode() const
    {
        return errorCode_;
    }

    nsCString&
    alternativeDataType()
    {
        return alternativeDataType_;
    }
    const nsCString&
    alternativeDataType() const
    {
        return alternativeDataType_;
    }

    mozilla::Maybe<BodyStreamVariant>&
    alternativeBody()
    {
        return alternativeBody_;
    }
    const mozilla::Maybe<BodyStreamVariant>&
    alternativeBody() const
    {
        return alternativeBody_;
    }

    IPCChannelInfo&
    channelInfo()
    {
        return channelInfo_;
    }
    const IPCChannelInfo&
    channelInfo() const
    {
        return channelInfo_;
    }

    mozilla::Maybe<PrincipalInfo>&
    principalInfo()
    {
        return principalInfo_;
    }
    const mozilla::Maybe<PrincipalInfo>&
    principalInfo() const
    {
        return principalInfo_;
    }

private:
    ResponseType type_;
    CopyableTArray<nsCString> urlList_;
    nsCString statusText_;
    HeadersGuardEnum headersGuard_;
    CopyableTArray<HeadersEntry> headers_;
    mozilla::Maybe<BodyStreamVariant> body_;
    nsresult errorCode_;
    nsCString alternativeDataType_;
    mozilla::Maybe<BodyStreamVariant> alternativeBody_;
    IPCChannelInfo channelInfo_;
    mozilla::Maybe<PrincipalInfo> principalInfo_;
    int64_t bodySize_;
    uint16_t status_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::IPCInternalResponse>
{
    typedef mozilla::dom::IPCInternalResponse paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

#endif // ifndef FetchTypes_h
