//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PHandlerService_h
#define PHandlerService_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct HandlerApp|
//
namespace mozilla {
namespace dom {
class HandlerApp final
{
private:

public:
    MOZ_IMPLICIT HandlerApp() :
        name_(),
        detailedDescription_()
    {
    }

    MOZ_IMPLICIT HandlerApp(
            const nsString& _name,
            const nsString& _detailedDescription) :
        name_(_name),
        detailedDescription_(_detailedDescription)
    {
    }

    nsString&
    name()
    {
        return name_;
    }
    const nsString&
    name() const
    {
        return name_;
    }

    nsString&
    detailedDescription()
    {
        return detailedDescription_;
    }
    const nsString&
    detailedDescription() const
    {
        return detailedDescription_;
    }

private:
    nsString name_;
    nsString detailedDescription_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::HandlerApp>
{
    typedef mozilla::dom::HandlerApp paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct HandlerInfo|
//
namespace mozilla {
namespace dom {
class HandlerInfo final
{
private:
    typedef mozilla::dom::HandlerApp HandlerApp;

public:
    MOZ_IMPLICIT HandlerInfo() :
        type_(),
        isMIMEInfo_(),
        description_(),
        alwaysAskBeforeHandling_(),
        extensions_(),
        preferredApplicationHandler_(),
        possibleApplicationHandlers_(),
        preferredAction_()
    {
    }

    MOZ_IMPLICIT HandlerInfo(
            const nsCString& _type,
            const bool& _isMIMEInfo,
            const nsString& _description,
            const bool& _alwaysAskBeforeHandling,
            const nsTArray<nsCString>& _extensions,
            const HandlerApp& _preferredApplicationHandler,
            const nsTArray<HandlerApp>& _possibleApplicationHandlers,
            const long& _preferredAction) :
        type_(_type),
        isMIMEInfo_(_isMIMEInfo),
        description_(_description),
        alwaysAskBeforeHandling_(_alwaysAskBeforeHandling),
        extensions_(_extensions),
        preferredApplicationHandler_(_preferredApplicationHandler),
        possibleApplicationHandlers_(_possibleApplicationHandlers),
        preferredAction_(_preferredAction)
    {
    }

    nsCString&
    type()
    {
        return type_;
    }
    const nsCString&
    type() const
    {
        return type_;
    }

    bool&
    isMIMEInfo()
    {
        return isMIMEInfo_;
    }
    const bool&
    isMIMEInfo() const
    {
        return isMIMEInfo_;
    }

    nsString&
    description()
    {
        return description_;
    }
    const nsString&
    description() const
    {
        return description_;
    }

    bool&
    alwaysAskBeforeHandling()
    {
        return alwaysAskBeforeHandling_;
    }
    const bool&
    alwaysAskBeforeHandling() const
    {
        return alwaysAskBeforeHandling_;
    }

    nsTArray<nsCString>&
    extensions()
    {
        return extensions_;
    }
    const nsTArray<nsCString>&
    extensions() const
    {
        return extensions_;
    }

    HandlerApp&
    preferredApplicationHandler()
    {
        return preferredApplicationHandler_;
    }
    const HandlerApp&
    preferredApplicationHandler() const
    {
        return preferredApplicationHandler_;
    }

    nsTArray<HandlerApp>&
    possibleApplicationHandlers()
    {
        return possibleApplicationHandlers_;
    }
    const nsTArray<HandlerApp>&
    possibleApplicationHandlers() const
    {
        return possibleApplicationHandlers_;
    }

    long&
    preferredAction()
    {
        return preferredAction_;
    }
    const long&
    preferredAction() const
    {
        return preferredAction_;
    }

private:
    nsCString type_;
    bool isMIMEInfo_;
    nsString description_;
    bool alwaysAskBeforeHandling_;
    CopyableTArray<nsCString> extensions_;
    HandlerApp preferredApplicationHandler_;
    CopyableTArray<HandlerApp> possibleApplicationHandlers_;
    long preferredAction_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::HandlerInfo>
{
    typedef mozilla::dom::HandlerInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace dom {
class PHandlerServiceParent;
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
class PHandlerServiceChild;
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Code common to PHandlerServiceChild and PHandlerServiceParent
//
namespace mozilla {
namespace dom {
namespace PHandlerService {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::dom::PHandlerServiceParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::dom::PHandlerServiceChild>* aChild);

enum MessageType {
    PHandlerServiceStart = PHandlerServiceMsgStart << 16,
    Msg_FillHandlerInfo__ID,
    Reply_FillHandlerInfo__ID,
    Msg_ExistsForProtocolOS__ID,
    Reply_ExistsForProtocolOS__ID,
    Msg_ExistsForProtocol__ID,
    Reply_ExistsForProtocol__ID,
    Msg_Exists__ID,
    Reply_Exists__ID,
    Msg_GetTypeFromExtension__ID,
    Reply_GetTypeFromExtension__ID,
    Msg_GetMIMEInfoFromOS__ID,
    Reply_GetMIMEInfoFromOS__ID,
    Msg_GetApplicationDescription__ID,
    Reply_GetApplicationDescription__ID,
    Msg___delete____ID,
    Reply___delete____ID,
    PHandlerServiceEnd
};

IPC::Message*
Msg_FillHandlerInfo(int32_t routingId);
IPC::Message*
Reply_FillHandlerInfo(int32_t routingId);

IPC::Message*
Msg_ExistsForProtocolOS(int32_t routingId);
IPC::Message*
Reply_ExistsForProtocolOS(int32_t routingId);

IPC::Message*
Msg_ExistsForProtocol(int32_t routingId);
IPC::Message*
Reply_ExistsForProtocol(int32_t routingId);

IPC::Message*
Msg_Exists(int32_t routingId);
IPC::Message*
Reply_Exists(int32_t routingId);

IPC::Message*
Msg_GetTypeFromExtension(int32_t routingId);
IPC::Message*
Reply_GetTypeFromExtension(int32_t routingId);

IPC::Message*
Msg_GetMIMEInfoFromOS(int32_t routingId);
IPC::Message*
Reply_GetMIMEInfoFromOS(int32_t routingId);

IPC::Message*
Msg_GetApplicationDescription(int32_t routingId);
IPC::Message*
Reply_GetApplicationDescription(int32_t routingId);

IPC::Message*
Msg___delete__(int32_t routingId);
IPC::Message*
Reply___delete__(int32_t routingId);



} // namespace PHandlerService
} // namespace dom
} // namespace mozilla

#endif // ifndef PHandlerService_h
