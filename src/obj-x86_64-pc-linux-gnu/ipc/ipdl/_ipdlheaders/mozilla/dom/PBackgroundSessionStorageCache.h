//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PBackgroundSessionStorageCache_h
#define PBackgroundSessionStorageCache_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SSSetItemInfo|
//
namespace mozilla {
namespace dom {
class SSSetItemInfo final
{
private:

public:
    MOZ_IMPLICIT SSSetItemInfo() :
        key_(),
        value_()
    {
    }

    MOZ_IMPLICIT SSSetItemInfo(
            const nsString& _key,
            const nsString& _value) :
        key_(_key),
        value_(_value)
    {
    }

    nsString&
    key()
    {
        return key_;
    }
    const nsString&
    key() const
    {
        return key_;
    }

    nsString&
    value()
    {
        return value_;
    }
    const nsString&
    value() const
    {
        return value_;
    }

private:
    nsString key_;
    nsString value_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::SSSetItemInfo>
{
    typedef mozilla::dom::SSSetItemInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SSRemoveItemInfo|
//
namespace mozilla {
namespace dom {
class SSRemoveItemInfo final
{
private:

public:
    MOZ_IMPLICIT SSRemoveItemInfo() :
        key_()
    {
    }

    MOZ_IMPLICIT SSRemoveItemInfo(const nsString& _key) :
        key_(_key)
    {
    }

    nsString&
    key()
    {
        return key_;
    }
    const nsString&
    key() const
    {
        return key_;
    }

private:
    nsString key_;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::SSRemoveItemInfo>
{
    typedef mozilla::dom::SSRemoveItemInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SSClearInfo|
//
namespace mozilla {
namespace dom {
class SSClearInfo final
{
private:

public:
    MOZ_IMPLICIT SSClearInfo()
    {
    }

private:
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::SSClearInfo>
{
    typedef mozilla::dom::SSClearInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union SSWriteInfo|
//
namespace mozilla {
namespace dom {
class SSWriteInfo final
{
public:
    enum Type {
        T__None,
        TSSSetItemInfo = 1,
        TSSRemoveItemInfo,
        TSSClearInfo,
        T__Last = TSSClearInfo
    };

private:
    typedef mozilla::dom::SSSetItemInfo SSSetItemInfo;
    typedef mozilla::dom::SSRemoveItemInfo SSRemoveItemInfo;
    typedef mozilla::dom::SSClearInfo SSClearInfo;
    typedef SSSetItemInfo SSSetItemInfo__tdef;
    typedef SSRemoveItemInfo SSRemoveItemInfo__tdef;
    typedef SSClearInfo SSClearInfo__tdef;

    union Value {
        mozilla::AlignedStorage2<SSSetItemInfo> VSSSetItemInfo;
        mozilla::AlignedStorage2<SSRemoveItemInfo> VSSRemoveItemInfo;
        mozilla::AlignedStorage2<SSClearInfo> VSSClearInfo;
    };

    SSSetItemInfo*
    ptr_SSSetItemInfo()
    {
        return ((mValue).VSSSetItemInfo).addr();
    }
    const SSSetItemInfo*
    constptr_SSSetItemInfo() const
    {
        return ((mValue).VSSSetItemInfo).addr();
    }
    SSRemoveItemInfo*
    ptr_SSRemoveItemInfo()
    {
        return ((mValue).VSSRemoveItemInfo).addr();
    }
    const SSRemoveItemInfo*
    constptr_SSRemoveItemInfo() const
    {
        return ((mValue).VSSRemoveItemInfo).addr();
    }
    SSClearInfo*
    ptr_SSClearInfo()
    {
        return ((mValue).VSSClearInfo).addr();
    }
    const SSClearInfo*
    constptr_SSClearInfo() const
    {
        return ((mValue).VSSClearInfo).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT SSWriteInfo() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT SSWriteInfo(const SSSetItemInfo& aOther);

    MOZ_IMPLICIT SSWriteInfo(SSSetItemInfo&& aOther);

    MOZ_IMPLICIT SSWriteInfo(const SSRemoveItemInfo& aOther);

    MOZ_IMPLICIT SSWriteInfo(SSRemoveItemInfo&& aOther);

    MOZ_IMPLICIT SSWriteInfo(const SSClearInfo& aOther);

    MOZ_IMPLICIT SSWriteInfo(SSClearInfo&& aOther);

    MOZ_IMPLICIT SSWriteInfo(const SSWriteInfo& aOther);

    MOZ_IMPLICIT SSWriteInfo(SSWriteInfo&& aOther);

    ~SSWriteInfo();

    Type
    type() const
    {
        return mType;
    }

    SSWriteInfo&
    operator=(const SSSetItemInfo& aRhs);

    SSWriteInfo&
    operator=(SSSetItemInfo&& aRhs);

    SSWriteInfo&
    operator=(const SSRemoveItemInfo& aRhs);

    SSWriteInfo&
    operator=(SSRemoveItemInfo&& aRhs);

    SSWriteInfo&
    operator=(const SSClearInfo& aRhs);

    SSWriteInfo&
    operator=(SSClearInfo&& aRhs);

    SSWriteInfo&
    operator=(const SSWriteInfo& aRhs);

    SSWriteInfo&
    operator=(SSWriteInfo&& aRhs);

    SSSetItemInfo&
    get_SSSetItemInfo()
    {
        AssertSanity(TSSSetItemInfo);
        return (*(ptr_SSSetItemInfo()));
    }
    const SSSetItemInfo&
    get_SSSetItemInfo() const
    {
        AssertSanity(TSSSetItemInfo);
        return (*(constptr_SSSetItemInfo()));
    }
    operator SSSetItemInfo&()
    {
        return get_SSSetItemInfo();
    }
    operator const SSSetItemInfo&() const
    {
        return get_SSSetItemInfo();
    }

    SSRemoveItemInfo&
    get_SSRemoveItemInfo()
    {
        AssertSanity(TSSRemoveItemInfo);
        return (*(ptr_SSRemoveItemInfo()));
    }
    const SSRemoveItemInfo&
    get_SSRemoveItemInfo() const
    {
        AssertSanity(TSSRemoveItemInfo);
        return (*(constptr_SSRemoveItemInfo()));
    }
    operator SSRemoveItemInfo&()
    {
        return get_SSRemoveItemInfo();
    }
    operator const SSRemoveItemInfo&() const
    {
        return get_SSRemoveItemInfo();
    }

    SSClearInfo&
    get_SSClearInfo()
    {
        AssertSanity(TSSClearInfo);
        return (*(ptr_SSClearInfo()));
    }
    const SSClearInfo&
    get_SSClearInfo() const
    {
        AssertSanity(TSSClearInfo);
        return (*(constptr_SSClearInfo()));
    }
    operator SSClearInfo&()
    {
        return get_SSClearInfo();
    }
    operator const SSClearInfo&() const
    {
        return get_SSClearInfo();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::SSWriteInfo>
{
    typedef mozilla::dom::SSWriteInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace dom {
class PBackgroundSessionStorageCacheParent;
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
class PBackgroundSessionStorageCacheChild;
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Code common to PBackgroundSessionStorageCacheChild and PBackgroundSessionStorageCacheParent
//
namespace mozilla {
namespace dom {
namespace PBackgroundSessionStorageCache {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::dom::PBackgroundSessionStorageCacheParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::dom::PBackgroundSessionStorageCacheChild>* aChild);

enum MessageType {
    PBackgroundSessionStorageCacheStart = PBackgroundSessionStorageCacheMsgStart << 16,
    Msg_DeleteMe__ID,
    Msg_Load__ID,
    Reply_Load__ID,
    Msg_Checkpoint__ID,
    Msg___delete____ID,
    Reply___delete____ID,
    PBackgroundSessionStorageCacheEnd
};

IPC::Message*
Msg_DeleteMe(int32_t routingId);

IPC::Message*
Msg_Load(int32_t routingId);
IPC::Message*
Reply_Load(int32_t routingId);

IPC::Message*
Msg_Checkpoint(int32_t routingId);

IPC::Message*
Msg___delete__(int32_t routingId);
IPC::Message*
Reply___delete__(int32_t routingId);



} // namespace PBackgroundSessionStorageCache
} // namespace dom
} // namespace mozilla

#endif // ifndef PBackgroundSessionStorageCache_h
