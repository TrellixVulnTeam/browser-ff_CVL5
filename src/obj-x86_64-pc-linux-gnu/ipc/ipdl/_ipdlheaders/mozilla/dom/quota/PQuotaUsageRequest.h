//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PQuotaUsageRequest_h
#define PQuotaUsageRequest_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OriginUsage|
//
namespace mozilla {
namespace dom {
namespace quota {
class OriginUsage final
{
private:

public:
    MOZ_IMPLICIT OriginUsage() :
        origin_(),
        persisted_(),
        usage_(),
        lastAccessed_()
    {
    }

    MOZ_IMPLICIT OriginUsage(
            const nsCString& _origin,
            const bool& _persisted,
            const uint64_t& _usage,
            const uint64_t& _lastAccessed) :
        origin_(_origin),
        persisted_(_persisted),
        usage_(_usage),
        lastAccessed_(_lastAccessed)
    {
    }

    nsCString&
    origin()
    {
        return origin_;
    }
    const nsCString&
    origin() const
    {
        return origin_;
    }

    bool&
    persisted()
    {
        return persisted_;
    }
    const bool&
    persisted() const
    {
        return persisted_;
    }

    uint64_t&
    usage()
    {
        return usage_;
    }
    const uint64_t&
    usage() const
    {
        return usage_;
    }

    uint64_t&
    lastAccessed()
    {
        return lastAccessed_;
    }
    const uint64_t&
    lastAccessed() const
    {
        return lastAccessed_;
    }

private:
    void
    StaticAssertions() const;
    nsCString origin_;
    bool persisted_;
    uint64_t usage_;
    uint64_t lastAccessed_;
};
} // namespace quota
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::quota::OriginUsage>
{
    typedef mozilla::dom::quota::OriginUsage paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct AllUsageResponse|
//
namespace mozilla {
namespace dom {
namespace quota {
class AllUsageResponse final
{
private:
    typedef mozilla::dom::quota::OriginUsage OriginUsage;

public:
    MOZ_IMPLICIT AllUsageResponse() :
        originUsages_()
    {
    }

    MOZ_IMPLICIT AllUsageResponse(const nsTArray<OriginUsage>& _originUsages) :
        originUsages_(_originUsages)
    {
    }

    nsTArray<OriginUsage>&
    originUsages()
    {
        return originUsages_;
    }
    const nsTArray<OriginUsage>&
    originUsages() const
    {
        return originUsages_;
    }

private:
    CopyableTArray<OriginUsage> originUsages_;
};
} // namespace quota
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::quota::AllUsageResponse>
{
    typedef mozilla::dom::quota::AllUsageResponse paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct OriginUsageResponse|
//
namespace mozilla {
namespace dom {
namespace quota {
class OriginUsageResponse final
{
private:

public:
    MOZ_IMPLICIT OriginUsageResponse() :
        usage_(),
        fileUsage_()
    {
    }

    MOZ_IMPLICIT OriginUsageResponse(
            const uint64_t& _usage,
            const uint64_t& _fileUsage) :
        usage_(_usage),
        fileUsage_(_fileUsage)
    {
    }

    uint64_t&
    usage()
    {
        return usage_;
    }
    const uint64_t&
    usage() const
    {
        return usage_;
    }

    uint64_t&
    fileUsage()
    {
        return fileUsage_;
    }
    const uint64_t&
    fileUsage() const
    {
        return fileUsage_;
    }

private:
    void
    StaticAssertions() const;
    uint64_t usage_;
    uint64_t fileUsage_;
};
} // namespace quota
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::quota::OriginUsageResponse>
{
    typedef mozilla::dom::quota::OriginUsageResponse paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union UsageRequestResponse|
//
namespace mozilla {
namespace dom {
namespace quota {
class UsageRequestResponse final
{
public:
    enum Type {
        T__None,
        Tnsresult = 1,
        TAllUsageResponse,
        TOriginUsageResponse,
        T__Last = TOriginUsageResponse
    };

private:
    typedef mozilla::dom::quota::AllUsageResponse AllUsageResponse;
    typedef mozilla::dom::quota::OriginUsageResponse OriginUsageResponse;
    typedef nsresult nsresult__tdef;
    typedef AllUsageResponse AllUsageResponse__tdef;
    typedef OriginUsageResponse OriginUsageResponse__tdef;

    union Value {
        mozilla::AlignedStorage2<nsresult> Vnsresult;
        mozilla::AlignedStorage2<AllUsageResponse> VAllUsageResponse;
        mozilla::AlignedStorage2<OriginUsageResponse> VOriginUsageResponse;
    };

    nsresult*
    ptr_nsresult()
    {
        return ((mValue).Vnsresult).addr();
    }
    const nsresult*
    constptr_nsresult() const
    {
        return ((mValue).Vnsresult).addr();
    }
    AllUsageResponse*
    ptr_AllUsageResponse()
    {
        return ((mValue).VAllUsageResponse).addr();
    }
    const AllUsageResponse*
    constptr_AllUsageResponse() const
    {
        return ((mValue).VAllUsageResponse).addr();
    }
    OriginUsageResponse*
    ptr_OriginUsageResponse()
    {
        return ((mValue).VOriginUsageResponse).addr();
    }
    const OriginUsageResponse*
    constptr_OriginUsageResponse() const
    {
        return ((mValue).VOriginUsageResponse).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT UsageRequestResponse() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT UsageRequestResponse(const nsresult& aOther);

    MOZ_IMPLICIT UsageRequestResponse(nsresult&& aOther);

    MOZ_IMPLICIT UsageRequestResponse(const AllUsageResponse& aOther);

    MOZ_IMPLICIT UsageRequestResponse(AllUsageResponse&& aOther);

    MOZ_IMPLICIT UsageRequestResponse(const OriginUsageResponse& aOther);

    MOZ_IMPLICIT UsageRequestResponse(OriginUsageResponse&& aOther);

    MOZ_IMPLICIT UsageRequestResponse(const UsageRequestResponse& aOther);

    MOZ_IMPLICIT UsageRequestResponse(UsageRequestResponse&& aOther);

    ~UsageRequestResponse();

    Type
    type() const
    {
        return mType;
    }

    UsageRequestResponse&
    operator=(const nsresult& aRhs);

    UsageRequestResponse&
    operator=(nsresult&& aRhs);

    UsageRequestResponse&
    operator=(const AllUsageResponse& aRhs);

    UsageRequestResponse&
    operator=(AllUsageResponse&& aRhs);

    UsageRequestResponse&
    operator=(const OriginUsageResponse& aRhs);

    UsageRequestResponse&
    operator=(OriginUsageResponse&& aRhs);

    UsageRequestResponse&
    operator=(const UsageRequestResponse& aRhs);

    UsageRequestResponse&
    operator=(UsageRequestResponse&& aRhs);

    nsresult&
    get_nsresult()
    {
        AssertSanity(Tnsresult);
        return (*(ptr_nsresult()));
    }
    const nsresult&
    get_nsresult() const
    {
        AssertSanity(Tnsresult);
        return (*(constptr_nsresult()));
    }
    operator nsresult&()
    {
        return get_nsresult();
    }
    operator const nsresult&() const
    {
        return get_nsresult();
    }

    AllUsageResponse&
    get_AllUsageResponse()
    {
        AssertSanity(TAllUsageResponse);
        return (*(ptr_AllUsageResponse()));
    }
    const AllUsageResponse&
    get_AllUsageResponse() const
    {
        AssertSanity(TAllUsageResponse);
        return (*(constptr_AllUsageResponse()));
    }
    operator AllUsageResponse&()
    {
        return get_AllUsageResponse();
    }
    operator const AllUsageResponse&() const
    {
        return get_AllUsageResponse();
    }

    OriginUsageResponse&
    get_OriginUsageResponse()
    {
        AssertSanity(TOriginUsageResponse);
        return (*(ptr_OriginUsageResponse()));
    }
    const OriginUsageResponse&
    get_OriginUsageResponse() const
    {
        AssertSanity(TOriginUsageResponse);
        return (*(constptr_OriginUsageResponse()));
    }
    operator OriginUsageResponse&()
    {
        return get_OriginUsageResponse();
    }
    operator const OriginUsageResponse&() const
    {
        return get_OriginUsageResponse();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace quota
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::dom::quota::UsageRequestResponse>
{
    typedef mozilla::dom::quota::UsageRequestResponse paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace dom {
namespace quota {
class PQuotaUsageRequestParent;
} // namespace quota
} // namespace dom
} // namespace mozilla
namespace mozilla {
namespace dom {
namespace quota {
class PQuotaUsageRequestChild;
} // namespace quota
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Code common to PQuotaUsageRequestChild and PQuotaUsageRequestParent
//
namespace mozilla {
namespace dom {
namespace quota {
namespace PQuotaUsageRequest {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::dom::quota::PQuotaUsageRequestParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::dom::quota::PQuotaUsageRequestChild>* aChild);

enum MessageType {
    PQuotaUsageRequestStart = PQuotaUsageRequestMsgStart << 16,
    Msg_Cancel__ID,
    Msg___delete____ID,
    Reply___delete____ID,
    PQuotaUsageRequestEnd
};

IPC::Message*
Msg_Cancel(int32_t routingId);

IPC::Message*
Msg___delete__(int32_t routingId);
IPC::Message*
Reply___delete__(int32_t routingId);



} // namespace PQuotaUsageRequest
} // namespace quota
} // namespace dom
} // namespace mozilla

#endif // ifndef PQuotaUsageRequest_h
