//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef ProfilerTypes_h
#define ProfilerTypes_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "mozilla/TimeStamp.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ProfilerInitParams|
//
namespace mozilla {
class ProfilerInitParams final
{
private:

public:
    MOZ_IMPLICIT ProfilerInitParams() :
        enabled_(),
        duration_(),
        filters_(),
        interval_(),
        activeBrowsingContextID_(),
        entries_(),
        features_()
    {
    }

    MOZ_IMPLICIT ProfilerInitParams(
            const bool& _enabled,
            const uint32_t& _entries,
            const mozilla::Maybe<double>& _duration,
            const double& _interval,
            const uint32_t& _features,
            const uint64_t& _activeBrowsingContextID,
            const nsTArray<nsCString>& _filters) :
        enabled_(_enabled),
        duration_(_duration),
        filters_(_filters),
        interval_(_interval),
        activeBrowsingContextID_(_activeBrowsingContextID),
        entries_(_entries),
        features_(_features)
    {
    }

    bool&
    enabled()
    {
        return enabled_;
    }
    const bool&
    enabled() const
    {
        return enabled_;
    }

    uint32_t&
    entries()
    {
        return entries_;
    }
    const uint32_t&
    entries() const
    {
        return entries_;
    }

    mozilla::Maybe<double>&
    duration()
    {
        return duration_;
    }
    const mozilla::Maybe<double>&
    duration() const
    {
        return duration_;
    }

    double&
    interval()
    {
        return interval_;
    }
    const double&
    interval() const
    {
        return interval_;
    }

    uint32_t&
    features()
    {
        return features_;
    }
    const uint32_t&
    features() const
    {
        return features_;
    }

    uint64_t&
    activeBrowsingContextID()
    {
        return activeBrowsingContextID_;
    }
    const uint64_t&
    activeBrowsingContextID() const
    {
        return activeBrowsingContextID_;
    }

    nsTArray<nsCString>&
    filters()
    {
        return filters_;
    }
    const nsTArray<nsCString>&
    filters() const
    {
        return filters_;
    }

private:
    void
    StaticAssertions() const;
    bool enabled_;
    mozilla::Maybe<double> duration_;
    CopyableTArray<nsCString> filters_;
    double interval_;
    uint64_t activeBrowsingContextID_;
    uint32_t entries_;
    uint32_t features_;
};
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ProfilerInitParams>
{
    typedef mozilla::ProfilerInitParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ProfileBufferChunkMetadata|
//
namespace mozilla {
class ProfileBufferChunkMetadata final
{
private:
    typedef mozilla::TimeStamp TimeStamp;

public:
    MOZ_IMPLICIT ProfileBufferChunkMetadata() :
        doneTimeStamp_(),
        bufferBytes_()
    {
    }

    MOZ_IMPLICIT ProfileBufferChunkMetadata(
            const TimeStamp& _doneTimeStamp,
            const uint32_t& _bufferBytes) :
        doneTimeStamp_(_doneTimeStamp),
        bufferBytes_(_bufferBytes)
    {
    }

    TimeStamp&
    doneTimeStamp()
    {
        return doneTimeStamp_;
    }
    const TimeStamp&
    doneTimeStamp() const
    {
        return doneTimeStamp_;
    }

    uint32_t&
    bufferBytes()
    {
        return bufferBytes_;
    }
    const uint32_t&
    bufferBytes() const
    {
        return bufferBytes_;
    }

private:
    TimeStamp doneTimeStamp_;
    uint32_t bufferBytes_;
};
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ProfileBufferChunkMetadata>
{
    typedef mozilla::ProfileBufferChunkMetadata paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ProfileBufferChunkManagerUpdate|
//
namespace mozilla {
class ProfileBufferChunkManagerUpdate final
{
private:
    typedef mozilla::TimeStamp TimeStamp;
    typedef mozilla::ProfileBufferChunkMetadata ProfileBufferChunkMetadata;

public:
    MOZ_IMPLICIT ProfileBufferChunkManagerUpdate() :
        oldestDoneTimeStamp_(),
        newlyReleasedChunks_(),
        unreleasedBytes_(),
        releasedBytes_()
    {
    }

    MOZ_IMPLICIT ProfileBufferChunkManagerUpdate(
            const uint64_t& _unreleasedBytes,
            const uint64_t& _releasedBytes,
            const TimeStamp& _oldestDoneTimeStamp,
            const nsTArray<ProfileBufferChunkMetadata>& _newlyReleasedChunks) :
        oldestDoneTimeStamp_(_oldestDoneTimeStamp),
        newlyReleasedChunks_(_newlyReleasedChunks),
        unreleasedBytes_(_unreleasedBytes),
        releasedBytes_(_releasedBytes)
    {
    }

    uint64_t&
    unreleasedBytes()
    {
        return unreleasedBytes_;
    }
    const uint64_t&
    unreleasedBytes() const
    {
        return unreleasedBytes_;
    }

    uint64_t&
    releasedBytes()
    {
        return releasedBytes_;
    }
    const uint64_t&
    releasedBytes() const
    {
        return releasedBytes_;
    }

    TimeStamp&
    oldestDoneTimeStamp()
    {
        return oldestDoneTimeStamp_;
    }
    const TimeStamp&
    oldestDoneTimeStamp() const
    {
        return oldestDoneTimeStamp_;
    }

    nsTArray<ProfileBufferChunkMetadata>&
    newlyReleasedChunks()
    {
        return newlyReleasedChunks_;
    }
    const nsTArray<ProfileBufferChunkMetadata>&
    newlyReleasedChunks() const
    {
        return newlyReleasedChunks_;
    }

private:
    void
    StaticAssertions() const;
    TimeStamp oldestDoneTimeStamp_;
    CopyableTArray<ProfileBufferChunkMetadata> newlyReleasedChunks_;
    uint64_t unreleasedBytes_;
    uint64_t releasedBytes_;
};
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::ProfileBufferChunkManagerUpdate>
{
    typedef mozilla::ProfileBufferChunkManagerUpdate paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

#endif // ifndef ProfilerTypes_h
