//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef LookAndFeelTypes_h
#define LookAndFeelTypes_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "mozilla/widget/WidgetMessageUtils.h"
#include "nsColor.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct LookAndFeelInt|
//
namespace mozilla {
namespace widget {
class LookAndFeelInt final
{
private:
    typedef mozilla::LookAndFeel::IntID IntID;

public:
    MOZ_IMPLICIT LookAndFeelInt() :
        id_(),
        value_()
    {
    }

    MOZ_IMPLICIT LookAndFeelInt(
            const IntID& _id,
            const int32_t& _value) :
        id_(_id),
        value_(_value)
    {
    }

    IntID&
    id()
    {
        return id_;
    }
    const IntID&
    id() const
    {
        return id_;
    }

    int32_t&
    value()
    {
        return value_;
    }
    const int32_t&
    value() const
    {
        return value_;
    }

private:
    IntID id_;
    int32_t value_;
};
} // namespace widget
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::widget::LookAndFeelInt>
{
    typedef mozilla::widget::LookAndFeelInt paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct LookAndFeelFont|
//
namespace mozilla {
namespace widget {
class LookAndFeelFont final
{
private:

public:
    MOZ_IMPLICIT LookAndFeelFont() :
        haveFont_(),
        name_(),
        italic_(),
        size_(),
        weight_()
    {
    }

    MOZ_IMPLICIT LookAndFeelFont(
            const bool& _haveFont,
            const nsString& _name,
            const float& _size,
            const float& _weight,
            const bool& _italic) :
        haveFont_(_haveFont),
        name_(_name),
        italic_(_italic),
        size_(_size),
        weight_(_weight)
    {
    }

    bool
    operator==(const LookAndFeelFont& _o) const;

    bool
    operator!=(const LookAndFeelFont& _o) const;

    bool&
    haveFont()
    {
        return haveFont_;
    }
    const bool&
    haveFont() const
    {
        return haveFont_;
    }

    nsString&
    name()
    {
        return name_;
    }
    const nsString&
    name() const
    {
        return name_;
    }

    float&
    size()
    {
        return size_;
    }
    const float&
    size() const
    {
        return size_;
    }

    float&
    weight()
    {
        return weight_;
    }
    const float&
    weight() const
    {
        return weight_;
    }

    bool&
    italic()
    {
        return italic_;
    }
    const bool&
    italic() const
    {
        return italic_;
    }

private:
    void
    StaticAssertions() const;
    bool haveFont_;
    nsString name_;
    bool italic_;
    float size_;
    float weight_;
};
} // namespace widget
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::widget::LookAndFeelFont>
{
    typedef mozilla::widget::LookAndFeelFont paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct LookAndFeelColor|
//
namespace mozilla {
namespace widget {
class LookAndFeelColor final
{
private:
    typedef mozilla::LookAndFeel::ColorID ColorID;

public:
    MOZ_IMPLICIT LookAndFeelColor() :
        id_(),
        color_()
    {
    }

    MOZ_IMPLICIT LookAndFeelColor(
            const ColorID& _id,
            const nscolor& _color) :
        id_(_id),
        color_(_color)
    {
    }

    ColorID&
    id()
    {
        return id_;
    }
    const ColorID&
    id() const
    {
        return id_;
    }

    nscolor&
    color()
    {
        return color_;
    }
    const nscolor&
    color() const
    {
        return color_;
    }

private:
    ColorID id_;
    nscolor color_;
};
} // namespace widget
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::widget::LookAndFeelColor>
{
    typedef mozilla::widget::LookAndFeelColor paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct LookAndFeelCache|
//
namespace mozilla {
namespace widget {
class LookAndFeelCache final
{
private:
    typedef mozilla::widget::LookAndFeelInt LookAndFeelInt;
    typedef mozilla::widget::LookAndFeelFont LookAndFeelFont;
    typedef mozilla::widget::LookAndFeelColor LookAndFeelColor;

public:
    MOZ_IMPLICIT LookAndFeelCache() :
        mInts_(),
        mFonts_(),
        mColors_()
    {
    }

    MOZ_IMPLICIT LookAndFeelCache(
            const nsTArray<LookAndFeelInt>& _mInts,
            const nsTArray<LookAndFeelFont>& _mFonts,
            const nsTArray<LookAndFeelColor>& _mColors) :
        mInts_(_mInts),
        mFonts_(_mFonts),
        mColors_(_mColors)
    {
    }

    nsTArray<LookAndFeelInt>&
    mInts()
    {
        return mInts_;
    }
    const nsTArray<LookAndFeelInt>&
    mInts() const
    {
        return mInts_;
    }

    nsTArray<LookAndFeelFont>&
    mFonts()
    {
        return mFonts_;
    }
    const nsTArray<LookAndFeelFont>&
    mFonts() const
    {
        return mFonts_;
    }

    nsTArray<LookAndFeelColor>&
    mColors()
    {
        return mColors_;
    }
    const nsTArray<LookAndFeelColor>&
    mColors() const
    {
        return mColors_;
    }

private:
    CopyableTArray<LookAndFeelInt> mInts_;
    CopyableTArray<LookAndFeelFont> mFonts_;
    CopyableTArray<LookAndFeelColor> mColors_;
};
} // namespace widget
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::widget::LookAndFeelCache>
{
    typedef mozilla::widget::LookAndFeelCache paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct LookAndFeelTables|
//
namespace mozilla {
namespace widget {
class LookAndFeelTables final
{
private:
    typedef mozilla::widget::LookAndFeelFont LookAndFeelFont;

public:
    MOZ_IMPLICIT LookAndFeelTables() :
        ints_(),
        floats_(),
        colors_(),
        fonts_(),
        intMap_(),
        floatMap_(),
        colorMap_(),
        fontMap_(),
        passwordEcho_(),
        passwordChar_()
    {
    }

    MOZ_IMPLICIT LookAndFeelTables(
            const nsTArray<int32_t>& _ints,
            const nsTArray<float>& _floats,
            const nsTArray<nscolor>& _colors,
            const nsTArray<LookAndFeelFont>& _fonts,
            const nsTArray<uint8_t>& _intMap,
            const nsTArray<uint8_t>& _floatMap,
            const nsTArray<uint8_t>& _colorMap,
            const nsTArray<uint8_t>& _fontMap,
            const uint16_t& _passwordChar,
            const bool& _passwordEcho) :
        ints_(_ints),
        floats_(_floats),
        colors_(_colors),
        fonts_(_fonts),
        intMap_(_intMap),
        floatMap_(_floatMap),
        colorMap_(_colorMap),
        fontMap_(_fontMap),
        passwordEcho_(_passwordEcho),
        passwordChar_(_passwordChar)
    {
    }

    nsTArray<int32_t>&
    ints()
    {
        return ints_;
    }
    const nsTArray<int32_t>&
    ints() const
    {
        return ints_;
    }

    nsTArray<float>&
    floats()
    {
        return floats_;
    }
    const nsTArray<float>&
    floats() const
    {
        return floats_;
    }

    nsTArray<nscolor>&
    colors()
    {
        return colors_;
    }
    const nsTArray<nscolor>&
    colors() const
    {
        return colors_;
    }

    nsTArray<LookAndFeelFont>&
    fonts()
    {
        return fonts_;
    }
    const nsTArray<LookAndFeelFont>&
    fonts() const
    {
        return fonts_;
    }

    nsTArray<uint8_t>&
    intMap()
    {
        return intMap_;
    }
    const nsTArray<uint8_t>&
    intMap() const
    {
        return intMap_;
    }

    nsTArray<uint8_t>&
    floatMap()
    {
        return floatMap_;
    }
    const nsTArray<uint8_t>&
    floatMap() const
    {
        return floatMap_;
    }

    nsTArray<uint8_t>&
    colorMap()
    {
        return colorMap_;
    }
    const nsTArray<uint8_t>&
    colorMap() const
    {
        return colorMap_;
    }

    nsTArray<uint8_t>&
    fontMap()
    {
        return fontMap_;
    }
    const nsTArray<uint8_t>&
    fontMap() const
    {
        return fontMap_;
    }

    uint16_t&
    passwordChar()
    {
        return passwordChar_;
    }
    const uint16_t&
    passwordChar() const
    {
        return passwordChar_;
    }

    bool&
    passwordEcho()
    {
        return passwordEcho_;
    }
    const bool&
    passwordEcho() const
    {
        return passwordEcho_;
    }

private:
    CopyableTArray<int32_t> ints_;
    CopyableTArray<float> floats_;
    CopyableTArray<nscolor> colors_;
    CopyableTArray<LookAndFeelFont> fonts_;
    CopyableTArray<uint8_t> intMap_;
    CopyableTArray<uint8_t> floatMap_;
    CopyableTArray<uint8_t> colorMap_;
    CopyableTArray<uint8_t> fontMap_;
    bool passwordEcho_;
    uint16_t passwordChar_;
};
} // namespace widget
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::widget::LookAndFeelTables>
{
    typedef mozilla::widget::LookAndFeelTables paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct LookAndFeelTheme|
//
namespace mozilla {
namespace widget {
class LookAndFeelTheme final
{
private:

public:
    MOZ_IMPLICIT LookAndFeelTheme() :
        themeName_(),
        preferDarkTheme_()
    {
    }

    MOZ_IMPLICIT LookAndFeelTheme(
            const nsCString& _themeName,
            const bool& _preferDarkTheme) :
        themeName_(_themeName),
        preferDarkTheme_(_preferDarkTheme)
    {
    }

    nsCString&
    themeName()
    {
        return themeName_;
    }
    const nsCString&
    themeName() const
    {
        return themeName_;
    }

    bool&
    preferDarkTheme()
    {
        return preferDarkTheme_;
    }
    const bool&
    preferDarkTheme() const
    {
        return preferDarkTheme_;
    }

private:
    nsCString themeName_;
    bool preferDarkTheme_;
};
} // namespace widget
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::widget::LookAndFeelTheme>
{
    typedef mozilla::widget::LookAndFeelTheme paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct FullLookAndFeel|
//
namespace mozilla {
namespace widget {
class FullLookAndFeel final
{
private:
    typedef mozilla::widget::LookAndFeelTables LookAndFeelTables;
    typedef mozilla::widget::LookAndFeelTheme LookAndFeelTheme;

public:
    MOZ_IMPLICIT FullLookAndFeel() :
        tables_(),
        theme_()
    {
    }

    MOZ_IMPLICIT FullLookAndFeel(
            const LookAndFeelTables& _tables,
            const LookAndFeelTheme& _theme) :
        tables_(_tables),
        theme_(_theme)
    {
    }

    LookAndFeelTables&
    tables()
    {
        return tables_;
    }
    const LookAndFeelTables&
    tables() const
    {
        return tables_;
    }

    LookAndFeelTheme&
    theme()
    {
        return theme_;
    }
    const LookAndFeelTheme&
    theme() const
    {
        return theme_;
    }

private:
    LookAndFeelTables tables_;
    LookAndFeelTheme theme_;
};
} // namespace widget
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::widget::FullLookAndFeel>
{
    typedef mozilla::widget::FullLookAndFeel paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union LookAndFeelData|
//
namespace mozilla {
namespace widget {
class LookAndFeelData final
{
public:
    enum Type {
        T__None,
        TLookAndFeelCache = 1,
        TFullLookAndFeel,
        T__Last = TFullLookAndFeel
    };

private:
    typedef mozilla::widget::LookAndFeelCache LookAndFeelCache;
    typedef mozilla::widget::FullLookAndFeel FullLookAndFeel;
    typedef LookAndFeelCache LookAndFeelCache__tdef;
    typedef FullLookAndFeel FullLookAndFeel__tdef;

    union Value {
        mozilla::AlignedStorage2<LookAndFeelCache> VLookAndFeelCache;
        mozilla::AlignedStorage2<FullLookAndFeel> VFullLookAndFeel;
    };

    LookAndFeelCache*
    ptr_LookAndFeelCache()
    {
        return ((mValue).VLookAndFeelCache).addr();
    }
    const LookAndFeelCache*
    constptr_LookAndFeelCache() const
    {
        return ((mValue).VLookAndFeelCache).addr();
    }
    FullLookAndFeel*
    ptr_FullLookAndFeel()
    {
        return ((mValue).VFullLookAndFeel).addr();
    }
    const FullLookAndFeel*
    constptr_FullLookAndFeel() const
    {
        return ((mValue).VFullLookAndFeel).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT LookAndFeelData() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT LookAndFeelData(const LookAndFeelCache& aOther);

    MOZ_IMPLICIT LookAndFeelData(LookAndFeelCache&& aOther);

    MOZ_IMPLICIT LookAndFeelData(const FullLookAndFeel& aOther);

    MOZ_IMPLICIT LookAndFeelData(FullLookAndFeel&& aOther);

    MOZ_IMPLICIT LookAndFeelData(const LookAndFeelData& aOther);

    MOZ_IMPLICIT LookAndFeelData(LookAndFeelData&& aOther);

    ~LookAndFeelData();

    Type
    type() const
    {
        return mType;
    }

    LookAndFeelData&
    operator=(const LookAndFeelCache& aRhs);

    LookAndFeelData&
    operator=(LookAndFeelCache&& aRhs);

    LookAndFeelData&
    operator=(const FullLookAndFeel& aRhs);

    LookAndFeelData&
    operator=(FullLookAndFeel&& aRhs);

    LookAndFeelData&
    operator=(const LookAndFeelData& aRhs);

    LookAndFeelData&
    operator=(LookAndFeelData&& aRhs);

    LookAndFeelCache&
    get_LookAndFeelCache()
    {
        AssertSanity(TLookAndFeelCache);
        return (*(ptr_LookAndFeelCache()));
    }
    const LookAndFeelCache&
    get_LookAndFeelCache() const
    {
        AssertSanity(TLookAndFeelCache);
        return (*(constptr_LookAndFeelCache()));
    }
    operator LookAndFeelCache&()
    {
        return get_LookAndFeelCache();
    }
    operator const LookAndFeelCache&() const
    {
        return get_LookAndFeelCache();
    }

    FullLookAndFeel&
    get_FullLookAndFeel()
    {
        AssertSanity(TFullLookAndFeel);
        return (*(ptr_FullLookAndFeel()));
    }
    const FullLookAndFeel&
    get_FullLookAndFeel() const
    {
        AssertSanity(TFullLookAndFeel);
        return (*(constptr_FullLookAndFeel()));
    }
    operator FullLookAndFeel&()
    {
        return get_FullLookAndFeel();
    }
    operator const FullLookAndFeel&() const
    {
        return get_FullLookAndFeel();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace widget
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::widget::LookAndFeelData>
{
    typedef mozilla::widget::LookAndFeelData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

#endif // ifndef LookAndFeelTypes_h
