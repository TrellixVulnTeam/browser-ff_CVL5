//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PHttpTransaction_h
#define PHttpTransaction_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "mozilla/net/DNS.h"
#include "mozilla/ipc/IPCStream.h"
#include "mozilla/net/NeckoChannelParams.h"

namespace mozilla {
namespace net {
class PHttpTransactionParent;
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace net {
class PHttpTransactionChild;
} // namespace net
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct H2PushedStreamArg|
//
namespace mozilla {
namespace net {
class H2PushedStreamArg final
{
private:
    typedef mozilla::net::PHttpTransactionParent PHttpTransactionParent;
    typedef mozilla::net::PHttpTransactionChild PHttpTransactionChild;

public:
    MOZ_IMPLICIT H2PushedStreamArg() :
        transWithPushedStreamParent_(),
        transWithPushedStreamChild_(),
        pushedStreamId_()
    {
    }

    MOZ_IMPLICIT H2PushedStreamArg(
            PHttpTransactionParent* _transWithPushedStreamParent,
            PHttpTransactionChild* _transWithPushedStreamChild,
            const uint32_t& _pushedStreamId) :
        transWithPushedStreamParent_(_transWithPushedStreamParent),
        transWithPushedStreamChild_(_transWithPushedStreamChild),
        pushedStreamId_(_pushedStreamId)
    {
    }

    PHttpTransactionParent*&
    transWithPushedStreamParent()
    {
        return transWithPushedStreamParent_;
    }
    PHttpTransactionParent*
    transWithPushedStreamParent() const
    {
        return transWithPushedStreamParent_;
    }

    PHttpTransactionChild*&
    transWithPushedStreamChild()
    {
        return transWithPushedStreamChild_;
    }
    PHttpTransactionChild*
    transWithPushedStreamChild() const
    {
        return transWithPushedStreamChild_;
    }

    uint32_t&
    pushedStreamId()
    {
        return pushedStreamId_;
    }
    const uint32_t&
    pushedStreamId() const
    {
        return pushedStreamId_;
    }

private:
    PHttpTransactionParent* transWithPushedStreamParent_;
    PHttpTransactionChild* transWithPushedStreamChild_;
    uint32_t pushedStreamId_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::H2PushedStreamArg>
{
    typedef mozilla::net::H2PushedStreamArg paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct NetworkAddressArg|
//
namespace mozilla {
namespace net {
class NetworkAddressArg final
{
private:
    typedef mozilla::net::NetAddr NetAddr;

public:
    MOZ_IMPLICIT NetworkAddressArg() :
        selfAddr_(),
        peerAddr_(),
        resolvedByTRR_(),
        echConfigUsed_()
    {
    }

    MOZ_IMPLICIT NetworkAddressArg(
            const NetAddr& _selfAddr,
            const NetAddr& _peerAddr,
            const bool& _resolvedByTRR,
            const bool& _echConfigUsed) :
        selfAddr_(_selfAddr),
        peerAddr_(_peerAddr),
        resolvedByTRR_(_resolvedByTRR),
        echConfigUsed_(_echConfigUsed)
    {
    }

    NetAddr&
    selfAddr()
    {
        return selfAddr_;
    }
    const NetAddr&
    selfAddr() const
    {
        return selfAddr_;
    }

    NetAddr&
    peerAddr()
    {
        return peerAddr_;
    }
    const NetAddr&
    peerAddr() const
    {
        return peerAddr_;
    }

    bool&
    resolvedByTRR()
    {
        return resolvedByTRR_;
    }
    const bool&
    resolvedByTRR() const
    {
        return resolvedByTRR_;
    }

    bool&
    echConfigUsed()
    {
        return echConfigUsed_;
    }
    const bool&
    echConfigUsed() const
    {
        return echConfigUsed_;
    }

private:
    NetAddr selfAddr_;
    NetAddr peerAddr_;
    bool resolvedByTRR_;
    bool echConfigUsed_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::NetworkAddressArg>
{
    typedef mozilla::net::NetworkAddressArg paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
namespace net {
class PHttpTransactionParent;
} // namespace net
} // namespace mozilla
namespace mozilla {
namespace net {
class PHttpTransactionChild;
} // namespace net
} // namespace mozilla

//-----------------------------------------------------------------------------
// Code common to PHttpTransactionChild and PHttpTransactionParent
//
namespace mozilla {
namespace net {
namespace PHttpTransaction {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::net::PHttpTransactionParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::net::PHttpTransactionChild>* aChild);

enum MessageType {
    PHttpTransactionStart = PHttpTransactionMsgStart << 16,
    Msg_OnStartRequest__ID,
    Msg_OnTransportStatus__ID,
    Msg_OnDataAvailable__ID,
    Msg_OnStopRequest__ID,
    Msg_OnInitFailed__ID,
    Msg_OnH2PushStream__ID,
    Msg___delete____ID,
    Reply___delete____ID,
    Msg_Init__ID,
    Msg_CancelPump__ID,
    Msg_SuspendPump__ID,
    Msg_ResumePump__ID,
    Msg_SetDNSWasRefreshed__ID,
    Msg_DontReuseConnection__ID,
    Msg_SetH2WSConnRefTaken__ID,
    PHttpTransactionEnd
};

IPC::Message*
Msg_OnStartRequest(int32_t routingId);

IPC::Message*
Msg_OnTransportStatus(int32_t routingId);

IPC::Message*
Msg_OnDataAvailable(int32_t routingId);

IPC::Message*
Msg_OnStopRequest(int32_t routingId);

IPC::Message*
Msg_OnInitFailed(int32_t routingId);

IPC::Message*
Msg_OnH2PushStream(int32_t routingId);

IPC::Message*
Msg___delete__(int32_t routingId);
IPC::Message*
Reply___delete__(int32_t routingId);

IPC::Message*
Msg_Init(int32_t routingId);

IPC::Message*
Msg_CancelPump(int32_t routingId);

IPC::Message*
Msg_SuspendPump(int32_t routingId);

IPC::Message*
Msg_ResumePump(int32_t routingId);

IPC::Message*
Msg_SetDNSWasRefreshed(int32_t routingId);

IPC::Message*
Msg_DontReuseConnection(int32_t routingId);

IPC::Message*
Msg_SetH2WSConnRefTaken(int32_t routingId);



} // namespace PHttpTransaction
} // namespace net
} // namespace mozilla

#endif // ifndef PHttpTransaction_h
