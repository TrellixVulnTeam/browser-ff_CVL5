//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef NeckoChannelParams_h
#define NeckoChannelParams_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "mozilla/TimeStamp.h"
#include "mozilla/dom/SessionHistoryEntry.h"
#include "mozilla/ipc/BackgroundUtils.h"
#include "mozilla/net/PHttpChannelParams.h"
#include "nsDOMNavigationTiming.h"
#include "nsIContentPolicy.h"
#include "nsILoadInfo.h"
#include "nsIPropertyBag2.h"
#include "mozilla/dom/BlobTypes.h"
#include "mozilla/dom/ClientIPCTypes.h"
#include "mozilla/ipc/URIParams.h"
#include "mozilla/dom/IPCServiceWorkerDescriptor.h"
#include "mozilla/ipc/IPCStream.h"
#include "mozilla/ipc/PBackgroundSharedTypes.h"
#include "mozilla/dom/DOMTypes.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CookiePermissionData|
//
namespace mozilla {
namespace net {
class CookiePermissionData final
{
private:
    typedef mozilla::ipc::PrincipalInfo PrincipalInfo;

public:
    MOZ_IMPLICIT CookiePermissionData() :
        principalInfo_(),
        cookiePermission_()
    {
    }

    MOZ_IMPLICIT CookiePermissionData(
            const PrincipalInfo& _principalInfo,
            const uint32_t& _cookiePermission) :
        principalInfo_(_principalInfo),
        cookiePermission_(_cookiePermission)
    {
    }

    PrincipalInfo&
    principalInfo()
    {
        return principalInfo_;
    }
    const PrincipalInfo&
    principalInfo() const
    {
        return principalInfo_;
    }

    uint32_t&
    cookiePermission()
    {
        return cookiePermission_;
    }
    const uint32_t&
    cookiePermission() const
    {
        return cookiePermission_;
    }

private:
    PrincipalInfo principalInfo_;
    uint32_t cookiePermission_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::CookiePermissionData>
{
    typedef mozilla::net::CookiePermissionData paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CookieJarSettingsArgs|
//
namespace mozilla {
namespace net {
class CookieJarSettingsArgs final
{
private:
    typedef mozilla::net::CookiePermissionData CookiePermissionData;

public:
    MOZ_IMPLICIT CookieJarSettingsArgs() :
        isFirstPartyIsolated_(),
        isOnContentBlockingAllowList_(),
        cookiePermissions_(),
        isFixed_(),
        partitionKey_(),
        cookieBehavior_()
    {
    }

    MOZ_IMPLICIT CookieJarSettingsArgs(
            const uint32_t& _cookieBehavior,
            const bool& _isFirstPartyIsolated,
            const bool& _isOnContentBlockingAllowList,
            const nsTArray<CookiePermissionData>& _cookiePermissions,
            const bool& _isFixed,
            const nsString& _partitionKey) :
        isFirstPartyIsolated_(_isFirstPartyIsolated),
        isOnContentBlockingAllowList_(_isOnContentBlockingAllowList),
        cookiePermissions_(_cookiePermissions),
        isFixed_(_isFixed),
        partitionKey_(_partitionKey),
        cookieBehavior_(_cookieBehavior)
    {
    }

    uint32_t&
    cookieBehavior()
    {
        return cookieBehavior_;
    }
    const uint32_t&
    cookieBehavior() const
    {
        return cookieBehavior_;
    }

    bool&
    isFirstPartyIsolated()
    {
        return isFirstPartyIsolated_;
    }
    const bool&
    isFirstPartyIsolated() const
    {
        return isFirstPartyIsolated_;
    }

    bool&
    isOnContentBlockingAllowList()
    {
        return isOnContentBlockingAllowList_;
    }
    const bool&
    isOnContentBlockingAllowList() const
    {
        return isOnContentBlockingAllowList_;
    }

    nsTArray<CookiePermissionData>&
    cookiePermissions()
    {
        return cookiePermissions_;
    }
    const nsTArray<CookiePermissionData>&
    cookiePermissions() const
    {
        return cookiePermissions_;
    }

    bool&
    isFixed()
    {
        return isFixed_;
    }
    const bool&
    isFixed() const
    {
        return isFixed_;
    }

    nsString&
    partitionKey()
    {
        return partitionKey_;
    }
    const nsString&
    partitionKey() const
    {
        return partitionKey_;
    }

private:
    bool isFirstPartyIsolated_;
    bool isOnContentBlockingAllowList_;
    CopyableTArray<CookiePermissionData> cookiePermissions_;
    bool isFixed_;
    nsString partitionKey_;
    uint32_t cookieBehavior_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::CookieJarSettingsArgs>
{
    typedef mozilla::net::CookieJarSettingsArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct PreferredAlternativeDataTypeParams|
//
namespace mozilla {
namespace net {
class PreferredAlternativeDataTypeParams final
{
private:

public:
    MOZ_IMPLICIT PreferredAlternativeDataTypeParams() :
        type_(),
        contentType_(),
        deliverAltData_()
    {
    }

    MOZ_IMPLICIT PreferredAlternativeDataTypeParams(
            const nsCString& _type,
            const nsCString& _contentType,
            const bool& _deliverAltData) :
        type_(_type),
        contentType_(_contentType),
        deliverAltData_(_deliverAltData)
    {
    }

    nsCString&
    type()
    {
        return type_;
    }
    const nsCString&
    type() const
    {
        return type_;
    }

    nsCString&
    contentType()
    {
        return contentType_;
    }
    const nsCString&
    contentType() const
    {
        return contentType_;
    }

    bool&
    deliverAltData()
    {
        return deliverAltData_;
    }
    const bool&
    deliverAltData() const
    {
        return deliverAltData_;
    }

private:
    nsCString type_;
    nsCString contentType_;
    bool deliverAltData_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::PreferredAlternativeDataTypeParams>
{
    typedef mozilla::net::PreferredAlternativeDataTypeParams paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct RedirectHistoryEntryInfo|
//
namespace mozilla {
namespace net {
class RedirectHistoryEntryInfo final
{
private:
    typedef mozilla::ipc::PrincipalInfo PrincipalInfo;
    typedef mozilla::ipc::URIParams URIParams;

public:
    MOZ_IMPLICIT RedirectHistoryEntryInfo() :
        principalInfo_(),
        referrerUri_(),
        remoteAddress_()
    {
    }

    MOZ_IMPLICIT RedirectHistoryEntryInfo(
            const PrincipalInfo& _principalInfo,
            const mozilla::Maybe<URIParams>& _referrerUri,
            const nsCString& _remoteAddress) :
        principalInfo_(_principalInfo),
        referrerUri_(_referrerUri),
        remoteAddress_(_remoteAddress)
    {
    }

    PrincipalInfo&
    principalInfo()
    {
        return principalInfo_;
    }
    const PrincipalInfo&
    principalInfo() const
    {
        return principalInfo_;
    }

    mozilla::Maybe<URIParams>&
    referrerUri()
    {
        return referrerUri_;
    }
    const mozilla::Maybe<URIParams>&
    referrerUri() const
    {
        return referrerUri_;
    }

    nsCString&
    remoteAddress()
    {
        return remoteAddress_;
    }
    const nsCString&
    remoteAddress() const
    {
        return remoteAddress_;
    }

private:
    PrincipalInfo principalInfo_;
    mozilla::Maybe<URIParams> referrerUri_;
    nsCString remoteAddress_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::RedirectHistoryEntryInfo>
{
    typedef mozilla::net::RedirectHistoryEntryInfo paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct LoadInfoArgs|
//
namespace mozilla {
namespace net {
class LoadInfoArgs final
{
private:
    typedef mozilla::ipc::PrincipalInfo PrincipalInfo;
    typedef mozilla::ipc::URIParams URIParams;
    typedef mozilla::OriginAttributes OriginAttributes;
    typedef mozilla::net::RedirectHistoryEntryInfo RedirectHistoryEntryInfo;
    typedef mozilla::dom::IPCClientInfo IPCClientInfo;
    typedef mozilla::dom::IPCServiceWorkerDescriptor IPCServiceWorkerDescriptor;
    typedef mozilla::net::CookieJarSettingsArgs CookieJarSettingsArgs;
    typedef mozilla::ipc::CSPInfo CSPInfo;
    typedef nsILoadInfo::CrossOriginEmbedderPolicy CrossOriginEmbedderPolicy;

public:
    MOZ_IMPLICIT LoadInfoArgs() :
        requestingPrincipalInfo_(),
        triggeringPrincipalInfo_(),
        principalToInheritInfo_(),
        sandboxedLoadingPrincipalInfo_(),
        topLevelPrincipalInfo_(),
        topLevelStorageAreaPrincipalInfo_(),
        resultPrincipalURI_(),
        contentPolicyType_(),
        blockAllMixedContent_(),
        upgradeInsecureRequests_(),
        browserUpgradeInsecureRequests_(),
        browserDidUpgradeInsecureRequests_(),
        browserWouldUpgradeInsecureRequests_(),
        forceAllowDataURI_(),
        allowInsecureRedirectToDataURI_(),
        bypassCORSChecks_(),
        skipContentPolicyCheckForWebRequest_(),
        originalFrameSrcLoad_(),
        forceInheritPrincipalDropped_(),
        initialSecurityCheckDone_(),
        isInThirdPartyContext_(),
        isThirdPartyContextToTopWindow_(),
        isFormSubmission_(),
        sendCSPViolationEvents_(),
        originAttributes_(),
        redirectChainIncludingInternalRedirects_(),
        redirectChain_(),
        clientInfo_(),
        reservedClientInfo_(),
        initialClientInfo_(),
        controller_(),
        corsUnsafeHeaders_(),
        forcePreflight_(),
        isPreflight_(),
        loadTriggeredFromExternal_(),
        serviceWorkerTaintingSynthesized_(),
        documentHasUserInteracted_(),
        allowListFutureDocumentsCreatedFromThisRedirectChain_(),
        cspNonce_(),
        skipContentSniffing_(),
        hasValidUserGestureActivation_(),
        allowDeprecatedSystemRequests_(),
        isInDevToolsContext_(),
        parserCreatedScript_(),
        isFromProcessingFrameAttributes_(),
        cookieJarSettings_(),
        cspToInheritInfo_(),
        hasStoragePermission_(),
        loadingEmbedderPolicy_(),
        innerWindowID_(),
        browsingContextID_(),
        frameBrowsingContextID_(),
        securityFlags_(),
        sandboxFlags_(),
        triggeringSandboxFlags_(),
        tainting_(),
        httpsOnlyStatus_(),
        requestBlockingReason_()
    {
    }

    MOZ_IMPLICIT LoadInfoArgs(
            const mozilla::Maybe<PrincipalInfo>& _requestingPrincipalInfo,
            const PrincipalInfo& _triggeringPrincipalInfo,
            const mozilla::Maybe<PrincipalInfo>& _principalToInheritInfo,
            const mozilla::Maybe<PrincipalInfo>& _sandboxedLoadingPrincipalInfo,
            const mozilla::Maybe<PrincipalInfo>& _topLevelPrincipalInfo,
            const mozilla::Maybe<PrincipalInfo>& _topLevelStorageAreaPrincipalInfo,
            const mozilla::Maybe<URIParams>& _resultPrincipalURI,
            const uint32_t& _securityFlags,
            const uint32_t& _sandboxFlags,
            const uint32_t& _triggeringSandboxFlags,
            const nsContentPolicyType& _contentPolicyType,
            const uint32_t& _tainting,
            const bool& _blockAllMixedContent,
            const bool& _upgradeInsecureRequests,
            const bool& _browserUpgradeInsecureRequests,
            const bool& _browserDidUpgradeInsecureRequests,
            const bool& _browserWouldUpgradeInsecureRequests,
            const bool& _forceAllowDataURI,
            const bool& _allowInsecureRedirectToDataURI,
            const bool& _bypassCORSChecks,
            const bool& _skipContentPolicyCheckForWebRequest,
            const bool& _originalFrameSrcLoad,
            const bool& _forceInheritPrincipalDropped,
            const uint64_t& _innerWindowID,
            const uint64_t& _browsingContextID,
            const uint64_t& _frameBrowsingContextID,
            const bool& _initialSecurityCheckDone,
            const bool& _isInThirdPartyContext,
            const bool& _isThirdPartyContextToTopWindow,
            const bool& _isFormSubmission,
            const bool& _sendCSPViolationEvents,
            const OriginAttributes& _originAttributes,
            const nsTArray<RedirectHistoryEntryInfo>& _redirectChainIncludingInternalRedirects,
            const nsTArray<RedirectHistoryEntryInfo>& _redirectChain,
            const mozilla::Maybe<IPCClientInfo>& _clientInfo,
            const mozilla::Maybe<IPCClientInfo>& _reservedClientInfo,
            const mozilla::Maybe<IPCClientInfo>& _initialClientInfo,
            const mozilla::Maybe<IPCServiceWorkerDescriptor>& _controller,
            const nsTArray<nsCString>& _corsUnsafeHeaders,
            const bool& _forcePreflight,
            const bool& _isPreflight,
            const bool& _loadTriggeredFromExternal,
            const bool& _serviceWorkerTaintingSynthesized,
            const bool& _documentHasUserInteracted,
            const bool& _allowListFutureDocumentsCreatedFromThisRedirectChain,
            const nsString& _cspNonce,
            const bool& _skipContentSniffing,
            const uint32_t& _httpsOnlyStatus,
            const bool& _hasValidUserGestureActivation,
            const bool& _allowDeprecatedSystemRequests,
            const bool& _isInDevToolsContext,
            const bool& _parserCreatedScript,
            const bool& _isFromProcessingFrameAttributes,
            const CookieJarSettingsArgs& _cookieJarSettings,
            const uint32_t& _requestBlockingReason,
            const mozilla::Maybe<CSPInfo>& _cspToInheritInfo,
            const bool& _hasStoragePermission,
            const CrossOriginEmbedderPolicy& _loadingEmbedderPolicy) :
        requestingPrincipalInfo_(_requestingPrincipalInfo),
        triggeringPrincipalInfo_(_triggeringPrincipalInfo),
        principalToInheritInfo_(_principalToInheritInfo),
        sandboxedLoadingPrincipalInfo_(_sandboxedLoadingPrincipalInfo),
        topLevelPrincipalInfo_(_topLevelPrincipalInfo),
        topLevelStorageAreaPrincipalInfo_(_topLevelStorageAreaPrincipalInfo),
        resultPrincipalURI_(_resultPrincipalURI),
        contentPolicyType_(_contentPolicyType),
        blockAllMixedContent_(_blockAllMixedContent),
        upgradeInsecureRequests_(_upgradeInsecureRequests),
        browserUpgradeInsecureRequests_(_browserUpgradeInsecureRequests),
        browserDidUpgradeInsecureRequests_(_browserDidUpgradeInsecureRequests),
        browserWouldUpgradeInsecureRequests_(_browserWouldUpgradeInsecureRequests),
        forceAllowDataURI_(_forceAllowDataURI),
        allowInsecureRedirectToDataURI_(_allowInsecureRedirectToDataURI),
        bypassCORSChecks_(_bypassCORSChecks),
        skipContentPolicyCheckForWebRequest_(_skipContentPolicyCheckForWebRequest),
        originalFrameSrcLoad_(_originalFrameSrcLoad),
        forceInheritPrincipalDropped_(_forceInheritPrincipalDropped),
        initialSecurityCheckDone_(_initialSecurityCheckDone),
        isInThirdPartyContext_(_isInThirdPartyContext),
        isThirdPartyContextToTopWindow_(_isThirdPartyContextToTopWindow),
        isFormSubmission_(_isFormSubmission),
        sendCSPViolationEvents_(_sendCSPViolationEvents),
        originAttributes_(_originAttributes),
        redirectChainIncludingInternalRedirects_(_redirectChainIncludingInternalRedirects),
        redirectChain_(_redirectChain),
        clientInfo_(_clientInfo),
        reservedClientInfo_(_reservedClientInfo),
        initialClientInfo_(_initialClientInfo),
        controller_(_controller),
        corsUnsafeHeaders_(_corsUnsafeHeaders),
        forcePreflight_(_forcePreflight),
        isPreflight_(_isPreflight),
        loadTriggeredFromExternal_(_loadTriggeredFromExternal),
        serviceWorkerTaintingSynthesized_(_serviceWorkerTaintingSynthesized),
        documentHasUserInteracted_(_documentHasUserInteracted),
        allowListFutureDocumentsCreatedFromThisRedirectChain_(_allowListFutureDocumentsCreatedFromThisRedirectChain),
        cspNonce_(_cspNonce),
        skipContentSniffing_(_skipContentSniffing),
        hasValidUserGestureActivation_(_hasValidUserGestureActivation),
        allowDeprecatedSystemRequests_(_allowDeprecatedSystemRequests),
        isInDevToolsContext_(_isInDevToolsContext),
        parserCreatedScript_(_parserCreatedScript),
        isFromProcessingFrameAttributes_(_isFromProcessingFrameAttributes),
        cookieJarSettings_(_cookieJarSettings),
        cspToInheritInfo_(_cspToInheritInfo),
        hasStoragePermission_(_hasStoragePermission),
        loadingEmbedderPolicy_(_loadingEmbedderPolicy),
        innerWindowID_(_innerWindowID),
        browsingContextID_(_browsingContextID),
        frameBrowsingContextID_(_frameBrowsingContextID),
        securityFlags_(_securityFlags),
        sandboxFlags_(_sandboxFlags),
        triggeringSandboxFlags_(_triggeringSandboxFlags),
        tainting_(_tainting),
        httpsOnlyStatus_(_httpsOnlyStatus),
        requestBlockingReason_(_requestBlockingReason)
    {
    }

    mozilla::Maybe<PrincipalInfo>&
    requestingPrincipalInfo()
    {
        return requestingPrincipalInfo_;
    }
    const mozilla::Maybe<PrincipalInfo>&
    requestingPrincipalInfo() const
    {
        return requestingPrincipalInfo_;
    }

    PrincipalInfo&
    triggeringPrincipalInfo()
    {
        return triggeringPrincipalInfo_;
    }
    const PrincipalInfo&
    triggeringPrincipalInfo() const
    {
        return triggeringPrincipalInfo_;
    }

    mozilla::Maybe<PrincipalInfo>&
    principalToInheritInfo()
    {
        return principalToInheritInfo_;
    }
    const mozilla::Maybe<PrincipalInfo>&
    principalToInheritInfo() const
    {
        return principalToInheritInfo_;
    }

    mozilla::Maybe<PrincipalInfo>&
    sandboxedLoadingPrincipalInfo()
    {
        return sandboxedLoadingPrincipalInfo_;
    }
    const mozilla::Maybe<PrincipalInfo>&
    sandboxedLoadingPrincipalInfo() const
    {
        return sandboxedLoadingPrincipalInfo_;
    }

    mozilla::Maybe<PrincipalInfo>&
    topLevelPrincipalInfo()
    {
        return topLevelPrincipalInfo_;
    }
    const mozilla::Maybe<PrincipalInfo>&
    topLevelPrincipalInfo() const
    {
        return topLevelPrincipalInfo_;
    }

    mozilla::Maybe<PrincipalInfo>&
    topLevelStorageAreaPrincipalInfo()
    {
        return topLevelStorageAreaPrincipalInfo_;
    }
    const mozilla::Maybe<PrincipalInfo>&
    topLevelStorageAreaPrincipalInfo() const
    {
        return topLevelStorageAreaPrincipalInfo_;
    }

    mozilla::Maybe<URIParams>&
    resultPrincipalURI()
    {
        return resultPrincipalURI_;
    }
    const mozilla::Maybe<URIParams>&
    resultPrincipalURI() const
    {
        return resultPrincipalURI_;
    }

    uint32_t&
    securityFlags()
    {
        return securityFlags_;
    }
    const uint32_t&
    securityFlags() const
    {
        return securityFlags_;
    }

    uint32_t&
    sandboxFlags()
    {
        return sandboxFlags_;
    }
    const uint32_t&
    sandboxFlags() const
    {
        return sandboxFlags_;
    }

    uint32_t&
    triggeringSandboxFlags()
    {
        return triggeringSandboxFlags_;
    }
    const uint32_t&
    triggeringSandboxFlags() const
    {
        return triggeringSandboxFlags_;
    }

    nsContentPolicyType&
    contentPolicyType()
    {
        return contentPolicyType_;
    }
    const nsContentPolicyType&
    contentPolicyType() const
    {
        return contentPolicyType_;
    }

    uint32_t&
    tainting()
    {
        return tainting_;
    }
    const uint32_t&
    tainting() const
    {
        return tainting_;
    }

    bool&
    blockAllMixedContent()
    {
        return blockAllMixedContent_;
    }
    const bool&
    blockAllMixedContent() const
    {
        return blockAllMixedContent_;
    }

    bool&
    upgradeInsecureRequests()
    {
        return upgradeInsecureRequests_;
    }
    const bool&
    upgradeInsecureRequests() const
    {
        return upgradeInsecureRequests_;
    }

    bool&
    browserUpgradeInsecureRequests()
    {
        return browserUpgradeInsecureRequests_;
    }
    const bool&
    browserUpgradeInsecureRequests() const
    {
        return browserUpgradeInsecureRequests_;
    }

    bool&
    browserDidUpgradeInsecureRequests()
    {
        return browserDidUpgradeInsecureRequests_;
    }
    const bool&
    browserDidUpgradeInsecureRequests() const
    {
        return browserDidUpgradeInsecureRequests_;
    }

    bool&
    browserWouldUpgradeInsecureRequests()
    {
        return browserWouldUpgradeInsecureRequests_;
    }
    const bool&
    browserWouldUpgradeInsecureRequests() const
    {
        return browserWouldUpgradeInsecureRequests_;
    }

    bool&
    forceAllowDataURI()
    {
        return forceAllowDataURI_;
    }
    const bool&
    forceAllowDataURI() const
    {
        return forceAllowDataURI_;
    }

    bool&
    allowInsecureRedirectToDataURI()
    {
        return allowInsecureRedirectToDataURI_;
    }
    const bool&
    allowInsecureRedirectToDataURI() const
    {
        return allowInsecureRedirectToDataURI_;
    }

    bool&
    bypassCORSChecks()
    {
        return bypassCORSChecks_;
    }
    const bool&
    bypassCORSChecks() const
    {
        return bypassCORSChecks_;
    }

    bool&
    skipContentPolicyCheckForWebRequest()
    {
        return skipContentPolicyCheckForWebRequest_;
    }
    const bool&
    skipContentPolicyCheckForWebRequest() const
    {
        return skipContentPolicyCheckForWebRequest_;
    }

    bool&
    originalFrameSrcLoad()
    {
        return originalFrameSrcLoad_;
    }
    const bool&
    originalFrameSrcLoad() const
    {
        return originalFrameSrcLoad_;
    }

    bool&
    forceInheritPrincipalDropped()
    {
        return forceInheritPrincipalDropped_;
    }
    const bool&
    forceInheritPrincipalDropped() const
    {
        return forceInheritPrincipalDropped_;
    }

    uint64_t&
    innerWindowID()
    {
        return innerWindowID_;
    }
    const uint64_t&
    innerWindowID() const
    {
        return innerWindowID_;
    }

    uint64_t&
    browsingContextID()
    {
        return browsingContextID_;
    }
    const uint64_t&
    browsingContextID() const
    {
        return browsingContextID_;
    }

    uint64_t&
    frameBrowsingContextID()
    {
        return frameBrowsingContextID_;
    }
    const uint64_t&
    frameBrowsingContextID() const
    {
        return frameBrowsingContextID_;
    }

    bool&
    initialSecurityCheckDone()
    {
        return initialSecurityCheckDone_;
    }
    const bool&
    initialSecurityCheckDone() const
    {
        return initialSecurityCheckDone_;
    }

    bool&
    isInThirdPartyContext()
    {
        return isInThirdPartyContext_;
    }
    const bool&
    isInThirdPartyContext() const
    {
        return isInThirdPartyContext_;
    }

    bool&
    isThirdPartyContextToTopWindow()
    {
        return isThirdPartyContextToTopWindow_;
    }
    const bool&
    isThirdPartyContextToTopWindow() const
    {
        return isThirdPartyContextToTopWindow_;
    }

    bool&
    isFormSubmission()
    {
        return isFormSubmission_;
    }
    const bool&
    isFormSubmission() const
    {
        return isFormSubmission_;
    }

    bool&
    sendCSPViolationEvents()
    {
        return sendCSPViolationEvents_;
    }
    const bool&
    sendCSPViolationEvents() const
    {
        return sendCSPViolationEvents_;
    }

    OriginAttributes&
    originAttributes()
    {
        return originAttributes_;
    }
    const OriginAttributes&
    originAttributes() const
    {
        return originAttributes_;
    }

    nsTArray<RedirectHistoryEntryInfo>&
    redirectChainIncludingInternalRedirects()
    {
        return redirectChainIncludingInternalRedirects_;
    }
    const nsTArray<RedirectHistoryEntryInfo>&
    redirectChainIncludingInternalRedirects() const
    {
        return redirectChainIncludingInternalRedirects_;
    }

    nsTArray<RedirectHistoryEntryInfo>&
    redirectChain()
    {
        return redirectChain_;
    }
    const nsTArray<RedirectHistoryEntryInfo>&
    redirectChain() const
    {
        return redirectChain_;
    }

    mozilla::Maybe<IPCClientInfo>&
    clientInfo()
    {
        return clientInfo_;
    }
    const mozilla::Maybe<IPCClientInfo>&
    clientInfo() const
    {
        return clientInfo_;
    }

    mozilla::Maybe<IPCClientInfo>&
    reservedClientInfo()
    {
        return reservedClientInfo_;
    }
    const mozilla::Maybe<IPCClientInfo>&
    reservedClientInfo() const
    {
        return reservedClientInfo_;
    }

    mozilla::Maybe<IPCClientInfo>&
    initialClientInfo()
    {
        return initialClientInfo_;
    }
    const mozilla::Maybe<IPCClientInfo>&
    initialClientInfo() const
    {
        return initialClientInfo_;
    }

    mozilla::Maybe<IPCServiceWorkerDescriptor>&
    controller()
    {
        return controller_;
    }
    const mozilla::Maybe<IPCServiceWorkerDescriptor>&
    controller() const
    {
        return controller_;
    }

    nsTArray<nsCString>&
    corsUnsafeHeaders()
    {
        return corsUnsafeHeaders_;
    }
    const nsTArray<nsCString>&
    corsUnsafeHeaders() const
    {
        return corsUnsafeHeaders_;
    }

    bool&
    forcePreflight()
    {
        return forcePreflight_;
    }
    const bool&
    forcePreflight() const
    {
        return forcePreflight_;
    }

    bool&
    isPreflight()
    {
        return isPreflight_;
    }
    const bool&
    isPreflight() const
    {
        return isPreflight_;
    }

    bool&
    loadTriggeredFromExternal()
    {
        return loadTriggeredFromExternal_;
    }
    const bool&
    loadTriggeredFromExternal() const
    {
        return loadTriggeredFromExternal_;
    }

    bool&
    serviceWorkerTaintingSynthesized()
    {
        return serviceWorkerTaintingSynthesized_;
    }
    const bool&
    serviceWorkerTaintingSynthesized() const
    {
        return serviceWorkerTaintingSynthesized_;
    }

    bool&
    documentHasUserInteracted()
    {
        return documentHasUserInteracted_;
    }
    const bool&
    documentHasUserInteracted() const
    {
        return documentHasUserInteracted_;
    }

    bool&
    allowListFutureDocumentsCreatedFromThisRedirectChain()
    {
        return allowListFutureDocumentsCreatedFromThisRedirectChain_;
    }
    const bool&
    allowListFutureDocumentsCreatedFromThisRedirectChain() const
    {
        return allowListFutureDocumentsCreatedFromThisRedirectChain_;
    }

    nsString&
    cspNonce()
    {
        return cspNonce_;
    }
    const nsString&
    cspNonce() const
    {
        return cspNonce_;
    }

    bool&
    skipContentSniffing()
    {
        return skipContentSniffing_;
    }
    const bool&
    skipContentSniffing() const
    {
        return skipContentSniffing_;
    }

    uint32_t&
    httpsOnlyStatus()
    {
        return httpsOnlyStatus_;
    }
    const uint32_t&
    httpsOnlyStatus() const
    {
        return httpsOnlyStatus_;
    }

    bool&
    hasValidUserGestureActivation()
    {
        return hasValidUserGestureActivation_;
    }
    const bool&
    hasValidUserGestureActivation() const
    {
        return hasValidUserGestureActivation_;
    }

    bool&
    allowDeprecatedSystemRequests()
    {
        return allowDeprecatedSystemRequests_;
    }
    const bool&
    allowDeprecatedSystemRequests() const
    {
        return allowDeprecatedSystemRequests_;
    }

    bool&
    isInDevToolsContext()
    {
        return isInDevToolsContext_;
    }
    const bool&
    isInDevToolsContext() const
    {
        return isInDevToolsContext_;
    }

    bool&
    parserCreatedScript()
    {
        return parserCreatedScript_;
    }
    const bool&
    parserCreatedScript() const
    {
        return parserCreatedScript_;
    }

    bool&
    isFromProcessingFrameAttributes()
    {
        return isFromProcessingFrameAttributes_;
    }
    const bool&
    isFromProcessingFrameAttributes() const
    {
        return isFromProcessingFrameAttributes_;
    }

    CookieJarSettingsArgs&
    cookieJarSettings()
    {
        return cookieJarSettings_;
    }
    const CookieJarSettingsArgs&
    cookieJarSettings() const
    {
        return cookieJarSettings_;
    }

    uint32_t&
    requestBlockingReason()
    {
        return requestBlockingReason_;
    }
    const uint32_t&
    requestBlockingReason() const
    {
        return requestBlockingReason_;
    }

    mozilla::Maybe<CSPInfo>&
    cspToInheritInfo()
    {
        return cspToInheritInfo_;
    }
    const mozilla::Maybe<CSPInfo>&
    cspToInheritInfo() const
    {
        return cspToInheritInfo_;
    }

    bool&
    hasStoragePermission()
    {
        return hasStoragePermission_;
    }
    const bool&
    hasStoragePermission() const
    {
        return hasStoragePermission_;
    }

    CrossOriginEmbedderPolicy&
    loadingEmbedderPolicy()
    {
        return loadingEmbedderPolicy_;
    }
    const CrossOriginEmbedderPolicy&
    loadingEmbedderPolicy() const
    {
        return loadingEmbedderPolicy_;
    }

private:
    void
    StaticAssertions() const;
    mozilla::Maybe<PrincipalInfo> requestingPrincipalInfo_;
    PrincipalInfo triggeringPrincipalInfo_;
    mozilla::Maybe<PrincipalInfo> principalToInheritInfo_;
    mozilla::Maybe<PrincipalInfo> sandboxedLoadingPrincipalInfo_;
    mozilla::Maybe<PrincipalInfo> topLevelPrincipalInfo_;
    mozilla::Maybe<PrincipalInfo> topLevelStorageAreaPrincipalInfo_;
    mozilla::Maybe<URIParams> resultPrincipalURI_;
    nsContentPolicyType contentPolicyType_;
    bool blockAllMixedContent_;
    bool upgradeInsecureRequests_;
    bool browserUpgradeInsecureRequests_;
    bool browserDidUpgradeInsecureRequests_;
    bool browserWouldUpgradeInsecureRequests_;
    bool forceAllowDataURI_;
    bool allowInsecureRedirectToDataURI_;
    bool bypassCORSChecks_;
    bool skipContentPolicyCheckForWebRequest_;
    bool originalFrameSrcLoad_;
    bool forceInheritPrincipalDropped_;
    bool initialSecurityCheckDone_;
    bool isInThirdPartyContext_;
    bool isThirdPartyContextToTopWindow_;
    bool isFormSubmission_;
    bool sendCSPViolationEvents_;
    OriginAttributes originAttributes_;
    CopyableTArray<RedirectHistoryEntryInfo> redirectChainIncludingInternalRedirects_;
    CopyableTArray<RedirectHistoryEntryInfo> redirectChain_;
    mozilla::Maybe<IPCClientInfo> clientInfo_;
    mozilla::Maybe<IPCClientInfo> reservedClientInfo_;
    mozilla::Maybe<IPCClientInfo> initialClientInfo_;
    mozilla::Maybe<IPCServiceWorkerDescriptor> controller_;
    CopyableTArray<nsCString> corsUnsafeHeaders_;
    bool forcePreflight_;
    bool isPreflight_;
    bool loadTriggeredFromExternal_;
    bool serviceWorkerTaintingSynthesized_;
    bool documentHasUserInteracted_;
    bool allowListFutureDocumentsCreatedFromThisRedirectChain_;
    nsString cspNonce_;
    bool skipContentSniffing_;
    bool hasValidUserGestureActivation_;
    bool allowDeprecatedSystemRequests_;
    bool isInDevToolsContext_;
    bool parserCreatedScript_;
    bool isFromProcessingFrameAttributes_;
    CookieJarSettingsArgs cookieJarSettings_;
    mozilla::Maybe<CSPInfo> cspToInheritInfo_;
    bool hasStoragePermission_;
    CrossOriginEmbedderPolicy loadingEmbedderPolicy_;
    uint64_t innerWindowID_;
    uint64_t browsingContextID_;
    uint64_t frameBrowsingContextID_;
    uint32_t securityFlags_;
    uint32_t sandboxFlags_;
    uint32_t triggeringSandboxFlags_;
    uint32_t tainting_;
    uint32_t httpsOnlyStatus_;
    uint32_t requestBlockingReason_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::LoadInfoArgs>
{
    typedef mozilla::net::LoadInfoArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ParentLoadInfoForwarderArgs|
//
namespace mozilla {
namespace net {
class ParentLoadInfoForwarderArgs final
{
private:
    typedef mozilla::dom::IPCServiceWorkerDescriptor IPCServiceWorkerDescriptor;
    typedef mozilla::net::CookieJarSettingsArgs CookieJarSettingsArgs;

public:
    MOZ_IMPLICIT ParentLoadInfoForwarderArgs() :
        allowInsecureRedirectToDataURI_(),
        bypassCORSChecks_(),
        controller_(),
        skipContentSniffing_(),
        hasValidUserGestureActivation_(),
        allowDeprecatedSystemRequests_(),
        isInDevToolsContext_(),
        parserCreatedScript_(),
        serviceWorkerTaintingSynthesized_(),
        documentHasUserInteracted_(),
        allowListFutureDocumentsCreatedFromThisRedirectChain_(),
        cookieJarSettings_(),
        hasStoragePermission_(),
        isThirdPartyContextToTopWindow_(),
        isInThirdPartyContext_(),
        tainting_(),
        httpsOnlyStatus_(),
        triggeringSandboxFlags_(),
        requestBlockingReason_()
    {
    }

    MOZ_IMPLICIT ParentLoadInfoForwarderArgs(
            const bool& _allowInsecureRedirectToDataURI,
            const bool& _bypassCORSChecks,
            const mozilla::Maybe<IPCServiceWorkerDescriptor>& _controller,
            const uint32_t& _tainting,
            const bool& _skipContentSniffing,
            const uint32_t& _httpsOnlyStatus,
            const bool& _hasValidUserGestureActivation,
            const bool& _allowDeprecatedSystemRequests,
            const bool& _isInDevToolsContext,
            const bool& _parserCreatedScript,
            const uint32_t& _triggeringSandboxFlags,
            const bool& _serviceWorkerTaintingSynthesized,
            const bool& _documentHasUserInteracted,
            const bool& _allowListFutureDocumentsCreatedFromThisRedirectChain,
            const mozilla::Maybe<CookieJarSettingsArgs>& _cookieJarSettings,
            const uint32_t& _requestBlockingReason,
            const bool& _hasStoragePermission,
            const bool& _isThirdPartyContextToTopWindow,
            const bool& _isInThirdPartyContext) :
        allowInsecureRedirectToDataURI_(_allowInsecureRedirectToDataURI),
        bypassCORSChecks_(_bypassCORSChecks),
        controller_(_controller),
        skipContentSniffing_(_skipContentSniffing),
        hasValidUserGestureActivation_(_hasValidUserGestureActivation),
        allowDeprecatedSystemRequests_(_allowDeprecatedSystemRequests),
        isInDevToolsContext_(_isInDevToolsContext),
        parserCreatedScript_(_parserCreatedScript),
        serviceWorkerTaintingSynthesized_(_serviceWorkerTaintingSynthesized),
        documentHasUserInteracted_(_documentHasUserInteracted),
        allowListFutureDocumentsCreatedFromThisRedirectChain_(_allowListFutureDocumentsCreatedFromThisRedirectChain),
        cookieJarSettings_(_cookieJarSettings),
        hasStoragePermission_(_hasStoragePermission),
        isThirdPartyContextToTopWindow_(_isThirdPartyContextToTopWindow),
        isInThirdPartyContext_(_isInThirdPartyContext),
        tainting_(_tainting),
        httpsOnlyStatus_(_httpsOnlyStatus),
        triggeringSandboxFlags_(_triggeringSandboxFlags),
        requestBlockingReason_(_requestBlockingReason)
    {
    }

    bool&
    allowInsecureRedirectToDataURI()
    {
        return allowInsecureRedirectToDataURI_;
    }
    const bool&
    allowInsecureRedirectToDataURI() const
    {
        return allowInsecureRedirectToDataURI_;
    }

    bool&
    bypassCORSChecks()
    {
        return bypassCORSChecks_;
    }
    const bool&
    bypassCORSChecks() const
    {
        return bypassCORSChecks_;
    }

    mozilla::Maybe<IPCServiceWorkerDescriptor>&
    controller()
    {
        return controller_;
    }
    const mozilla::Maybe<IPCServiceWorkerDescriptor>&
    controller() const
    {
        return controller_;
    }

    uint32_t&
    tainting()
    {
        return tainting_;
    }
    const uint32_t&
    tainting() const
    {
        return tainting_;
    }

    bool&
    skipContentSniffing()
    {
        return skipContentSniffing_;
    }
    const bool&
    skipContentSniffing() const
    {
        return skipContentSniffing_;
    }

    uint32_t&
    httpsOnlyStatus()
    {
        return httpsOnlyStatus_;
    }
    const uint32_t&
    httpsOnlyStatus() const
    {
        return httpsOnlyStatus_;
    }

    bool&
    hasValidUserGestureActivation()
    {
        return hasValidUserGestureActivation_;
    }
    const bool&
    hasValidUserGestureActivation() const
    {
        return hasValidUserGestureActivation_;
    }

    bool&
    allowDeprecatedSystemRequests()
    {
        return allowDeprecatedSystemRequests_;
    }
    const bool&
    allowDeprecatedSystemRequests() const
    {
        return allowDeprecatedSystemRequests_;
    }

    bool&
    isInDevToolsContext()
    {
        return isInDevToolsContext_;
    }
    const bool&
    isInDevToolsContext() const
    {
        return isInDevToolsContext_;
    }

    bool&
    parserCreatedScript()
    {
        return parserCreatedScript_;
    }
    const bool&
    parserCreatedScript() const
    {
        return parserCreatedScript_;
    }

    uint32_t&
    triggeringSandboxFlags()
    {
        return triggeringSandboxFlags_;
    }
    const uint32_t&
    triggeringSandboxFlags() const
    {
        return triggeringSandboxFlags_;
    }

    bool&
    serviceWorkerTaintingSynthesized()
    {
        return serviceWorkerTaintingSynthesized_;
    }
    const bool&
    serviceWorkerTaintingSynthesized() const
    {
        return serviceWorkerTaintingSynthesized_;
    }

    bool&
    documentHasUserInteracted()
    {
        return documentHasUserInteracted_;
    }
    const bool&
    documentHasUserInteracted() const
    {
        return documentHasUserInteracted_;
    }

    bool&
    allowListFutureDocumentsCreatedFromThisRedirectChain()
    {
        return allowListFutureDocumentsCreatedFromThisRedirectChain_;
    }
    const bool&
    allowListFutureDocumentsCreatedFromThisRedirectChain() const
    {
        return allowListFutureDocumentsCreatedFromThisRedirectChain_;
    }

    mozilla::Maybe<CookieJarSettingsArgs>&
    cookieJarSettings()
    {
        return cookieJarSettings_;
    }
    const mozilla::Maybe<CookieJarSettingsArgs>&
    cookieJarSettings() const
    {
        return cookieJarSettings_;
    }

    uint32_t&
    requestBlockingReason()
    {
        return requestBlockingReason_;
    }
    const uint32_t&
    requestBlockingReason() const
    {
        return requestBlockingReason_;
    }

    bool&
    hasStoragePermission()
    {
        return hasStoragePermission_;
    }
    const bool&
    hasStoragePermission() const
    {
        return hasStoragePermission_;
    }

    bool&
    isThirdPartyContextToTopWindow()
    {
        return isThirdPartyContextToTopWindow_;
    }
    const bool&
    isThirdPartyContextToTopWindow() const
    {
        return isThirdPartyContextToTopWindow_;
    }

    bool&
    isInThirdPartyContext()
    {
        return isInThirdPartyContext_;
    }
    const bool&
    isInThirdPartyContext() const
    {
        return isInThirdPartyContext_;
    }

private:
    void
    StaticAssertions() const;
    bool allowInsecureRedirectToDataURI_;
    bool bypassCORSChecks_;
    mozilla::Maybe<IPCServiceWorkerDescriptor> controller_;
    bool skipContentSniffing_;
    bool hasValidUserGestureActivation_;
    bool allowDeprecatedSystemRequests_;
    bool isInDevToolsContext_;
    bool parserCreatedScript_;
    bool serviceWorkerTaintingSynthesized_;
    bool documentHasUserInteracted_;
    bool allowListFutureDocumentsCreatedFromThisRedirectChain_;
    mozilla::Maybe<CookieJarSettingsArgs> cookieJarSettings_;
    bool hasStoragePermission_;
    bool isThirdPartyContextToTopWindow_;
    bool isInThirdPartyContext_;
    uint32_t tainting_;
    uint32_t httpsOnlyStatus_;
    uint32_t triggeringSandboxFlags_;
    uint32_t requestBlockingReason_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::ParentLoadInfoForwarderArgs>
{
    typedef mozilla::net::ParentLoadInfoForwarderArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ChildLoadInfoForwarderArgs|
//
namespace mozilla {
namespace net {
class ChildLoadInfoForwarderArgs final
{
private:
    typedef mozilla::dom::IPCClientInfo IPCClientInfo;
    typedef mozilla::dom::IPCServiceWorkerDescriptor IPCServiceWorkerDescriptor;

public:
    MOZ_IMPLICIT ChildLoadInfoForwarderArgs() :
        reservedClientInfo_(),
        initialClientInfo_(),
        controller_(),
        requestBlockingReason_()
    {
    }

    MOZ_IMPLICIT ChildLoadInfoForwarderArgs(
            const mozilla::Maybe<IPCClientInfo>& _reservedClientInfo,
            const mozilla::Maybe<IPCClientInfo>& _initialClientInfo,
            const mozilla::Maybe<IPCServiceWorkerDescriptor>& _controller,
            const uint32_t& _requestBlockingReason) :
        reservedClientInfo_(_reservedClientInfo),
        initialClientInfo_(_initialClientInfo),
        controller_(_controller),
        requestBlockingReason_(_requestBlockingReason)
    {
    }

    mozilla::Maybe<IPCClientInfo>&
    reservedClientInfo()
    {
        return reservedClientInfo_;
    }
    const mozilla::Maybe<IPCClientInfo>&
    reservedClientInfo() const
    {
        return reservedClientInfo_;
    }

    mozilla::Maybe<IPCClientInfo>&
    initialClientInfo()
    {
        return initialClientInfo_;
    }
    const mozilla::Maybe<IPCClientInfo>&
    initialClientInfo() const
    {
        return initialClientInfo_;
    }

    mozilla::Maybe<IPCServiceWorkerDescriptor>&
    controller()
    {
        return controller_;
    }
    const mozilla::Maybe<IPCServiceWorkerDescriptor>&
    controller() const
    {
        return controller_;
    }

    uint32_t&
    requestBlockingReason()
    {
        return requestBlockingReason_;
    }
    const uint32_t&
    requestBlockingReason() const
    {
        return requestBlockingReason_;
    }

private:
    mozilla::Maybe<IPCClientInfo> reservedClientInfo_;
    mozilla::Maybe<IPCClientInfo> initialClientInfo_;
    mozilla::Maybe<IPCServiceWorkerDescriptor> controller_;
    uint32_t requestBlockingReason_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::ChildLoadInfoForwarderArgs>
{
    typedef mozilla::net::ChildLoadInfoForwarderArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CorsPreflightArgs|
//
namespace mozilla {
namespace net {
class CorsPreflightArgs final
{
private:

public:
    MOZ_IMPLICIT CorsPreflightArgs() :
        unsafeHeaders_()
    {
    }

    MOZ_IMPLICIT CorsPreflightArgs(const nsTArray<nsCString>& _unsafeHeaders) :
        unsafeHeaders_(_unsafeHeaders)
    {
    }

    nsTArray<nsCString>&
    unsafeHeaders()
    {
        return unsafeHeaders_;
    }
    const nsTArray<nsCString>&
    unsafeHeaders() const
    {
        return unsafeHeaders_;
    }

private:
    CopyableTArray<nsCString> unsafeHeaders_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::CorsPreflightArgs>
{
    typedef mozilla::net::CorsPreflightArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct HttpChannelOpenArgs|
//
namespace mozilla {
namespace net {
class HttpChannelOpenArgs final
{
private:
    typedef mozilla::ipc::URIParams URIParams;
    typedef mozilla::ipc::IPCStream IPCStream;
    typedef mozilla::net::LoadInfoArgs LoadInfoArgs;
    typedef mozilla::net::CorsPreflightArgs CorsPreflightArgs;
    typedef mozilla::net::PreferredAlternativeDataTypeParams PreferredAlternativeDataTypeParams;
    typedef mozilla::TimeStamp TimeStamp;

public:
    MOZ_IMPLICIT HttpChannelOpenArgs() :
        uri_(),
        original_(),
        doc_(),
        referrerInfo_(),
        apiRedirectTo_(),
        topWindowURI_(),
        requestHeaders_(),
        requestMethod_(),
        uploadStream_(),
        uploadStreamHasHeaders_(),
        allowSTS_(),
        resumeAt_(),
        entityID_(),
        chooseApplicationCache_(),
        appCacheClientID_(),
        allowSpdy_(),
        allowHttp3_(),
        allowAltSvc_(),
        beConservative_(),
        loadInfo_(),
        preflightArgs_(),
        blockAuthPrompt_(),
        allowStaleCacheContent_(),
        preferCacheLoadOverBypass_(),
        contentTypeHint_(),
        integrityMetadata_(),
        preferredAlternativeTypes_(),
        launchServiceWorkerStart_(),
        launchServiceWorkerEnd_(),
        dispatchFetchEventStart_(),
        dispatchFetchEventEnd_(),
        handleFetchEventStart_(),
        handleFetchEventEnd_(),
        forceMainDocumentChannel_(),
        navigationStartTimeStamp_(),
        hasNonEmptySandboxingFlag_(),
        startPos_(),
        requestContextID_(),
        channelId_(),
        contentWindowId_(),
        topLevelOuterContentWindowId_(),
        loadFlags_(),
        classOfService_(),
        thirdPartyFlags_(),
        tlsFlags_(),
        cacheKey_(),
        initialRwin_(),
        corsMode_(),
        redirectMode_(),
        priority_(),
        redirectionLimit_()
    {
    }

    MOZ_IMPLICIT HttpChannelOpenArgs(
            const URIParams& _uri,
            const mozilla::Maybe<URIParams>& _original,
            const mozilla::Maybe<URIParams>& _doc,
            nsIReferrerInfo* _referrerInfo,
            const mozilla::Maybe<URIParams>& _apiRedirectTo,
            const mozilla::Maybe<URIParams>& _topWindowURI,
            const uint32_t& _loadFlags,
            const RequestHeaderTuples& _requestHeaders,
            const nsCString& _requestMethod,
            const mozilla::Maybe<IPCStream>& _uploadStream,
            const bool& _uploadStreamHasHeaders,
            const int16_t& _priority,
            const uint32_t& _classOfService,
            const uint8_t& _redirectionLimit,
            const bool& _allowSTS,
            const uint32_t& _thirdPartyFlags,
            const bool& _resumeAt,
            const uint64_t& _startPos,
            const nsCString& _entityID,
            const bool& _chooseApplicationCache,
            const nsCString& _appCacheClientID,
            const bool& _allowSpdy,
            const bool& _allowHttp3,
            const bool& _allowAltSvc,
            const bool& _beConservative,
            const uint32_t& _tlsFlags,
            const mozilla::Maybe<LoadInfoArgs>& _loadInfo,
            const uint32_t& _cacheKey,
            const uint64_t& _requestContextID,
            const mozilla::Maybe<CorsPreflightArgs>& _preflightArgs,
            const uint32_t& _initialRwin,
            const bool& _blockAuthPrompt,
            const bool& _allowStaleCacheContent,
            const bool& _preferCacheLoadOverBypass,
            const nsCString& _contentTypeHint,
            const uint32_t& _corsMode,
            const uint32_t& _redirectMode,
            const uint64_t& _channelId,
            const nsString& _integrityMetadata,
            const uint64_t& _contentWindowId,
            const nsTArray<PreferredAlternativeDataTypeParams>& _preferredAlternativeTypes,
            const uint64_t& _topLevelOuterContentWindowId,
            const TimeStamp& _launchServiceWorkerStart,
            const TimeStamp& _launchServiceWorkerEnd,
            const TimeStamp& _dispatchFetchEventStart,
            const TimeStamp& _dispatchFetchEventEnd,
            const TimeStamp& _handleFetchEventStart,
            const TimeStamp& _handleFetchEventEnd,
            const bool& _forceMainDocumentChannel,
            const TimeStamp& _navigationStartTimeStamp,
            const bool& _hasNonEmptySandboxingFlag) :
        uri_(_uri),
        original_(_original),
        doc_(_doc),
        referrerInfo_(_referrerInfo),
        apiRedirectTo_(_apiRedirectTo),
        topWindowURI_(_topWindowURI),
        requestHeaders_(_requestHeaders),
        requestMethod_(_requestMethod),
        uploadStream_(_uploadStream),
        uploadStreamHasHeaders_(_uploadStreamHasHeaders),
        allowSTS_(_allowSTS),
        resumeAt_(_resumeAt),
        entityID_(_entityID),
        chooseApplicationCache_(_chooseApplicationCache),
        appCacheClientID_(_appCacheClientID),
        allowSpdy_(_allowSpdy),
        allowHttp3_(_allowHttp3),
        allowAltSvc_(_allowAltSvc),
        beConservative_(_beConservative),
        loadInfo_(_loadInfo),
        preflightArgs_(_preflightArgs),
        blockAuthPrompt_(_blockAuthPrompt),
        allowStaleCacheContent_(_allowStaleCacheContent),
        preferCacheLoadOverBypass_(_preferCacheLoadOverBypass),
        contentTypeHint_(_contentTypeHint),
        integrityMetadata_(_integrityMetadata),
        preferredAlternativeTypes_(_preferredAlternativeTypes),
        launchServiceWorkerStart_(_launchServiceWorkerStart),
        launchServiceWorkerEnd_(_launchServiceWorkerEnd),
        dispatchFetchEventStart_(_dispatchFetchEventStart),
        dispatchFetchEventEnd_(_dispatchFetchEventEnd),
        handleFetchEventStart_(_handleFetchEventStart),
        handleFetchEventEnd_(_handleFetchEventEnd),
        forceMainDocumentChannel_(_forceMainDocumentChannel),
        navigationStartTimeStamp_(_navigationStartTimeStamp),
        hasNonEmptySandboxingFlag_(_hasNonEmptySandboxingFlag),
        startPos_(_startPos),
        requestContextID_(_requestContextID),
        channelId_(_channelId),
        contentWindowId_(_contentWindowId),
        topLevelOuterContentWindowId_(_topLevelOuterContentWindowId),
        loadFlags_(_loadFlags),
        classOfService_(_classOfService),
        thirdPartyFlags_(_thirdPartyFlags),
        tlsFlags_(_tlsFlags),
        cacheKey_(_cacheKey),
        initialRwin_(_initialRwin),
        corsMode_(_corsMode),
        redirectMode_(_redirectMode),
        priority_(_priority),
        redirectionLimit_(_redirectionLimit)
    {
    }

    URIParams&
    uri()
    {
        return uri_;
    }
    const URIParams&
    uri() const
    {
        return uri_;
    }

    mozilla::Maybe<URIParams>&
    original()
    {
        return original_;
    }
    const mozilla::Maybe<URIParams>&
    original() const
    {
        return original_;
    }

    mozilla::Maybe<URIParams>&
    doc()
    {
        return doc_;
    }
    const mozilla::Maybe<URIParams>&
    doc() const
    {
        return doc_;
    }

    RefPtr<nsIReferrerInfo>&
    referrerInfo()
    {
        return referrerInfo_;
    }
    nsIReferrerInfo*
    referrerInfo() const
    {
        return referrerInfo_;
    }

    mozilla::Maybe<URIParams>&
    apiRedirectTo()
    {
        return apiRedirectTo_;
    }
    const mozilla::Maybe<URIParams>&
    apiRedirectTo() const
    {
        return apiRedirectTo_;
    }

    mozilla::Maybe<URIParams>&
    topWindowURI()
    {
        return topWindowURI_;
    }
    const mozilla::Maybe<URIParams>&
    topWindowURI() const
    {
        return topWindowURI_;
    }

    uint32_t&
    loadFlags()
    {
        return loadFlags_;
    }
    const uint32_t&
    loadFlags() const
    {
        return loadFlags_;
    }

    RequestHeaderTuples&
    requestHeaders()
    {
        return requestHeaders_;
    }
    const RequestHeaderTuples&
    requestHeaders() const
    {
        return requestHeaders_;
    }

    nsCString&
    requestMethod()
    {
        return requestMethod_;
    }
    const nsCString&
    requestMethod() const
    {
        return requestMethod_;
    }

    mozilla::Maybe<IPCStream>&
    uploadStream()
    {
        return uploadStream_;
    }
    const mozilla::Maybe<IPCStream>&
    uploadStream() const
    {
        return uploadStream_;
    }

    bool&
    uploadStreamHasHeaders()
    {
        return uploadStreamHasHeaders_;
    }
    const bool&
    uploadStreamHasHeaders() const
    {
        return uploadStreamHasHeaders_;
    }

    int16_t&
    priority()
    {
        return priority_;
    }
    const int16_t&
    priority() const
    {
        return priority_;
    }

    uint32_t&
    classOfService()
    {
        return classOfService_;
    }
    const uint32_t&
    classOfService() const
    {
        return classOfService_;
    }

    uint8_t&
    redirectionLimit()
    {
        return redirectionLimit_;
    }
    const uint8_t&
    redirectionLimit() const
    {
        return redirectionLimit_;
    }

    bool&
    allowSTS()
    {
        return allowSTS_;
    }
    const bool&
    allowSTS() const
    {
        return allowSTS_;
    }

    uint32_t&
    thirdPartyFlags()
    {
        return thirdPartyFlags_;
    }
    const uint32_t&
    thirdPartyFlags() const
    {
        return thirdPartyFlags_;
    }

    bool&
    resumeAt()
    {
        return resumeAt_;
    }
    const bool&
    resumeAt() const
    {
        return resumeAt_;
    }

    uint64_t&
    startPos()
    {
        return startPos_;
    }
    const uint64_t&
    startPos() const
    {
        return startPos_;
    }

    nsCString&
    entityID()
    {
        return entityID_;
    }
    const nsCString&
    entityID() const
    {
        return entityID_;
    }

    bool&
    chooseApplicationCache()
    {
        return chooseApplicationCache_;
    }
    const bool&
    chooseApplicationCache() const
    {
        return chooseApplicationCache_;
    }

    nsCString&
    appCacheClientID()
    {
        return appCacheClientID_;
    }
    const nsCString&
    appCacheClientID() const
    {
        return appCacheClientID_;
    }

    bool&
    allowSpdy()
    {
        return allowSpdy_;
    }
    const bool&
    allowSpdy() const
    {
        return allowSpdy_;
    }

    bool&
    allowHttp3()
    {
        return allowHttp3_;
    }
    const bool&
    allowHttp3() const
    {
        return allowHttp3_;
    }

    bool&
    allowAltSvc()
    {
        return allowAltSvc_;
    }
    const bool&
    allowAltSvc() const
    {
        return allowAltSvc_;
    }

    bool&
    beConservative()
    {
        return beConservative_;
    }
    const bool&
    beConservative() const
    {
        return beConservative_;
    }

    uint32_t&
    tlsFlags()
    {
        return tlsFlags_;
    }
    const uint32_t&
    tlsFlags() const
    {
        return tlsFlags_;
    }

    mozilla::Maybe<LoadInfoArgs>&
    loadInfo()
    {
        return loadInfo_;
    }
    const mozilla::Maybe<LoadInfoArgs>&
    loadInfo() const
    {
        return loadInfo_;
    }

    uint32_t&
    cacheKey()
    {
        return cacheKey_;
    }
    const uint32_t&
    cacheKey() const
    {
        return cacheKey_;
    }

    uint64_t&
    requestContextID()
    {
        return requestContextID_;
    }
    const uint64_t&
    requestContextID() const
    {
        return requestContextID_;
    }

    mozilla::Maybe<CorsPreflightArgs>&
    preflightArgs()
    {
        return preflightArgs_;
    }
    const mozilla::Maybe<CorsPreflightArgs>&
    preflightArgs() const
    {
        return preflightArgs_;
    }

    uint32_t&
    initialRwin()
    {
        return initialRwin_;
    }
    const uint32_t&
    initialRwin() const
    {
        return initialRwin_;
    }

    bool&
    blockAuthPrompt()
    {
        return blockAuthPrompt_;
    }
    const bool&
    blockAuthPrompt() const
    {
        return blockAuthPrompt_;
    }

    bool&
    allowStaleCacheContent()
    {
        return allowStaleCacheContent_;
    }
    const bool&
    allowStaleCacheContent() const
    {
        return allowStaleCacheContent_;
    }

    bool&
    preferCacheLoadOverBypass()
    {
        return preferCacheLoadOverBypass_;
    }
    const bool&
    preferCacheLoadOverBypass() const
    {
        return preferCacheLoadOverBypass_;
    }

    nsCString&
    contentTypeHint()
    {
        return contentTypeHint_;
    }
    const nsCString&
    contentTypeHint() const
    {
        return contentTypeHint_;
    }

    uint32_t&
    corsMode()
    {
        return corsMode_;
    }
    const uint32_t&
    corsMode() const
    {
        return corsMode_;
    }

    uint32_t&
    redirectMode()
    {
        return redirectMode_;
    }
    const uint32_t&
    redirectMode() const
    {
        return redirectMode_;
    }

    uint64_t&
    channelId()
    {
        return channelId_;
    }
    const uint64_t&
    channelId() const
    {
        return channelId_;
    }

    nsString&
    integrityMetadata()
    {
        return integrityMetadata_;
    }
    const nsString&
    integrityMetadata() const
    {
        return integrityMetadata_;
    }

    uint64_t&
    contentWindowId()
    {
        return contentWindowId_;
    }
    const uint64_t&
    contentWindowId() const
    {
        return contentWindowId_;
    }

    nsTArray<PreferredAlternativeDataTypeParams>&
    preferredAlternativeTypes()
    {
        return preferredAlternativeTypes_;
    }
    const nsTArray<PreferredAlternativeDataTypeParams>&
    preferredAlternativeTypes() const
    {
        return preferredAlternativeTypes_;
    }

    uint64_t&
    topLevelOuterContentWindowId()
    {
        return topLevelOuterContentWindowId_;
    }
    const uint64_t&
    topLevelOuterContentWindowId() const
    {
        return topLevelOuterContentWindowId_;
    }

    TimeStamp&
    launchServiceWorkerStart()
    {
        return launchServiceWorkerStart_;
    }
    const TimeStamp&
    launchServiceWorkerStart() const
    {
        return launchServiceWorkerStart_;
    }

    TimeStamp&
    launchServiceWorkerEnd()
    {
        return launchServiceWorkerEnd_;
    }
    const TimeStamp&
    launchServiceWorkerEnd() const
    {
        return launchServiceWorkerEnd_;
    }

    TimeStamp&
    dispatchFetchEventStart()
    {
        return dispatchFetchEventStart_;
    }
    const TimeStamp&
    dispatchFetchEventStart() const
    {
        return dispatchFetchEventStart_;
    }

    TimeStamp&
    dispatchFetchEventEnd()
    {
        return dispatchFetchEventEnd_;
    }
    const TimeStamp&
    dispatchFetchEventEnd() const
    {
        return dispatchFetchEventEnd_;
    }

    TimeStamp&
    handleFetchEventStart()
    {
        return handleFetchEventStart_;
    }
    const TimeStamp&
    handleFetchEventStart() const
    {
        return handleFetchEventStart_;
    }

    TimeStamp&
    handleFetchEventEnd()
    {
        return handleFetchEventEnd_;
    }
    const TimeStamp&
    handleFetchEventEnd() const
    {
        return handleFetchEventEnd_;
    }

    bool&
    forceMainDocumentChannel()
    {
        return forceMainDocumentChannel_;
    }
    const bool&
    forceMainDocumentChannel() const
    {
        return forceMainDocumentChannel_;
    }

    TimeStamp&
    navigationStartTimeStamp()
    {
        return navigationStartTimeStamp_;
    }
    const TimeStamp&
    navigationStartTimeStamp() const
    {
        return navigationStartTimeStamp_;
    }

    bool&
    hasNonEmptySandboxingFlag()
    {
        return hasNonEmptySandboxingFlag_;
    }
    const bool&
    hasNonEmptySandboxingFlag() const
    {
        return hasNonEmptySandboxingFlag_;
    }

private:
    void
    StaticAssertions() const;
    URIParams uri_;
    mozilla::Maybe<URIParams> original_;
    mozilla::Maybe<URIParams> doc_;
    RefPtr<nsIReferrerInfo> referrerInfo_;
    mozilla::Maybe<URIParams> apiRedirectTo_;
    mozilla::Maybe<URIParams> topWindowURI_;
    RequestHeaderTuples requestHeaders_;
    nsCString requestMethod_;
    mozilla::Maybe<IPCStream> uploadStream_;
    bool uploadStreamHasHeaders_;
    bool allowSTS_;
    bool resumeAt_;
    nsCString entityID_;
    bool chooseApplicationCache_;
    nsCString appCacheClientID_;
    bool allowSpdy_;
    bool allowHttp3_;
    bool allowAltSvc_;
    bool beConservative_;
    mozilla::Maybe<LoadInfoArgs> loadInfo_;
    mozilla::Maybe<CorsPreflightArgs> preflightArgs_;
    bool blockAuthPrompt_;
    bool allowStaleCacheContent_;
    bool preferCacheLoadOverBypass_;
    nsCString contentTypeHint_;
    nsString integrityMetadata_;
    CopyableTArray<PreferredAlternativeDataTypeParams> preferredAlternativeTypes_;
    TimeStamp launchServiceWorkerStart_;
    TimeStamp launchServiceWorkerEnd_;
    TimeStamp dispatchFetchEventStart_;
    TimeStamp dispatchFetchEventEnd_;
    TimeStamp handleFetchEventStart_;
    TimeStamp handleFetchEventEnd_;
    bool forceMainDocumentChannel_;
    TimeStamp navigationStartTimeStamp_;
    bool hasNonEmptySandboxingFlag_;
    uint64_t startPos_;
    uint64_t requestContextID_;
    uint64_t channelId_;
    uint64_t contentWindowId_;
    uint64_t topLevelOuterContentWindowId_;
    uint32_t loadFlags_;
    uint32_t classOfService_;
    uint32_t thirdPartyFlags_;
    uint32_t tlsFlags_;
    uint32_t cacheKey_;
    uint32_t initialRwin_;
    uint32_t corsMode_;
    uint32_t redirectMode_;
    int16_t priority_;
    uint8_t redirectionLimit_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::HttpChannelOpenArgs>
{
    typedef mozilla::net::HttpChannelOpenArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct HttpChannelConnectArgs|
//
namespace mozilla {
namespace net {
class HttpChannelConnectArgs final
{
private:

public:
    MOZ_IMPLICIT HttpChannelConnectArgs() :
        registrarId_()
    {
    }

    MOZ_IMPLICIT HttpChannelConnectArgs(const uint32_t& _registrarId) :
        registrarId_(_registrarId)
    {
    }

    uint32_t&
    registrarId()
    {
        return registrarId_;
    }
    const uint32_t&
    registrarId() const
    {
        return registrarId_;
    }

private:
    uint32_t registrarId_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::HttpChannelConnectArgs>
{
    typedef mozilla::net::HttpChannelConnectArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union HttpChannelCreationArgs|
//
namespace mozilla {
namespace net {
class HttpChannelCreationArgs final
{
public:
    enum Type {
        T__None,
        THttpChannelOpenArgs = 1,
        THttpChannelConnectArgs,
        T__Last = THttpChannelConnectArgs
    };

private:
    typedef mozilla::net::HttpChannelOpenArgs HttpChannelOpenArgs;
    typedef mozilla::net::HttpChannelConnectArgs HttpChannelConnectArgs;
    typedef HttpChannelOpenArgs HttpChannelOpenArgs__tdef;
    typedef HttpChannelConnectArgs HttpChannelConnectArgs__tdef;

    union Value {
        mozilla::AlignedStorage2<HttpChannelOpenArgs> VHttpChannelOpenArgs;
        mozilla::AlignedStorage2<HttpChannelConnectArgs> VHttpChannelConnectArgs;
    };

    HttpChannelOpenArgs*
    ptr_HttpChannelOpenArgs()
    {
        return ((mValue).VHttpChannelOpenArgs).addr();
    }
    const HttpChannelOpenArgs*
    constptr_HttpChannelOpenArgs() const
    {
        return ((mValue).VHttpChannelOpenArgs).addr();
    }
    HttpChannelConnectArgs*
    ptr_HttpChannelConnectArgs()
    {
        return ((mValue).VHttpChannelConnectArgs).addr();
    }
    const HttpChannelConnectArgs*
    constptr_HttpChannelConnectArgs() const
    {
        return ((mValue).VHttpChannelConnectArgs).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT HttpChannelCreationArgs() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT HttpChannelCreationArgs(const HttpChannelOpenArgs& aOther);

    MOZ_IMPLICIT HttpChannelCreationArgs(HttpChannelOpenArgs&& aOther);

    MOZ_IMPLICIT HttpChannelCreationArgs(const HttpChannelConnectArgs& aOther);

    MOZ_IMPLICIT HttpChannelCreationArgs(HttpChannelConnectArgs&& aOther);

    MOZ_IMPLICIT HttpChannelCreationArgs(const HttpChannelCreationArgs& aOther);

    MOZ_IMPLICIT HttpChannelCreationArgs(HttpChannelCreationArgs&& aOther);

    ~HttpChannelCreationArgs();

    Type
    type() const
    {
        return mType;
    }

    HttpChannelCreationArgs&
    operator=(const HttpChannelOpenArgs& aRhs);

    HttpChannelCreationArgs&
    operator=(HttpChannelOpenArgs&& aRhs);

    HttpChannelCreationArgs&
    operator=(const HttpChannelConnectArgs& aRhs);

    HttpChannelCreationArgs&
    operator=(HttpChannelConnectArgs&& aRhs);

    HttpChannelCreationArgs&
    operator=(const HttpChannelCreationArgs& aRhs);

    HttpChannelCreationArgs&
    operator=(HttpChannelCreationArgs&& aRhs);

    HttpChannelOpenArgs&
    get_HttpChannelOpenArgs()
    {
        AssertSanity(THttpChannelOpenArgs);
        return (*(ptr_HttpChannelOpenArgs()));
    }
    const HttpChannelOpenArgs&
    get_HttpChannelOpenArgs() const
    {
        AssertSanity(THttpChannelOpenArgs);
        return (*(constptr_HttpChannelOpenArgs()));
    }
    operator HttpChannelOpenArgs&()
    {
        return get_HttpChannelOpenArgs();
    }
    operator const HttpChannelOpenArgs&() const
    {
        return get_HttpChannelOpenArgs();
    }

    HttpChannelConnectArgs&
    get_HttpChannelConnectArgs()
    {
        AssertSanity(THttpChannelConnectArgs);
        return (*(ptr_HttpChannelConnectArgs()));
    }
    const HttpChannelConnectArgs&
    get_HttpChannelConnectArgs() const
    {
        AssertSanity(THttpChannelConnectArgs);
        return (*(constptr_HttpChannelConnectArgs()));
    }
    operator HttpChannelConnectArgs&()
    {
        return get_HttpChannelConnectArgs();
    }
    operator const HttpChannelConnectArgs&() const
    {
        return get_HttpChannelConnectArgs();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::HttpChannelCreationArgs>
{
    typedef mozilla::net::HttpChannelCreationArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ProxyInfoCloneArgs|
//
namespace mozilla {
namespace net {
class ProxyInfoCloneArgs final
{
private:

public:
    MOZ_IMPLICIT ProxyInfoCloneArgs() :
        type_(),
        host_(),
        username_(),
        password_(),
        proxyAuthorizationHeader_(),
        connectionIsolationKey_(),
        port_(),
        flags_(),
        timeout_(),
        resolveFlags_()
    {
    }

    MOZ_IMPLICIT ProxyInfoCloneArgs(
            const nsCString& _type,
            const nsCString& _host,
            const int32_t& _port,
            const nsCString& _username,
            const nsCString& _password,
            const uint32_t& _flags,
            const uint32_t& _timeout,
            const uint32_t& _resolveFlags,
            const nsCString& _proxyAuthorizationHeader,
            const nsCString& _connectionIsolationKey) :
        type_(_type),
        host_(_host),
        username_(_username),
        password_(_password),
        proxyAuthorizationHeader_(_proxyAuthorizationHeader),
        connectionIsolationKey_(_connectionIsolationKey),
        port_(_port),
        flags_(_flags),
        timeout_(_timeout),
        resolveFlags_(_resolveFlags)
    {
    }

    nsCString&
    type()
    {
        return type_;
    }
    const nsCString&
    type() const
    {
        return type_;
    }

    nsCString&
    host()
    {
        return host_;
    }
    const nsCString&
    host() const
    {
        return host_;
    }

    int32_t&
    port()
    {
        return port_;
    }
    const int32_t&
    port() const
    {
        return port_;
    }

    nsCString&
    username()
    {
        return username_;
    }
    const nsCString&
    username() const
    {
        return username_;
    }

    nsCString&
    password()
    {
        return password_;
    }
    const nsCString&
    password() const
    {
        return password_;
    }

    uint32_t&
    flags()
    {
        return flags_;
    }
    const uint32_t&
    flags() const
    {
        return flags_;
    }

    uint32_t&
    timeout()
    {
        return timeout_;
    }
    const uint32_t&
    timeout() const
    {
        return timeout_;
    }

    uint32_t&
    resolveFlags()
    {
        return resolveFlags_;
    }
    const uint32_t&
    resolveFlags() const
    {
        return resolveFlags_;
    }

    nsCString&
    proxyAuthorizationHeader()
    {
        return proxyAuthorizationHeader_;
    }
    const nsCString&
    proxyAuthorizationHeader() const
    {
        return proxyAuthorizationHeader_;
    }

    nsCString&
    connectionIsolationKey()
    {
        return connectionIsolationKey_;
    }
    const nsCString&
    connectionIsolationKey() const
    {
        return connectionIsolationKey_;
    }

private:
    void
    StaticAssertions() const;
    nsCString type_;
    nsCString host_;
    nsCString username_;
    nsCString password_;
    nsCString proxyAuthorizationHeader_;
    nsCString connectionIsolationKey_;
    int32_t port_;
    uint32_t flags_;
    uint32_t timeout_;
    uint32_t resolveFlags_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::ProxyInfoCloneArgs>
{
    typedef mozilla::net::ProxyInfoCloneArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct HttpConnectionInfoCloneArgs|
//
namespace mozilla {
namespace net {
class HttpConnectionInfoCloneArgs final
{
private:
    typedef mozilla::OriginAttributes OriginAttributes;
    typedef mozilla::net::ProxyInfoCloneArgs ProxyInfoCloneArgs;

public:
    MOZ_IMPLICIT HttpConnectionInfoCloneArgs() :
        host_(),
        npnToken_(),
        username_(),
        originAttributes_(),
        endToEndSSL_(),
        routedHost_(),
        anonymous_(),
        aPrivate_(),
        insecureScheme_(),
        noSpdy_(),
        beConservative_(),
        anonymousAllowClientCert_(),
        isolated_(),
        isTrrServiceChannel_(),
        isIPv4Disabled_(),
        isIPv6Disabled_(),
        topWindowOrigin_(),
        isHttp3_(),
        hasIPHintAddress_(),
        echConfig_(),
        proxyInfo_(),
        port_(),
        routedPort_(),
        tlsFlags_(),
        trrMode_()
    {
    }

    MOZ_IMPLICIT HttpConnectionInfoCloneArgs(
            const nsCString& _host,
            const int32_t& _port,
            const nsCString& _npnToken,
            const nsCString& _username,
            const OriginAttributes& _originAttributes,
            const bool& _endToEndSSL,
            const nsCString& _routedHost,
            const int32_t& _routedPort,
            const bool& _anonymous,
            const bool& _aPrivate,
            const bool& _insecureScheme,
            const bool& _noSpdy,
            const bool& _beConservative,
            const bool& _anonymousAllowClientCert,
            const uint32_t& _tlsFlags,
            const bool& _isolated,
            const bool& _isTrrServiceChannel,
            const uint8_t& _trrMode,
            const bool& _isIPv4Disabled,
            const bool& _isIPv6Disabled,
            const nsCString& _topWindowOrigin,
            const bool& _isHttp3,
            const bool& _hasIPHintAddress,
            const nsCString& _echConfig,
            const nsTArray<ProxyInfoCloneArgs>& _proxyInfo) :
        host_(_host),
        npnToken_(_npnToken),
        username_(_username),
        originAttributes_(_originAttributes),
        endToEndSSL_(_endToEndSSL),
        routedHost_(_routedHost),
        anonymous_(_anonymous),
        aPrivate_(_aPrivate),
        insecureScheme_(_insecureScheme),
        noSpdy_(_noSpdy),
        beConservative_(_beConservative),
        anonymousAllowClientCert_(_anonymousAllowClientCert),
        isolated_(_isolated),
        isTrrServiceChannel_(_isTrrServiceChannel),
        isIPv4Disabled_(_isIPv4Disabled),
        isIPv6Disabled_(_isIPv6Disabled),
        topWindowOrigin_(_topWindowOrigin),
        isHttp3_(_isHttp3),
        hasIPHintAddress_(_hasIPHintAddress),
        echConfig_(_echConfig),
        proxyInfo_(_proxyInfo),
        port_(_port),
        routedPort_(_routedPort),
        tlsFlags_(_tlsFlags),
        trrMode_(_trrMode)
    {
    }

    nsCString&
    host()
    {
        return host_;
    }
    const nsCString&
    host() const
    {
        return host_;
    }

    int32_t&
    port()
    {
        return port_;
    }
    const int32_t&
    port() const
    {
        return port_;
    }

    nsCString&
    npnToken()
    {
        return npnToken_;
    }
    const nsCString&
    npnToken() const
    {
        return npnToken_;
    }

    nsCString&
    username()
    {
        return username_;
    }
    const nsCString&
    username() const
    {
        return username_;
    }

    OriginAttributes&
    originAttributes()
    {
        return originAttributes_;
    }
    const OriginAttributes&
    originAttributes() const
    {
        return originAttributes_;
    }

    bool&
    endToEndSSL()
    {
        return endToEndSSL_;
    }
    const bool&
    endToEndSSL() const
    {
        return endToEndSSL_;
    }

    nsCString&
    routedHost()
    {
        return routedHost_;
    }
    const nsCString&
    routedHost() const
    {
        return routedHost_;
    }

    int32_t&
    routedPort()
    {
        return routedPort_;
    }
    const int32_t&
    routedPort() const
    {
        return routedPort_;
    }

    bool&
    anonymous()
    {
        return anonymous_;
    }
    const bool&
    anonymous() const
    {
        return anonymous_;
    }

    bool&
    aPrivate()
    {
        return aPrivate_;
    }
    const bool&
    aPrivate() const
    {
        return aPrivate_;
    }

    bool&
    insecureScheme()
    {
        return insecureScheme_;
    }
    const bool&
    insecureScheme() const
    {
        return insecureScheme_;
    }

    bool&
    noSpdy()
    {
        return noSpdy_;
    }
    const bool&
    noSpdy() const
    {
        return noSpdy_;
    }

    bool&
    beConservative()
    {
        return beConservative_;
    }
    const bool&
    beConservative() const
    {
        return beConservative_;
    }

    bool&
    anonymousAllowClientCert()
    {
        return anonymousAllowClientCert_;
    }
    const bool&
    anonymousAllowClientCert() const
    {
        return anonymousAllowClientCert_;
    }

    uint32_t&
    tlsFlags()
    {
        return tlsFlags_;
    }
    const uint32_t&
    tlsFlags() const
    {
        return tlsFlags_;
    }

    bool&
    isolated()
    {
        return isolated_;
    }
    const bool&
    isolated() const
    {
        return isolated_;
    }

    bool&
    isTrrServiceChannel()
    {
        return isTrrServiceChannel_;
    }
    const bool&
    isTrrServiceChannel() const
    {
        return isTrrServiceChannel_;
    }

    uint8_t&
    trrMode()
    {
        return trrMode_;
    }
    const uint8_t&
    trrMode() const
    {
        return trrMode_;
    }

    bool&
    isIPv4Disabled()
    {
        return isIPv4Disabled_;
    }
    const bool&
    isIPv4Disabled() const
    {
        return isIPv4Disabled_;
    }

    bool&
    isIPv6Disabled()
    {
        return isIPv6Disabled_;
    }
    const bool&
    isIPv6Disabled() const
    {
        return isIPv6Disabled_;
    }

    nsCString&
    topWindowOrigin()
    {
        return topWindowOrigin_;
    }
    const nsCString&
    topWindowOrigin() const
    {
        return topWindowOrigin_;
    }

    bool&
    isHttp3()
    {
        return isHttp3_;
    }
    const bool&
    isHttp3() const
    {
        return isHttp3_;
    }

    bool&
    hasIPHintAddress()
    {
        return hasIPHintAddress_;
    }
    const bool&
    hasIPHintAddress() const
    {
        return hasIPHintAddress_;
    }

    nsCString&
    echConfig()
    {
        return echConfig_;
    }
    const nsCString&
    echConfig() const
    {
        return echConfig_;
    }

    nsTArray<ProxyInfoCloneArgs>&
    proxyInfo()
    {
        return proxyInfo_;
    }
    const nsTArray<ProxyInfoCloneArgs>&
    proxyInfo() const
    {
        return proxyInfo_;
    }

private:
    void
    StaticAssertions() const;
    nsCString host_;
    nsCString npnToken_;
    nsCString username_;
    OriginAttributes originAttributes_;
    bool endToEndSSL_;
    nsCString routedHost_;
    bool anonymous_;
    bool aPrivate_;
    bool insecureScheme_;
    bool noSpdy_;
    bool beConservative_;
    bool anonymousAllowClientCert_;
    bool isolated_;
    bool isTrrServiceChannel_;
    bool isIPv4Disabled_;
    bool isIPv6Disabled_;
    nsCString topWindowOrigin_;
    bool isHttp3_;
    bool hasIPHintAddress_;
    nsCString echConfig_;
    CopyableTArray<ProxyInfoCloneArgs> proxyInfo_;
    int32_t port_;
    int32_t routedPort_;
    uint32_t tlsFlags_;
    uint8_t trrMode_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::HttpConnectionInfoCloneArgs>
{
    typedef mozilla::net::HttpConnectionInfoCloneArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ConsoleReportCollected|
//
namespace mozilla {
namespace net {
class ConsoleReportCollected final
{
private:

public:
    MOZ_IMPLICIT ConsoleReportCollected() :
        category_(),
        sourceFileURI_(),
        messageName_(),
        stringParams_(),
        errorFlags_(),
        propertiesFile_(),
        lineNumber_(),
        columnNumber_()
    {
    }

    MOZ_IMPLICIT ConsoleReportCollected(
            const uint32_t& _errorFlags,
            const nsCString& _category,
            const uint32_t& _propertiesFile,
            const nsCString& _sourceFileURI,
            const uint32_t& _lineNumber,
            const uint32_t& _columnNumber,
            const nsCString& _messageName,
            const nsTArray<nsString>& _stringParams) :
        category_(_category),
        sourceFileURI_(_sourceFileURI),
        messageName_(_messageName),
        stringParams_(_stringParams),
        errorFlags_(_errorFlags),
        propertiesFile_(_propertiesFile),
        lineNumber_(_lineNumber),
        columnNumber_(_columnNumber)
    {
    }

    uint32_t&
    errorFlags()
    {
        return errorFlags_;
    }
    const uint32_t&
    errorFlags() const
    {
        return errorFlags_;
    }

    nsCString&
    category()
    {
        return category_;
    }
    const nsCString&
    category() const
    {
        return category_;
    }

    uint32_t&
    propertiesFile()
    {
        return propertiesFile_;
    }
    const uint32_t&
    propertiesFile() const
    {
        return propertiesFile_;
    }

    nsCString&
    sourceFileURI()
    {
        return sourceFileURI_;
    }
    const nsCString&
    sourceFileURI() const
    {
        return sourceFileURI_;
    }

    uint32_t&
    lineNumber()
    {
        return lineNumber_;
    }
    const uint32_t&
    lineNumber() const
    {
        return lineNumber_;
    }

    uint32_t&
    columnNumber()
    {
        return columnNumber_;
    }
    const uint32_t&
    columnNumber() const
    {
        return columnNumber_;
    }

    nsCString&
    messageName()
    {
        return messageName_;
    }
    const nsCString&
    messageName() const
    {
        return messageName_;
    }

    nsTArray<nsString>&
    stringParams()
    {
        return stringParams_;
    }
    const nsTArray<nsString>&
    stringParams() const
    {
        return stringParams_;
    }

private:
    void
    StaticAssertions() const;
    nsCString category_;
    nsCString sourceFileURI_;
    nsCString messageName_;
    CopyableTArray<nsString> stringParams_;
    uint32_t errorFlags_;
    uint32_t propertiesFile_;
    uint32_t lineNumber_;
    uint32_t columnNumber_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::ConsoleReportCollected>
{
    typedef mozilla::net::ConsoleReportCollected paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct FTPChannelOpenArgs|
//
namespace mozilla {
namespace net {
class FTPChannelOpenArgs final
{
private:
    typedef mozilla::ipc::URIParams URIParams;
    typedef mozilla::ipc::IPCStream IPCStream;
    typedef mozilla::net::LoadInfoArgs LoadInfoArgs;

public:
    MOZ_IMPLICIT FTPChannelOpenArgs() :
        uri_(),
        entityID_(),
        uploadStream_(),
        loadInfo_(),
        startPos_(),
        loadFlags_()
    {
    }

    MOZ_IMPLICIT FTPChannelOpenArgs(
            const URIParams& _uri,
            const uint64_t& _startPos,
            const nsCString& _entityID,
            const mozilla::Maybe<IPCStream>& _uploadStream,
            const mozilla::Maybe<LoadInfoArgs>& _loadInfo,
            const uint32_t& _loadFlags) :
        uri_(_uri),
        entityID_(_entityID),
        uploadStream_(_uploadStream),
        loadInfo_(_loadInfo),
        startPos_(_startPos),
        loadFlags_(_loadFlags)
    {
    }

    URIParams&
    uri()
    {
        return uri_;
    }
    const URIParams&
    uri() const
    {
        return uri_;
    }

    uint64_t&
    startPos()
    {
        return startPos_;
    }
    const uint64_t&
    startPos() const
    {
        return startPos_;
    }

    nsCString&
    entityID()
    {
        return entityID_;
    }
    const nsCString&
    entityID() const
    {
        return entityID_;
    }

    mozilla::Maybe<IPCStream>&
    uploadStream()
    {
        return uploadStream_;
    }
    const mozilla::Maybe<IPCStream>&
    uploadStream() const
    {
        return uploadStream_;
    }

    mozilla::Maybe<LoadInfoArgs>&
    loadInfo()
    {
        return loadInfo_;
    }
    const mozilla::Maybe<LoadInfoArgs>&
    loadInfo() const
    {
        return loadInfo_;
    }

    uint32_t&
    loadFlags()
    {
        return loadFlags_;
    }
    const uint32_t&
    loadFlags() const
    {
        return loadFlags_;
    }

private:
    URIParams uri_;
    nsCString entityID_;
    mozilla::Maybe<IPCStream> uploadStream_;
    mozilla::Maybe<LoadInfoArgs> loadInfo_;
    uint64_t startPos_;
    uint32_t loadFlags_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::FTPChannelOpenArgs>
{
    typedef mozilla::net::FTPChannelOpenArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct FTPChannelConnectArgs|
//
namespace mozilla {
namespace net {
class FTPChannelConnectArgs final
{
private:

public:
    MOZ_IMPLICIT FTPChannelConnectArgs() :
        channelId_()
    {
    }

    MOZ_IMPLICIT FTPChannelConnectArgs(const uint32_t& _channelId) :
        channelId_(_channelId)
    {
    }

    uint32_t&
    channelId()
    {
        return channelId_;
    }
    const uint32_t&
    channelId() const
    {
        return channelId_;
    }

private:
    uint32_t channelId_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::FTPChannelConnectArgs>
{
    typedef mozilla::net::FTPChannelConnectArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union FTPChannelCreationArgs|
//
namespace mozilla {
namespace net {
class FTPChannelCreationArgs final
{
public:
    enum Type {
        T__None,
        TFTPChannelOpenArgs = 1,
        TFTPChannelConnectArgs,
        T__Last = TFTPChannelConnectArgs
    };

private:
    typedef mozilla::net::FTPChannelOpenArgs FTPChannelOpenArgs;
    typedef mozilla::net::FTPChannelConnectArgs FTPChannelConnectArgs;
    typedef FTPChannelOpenArgs FTPChannelOpenArgs__tdef;
    typedef FTPChannelConnectArgs FTPChannelConnectArgs__tdef;

    union Value {
        mozilla::AlignedStorage2<FTPChannelOpenArgs> VFTPChannelOpenArgs;
        mozilla::AlignedStorage2<FTPChannelConnectArgs> VFTPChannelConnectArgs;
    };

    FTPChannelOpenArgs*
    ptr_FTPChannelOpenArgs()
    {
        return ((mValue).VFTPChannelOpenArgs).addr();
    }
    const FTPChannelOpenArgs*
    constptr_FTPChannelOpenArgs() const
    {
        return ((mValue).VFTPChannelOpenArgs).addr();
    }
    FTPChannelConnectArgs*
    ptr_FTPChannelConnectArgs()
    {
        return ((mValue).VFTPChannelConnectArgs).addr();
    }
    const FTPChannelConnectArgs*
    constptr_FTPChannelConnectArgs() const
    {
        return ((mValue).VFTPChannelConnectArgs).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT FTPChannelCreationArgs() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT FTPChannelCreationArgs(const FTPChannelOpenArgs& aOther);

    MOZ_IMPLICIT FTPChannelCreationArgs(FTPChannelOpenArgs&& aOther);

    MOZ_IMPLICIT FTPChannelCreationArgs(const FTPChannelConnectArgs& aOther);

    MOZ_IMPLICIT FTPChannelCreationArgs(FTPChannelConnectArgs&& aOther);

    MOZ_IMPLICIT FTPChannelCreationArgs(const FTPChannelCreationArgs& aOther);

    MOZ_IMPLICIT FTPChannelCreationArgs(FTPChannelCreationArgs&& aOther);

    ~FTPChannelCreationArgs();

    Type
    type() const
    {
        return mType;
    }

    FTPChannelCreationArgs&
    operator=(const FTPChannelOpenArgs& aRhs);

    FTPChannelCreationArgs&
    operator=(FTPChannelOpenArgs&& aRhs);

    FTPChannelCreationArgs&
    operator=(const FTPChannelConnectArgs& aRhs);

    FTPChannelCreationArgs&
    operator=(FTPChannelConnectArgs&& aRhs);

    FTPChannelCreationArgs&
    operator=(const FTPChannelCreationArgs& aRhs);

    FTPChannelCreationArgs&
    operator=(FTPChannelCreationArgs&& aRhs);

    FTPChannelOpenArgs&
    get_FTPChannelOpenArgs()
    {
        AssertSanity(TFTPChannelOpenArgs);
        return (*(ptr_FTPChannelOpenArgs()));
    }
    const FTPChannelOpenArgs&
    get_FTPChannelOpenArgs() const
    {
        AssertSanity(TFTPChannelOpenArgs);
        return (*(constptr_FTPChannelOpenArgs()));
    }
    operator FTPChannelOpenArgs&()
    {
        return get_FTPChannelOpenArgs();
    }
    operator const FTPChannelOpenArgs&() const
    {
        return get_FTPChannelOpenArgs();
    }

    FTPChannelConnectArgs&
    get_FTPChannelConnectArgs()
    {
        AssertSanity(TFTPChannelConnectArgs);
        return (*(ptr_FTPChannelConnectArgs()));
    }
    const FTPChannelConnectArgs&
    get_FTPChannelConnectArgs() const
    {
        AssertSanity(TFTPChannelConnectArgs);
        return (*(constptr_FTPChannelConnectArgs()));
    }
    operator FTPChannelConnectArgs&()
    {
        return get_FTPChannelConnectArgs();
    }
    operator const FTPChannelConnectArgs&() const
    {
        return get_FTPChannelConnectArgs();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::FTPChannelCreationArgs>
{
    typedef mozilla::net::FTPChannelCreationArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct CookieStruct|
//
namespace mozilla {
namespace net {
class CookieStruct final
{
private:

public:
    MOZ_IMPLICIT CookieStruct() :
        name_(),
        value_(),
        host_(),
        path_(),
        isHttpOnly_(),
        isSession_(),
        isSecure_(),
        expiry_(),
        lastAccessed_(),
        creationTime_(),
        sameSite_(),
        rawSameSite_(),
        schemeMap_()
    {
    }

    MOZ_IMPLICIT CookieStruct(
            const nsCString& _name,
            const nsCString& _value,
            const nsCString& _host,
            const nsCString& _path,
            const int64_t& _expiry,
            const int64_t& _lastAccessed,
            const int64_t& _creationTime,
            const bool& _isHttpOnly,
            const bool& _isSession,
            const bool& _isSecure,
            const int32_t& _sameSite,
            const int32_t& _rawSameSite,
            const uint8_t& _schemeMap) :
        name_(_name),
        value_(_value),
        host_(_host),
        path_(_path),
        isHttpOnly_(_isHttpOnly),
        isSession_(_isSession),
        isSecure_(_isSecure),
        expiry_(_expiry),
        lastAccessed_(_lastAccessed),
        creationTime_(_creationTime),
        sameSite_(_sameSite),
        rawSameSite_(_rawSameSite),
        schemeMap_(_schemeMap)
    {
    }

    nsCString&
    name()
    {
        return name_;
    }
    const nsCString&
    name() const
    {
        return name_;
    }

    nsCString&
    value()
    {
        return value_;
    }
    const nsCString&
    value() const
    {
        return value_;
    }

    nsCString&
    host()
    {
        return host_;
    }
    const nsCString&
    host() const
    {
        return host_;
    }

    nsCString&
    path()
    {
        return path_;
    }
    const nsCString&
    path() const
    {
        return path_;
    }

    int64_t&
    expiry()
    {
        return expiry_;
    }
    const int64_t&
    expiry() const
    {
        return expiry_;
    }

    int64_t&
    lastAccessed()
    {
        return lastAccessed_;
    }
    const int64_t&
    lastAccessed() const
    {
        return lastAccessed_;
    }

    int64_t&
    creationTime()
    {
        return creationTime_;
    }
    const int64_t&
    creationTime() const
    {
        return creationTime_;
    }

    bool&
    isHttpOnly()
    {
        return isHttpOnly_;
    }
    const bool&
    isHttpOnly() const
    {
        return isHttpOnly_;
    }

    bool&
    isSession()
    {
        return isSession_;
    }
    const bool&
    isSession() const
    {
        return isSession_;
    }

    bool&
    isSecure()
    {
        return isSecure_;
    }
    const bool&
    isSecure() const
    {
        return isSecure_;
    }

    int32_t&
    sameSite()
    {
        return sameSite_;
    }
    const int32_t&
    sameSite() const
    {
        return sameSite_;
    }

    int32_t&
    rawSameSite()
    {
        return rawSameSite_;
    }
    const int32_t&
    rawSameSite() const
    {
        return rawSameSite_;
    }

    uint8_t&
    schemeMap()
    {
        return schemeMap_;
    }
    const uint8_t&
    schemeMap() const
    {
        return schemeMap_;
    }

private:
    void
    StaticAssertions() const;
    nsCString name_;
    nsCString value_;
    nsCString host_;
    nsCString path_;
    bool isHttpOnly_;
    bool isSession_;
    bool isSecure_;
    int64_t expiry_;
    int64_t lastAccessed_;
    int64_t creationTime_;
    int32_t sameSite_;
    int32_t rawSameSite_;
    uint8_t schemeMap_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::CookieStruct>
{
    typedef mozilla::net::CookieStruct paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct DocumentCreationArgs|
//
namespace mozilla {
namespace net {
class DocumentCreationArgs final
{
private:

public:
    MOZ_IMPLICIT DocumentCreationArgs() :
        uriModified_(),
        isXFOError_()
    {
    }

    MOZ_IMPLICIT DocumentCreationArgs(
            const bool& _uriModified,
            const bool& _isXFOError) :
        uriModified_(_uriModified),
        isXFOError_(_isXFOError)
    {
    }

    bool&
    uriModified()
    {
        return uriModified_;
    }
    const bool&
    uriModified() const
    {
        return uriModified_;
    }

    bool&
    isXFOError()
    {
        return isXFOError_;
    }
    const bool&
    isXFOError() const
    {
        return isXFOError_;
    }

private:
    bool uriModified_;
    bool isXFOError_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::DocumentCreationArgs>
{
    typedef mozilla::net::DocumentCreationArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ObjectCreationArgs|
//
namespace mozilla {
namespace net {
class ObjectCreationArgs final
{
private:

public:
    MOZ_IMPLICIT ObjectCreationArgs() :
        contentPolicyType_(),
        isUrgentStart_(),
        embedderInnerWindowId_(),
        loadFlags_()
    {
    }

    MOZ_IMPLICIT ObjectCreationArgs(
            const uint64_t& _embedderInnerWindowId,
            const uint32_t& _loadFlags,
            const nsContentPolicyType& _contentPolicyType,
            const bool& _isUrgentStart) :
        contentPolicyType_(_contentPolicyType),
        isUrgentStart_(_isUrgentStart),
        embedderInnerWindowId_(_embedderInnerWindowId),
        loadFlags_(_loadFlags)
    {
    }

    uint64_t&
    embedderInnerWindowId()
    {
        return embedderInnerWindowId_;
    }
    const uint64_t&
    embedderInnerWindowId() const
    {
        return embedderInnerWindowId_;
    }

    uint32_t&
    loadFlags()
    {
        return loadFlags_;
    }
    const uint32_t&
    loadFlags() const
    {
        return loadFlags_;
    }

    nsContentPolicyType&
    contentPolicyType()
    {
        return contentPolicyType_;
    }
    const nsContentPolicyType&
    contentPolicyType() const
    {
        return contentPolicyType_;
    }

    bool&
    isUrgentStart()
    {
        return isUrgentStart_;
    }
    const bool&
    isUrgentStart() const
    {
        return isUrgentStart_;
    }

private:
    nsContentPolicyType contentPolicyType_;
    bool isUrgentStart_;
    uint64_t embedderInnerWindowId_;
    uint32_t loadFlags_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::ObjectCreationArgs>
{
    typedef mozilla::net::ObjectCreationArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union DocumentChannelElementCreationArgs|
//
namespace mozilla {
namespace net {
class DocumentChannelElementCreationArgs final
{
public:
    enum Type {
        T__None,
        TDocumentCreationArgs = 1,
        TObjectCreationArgs,
        T__Last = TObjectCreationArgs
    };

private:
    typedef mozilla::net::DocumentCreationArgs DocumentCreationArgs;
    typedef mozilla::net::ObjectCreationArgs ObjectCreationArgs;
    typedef DocumentCreationArgs DocumentCreationArgs__tdef;
    typedef ObjectCreationArgs ObjectCreationArgs__tdef;

    union Value {
        mozilla::AlignedStorage2<DocumentCreationArgs> VDocumentCreationArgs;
        mozilla::AlignedStorage2<ObjectCreationArgs> VObjectCreationArgs;
    };

    DocumentCreationArgs*
    ptr_DocumentCreationArgs()
    {
        return ((mValue).VDocumentCreationArgs).addr();
    }
    const DocumentCreationArgs*
    constptr_DocumentCreationArgs() const
    {
        return ((mValue).VDocumentCreationArgs).addr();
    }
    ObjectCreationArgs*
    ptr_ObjectCreationArgs()
    {
        return ((mValue).VObjectCreationArgs).addr();
    }
    const ObjectCreationArgs*
    constptr_ObjectCreationArgs() const
    {
        return ((mValue).VObjectCreationArgs).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT DocumentChannelElementCreationArgs() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT DocumentChannelElementCreationArgs(const DocumentCreationArgs& aOther);

    MOZ_IMPLICIT DocumentChannelElementCreationArgs(DocumentCreationArgs&& aOther);

    MOZ_IMPLICIT DocumentChannelElementCreationArgs(const ObjectCreationArgs& aOther);

    MOZ_IMPLICIT DocumentChannelElementCreationArgs(ObjectCreationArgs&& aOther);

    MOZ_IMPLICIT DocumentChannelElementCreationArgs(const DocumentChannelElementCreationArgs& aOther);

    MOZ_IMPLICIT DocumentChannelElementCreationArgs(DocumentChannelElementCreationArgs&& aOther);

    ~DocumentChannelElementCreationArgs();

    Type
    type() const
    {
        return mType;
    }

    DocumentChannelElementCreationArgs&
    operator=(const DocumentCreationArgs& aRhs);

    DocumentChannelElementCreationArgs&
    operator=(DocumentCreationArgs&& aRhs);

    DocumentChannelElementCreationArgs&
    operator=(const ObjectCreationArgs& aRhs);

    DocumentChannelElementCreationArgs&
    operator=(ObjectCreationArgs&& aRhs);

    DocumentChannelElementCreationArgs&
    operator=(const DocumentChannelElementCreationArgs& aRhs);

    DocumentChannelElementCreationArgs&
    operator=(DocumentChannelElementCreationArgs&& aRhs);

    DocumentCreationArgs&
    get_DocumentCreationArgs()
    {
        AssertSanity(TDocumentCreationArgs);
        return (*(ptr_DocumentCreationArgs()));
    }
    const DocumentCreationArgs&
    get_DocumentCreationArgs() const
    {
        AssertSanity(TDocumentCreationArgs);
        return (*(constptr_DocumentCreationArgs()));
    }
    operator DocumentCreationArgs&()
    {
        return get_DocumentCreationArgs();
    }
    operator const DocumentCreationArgs&() const
    {
        return get_DocumentCreationArgs();
    }

    ObjectCreationArgs&
    get_ObjectCreationArgs()
    {
        AssertSanity(TObjectCreationArgs);
        return (*(ptr_ObjectCreationArgs()));
    }
    const ObjectCreationArgs&
    get_ObjectCreationArgs() const
    {
        AssertSanity(TObjectCreationArgs);
        return (*(constptr_ObjectCreationArgs()));
    }
    operator ObjectCreationArgs&()
    {
        return get_ObjectCreationArgs();
    }
    operator const ObjectCreationArgs&() const
    {
        return get_ObjectCreationArgs();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::DocumentChannelElementCreationArgs>
{
    typedef mozilla::net::DocumentChannelElementCreationArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct DocumentChannelCreationArgs|
//
namespace mozilla {
namespace net {
class DocumentChannelCreationArgs final
{
private:
    typedef mozilla::dom::DocShellLoadStateInit DocShellLoadStateInit;
    typedef mozilla::TimeStamp TimeStamp;
    typedef mozilla::dom::IPCClientInfo IPCClientInfo;
    typedef mozilla::net::DocumentChannelElementCreationArgs DocumentChannelElementCreationArgs;

public:
    MOZ_IMPLICIT DocumentChannelCreationArgs() :
        loadState_(),
        asyncOpenTime_(),
        timing_(),
        initialClientInfo_(),
        elementCreationArgs_(),
        channelId_(),
        cacheKey_()
    {
    }

    MOZ_IMPLICIT DocumentChannelCreationArgs(
            const DocShellLoadStateInit& _loadState,
            const TimeStamp& _asyncOpenTime,
            const uint64_t& _channelId,
            const uint32_t& _cacheKey,
            const mozilla::Maybe<RefPtr<nsDOMNavigationTiming>>& _timing,
            const mozilla::Maybe<IPCClientInfo>& _initialClientInfo,
            const DocumentChannelElementCreationArgs& _elementCreationArgs) :
        loadState_(_loadState),
        asyncOpenTime_(_asyncOpenTime),
        timing_(_timing),
        initialClientInfo_(_initialClientInfo),
        elementCreationArgs_(_elementCreationArgs),
        channelId_(_channelId),
        cacheKey_(_cacheKey)
    {
    }

    DocShellLoadStateInit&
    loadState()
    {
        return loadState_;
    }
    const DocShellLoadStateInit&
    loadState() const
    {
        return loadState_;
    }

    TimeStamp&
    asyncOpenTime()
    {
        return asyncOpenTime_;
    }
    const TimeStamp&
    asyncOpenTime() const
    {
        return asyncOpenTime_;
    }

    uint64_t&
    channelId()
    {
        return channelId_;
    }
    const uint64_t&
    channelId() const
    {
        return channelId_;
    }

    uint32_t&
    cacheKey()
    {
        return cacheKey_;
    }
    const uint32_t&
    cacheKey() const
    {
        return cacheKey_;
    }

    mozilla::Maybe<RefPtr<nsDOMNavigationTiming>>&
    timing()
    {
        return timing_;
    }
    const mozilla::Maybe<RefPtr<nsDOMNavigationTiming>>&
    timing() const
    {
        return timing_;
    }

    mozilla::Maybe<IPCClientInfo>&
    initialClientInfo()
    {
        return initialClientInfo_;
    }
    const mozilla::Maybe<IPCClientInfo>&
    initialClientInfo() const
    {
        return initialClientInfo_;
    }

    DocumentChannelElementCreationArgs&
    elementCreationArgs()
    {
        return elementCreationArgs_;
    }
    const DocumentChannelElementCreationArgs&
    elementCreationArgs() const
    {
        return elementCreationArgs_;
    }

private:
    DocShellLoadStateInit loadState_;
    TimeStamp asyncOpenTime_;
    mozilla::Maybe<RefPtr<nsDOMNavigationTiming>> timing_;
    mozilla::Maybe<IPCClientInfo> initialClientInfo_;
    DocumentChannelElementCreationArgs elementCreationArgs_;
    uint64_t channelId_;
    uint32_t cacheKey_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::DocumentChannelCreationArgs>
{
    typedef mozilla::net::DocumentChannelCreationArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct RedirectToRealChannelArgs|
//
namespace mozilla {
namespace net {
class RedirectToRealChannelArgs final
{
private:
    typedef mozilla::dom::ReplacementChannelConfigInit ReplacementChannelConfigInit;
    typedef mozilla::net::LoadInfoArgs LoadInfoArgs;
    typedef mozilla::dom::LoadingSessionHistoryInfo LoadingSessionHistoryInfo;

public:
    MOZ_IMPLICIT RedirectToRealChannelArgs() :
        uri_(),
        init_(),
        loadInfo_(),
        originalURI_(),
        contentDisposition_(),
        contentDispositionFilename_(),
        properties_(),
        timing_(),
        srcdocData_(),
        baseUri_(),
        loadingSessionHistoryInfo_(),
        originalUriString_(),
        channelId_(),
        loadIdentifier_(),
        registrarId_(),
        newLoadFlags_(),
        redirectMode_(),
        redirectFlags_(),
        loadStateExternalLoadFlags_(),
        loadStateInternalLoadFlags_(),
        loadStateLoadType_()
    {
    }

    MOZ_IMPLICIT RedirectToRealChannelArgs(
            const uint32_t& _registrarId,
            nsIURI* _uri,
            const uint32_t& _newLoadFlags,
            const mozilla::Maybe<ReplacementChannelConfigInit>& _init,
            const mozilla::Maybe<LoadInfoArgs>& _loadInfo,
            const uint64_t& _channelId,
            nsIURI* _originalURI,
            const uint32_t& _redirectMode,
            const uint32_t& _redirectFlags,
            const mozilla::Maybe<uint32_t>& _contentDisposition,
            const mozilla::Maybe<nsString>& _contentDispositionFilename,
            nsIPropertyBag2* _properties,
            const uint32_t& _loadStateExternalLoadFlags,
            const uint32_t& _loadStateInternalLoadFlags,
            const uint32_t& _loadStateLoadType,
            const mozilla::Maybe<RefPtr<nsDOMNavigationTiming>>& _timing,
            const nsString& _srcdocData,
            nsIURI* _baseUri,
            const mozilla::Maybe<LoadingSessionHistoryInfo>& _loadingSessionHistoryInfo,
            const uint64_t& _loadIdentifier,
            const mozilla::Maybe<nsCString>& _originalUriString) :
        uri_(_uri),
        init_(_init),
        loadInfo_(_loadInfo),
        originalURI_(_originalURI),
        contentDisposition_(_contentDisposition),
        contentDispositionFilename_(_contentDispositionFilename),
        properties_(_properties),
        timing_(_timing),
        srcdocData_(_srcdocData),
        baseUri_(_baseUri),
        loadingSessionHistoryInfo_(_loadingSessionHistoryInfo),
        originalUriString_(_originalUriString),
        channelId_(_channelId),
        loadIdentifier_(_loadIdentifier),
        registrarId_(_registrarId),
        newLoadFlags_(_newLoadFlags),
        redirectMode_(_redirectMode),
        redirectFlags_(_redirectFlags),
        loadStateExternalLoadFlags_(_loadStateExternalLoadFlags),
        loadStateInternalLoadFlags_(_loadStateInternalLoadFlags),
        loadStateLoadType_(_loadStateLoadType)
    {
    }

    uint32_t&
    registrarId()
    {
        return registrarId_;
    }
    const uint32_t&
    registrarId() const
    {
        return registrarId_;
    }

    RefPtr<nsIURI>&
    uri()
    {
        return uri_;
    }
    nsIURI*
    uri() const
    {
        return uri_;
    }

    uint32_t&
    newLoadFlags()
    {
        return newLoadFlags_;
    }
    const uint32_t&
    newLoadFlags() const
    {
        return newLoadFlags_;
    }

    mozilla::Maybe<ReplacementChannelConfigInit>&
    init()
    {
        return init_;
    }
    const mozilla::Maybe<ReplacementChannelConfigInit>&
    init() const
    {
        return init_;
    }

    mozilla::Maybe<LoadInfoArgs>&
    loadInfo()
    {
        return loadInfo_;
    }
    const mozilla::Maybe<LoadInfoArgs>&
    loadInfo() const
    {
        return loadInfo_;
    }

    uint64_t&
    channelId()
    {
        return channelId_;
    }
    const uint64_t&
    channelId() const
    {
        return channelId_;
    }

    RefPtr<nsIURI>&
    originalURI()
    {
        return originalURI_;
    }
    nsIURI*
    originalURI() const
    {
        return originalURI_;
    }

    uint32_t&
    redirectMode()
    {
        return redirectMode_;
    }
    const uint32_t&
    redirectMode() const
    {
        return redirectMode_;
    }

    uint32_t&
    redirectFlags()
    {
        return redirectFlags_;
    }
    const uint32_t&
    redirectFlags() const
    {
        return redirectFlags_;
    }

    mozilla::Maybe<uint32_t>&
    contentDisposition()
    {
        return contentDisposition_;
    }
    const mozilla::Maybe<uint32_t>&
    contentDisposition() const
    {
        return contentDisposition_;
    }

    mozilla::Maybe<nsString>&
    contentDispositionFilename()
    {
        return contentDispositionFilename_;
    }
    const mozilla::Maybe<nsString>&
    contentDispositionFilename() const
    {
        return contentDispositionFilename_;
    }

    RefPtr<nsIPropertyBag2>&
    properties()
    {
        return properties_;
    }
    nsIPropertyBag2*
    properties() const
    {
        return properties_;
    }

    uint32_t&
    loadStateExternalLoadFlags()
    {
        return loadStateExternalLoadFlags_;
    }
    const uint32_t&
    loadStateExternalLoadFlags() const
    {
        return loadStateExternalLoadFlags_;
    }

    uint32_t&
    loadStateInternalLoadFlags()
    {
        return loadStateInternalLoadFlags_;
    }
    const uint32_t&
    loadStateInternalLoadFlags() const
    {
        return loadStateInternalLoadFlags_;
    }

    uint32_t&
    loadStateLoadType()
    {
        return loadStateLoadType_;
    }
    const uint32_t&
    loadStateLoadType() const
    {
        return loadStateLoadType_;
    }

    mozilla::Maybe<RefPtr<nsDOMNavigationTiming>>&
    timing()
    {
        return timing_;
    }
    const mozilla::Maybe<RefPtr<nsDOMNavigationTiming>>&
    timing() const
    {
        return timing_;
    }

    nsString&
    srcdocData()
    {
        return srcdocData_;
    }
    const nsString&
    srcdocData() const
    {
        return srcdocData_;
    }

    RefPtr<nsIURI>&
    baseUri()
    {
        return baseUri_;
    }
    nsIURI*
    baseUri() const
    {
        return baseUri_;
    }

    mozilla::Maybe<LoadingSessionHistoryInfo>&
    loadingSessionHistoryInfo()
    {
        return loadingSessionHistoryInfo_;
    }
    const mozilla::Maybe<LoadingSessionHistoryInfo>&
    loadingSessionHistoryInfo() const
    {
        return loadingSessionHistoryInfo_;
    }

    uint64_t&
    loadIdentifier()
    {
        return loadIdentifier_;
    }
    const uint64_t&
    loadIdentifier() const
    {
        return loadIdentifier_;
    }

    mozilla::Maybe<nsCString>&
    originalUriString()
    {
        return originalUriString_;
    }
    const mozilla::Maybe<nsCString>&
    originalUriString() const
    {
        return originalUriString_;
    }

private:
    void
    StaticAssertions() const;
    RefPtr<nsIURI> uri_;
    mozilla::Maybe<ReplacementChannelConfigInit> init_;
    mozilla::Maybe<LoadInfoArgs> loadInfo_;
    RefPtr<nsIURI> originalURI_;
    mozilla::Maybe<uint32_t> contentDisposition_;
    mozilla::Maybe<nsString> contentDispositionFilename_;
    RefPtr<nsIPropertyBag2> properties_;
    mozilla::Maybe<RefPtr<nsDOMNavigationTiming>> timing_;
    nsString srcdocData_;
    RefPtr<nsIURI> baseUri_;
    mozilla::Maybe<LoadingSessionHistoryInfo> loadingSessionHistoryInfo_;
    mozilla::Maybe<nsCString> originalUriString_;
    uint64_t channelId_;
    uint64_t loadIdentifier_;
    uint32_t registrarId_;
    uint32_t newLoadFlags_;
    uint32_t redirectMode_;
    uint32_t redirectFlags_;
    uint32_t loadStateExternalLoadFlags_;
    uint32_t loadStateInternalLoadFlags_;
    uint32_t loadStateLoadType_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::RedirectToRealChannelArgs>
{
    typedef mozilla::net::RedirectToRealChannelArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct TimingStructArgs|
//
namespace mozilla {
namespace net {
class TimingStructArgs final
{
private:
    typedef mozilla::TimeStamp TimeStamp;

public:
    MOZ_IMPLICIT TimingStructArgs() :
        domainLookupStart_(),
        domainLookupEnd_(),
        connectStart_(),
        tcpConnectEnd_(),
        secureConnectionStart_(),
        connectEnd_(),
        requestStart_(),
        responseStart_(),
        responseEnd_()
    {
    }

    MOZ_IMPLICIT TimingStructArgs(
            const TimeStamp& _domainLookupStart,
            const TimeStamp& _domainLookupEnd,
            const TimeStamp& _connectStart,
            const TimeStamp& _tcpConnectEnd,
            const TimeStamp& _secureConnectionStart,
            const TimeStamp& _connectEnd,
            const TimeStamp& _requestStart,
            const TimeStamp& _responseStart,
            const TimeStamp& _responseEnd) :
        domainLookupStart_(_domainLookupStart),
        domainLookupEnd_(_domainLookupEnd),
        connectStart_(_connectStart),
        tcpConnectEnd_(_tcpConnectEnd),
        secureConnectionStart_(_secureConnectionStart),
        connectEnd_(_connectEnd),
        requestStart_(_requestStart),
        responseStart_(_responseStart),
        responseEnd_(_responseEnd)
    {
    }

    TimeStamp&
    domainLookupStart()
    {
        return domainLookupStart_;
    }
    const TimeStamp&
    domainLookupStart() const
    {
        return domainLookupStart_;
    }

    TimeStamp&
    domainLookupEnd()
    {
        return domainLookupEnd_;
    }
    const TimeStamp&
    domainLookupEnd() const
    {
        return domainLookupEnd_;
    }

    TimeStamp&
    connectStart()
    {
        return connectStart_;
    }
    const TimeStamp&
    connectStart() const
    {
        return connectStart_;
    }

    TimeStamp&
    tcpConnectEnd()
    {
        return tcpConnectEnd_;
    }
    const TimeStamp&
    tcpConnectEnd() const
    {
        return tcpConnectEnd_;
    }

    TimeStamp&
    secureConnectionStart()
    {
        return secureConnectionStart_;
    }
    const TimeStamp&
    secureConnectionStart() const
    {
        return secureConnectionStart_;
    }

    TimeStamp&
    connectEnd()
    {
        return connectEnd_;
    }
    const TimeStamp&
    connectEnd() const
    {
        return connectEnd_;
    }

    TimeStamp&
    requestStart()
    {
        return requestStart_;
    }
    const TimeStamp&
    requestStart() const
    {
        return requestStart_;
    }

    TimeStamp&
    responseStart()
    {
        return responseStart_;
    }
    const TimeStamp&
    responseStart() const
    {
        return responseStart_;
    }

    TimeStamp&
    responseEnd()
    {
        return responseEnd_;
    }
    const TimeStamp&
    responseEnd() const
    {
        return responseEnd_;
    }

private:
    TimeStamp domainLookupStart_;
    TimeStamp domainLookupEnd_;
    TimeStamp connectStart_;
    TimeStamp tcpConnectEnd_;
    TimeStamp secureConnectionStart_;
    TimeStamp connectEnd_;
    TimeStamp requestStart_;
    TimeStamp responseStart_;
    TimeStamp responseEnd_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::TimingStructArgs>
{
    typedef mozilla::net::TimingStructArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct ResourceTimingStructArgs|
//
namespace mozilla {
namespace net {
class ResourceTimingStructArgs final
{
private:
    typedef mozilla::TimeStamp TimeStamp;

public:
    MOZ_IMPLICIT ResourceTimingStructArgs() :
        domainLookupStart_(),
        domainLookupEnd_(),
        connectStart_(),
        tcpConnectEnd_(),
        secureConnectionStart_(),
        connectEnd_(),
        requestStart_(),
        responseStart_(),
        responseEnd_(),
        fetchStart_(),
        redirectStart_(),
        redirectEnd_(),
        protocolVersion_(),
        cacheReadStart_(),
        cacheReadEnd_(),
        transferSize_(),
        encodedBodySize_()
    {
    }

    MOZ_IMPLICIT ResourceTimingStructArgs(
            const TimeStamp& _domainLookupStart,
            const TimeStamp& _domainLookupEnd,
            const TimeStamp& _connectStart,
            const TimeStamp& _tcpConnectEnd,
            const TimeStamp& _secureConnectionStart,
            const TimeStamp& _connectEnd,
            const TimeStamp& _requestStart,
            const TimeStamp& _responseStart,
            const TimeStamp& _responseEnd,
            const TimeStamp& _fetchStart,
            const TimeStamp& _redirectStart,
            const TimeStamp& _redirectEnd,
            const uint64_t& _transferSize,
            const uint64_t& _encodedBodySize,
            const nsCString& _protocolVersion,
            const TimeStamp& _cacheReadStart,
            const TimeStamp& _cacheReadEnd) :
        domainLookupStart_(_domainLookupStart),
        domainLookupEnd_(_domainLookupEnd),
        connectStart_(_connectStart),
        tcpConnectEnd_(_tcpConnectEnd),
        secureConnectionStart_(_secureConnectionStart),
        connectEnd_(_connectEnd),
        requestStart_(_requestStart),
        responseStart_(_responseStart),
        responseEnd_(_responseEnd),
        fetchStart_(_fetchStart),
        redirectStart_(_redirectStart),
        redirectEnd_(_redirectEnd),
        protocolVersion_(_protocolVersion),
        cacheReadStart_(_cacheReadStart),
        cacheReadEnd_(_cacheReadEnd),
        transferSize_(_transferSize),
        encodedBodySize_(_encodedBodySize)
    {
    }

    TimeStamp&
    domainLookupStart()
    {
        return domainLookupStart_;
    }
    const TimeStamp&
    domainLookupStart() const
    {
        return domainLookupStart_;
    }

    TimeStamp&
    domainLookupEnd()
    {
        return domainLookupEnd_;
    }
    const TimeStamp&
    domainLookupEnd() const
    {
        return domainLookupEnd_;
    }

    TimeStamp&
    connectStart()
    {
        return connectStart_;
    }
    const TimeStamp&
    connectStart() const
    {
        return connectStart_;
    }

    TimeStamp&
    tcpConnectEnd()
    {
        return tcpConnectEnd_;
    }
    const TimeStamp&
    tcpConnectEnd() const
    {
        return tcpConnectEnd_;
    }

    TimeStamp&
    secureConnectionStart()
    {
        return secureConnectionStart_;
    }
    const TimeStamp&
    secureConnectionStart() const
    {
        return secureConnectionStart_;
    }

    TimeStamp&
    connectEnd()
    {
        return connectEnd_;
    }
    const TimeStamp&
    connectEnd() const
    {
        return connectEnd_;
    }

    TimeStamp&
    requestStart()
    {
        return requestStart_;
    }
    const TimeStamp&
    requestStart() const
    {
        return requestStart_;
    }

    TimeStamp&
    responseStart()
    {
        return responseStart_;
    }
    const TimeStamp&
    responseStart() const
    {
        return responseStart_;
    }

    TimeStamp&
    responseEnd()
    {
        return responseEnd_;
    }
    const TimeStamp&
    responseEnd() const
    {
        return responseEnd_;
    }

    TimeStamp&
    fetchStart()
    {
        return fetchStart_;
    }
    const TimeStamp&
    fetchStart() const
    {
        return fetchStart_;
    }

    TimeStamp&
    redirectStart()
    {
        return redirectStart_;
    }
    const TimeStamp&
    redirectStart() const
    {
        return redirectStart_;
    }

    TimeStamp&
    redirectEnd()
    {
        return redirectEnd_;
    }
    const TimeStamp&
    redirectEnd() const
    {
        return redirectEnd_;
    }

    uint64_t&
    transferSize()
    {
        return transferSize_;
    }
    const uint64_t&
    transferSize() const
    {
        return transferSize_;
    }

    uint64_t&
    encodedBodySize()
    {
        return encodedBodySize_;
    }
    const uint64_t&
    encodedBodySize() const
    {
        return encodedBodySize_;
    }

    nsCString&
    protocolVersion()
    {
        return protocolVersion_;
    }
    const nsCString&
    protocolVersion() const
    {
        return protocolVersion_;
    }

    TimeStamp&
    cacheReadStart()
    {
        return cacheReadStart_;
    }
    const TimeStamp&
    cacheReadStart() const
    {
        return cacheReadStart_;
    }

    TimeStamp&
    cacheReadEnd()
    {
        return cacheReadEnd_;
    }
    const TimeStamp&
    cacheReadEnd() const
    {
        return cacheReadEnd_;
    }

private:
    void
    StaticAssertions() const;
    TimeStamp domainLookupStart_;
    TimeStamp domainLookupEnd_;
    TimeStamp connectStart_;
    TimeStamp tcpConnectEnd_;
    TimeStamp secureConnectionStart_;
    TimeStamp connectEnd_;
    TimeStamp requestStart_;
    TimeStamp responseStart_;
    TimeStamp responseEnd_;
    TimeStamp fetchStart_;
    TimeStamp redirectStart_;
    TimeStamp redirectEnd_;
    nsCString protocolVersion_;
    TimeStamp cacheReadStart_;
    TimeStamp cacheReadEnd_;
    uint64_t transferSize_;
    uint64_t encodedBodySize_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::ResourceTimingStructArgs>
{
    typedef mozilla::net::ResourceTimingStructArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct HttpActivity|
//
namespace mozilla {
namespace net {
class HttpActivity final
{
private:

public:
    MOZ_IMPLICIT HttpActivity() :
        host_(),
        endToEndSSL_(),
        port_()
    {
    }

    MOZ_IMPLICIT HttpActivity(
            const nsCString& _host,
            const int32_t& _port,
            const bool& _endToEndSSL) :
        host_(_host),
        endToEndSSL_(_endToEndSSL),
        port_(_port)
    {
    }

    nsCString&
    host()
    {
        return host_;
    }
    const nsCString&
    host() const
    {
        return host_;
    }

    int32_t&
    port()
    {
        return port_;
    }
    const int32_t&
    port() const
    {
        return port_;
    }

    bool&
    endToEndSSL()
    {
        return endToEndSSL_;
    }
    const bool&
    endToEndSSL() const
    {
        return endToEndSSL_;
    }

private:
    nsCString host_;
    bool endToEndSSL_;
    int32_t port_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::HttpActivity>
{
    typedef mozilla::net::HttpActivity paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union HttpActivityArgs|
//
namespace mozilla {
namespace net {
class HttpActivityArgs final
{
public:
    enum Type {
        T__None,
        Tuint64_t = 1,
        THttpActivity,
        T__Last = THttpActivity
    };

private:
    typedef mozilla::net::HttpActivity HttpActivity;
    typedef uint64_t uint64_t__tdef;
    typedef HttpActivity HttpActivity__tdef;

    union Value {
        mozilla::AlignedStorage2<uint64_t> Vuint64_t;
        mozilla::AlignedStorage2<HttpActivity> VHttpActivity;
    };

    uint64_t*
    ptr_uint64_t()
    {
        return ((mValue).Vuint64_t).addr();
    }
    const uint64_t*
    constptr_uint64_t() const
    {
        return ((mValue).Vuint64_t).addr();
    }
    HttpActivity*
    ptr_HttpActivity()
    {
        return ((mValue).VHttpActivity).addr();
    }
    const HttpActivity*
    constptr_HttpActivity() const
    {
        return ((mValue).VHttpActivity).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT HttpActivityArgs() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT HttpActivityArgs(const uint64_t& aOther);

    MOZ_IMPLICIT HttpActivityArgs(uint64_t&& aOther);

    MOZ_IMPLICIT HttpActivityArgs(const HttpActivity& aOther);

    MOZ_IMPLICIT HttpActivityArgs(HttpActivity&& aOther);

    MOZ_IMPLICIT HttpActivityArgs(const HttpActivityArgs& aOther);

    MOZ_IMPLICIT HttpActivityArgs(HttpActivityArgs&& aOther);

    ~HttpActivityArgs();

    Type
    type() const
    {
        return mType;
    }

    HttpActivityArgs&
    operator=(const uint64_t& aRhs);

    HttpActivityArgs&
    operator=(uint64_t&& aRhs);

    HttpActivityArgs&
    operator=(const HttpActivity& aRhs);

    HttpActivityArgs&
    operator=(HttpActivity&& aRhs);

    HttpActivityArgs&
    operator=(const HttpActivityArgs& aRhs);

    HttpActivityArgs&
    operator=(HttpActivityArgs&& aRhs);

    uint64_t&
    get_uint64_t()
    {
        AssertSanity(Tuint64_t);
        return (*(ptr_uint64_t()));
    }
    const uint64_t&
    get_uint64_t() const
    {
        AssertSanity(Tuint64_t);
        return (*(constptr_uint64_t()));
    }
    operator uint64_t&()
    {
        return get_uint64_t();
    }
    operator const uint64_t&() const
    {
        return get_uint64_t();
    }

    HttpActivity&
    get_HttpActivity()
    {
        AssertSanity(THttpActivity);
        return (*(ptr_HttpActivity()));
    }
    const HttpActivity&
    get_HttpActivity() const
    {
        AssertSanity(THttpActivity);
        return (*(constptr_HttpActivity()));
    }
    operator HttpActivity&()
    {
        return get_HttpActivity();
    }
    operator const HttpActivity&() const
    {
        return get_HttpActivity();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::HttpActivityArgs>
{
    typedef mozilla::net::HttpActivityArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct TransactionObserverResult|
//
namespace mozilla {
namespace net {
class TransactionObserverResult final
{
private:

public:
    MOZ_IMPLICIT TransactionObserverResult() :
        versionOk_(),
        authOk_(),
        closeReason_()
    {
    }

    MOZ_IMPLICIT TransactionObserverResult(
            const bool& _versionOk,
            const bool& _authOk,
            const nsresult& _closeReason) :
        versionOk_(_versionOk),
        authOk_(_authOk),
        closeReason_(_closeReason)
    {
    }

    bool&
    versionOk()
    {
        return versionOk_;
    }
    const bool&
    versionOk() const
    {
        return versionOk_;
    }

    bool&
    authOk()
    {
        return authOk_;
    }
    const bool&
    authOk() const
    {
        return authOk_;
    }

    nsresult&
    closeReason()
    {
        return closeReason_;
    }
    const nsresult&
    closeReason() const
    {
        return closeReason_;
    }

private:
    bool versionOk_;
    bool authOk_;
    nsresult closeReason_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::TransactionObserverResult>
{
    typedef mozilla::net::TransactionObserverResult paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct SpeculativeConnectionOverriderArgs|
//
namespace mozilla {
namespace net {
class SpeculativeConnectionOverriderArgs final
{
private:

public:
    MOZ_IMPLICIT SpeculativeConnectionOverriderArgs() :
        ignoreIdle_(),
        isFromPredictor_(),
        allow1918_(),
        parallelSpeculativeConnectLimit_()
    {
    }

    MOZ_IMPLICIT SpeculativeConnectionOverriderArgs(
            const uint32_t& _parallelSpeculativeConnectLimit,
            const bool& _ignoreIdle,
            const bool& _isFromPredictor,
            const bool& _allow1918) :
        ignoreIdle_(_ignoreIdle),
        isFromPredictor_(_isFromPredictor),
        allow1918_(_allow1918),
        parallelSpeculativeConnectLimit_(_parallelSpeculativeConnectLimit)
    {
    }

    uint32_t&
    parallelSpeculativeConnectLimit()
    {
        return parallelSpeculativeConnectLimit_;
    }
    const uint32_t&
    parallelSpeculativeConnectLimit() const
    {
        return parallelSpeculativeConnectLimit_;
    }

    bool&
    ignoreIdle()
    {
        return ignoreIdle_;
    }
    const bool&
    ignoreIdle() const
    {
        return ignoreIdle_;
    }

    bool&
    isFromPredictor()
    {
        return isFromPredictor_;
    }
    const bool&
    isFromPredictor() const
    {
        return isFromPredictor_;
    }

    bool&
    allow1918()
    {
        return allow1918_;
    }
    const bool&
    allow1918() const
    {
        return allow1918_;
    }

private:
    bool ignoreIdle_;
    bool isFromPredictor_;
    bool allow1918_;
    uint32_t parallelSpeculativeConnectLimit_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::SpeculativeConnectionOverriderArgs>
{
    typedef mozilla::net::SpeculativeConnectionOverriderArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct GIOChannelOpenArgs|
//
namespace mozilla {
namespace net {
class GIOChannelOpenArgs final
{
private:
    typedef mozilla::ipc::URIParams URIParams;
    typedef mozilla::ipc::IPCStream IPCStream;
    typedef mozilla::net::LoadInfoArgs LoadInfoArgs;

public:
    MOZ_IMPLICIT GIOChannelOpenArgs() :
        uri_(),
        entityID_(),
        uploadStream_(),
        loadInfo_(),
        startPos_(),
        loadFlags_()
    {
    }

    MOZ_IMPLICIT GIOChannelOpenArgs(
            const URIParams& _uri,
            const uint64_t& _startPos,
            const nsCString& _entityID,
            const mozilla::Maybe<IPCStream>& _uploadStream,
            const mozilla::Maybe<LoadInfoArgs>& _loadInfo,
            const uint32_t& _loadFlags) :
        uri_(_uri),
        entityID_(_entityID),
        uploadStream_(_uploadStream),
        loadInfo_(_loadInfo),
        startPos_(_startPos),
        loadFlags_(_loadFlags)
    {
    }

    URIParams&
    uri()
    {
        return uri_;
    }
    const URIParams&
    uri() const
    {
        return uri_;
    }

    uint64_t&
    startPos()
    {
        return startPos_;
    }
    const uint64_t&
    startPos() const
    {
        return startPos_;
    }

    nsCString&
    entityID()
    {
        return entityID_;
    }
    const nsCString&
    entityID() const
    {
        return entityID_;
    }

    mozilla::Maybe<IPCStream>&
    uploadStream()
    {
        return uploadStream_;
    }
    const mozilla::Maybe<IPCStream>&
    uploadStream() const
    {
        return uploadStream_;
    }

    mozilla::Maybe<LoadInfoArgs>&
    loadInfo()
    {
        return loadInfo_;
    }
    const mozilla::Maybe<LoadInfoArgs>&
    loadInfo() const
    {
        return loadInfo_;
    }

    uint32_t&
    loadFlags()
    {
        return loadFlags_;
    }
    const uint32_t&
    loadFlags() const
    {
        return loadFlags_;
    }

private:
    URIParams uri_;
    nsCString entityID_;
    mozilla::Maybe<IPCStream> uploadStream_;
    mozilla::Maybe<LoadInfoArgs> loadInfo_;
    uint64_t startPos_;
    uint32_t loadFlags_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::GIOChannelOpenArgs>
{
    typedef mozilla::net::GIOChannelOpenArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct GIOChannelConnectArgs|
//
namespace mozilla {
namespace net {
class GIOChannelConnectArgs final
{
private:

public:
    MOZ_IMPLICIT GIOChannelConnectArgs() :
        channelId_()
    {
    }

    MOZ_IMPLICIT GIOChannelConnectArgs(const uint32_t& _channelId) :
        channelId_(_channelId)
    {
    }

    uint32_t&
    channelId()
    {
        return channelId_;
    }
    const uint32_t&
    channelId() const
    {
        return channelId_;
    }

private:
    uint32_t channelId_;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::GIOChannelConnectArgs>
{
    typedef mozilla::net::GIOChannelConnectArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union GIOChannelCreationArgs|
//
namespace mozilla {
namespace net {
class GIOChannelCreationArgs final
{
public:
    enum Type {
        T__None,
        TGIOChannelOpenArgs = 1,
        TGIOChannelConnectArgs,
        T__Last = TGIOChannelConnectArgs
    };

private:
    typedef mozilla::net::GIOChannelOpenArgs GIOChannelOpenArgs;
    typedef mozilla::net::GIOChannelConnectArgs GIOChannelConnectArgs;
    typedef GIOChannelOpenArgs GIOChannelOpenArgs__tdef;
    typedef GIOChannelConnectArgs GIOChannelConnectArgs__tdef;

    union Value {
        mozilla::AlignedStorage2<GIOChannelOpenArgs> VGIOChannelOpenArgs;
        mozilla::AlignedStorage2<GIOChannelConnectArgs> VGIOChannelConnectArgs;
    };

    GIOChannelOpenArgs*
    ptr_GIOChannelOpenArgs()
    {
        return ((mValue).VGIOChannelOpenArgs).addr();
    }
    const GIOChannelOpenArgs*
    constptr_GIOChannelOpenArgs() const
    {
        return ((mValue).VGIOChannelOpenArgs).addr();
    }
    GIOChannelConnectArgs*
    ptr_GIOChannelConnectArgs()
    {
        return ((mValue).VGIOChannelConnectArgs).addr();
    }
    const GIOChannelConnectArgs*
    constptr_GIOChannelConnectArgs() const
    {
        return ((mValue).VGIOChannelConnectArgs).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT GIOChannelCreationArgs() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT GIOChannelCreationArgs(const GIOChannelOpenArgs& aOther);

    MOZ_IMPLICIT GIOChannelCreationArgs(GIOChannelOpenArgs&& aOther);

    MOZ_IMPLICIT GIOChannelCreationArgs(const GIOChannelConnectArgs& aOther);

    MOZ_IMPLICIT GIOChannelCreationArgs(GIOChannelConnectArgs&& aOther);

    MOZ_IMPLICIT GIOChannelCreationArgs(const GIOChannelCreationArgs& aOther);

    MOZ_IMPLICIT GIOChannelCreationArgs(GIOChannelCreationArgs&& aOther);

    ~GIOChannelCreationArgs();

    Type
    type() const
    {
        return mType;
    }

    GIOChannelCreationArgs&
    operator=(const GIOChannelOpenArgs& aRhs);

    GIOChannelCreationArgs&
    operator=(GIOChannelOpenArgs&& aRhs);

    GIOChannelCreationArgs&
    operator=(const GIOChannelConnectArgs& aRhs);

    GIOChannelCreationArgs&
    operator=(GIOChannelConnectArgs&& aRhs);

    GIOChannelCreationArgs&
    operator=(const GIOChannelCreationArgs& aRhs);

    GIOChannelCreationArgs&
    operator=(GIOChannelCreationArgs&& aRhs);

    GIOChannelOpenArgs&
    get_GIOChannelOpenArgs()
    {
        AssertSanity(TGIOChannelOpenArgs);
        return (*(ptr_GIOChannelOpenArgs()));
    }
    const GIOChannelOpenArgs&
    get_GIOChannelOpenArgs() const
    {
        AssertSanity(TGIOChannelOpenArgs);
        return (*(constptr_GIOChannelOpenArgs()));
    }
    operator GIOChannelOpenArgs&()
    {
        return get_GIOChannelOpenArgs();
    }
    operator const GIOChannelOpenArgs&() const
    {
        return get_GIOChannelOpenArgs();
    }

    GIOChannelConnectArgs&
    get_GIOChannelConnectArgs()
    {
        AssertSanity(TGIOChannelConnectArgs);
        return (*(ptr_GIOChannelConnectArgs()));
    }
    const GIOChannelConnectArgs&
    get_GIOChannelConnectArgs() const
    {
        AssertSanity(TGIOChannelConnectArgs);
        return (*(constptr_GIOChannelConnectArgs()));
    }
    operator GIOChannelConnectArgs&()
    {
        return get_GIOChannelConnectArgs();
    }
    operator const GIOChannelConnectArgs&() const
    {
        return get_GIOChannelConnectArgs();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::net::GIOChannelCreationArgs>
{
    typedef mozilla::net::GIOChannelCreationArgs paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

#endif // ifndef NeckoChannelParams_h
