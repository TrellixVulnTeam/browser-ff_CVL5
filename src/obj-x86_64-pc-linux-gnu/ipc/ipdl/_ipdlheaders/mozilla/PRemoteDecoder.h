//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PRemoteDecoder_h
#define PRemoteDecoder_h

#include "mozilla/Attributes.h"
#include "IPCMessageStart.h"
#include "mozilla/RefPtr.h"
#include "nsString.h"
#include "nsTArray.h"
#include "nsTHashtable.h"
#include "mozilla/MozPromise.h"
#include "mozilla/OperatorNewExtensions.h"
#include "mozilla/UniquePtr.h"
#include "mozilla/ipc/ByteBuf.h"
#include "mozilla/ipc/FileDescriptor.h"
#include "mozilla/ipc/ProtocolUtilsFwd.h"
#include "mozilla/ipc/Shmem.h"

// Headers for typedefs
#include "MediaInfo.h"
#include "MediaResult.h"
#include "PlatformDecoderModule.h"
#include "mozilla/RemoteMediaData.h"
#include "mozilla/PMediaDecoderParams.h"
#include "mozilla/layers/LayersSurfaces.h"


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union DecodedOutputIPDL|
//
namespace mozilla {
class DecodedOutputIPDL final
{
public:
    enum Type {
        T__None,
        TArrayOfRemoteAudioData = 1,
        TArrayOfRemoteVideoData,
        T__Last = TArrayOfRemoteVideoData
    };

private:
    typedef mozilla::ArrayOfRemoteAudioData ArrayOfRemoteAudioData;
    typedef mozilla::ArrayOfRemoteVideoData ArrayOfRemoteVideoData;
    typedef RefPtr<ArrayOfRemoteAudioData> ArrayOfRemoteAudioData__tdef;
    typedef RefPtr<ArrayOfRemoteVideoData> ArrayOfRemoteVideoData__tdef;

    union Value {
        mozilla::AlignedStorage2<RefPtr<ArrayOfRemoteAudioData>> VArrayOfRemoteAudioData;
        mozilla::AlignedStorage2<RefPtr<ArrayOfRemoteVideoData>> VArrayOfRemoteVideoData;
    };

    RefPtr<ArrayOfRemoteAudioData>*
    ptr_ArrayOfRemoteAudioData()
    {
        return ((mValue).VArrayOfRemoteAudioData).addr();
    }
    const RefPtr<ArrayOfRemoteAudioData>*
    constptr_ArrayOfRemoteAudioData() const
    {
        return ((mValue).VArrayOfRemoteAudioData).addr();
    }
    RefPtr<ArrayOfRemoteVideoData>*
    ptr_ArrayOfRemoteVideoData()
    {
        return ((mValue).VArrayOfRemoteVideoData).addr();
    }
    const RefPtr<ArrayOfRemoteVideoData>*
    constptr_ArrayOfRemoteVideoData() const
    {
        return ((mValue).VArrayOfRemoteVideoData).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT DecodedOutputIPDL() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT DecodedOutputIPDL(ArrayOfRemoteAudioData* aOther);

    MOZ_IMPLICIT DecodedOutputIPDL(RefPtr<ArrayOfRemoteAudioData>&& aOther);

    MOZ_IMPLICIT DecodedOutputIPDL(ArrayOfRemoteVideoData* aOther);

    MOZ_IMPLICIT DecodedOutputIPDL(RefPtr<ArrayOfRemoteVideoData>&& aOther);

    MOZ_IMPLICIT DecodedOutputIPDL(const DecodedOutputIPDL& aOther);

    MOZ_IMPLICIT DecodedOutputIPDL(DecodedOutputIPDL&& aOther);

    ~DecodedOutputIPDL();

    Type
    type() const
    {
        return mType;
    }

    DecodedOutputIPDL&
    operator=(ArrayOfRemoteAudioData* aRhs);

    DecodedOutputIPDL&
    operator=(RefPtr<ArrayOfRemoteAudioData>&& aRhs);

    DecodedOutputIPDL&
    operator=(ArrayOfRemoteVideoData* aRhs);

    DecodedOutputIPDL&
    operator=(RefPtr<ArrayOfRemoteVideoData>&& aRhs);

    DecodedOutputIPDL&
    operator=(const DecodedOutputIPDL& aRhs);

    DecodedOutputIPDL&
    operator=(DecodedOutputIPDL&& aRhs);

    RefPtr<ArrayOfRemoteAudioData>&
    get_ArrayOfRemoteAudioData()
    {
        AssertSanity(TArrayOfRemoteAudioData);
        return (*(ptr_ArrayOfRemoteAudioData()));
    }
    ArrayOfRemoteAudioData*
    get_ArrayOfRemoteAudioData() const
    {
        AssertSanity(TArrayOfRemoteAudioData);
        return (*(constptr_ArrayOfRemoteAudioData()));
    }
    operator RefPtr<ArrayOfRemoteAudioData>&()
    {
        return get_ArrayOfRemoteAudioData();
    }
    operator ArrayOfRemoteAudioData*() const
    {
        return get_ArrayOfRemoteAudioData();
    }

    RefPtr<ArrayOfRemoteVideoData>&
    get_ArrayOfRemoteVideoData()
    {
        AssertSanity(TArrayOfRemoteVideoData);
        return (*(ptr_ArrayOfRemoteVideoData()));
    }
    ArrayOfRemoteVideoData*
    get_ArrayOfRemoteVideoData() const
    {
        AssertSanity(TArrayOfRemoteVideoData);
        return (*(constptr_ArrayOfRemoteVideoData()));
    }
    operator RefPtr<ArrayOfRemoteVideoData>&()
    {
        return get_ArrayOfRemoteVideoData();
    }
    operator ArrayOfRemoteVideoData*() const
    {
        return get_ArrayOfRemoteVideoData();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::DecodedOutputIPDL>
{
    typedef mozilla::DecodedOutputIPDL paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |struct InitCompletionIPDL|
//
namespace mozilla {
class InitCompletionIPDL final
{
private:
    typedef mozilla::TrackInfo::TrackType TrackType;
    typedef mozilla::MediaDataDecoder::ConversionRequired ConversionRequired;

public:
    MOZ_IMPLICIT InitCompletionIPDL() :
        type_(),
        decoderDescription_(),
        hardware_(),
        hardwareReason_(),
        conversion_()
    {
    }

    MOZ_IMPLICIT InitCompletionIPDL(
            const TrackType& _type,
            const nsCString& _decoderDescription,
            const bool& _hardware,
            const nsCString& _hardwareReason,
            const ConversionRequired& _conversion) :
        type_(_type),
        decoderDescription_(_decoderDescription),
        hardware_(_hardware),
        hardwareReason_(_hardwareReason),
        conversion_(_conversion)
    {
    }

    TrackType&
    type()
    {
        return type_;
    }
    const TrackType&
    type() const
    {
        return type_;
    }

    nsCString&
    decoderDescription()
    {
        return decoderDescription_;
    }
    const nsCString&
    decoderDescription() const
    {
        return decoderDescription_;
    }

    bool&
    hardware()
    {
        return hardware_;
    }
    const bool&
    hardware() const
    {
        return hardware_;
    }

    nsCString&
    hardwareReason()
    {
        return hardwareReason_;
    }
    const nsCString&
    hardwareReason() const
    {
        return hardwareReason_;
    }

    ConversionRequired&
    conversion()
    {
        return conversion_;
    }
    const ConversionRequired&
    conversion() const
    {
        return conversion_;
    }

private:
    TrackType type_;
    nsCString decoderDescription_;
    bool hardware_;
    nsCString hardwareReason_;
    ConversionRequired conversion_;
};
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::InitCompletionIPDL>
{
    typedef mozilla::InitCompletionIPDL paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union InitResultIPDL|
//
namespace mozilla {
class InitResultIPDL final
{
public:
    enum Type {
        T__None,
        TMediaResult = 1,
        TInitCompletionIPDL,
        T__Last = TInitCompletionIPDL
    };

private:
    typedef mozilla::MediaResult MediaResult;
    typedef mozilla::InitCompletionIPDL InitCompletionIPDL;
    typedef MediaResult MediaResult__tdef;
    typedef InitCompletionIPDL InitCompletionIPDL__tdef;

    union Value {
        mozilla::AlignedStorage2<MediaResult> VMediaResult;
        mozilla::AlignedStorage2<InitCompletionIPDL> VInitCompletionIPDL;
    };

    MediaResult*
    ptr_MediaResult()
    {
        return ((mValue).VMediaResult).addr();
    }
    const MediaResult*
    constptr_MediaResult() const
    {
        return ((mValue).VMediaResult).addr();
    }
    InitCompletionIPDL*
    ptr_InitCompletionIPDL()
    {
        return ((mValue).VInitCompletionIPDL).addr();
    }
    const InitCompletionIPDL*
    constptr_InitCompletionIPDL() const
    {
        return ((mValue).VInitCompletionIPDL).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT InitResultIPDL() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT InitResultIPDL(const MediaResult& aOther);

    MOZ_IMPLICIT InitResultIPDL(MediaResult&& aOther);

    MOZ_IMPLICIT InitResultIPDL(const InitCompletionIPDL& aOther);

    MOZ_IMPLICIT InitResultIPDL(InitCompletionIPDL&& aOther);

    MOZ_IMPLICIT InitResultIPDL(const InitResultIPDL& aOther);

    MOZ_IMPLICIT InitResultIPDL(InitResultIPDL&& aOther);

    ~InitResultIPDL();

    Type
    type() const
    {
        return mType;
    }

    InitResultIPDL&
    operator=(const MediaResult& aRhs);

    InitResultIPDL&
    operator=(MediaResult&& aRhs);

    InitResultIPDL&
    operator=(const InitCompletionIPDL& aRhs);

    InitResultIPDL&
    operator=(InitCompletionIPDL&& aRhs);

    InitResultIPDL&
    operator=(const InitResultIPDL& aRhs);

    InitResultIPDL&
    operator=(InitResultIPDL&& aRhs);

    MediaResult&
    get_MediaResult()
    {
        AssertSanity(TMediaResult);
        return (*(ptr_MediaResult()));
    }
    const MediaResult&
    get_MediaResult() const
    {
        AssertSanity(TMediaResult);
        return (*(constptr_MediaResult()));
    }
    operator MediaResult&()
    {
        return get_MediaResult();
    }
    operator const MediaResult&() const
    {
        return get_MediaResult();
    }

    InitCompletionIPDL&
    get_InitCompletionIPDL()
    {
        AssertSanity(TInitCompletionIPDL);
        return (*(ptr_InitCompletionIPDL()));
    }
    const InitCompletionIPDL&
    get_InitCompletionIPDL() const
    {
        AssertSanity(TInitCompletionIPDL);
        return (*(constptr_InitCompletionIPDL()));
    }
    operator InitCompletionIPDL&()
    {
        return get_InitCompletionIPDL();
    }
    operator const InitCompletionIPDL&() const
    {
        return get_InitCompletionIPDL();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::InitResultIPDL>
{
    typedef mozilla::InitResultIPDL paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla


//-----------------------------------------------------------------------------
// Declaration of the IPDL type |union DecodeResultIPDL|
//
namespace mozilla {
class DecodeResultIPDL final
{
public:
    enum Type {
        T__None,
        TMediaResult = 1,
        TDecodedOutputIPDL,
        T__Last = TDecodedOutputIPDL
    };

private:
    typedef mozilla::MediaResult MediaResult;
    typedef mozilla::DecodedOutputIPDL DecodedOutputIPDL;
    typedef MediaResult MediaResult__tdef;
    typedef DecodedOutputIPDL DecodedOutputIPDL__tdef;

    union Value {
        mozilla::AlignedStorage2<MediaResult> VMediaResult;
        mozilla::AlignedStorage2<DecodedOutputIPDL> VDecodedOutputIPDL;
    };

    MediaResult*
    ptr_MediaResult()
    {
        return ((mValue).VMediaResult).addr();
    }
    const MediaResult*
    constptr_MediaResult() const
    {
        return ((mValue).VMediaResult).addr();
    }
    DecodedOutputIPDL*
    ptr_DecodedOutputIPDL()
    {
        return ((mValue).VDecodedOutputIPDL).addr();
    }
    const DecodedOutputIPDL*
    constptr_DecodedOutputIPDL() const
    {
        return ((mValue).VDecodedOutputIPDL).addr();
    }

    bool
    MaybeDestroy(Type aNewType);

    void
    AssertSanity() const
    {
        MOZ_RELEASE_ASSERT((T__None) <= (mType), "invalid type tag");
        MOZ_RELEASE_ASSERT((mType) <= (T__Last), "invalid type tag");
    }
    void
    AssertSanity(Type aType) const
    {
        AssertSanity();
        MOZ_RELEASE_ASSERT((mType) == (aType), "unexpected type tag");
    }

public:
    MOZ_IMPLICIT DecodeResultIPDL() :
        mType(T__None)
    {
    }

    MOZ_IMPLICIT DecodeResultIPDL(const MediaResult& aOther);

    MOZ_IMPLICIT DecodeResultIPDL(MediaResult&& aOther);

    MOZ_IMPLICIT DecodeResultIPDL(const DecodedOutputIPDL& aOther);

    MOZ_IMPLICIT DecodeResultIPDL(DecodedOutputIPDL&& aOther);

    MOZ_IMPLICIT DecodeResultIPDL(const DecodeResultIPDL& aOther);

    MOZ_IMPLICIT DecodeResultIPDL(DecodeResultIPDL&& aOther);

    ~DecodeResultIPDL();

    Type
    type() const
    {
        return mType;
    }

    DecodeResultIPDL&
    operator=(const MediaResult& aRhs);

    DecodeResultIPDL&
    operator=(MediaResult&& aRhs);

    DecodeResultIPDL&
    operator=(const DecodedOutputIPDL& aRhs);

    DecodeResultIPDL&
    operator=(DecodedOutputIPDL&& aRhs);

    DecodeResultIPDL&
    operator=(const DecodeResultIPDL& aRhs);

    DecodeResultIPDL&
    operator=(DecodeResultIPDL&& aRhs);

    MediaResult&
    get_MediaResult()
    {
        AssertSanity(TMediaResult);
        return (*(ptr_MediaResult()));
    }
    const MediaResult&
    get_MediaResult() const
    {
        AssertSanity(TMediaResult);
        return (*(constptr_MediaResult()));
    }
    operator MediaResult&()
    {
        return get_MediaResult();
    }
    operator const MediaResult&() const
    {
        return get_MediaResult();
    }

    DecodedOutputIPDL&
    get_DecodedOutputIPDL()
    {
        AssertSanity(TDecodedOutputIPDL);
        return (*(ptr_DecodedOutputIPDL()));
    }
    const DecodedOutputIPDL&
    get_DecodedOutputIPDL() const
    {
        AssertSanity(TDecodedOutputIPDL);
        return (*(constptr_DecodedOutputIPDL()));
    }
    operator DecodedOutputIPDL&()
    {
        return get_DecodedOutputIPDL();
    }
    operator const DecodedOutputIPDL&() const
    {
        return get_DecodedOutputIPDL();
    }

private:
    Value mValue;
    Type mType;
};
} // namespace mozilla

namespace mozilla {
namespace ipc {
template<>
struct IPDLParamTraits <mozilla::DecodeResultIPDL>
{
    typedef mozilla::DecodeResultIPDL paramType;
    static void
    Write(
            IPC::Message* aMsg,
            mozilla::ipc::IProtocol* aActor,
            const paramType& aVar);
    static bool
    Read(
            const IPC::Message* aMsg,
            PickleIterator* aIter,
            mozilla::ipc::IProtocol* aActor,
            paramType* aVar);
};
} // namespace ipc
} // namespace mozilla

namespace mozilla {
class PRemoteDecoderParent;
} // namespace mozilla
namespace mozilla {
class PRemoteDecoderChild;
} // namespace mozilla

//-----------------------------------------------------------------------------
// Code common to PRemoteDecoderChild and PRemoteDecoderParent
//
namespace mozilla {
namespace PRemoteDecoder {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::PRemoteDecoderParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::PRemoteDecoderChild>* aChild);

enum MessageType {
    PRemoteDecoderStart = PRemoteDecoderMsgStart << 16,
    Msg_Construct__ID,
    Reply_Construct__ID,
    Msg_Init__ID,
    Reply_Init__ID,
    Msg_Decode__ID,
    Reply_Decode__ID,
    Msg_Flush__ID,
    Reply_Flush__ID,
    Msg_Drain__ID,
    Reply_Drain__ID,
    Msg_Shutdown__ID,
    Reply_Shutdown__ID,
    Msg_SetSeekThreshold__ID,
    Msg___delete____ID,
    Reply___delete____ID,
    PRemoteDecoderEnd
};

IPC::Message*
Msg_Construct(int32_t routingId);
IPC::Message*
Reply_Construct(int32_t routingId);

IPC::Message*
Msg_Init(int32_t routingId);
IPC::Message*
Reply_Init(int32_t routingId);

IPC::Message*
Msg_Decode(int32_t routingId);
IPC::Message*
Reply_Decode(int32_t routingId);

IPC::Message*
Msg_Flush(int32_t routingId);
IPC::Message*
Reply_Flush(int32_t routingId);

IPC::Message*
Msg_Drain(int32_t routingId);
IPC::Message*
Reply_Drain(int32_t routingId);

IPC::Message*
Msg_Shutdown(int32_t routingId);
IPC::Message*
Reply_Shutdown(int32_t routingId);

IPC::Message*
Msg_SetSeekThreshold(int32_t routingId);

IPC::Message*
Msg___delete__(int32_t routingId);
IPC::Message*
Reply___delete__(int32_t routingId);



} // namespace PRemoteDecoder
} // namespace mozilla

#endif // ifndef PRemoteDecoder_h
