//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/TabMessageUtils.h"
#include "mozilla/PProcessHangMonitor.h"
#include "mozilla/PProcessHangMonitorParent.h"
#include "mozilla/PProcessHangMonitorChild.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace PProcessHangMonitor {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::PProcessHangMonitorParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::PProcessHangMonitorChild>* aChild)
{
    return mozilla::ipc::CreateEndpoints(
        mozilla::ipc::PrivateIPDLInterface(),
        aParentDestPid, aChildDestPid,
        aParent, aChild);
}
IPC::Message*
Msg_HangEvidence(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_HangEvidence__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_ClearHang(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_ClearHang__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_TerminateScript(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_TerminateScript__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_BeginStartingDebugger(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_BeginStartingDebugger__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_EndStartingDebugger(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_EndStartingDebugger__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_PaintWhileInterruptingJS(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_PaintWhileInterruptingJS__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_CancelContentJSExecutionIfRunning(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_CancelContentJSExecutionIfRunning__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}

} // namespace PProcessHangMonitor
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct SlowScriptData|
//
namespace mozilla {
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::SlowScriptData>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).tabId());
    // Sentinel = 'tabId'
    (aMsg)->WriteSentinel(99156453);
    WriteIPDLParam(aMsg, aActor, (aVar).filename());
    // Sentinel = 'filename'
    (aMsg)->WriteSentinel(246547266);
    WriteIPDLParam(aMsg, aActor, (aVar).addonId());
    // Sentinel = 'addonId'
    (aMsg)->WriteSentinel(183894708);
    (aMsg)->WriteBytes((&((aVar).duration())), 8);
    // Sentinel = 'duration'
    (aMsg)->WriteSentinel(256050023);
}

auto IPDLParamTraits<mozilla::SlowScriptData>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->tabId())))))) {
        aActor->FatalError("Error deserializing 'tabId' (TabId) member of 'SlowScriptData'");
        return false;
    }
    // Sentinel = 'tabId'
    if ((!((aMsg)->ReadSentinel(aIter, 99156453)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'tabId' (TabId) member of 'SlowScriptData'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->filename())))))) {
        aActor->FatalError("Error deserializing 'filename' (nsCString) member of 'SlowScriptData'");
        return false;
    }
    // Sentinel = 'filename'
    if ((!((aMsg)->ReadSentinel(aIter, 246547266)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'filename' (nsCString) member of 'SlowScriptData'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->addonId())))))) {
        aActor->FatalError("Error deserializing 'addonId' (nsString) member of 'SlowScriptData'");
        return false;
    }
    // Sentinel = 'addonId'
    if ((!((aMsg)->ReadSentinel(aIter, 183894708)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'addonId' (nsString) member of 'SlowScriptData'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->duration())), 8)))) {
        aActor->FatalError("Error bulk reading fields from double");
        return false;
    }
    // Sentinel = 'duration'
    if ((!((aMsg)->ReadSentinel(aIter, 256050023)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from double");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct PluginHangData|
//
namespace mozilla {
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::PluginHangData>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).contentProcessId());
    // Sentinel = 'contentProcessId'
    (aMsg)->WriteSentinel(947259016);
    (aMsg)->WriteBytes((&((aVar).pluginId())), 4);
    // Sentinel = 'pluginId'
    (aMsg)->WriteSentinel(253821757);
}

auto IPDLParamTraits<mozilla::PluginHangData>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->contentProcessId())))))) {
        aActor->FatalError("Error deserializing 'contentProcessId' (ProcessId) member of 'PluginHangData'");
        return false;
    }
    // Sentinel = 'contentProcessId'
    if ((!((aMsg)->ReadSentinel(aIter, 947259016)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'contentProcessId' (ProcessId) member of 'PluginHangData'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->pluginId())), 4)))) {
        aActor->FatalError("Error bulk reading fields from uint32_t");
        return false;
    }
    // Sentinel = 'pluginId'
    if ((!((aMsg)->ReadSentinel(aIter, 253821757)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint32_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union HangData|
//
namespace mozilla {
auto HangData::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TSlowScriptData:
        {
            (ptr_SlowScriptData())->~SlowScriptData__tdef();
            break;
        }
    case TPluginHangData:
        {
            (ptr_PluginHangData())->~PluginHangData__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT HangData::HangData(const SlowScriptData& aOther)
{
    new (mozilla::KnownNotNull, ptr_SlowScriptData()) SlowScriptData(aOther);
    mType = TSlowScriptData;
}

MOZ_IMPLICIT HangData::HangData(SlowScriptData&& aOther)
{
    new (mozilla::KnownNotNull, ptr_SlowScriptData()) SlowScriptData(std::move(aOther));
    mType = TSlowScriptData;
}

MOZ_IMPLICIT HangData::HangData(const PluginHangData& aOther)
{
    new (mozilla::KnownNotNull, ptr_PluginHangData()) PluginHangData(aOther);
    mType = TPluginHangData;
}

MOZ_IMPLICIT HangData::HangData(PluginHangData&& aOther)
{
    new (mozilla::KnownNotNull, ptr_PluginHangData()) PluginHangData(std::move(aOther));
    mType = TPluginHangData;
}

MOZ_IMPLICIT HangData::HangData(const HangData& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TSlowScriptData:
        {
            new (mozilla::KnownNotNull, ptr_SlowScriptData()) SlowScriptData((aOther).get_SlowScriptData());
            break;
        }
    case TPluginHangData:
        {
            new (mozilla::KnownNotNull, ptr_PluginHangData()) PluginHangData((aOther).get_PluginHangData());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT HangData::HangData(HangData&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TSlowScriptData:
        {
            new (mozilla::KnownNotNull, ptr_SlowScriptData()) SlowScriptData(std::move((aOther).get_SlowScriptData()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TPluginHangData:
        {
            new (mozilla::KnownNotNull, ptr_PluginHangData()) PluginHangData(std::move((aOther).get_PluginHangData()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

HangData::~HangData()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto HangData::operator=(const SlowScriptData& aRhs) -> HangData&
{
    if (MaybeDestroy(TSlowScriptData)) {
        new (mozilla::KnownNotNull, ptr_SlowScriptData()) SlowScriptData;
    }
    (*(ptr_SlowScriptData())) = aRhs;
    mType = TSlowScriptData;
    return (*(this));
}

auto HangData::operator=(SlowScriptData&& aRhs) -> HangData&
{
    if (MaybeDestroy(TSlowScriptData)) {
        new (mozilla::KnownNotNull, ptr_SlowScriptData()) SlowScriptData;
    }
    (*(ptr_SlowScriptData())) = std::move(aRhs);
    mType = TSlowScriptData;
    return (*(this));
}

auto HangData::operator=(const PluginHangData& aRhs) -> HangData&
{
    if (MaybeDestroy(TPluginHangData)) {
        new (mozilla::KnownNotNull, ptr_PluginHangData()) PluginHangData;
    }
    (*(ptr_PluginHangData())) = aRhs;
    mType = TPluginHangData;
    return (*(this));
}

auto HangData::operator=(PluginHangData&& aRhs) -> HangData&
{
    if (MaybeDestroy(TPluginHangData)) {
        new (mozilla::KnownNotNull, ptr_PluginHangData()) PluginHangData;
    }
    (*(ptr_PluginHangData())) = std::move(aRhs);
    mType = TPluginHangData;
    return (*(this));
}

auto HangData::operator=(const HangData& aRhs) -> HangData&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TSlowScriptData:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_SlowScriptData()) SlowScriptData;
            }
            (*(ptr_SlowScriptData())) = (aRhs).get_SlowScriptData();
            break;
        }
    case TPluginHangData:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_PluginHangData()) PluginHangData;
            }
            (*(ptr_PluginHangData())) = (aRhs).get_PluginHangData();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto HangData::operator=(HangData&& aRhs) -> HangData&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TSlowScriptData:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_SlowScriptData()) SlowScriptData;
            }
            (*(ptr_SlowScriptData())) = std::move((aRhs).get_SlowScriptData());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TPluginHangData:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_PluginHangData()) PluginHangData;
            }
            (*(ptr_PluginHangData())) = std::move((aRhs).get_PluginHangData());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::HangData>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::HangData union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'HangData'
    (aMsg)->WriteSentinel(218235641);

    switch (type) {
    case union__::TSlowScriptData:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_SlowScriptData());
            // Sentinel = 'TSlowScriptData'
            (aMsg)->WriteSentinel(786040297);
            return;
        }
    case union__::TPluginHangData:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_PluginHangData());
            // Sentinel = 'TPluginHangData'
            (aMsg)->WriteSentinel(766641596);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::HangData>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::HangData union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union HangData");
        return false;
    }
    // Sentinel = 'HangData'
    if ((!((aMsg)->ReadSentinel(aIter, 218235641)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union HangData");
        return false;
    }

    switch (type) {
    case union__::TSlowScriptData:
        {
            mozilla::SlowScriptData tmp = mozilla::SlowScriptData();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_SlowScriptData())))))) {
                aActor->FatalError("Error deserializing variant TSlowScriptData of union HangData");
                return false;
            }
            // Sentinel = 'TSlowScriptData'
            if ((!((aMsg)->ReadSentinel(aIter, 786040297)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TSlowScriptData of union HangData");
                return false;
            }
            return true;
        }
    case union__::TPluginHangData:
        {
            mozilla::PluginHangData tmp = mozilla::PluginHangData();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_PluginHangData())))))) {
                aActor->FatalError("Error deserializing variant TPluginHangData of union HangData");
                return false;
            }
            // Sentinel = 'TPluginHangData'
            if ((!((aMsg)->ReadSentinel(aIter, 766641596)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TPluginHangData of union HangData");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla
