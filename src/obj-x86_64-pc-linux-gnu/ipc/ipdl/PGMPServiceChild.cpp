//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/gmp/PGMPServiceChild.h"
#include "mozilla/ProfilerLabels.h"
#include "mozilla/ProfilerMarkers.h"

#include "mozilla/gmp/PGMPContentChild.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace gmp {


auto PGMPServiceChild::ProcessingError(
        Result aCode,
        const char* aReason) -> void
{
}

auto PGMPServiceChild::ShouldContinueFromReplyTimeout() -> bool
{
    return true;
}

auto PGMPServiceChild::EnteredCxxStack() -> void
{
}

auto PGMPServiceChild::ExitedCxxStack() -> void
{
}

auto PGMPServiceChild::EnteredCall() -> void
{
}

auto PGMPServiceChild::ExitedCall() -> void
{
}

MOZ_IMPLICIT PGMPServiceChild::PGMPServiceChild() :
    mozilla::ipc::IToplevelProtocol("PGMPServiceChild", PGMPServiceMsgStart, mozilla::ipc::ChildSide)
{
    MOZ_COUNT_CTOR(PGMPServiceChild);
}

PGMPServiceChild::~PGMPServiceChild()
{
    MOZ_COUNT_DTOR(PGMPServiceChild);
}

auto PGMPServiceChild::AllManagedActors(nsTArray<RefPtr<mozilla::ipc::ActorLifecycleProxy>>& arr__) const -> void
{
    uint32_t total = 0;
    arr__.SetCapacity(total);

}

auto PGMPServiceChild::SendLaunchGMP(
        const NodeIdVariant& nodeIdVariant,
        const nsCString& api,
        const nsTArray<nsCString>& tags,
        const nsTArray<ProcessId>& alreadyBridgedTo,
        uint32_t* pluginId,
        ProcessId* id,
        nsCString* displayName,
        Endpoint<mozilla::gmp::PGMPContentParent>* endpoint,
        nsresult* aResult,
        nsCString* aErrorDescription) -> bool
{
    IPC::Message* msg__ = PGMPService::Msg_LaunchGMP(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, nodeIdVariant);
    // Sentinel = 'nodeIdVariant'
    (msg__)->WriteSentinel(599196969);
    WriteIPDLParam(msg__, this, api);
    // Sentinel = 'api'
    (msg__)->WriteSentinel(40829243);
    WriteIPDLParam(msg__, this, tags);
    // Sentinel = 'tags'
    (msg__)->WriteSentinel(70779312);
    WriteIPDLParam(msg__, this, alreadyBridgedTo);
    // Sentinel = 'alreadyBridgedTo'
    (msg__)->WriteSentinel(911607383);



    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PGMPServiceChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGMPServiceChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGMPService::Msg_LaunchGMP", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PGMPService::Msg_LaunchGMP", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PGMPServiceChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGMPServiceChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    PickleIterator iter__{reply__};

    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, pluginId)))) {
        FatalError("Error deserializing 'uint32_t'");
        return false;
    }
    // Sentinel = 'pluginId'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 253821757)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
        return false;
    }
    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, id)))) {
        FatalError("Error deserializing 'ProcessId'");
        return false;
    }
    // Sentinel = 'id'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 20447438)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'ProcessId'");
        return false;
    }
    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, displayName)))) {
        FatalError("Error deserializing 'nsCString'");
        return false;
    }
    // Sentinel = 'displayName'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 455935096)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
        return false;
    }
    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, endpoint)))) {
        FatalError("Error deserializing 'Endpoint<mozilla::gmp::PGMPContentParent>'");
        return false;
    }
    // Sentinel = 'endpoint'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 251724642)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'Endpoint<mozilla::gmp::PGMPContentParent>'");
        return false;
    }
    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, aResult)))) {
        FatalError("Error deserializing 'nsresult'");
        return false;
    }
    // Sentinel = 'aResult'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 185205473)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'nsresult'");
        return false;
    }
    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, aErrorDescription)))) {
        FatalError("Error deserializing 'nsCString'");
        return false;
    }
    // Sentinel = 'aErrorDescription'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 1020462832)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
        return false;
    }
    reply__.EndRead(iter__, reply__.type());

    return true;
}

auto PGMPServiceChild::SendGetGMPNodeId(
        const nsString& origin,
        const nsString& topLevelOrigin,
        const nsString& gmpName,
        nsCString* id) -> bool
{
    IPC::Message* msg__ = PGMPService::Msg_GetGMPNodeId(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, origin);
    // Sentinel = 'origin'
    (msg__)->WriteSentinel(150143625);
    WriteIPDLParam(msg__, this, topLevelOrigin);
    // Sentinel = 'topLevelOrigin'
    (msg__)->WriteSentinel(720242100);
    WriteIPDLParam(msg__, this, gmpName);
    // Sentinel = 'gmpName'
    (msg__)->WriteSentinel(187695814);



    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PGMPServiceChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGMPServiceChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PGMPService::Msg_GetGMPNodeId", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PGMPService::Msg_GetGMPNodeId", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PGMPServiceChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PGMPServiceChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    PickleIterator iter__{reply__};

    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, id)))) {
        FatalError("Error deserializing 'nsCString'");
        return false;
    }
    // Sentinel = 'id'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 20447438)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
        return false;
    }
    reply__.EndRead(iter__, reply__.type());

    return true;
}

auto PGMPServiceChild::RemoveManagee(
        int32_t aProtocolId,
        IProtocol* aListener) -> void
{
    FatalError("unreached");
    return;
}

auto PGMPServiceChild::DeallocManagee(
        int32_t aProtocolId,
        IProtocol* aListener) -> void
{
    FatalError("unreached");
    return;
}

auto PGMPServiceChild::OnMessageReceived(const Message& msg__) -> PGMPServiceChild::Result
{
    switch (msg__.type()) {
    case PGMPService::Msg_BeginShutdown__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PGMPServiceChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PGMPServiceChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PGMPService::Msg_BeginShutdown", OTHER);

            if ((!((this)->RecvBeginShutdown()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    default:
        return MsgNotKnown;
    case SHMEM_CREATED_MESSAGE_TYPE:
        {
            FatalError("this protocol tree does not use shmem");
            return MsgNotKnown;
        }
    case SHMEM_DESTROYED_MESSAGE_TYPE:
        {
            FatalError("this protocol tree does not use shmem");
            return MsgNotKnown;
        }
    }
}

auto PGMPServiceChild::OnMessageReceived(
        const Message& msg__,
        Message*& reply__) -> PGMPServiceChild::Result
{
    return MsgNotKnown;
}

auto PGMPServiceChild::OnCallReceived(
        const Message& msg__,
        Message*& reply__) -> PGMPServiceChild::Result
{
    MOZ_ASSERT_UNREACHABLE("message protocol not supported");
    return MsgNotKnown;
}

auto PGMPServiceChild::OnChannelClose() -> void
{
    DestroySubtree(NormalShutdown);
    ClearSubtree();
    DeallocShmems();
    if (GetLifecycleProxy()) {
        GetLifecycleProxy()->Release();
    }
}

auto PGMPServiceChild::OnChannelError() -> void
{
    DestroySubtree(AbnormalShutdown);
    ClearSubtree();
    DeallocShmems();
    if (GetLifecycleProxy()) {
        GetLifecycleProxy()->Release();
    }
}

auto PGMPServiceChild::ClearSubtree() -> void
{
}



} // namespace gmp
} // namespace mozilla
namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::gmp::PGMPServiceChild*>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    int32_t id;
    if (!aVar) {
        id = 0;  // kNullActorId
    } else {
        id = aVar->Id();
        if (id == 1) {  // kFreedActorId
            aVar->FatalError("Actor has been |delete|d");
        }
        MOZ_RELEASE_ASSERT(
            aActor->GetIPCChannel() == aVar->GetIPCChannel(),
            "Actor must be from the same channel as the"
            " actor it's being sent over");
        MOZ_RELEASE_ASSERT(
            aVar->CanSend(),
            "Actor must still be open when sending");
    }

    WriteIPDLParam(aMsg, aActor, id);
}

auto IPDLParamTraits<mozilla::gmp::PGMPServiceChild*>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    mozilla::Maybe<mozilla::ipc::IProtocol*> actor =
        aActor->ReadActor(aMsg, aIter, true, "PGMPService", PGMPServiceMsgStart);
    if (actor.isNothing()) {
        return false;
    }

    *aVar = static_cast<mozilla::gmp::PGMPServiceChild*>(actor.value());
    return true;
}

} // namespace ipc
} // namespace mozilla
