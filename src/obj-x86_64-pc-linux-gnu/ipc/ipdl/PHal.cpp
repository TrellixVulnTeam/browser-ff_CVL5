//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/ReferrerInfoUtils.h"
#include "mozilla/GfxMessageUtils.h"
#include "mozilla/dom/PContentParent.h"
#include "mozilla/dom/PContentChild.h"
#include "mozilla/dom/PBrowserParent.h"
#include "mozilla/dom/PBrowserChild.h"
#include "mozilla/hal_sandbox/PHal.h"
#include "mozilla/hal_sandbox/PHalParent.h"
#include "mozilla/hal_sandbox/PHalChild.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace hal_sandbox {
namespace PHal {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::hal_sandbox::PHalParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::hal_sandbox::PHalChild>* aChild)
{
    return mozilla::ipc::CreateEndpoints(
        mozilla::ipc::PrivateIPDLInterface(),
        aParentDestPid, aChildDestPid,
        aParent, aChild);
}
IPC::Message*
Msg_NotifyBatteryChange(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_NotifyBatteryChange__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_NotifyNetworkChange(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_NotifyNetworkChange__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_NotifyWakeLockChange(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_NotifyWakeLockChange__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_NotifyScreenConfigurationChange(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_NotifyScreenConfigurationChange__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_Vibrate(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Vibrate__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_CancelVibrate(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_CancelVibrate__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_EnableBatteryNotifications(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_EnableBatteryNotifications__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_DisableBatteryNotifications(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_DisableBatteryNotifications__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_GetCurrentBatteryInformation(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_GetCurrentBatteryInformation__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply_GetCurrentBatteryInformation(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply_GetCurrentBatteryInformation__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg_EnableNetworkNotifications(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_EnableNetworkNotifications__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_DisableNetworkNotifications(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_DisableNetworkNotifications__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_GetCurrentNetworkInformation(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_GetCurrentNetworkInformation__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply_GetCurrentNetworkInformation(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply_GetCurrentNetworkInformation__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg_ModifyWakeLock(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_ModifyWakeLock__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_EnableWakeLockNotifications(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_EnableWakeLockNotifications__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_DisableWakeLockNotifications(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_DisableWakeLockNotifications__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_GetWakeLockInfo(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_GetWakeLockInfo__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply_GetWakeLockInfo(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply_GetWakeLockInfo__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg_EnableScreenConfigurationNotifications(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_EnableScreenConfigurationNotifications__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_DisableScreenConfigurationNotifications(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_DisableScreenConfigurationNotifications__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_LockScreenOrientation(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_LockScreenOrientation__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply_LockScreenOrientation(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply_LockScreenOrientation__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg_UnlockScreenOrientation(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_UnlockScreenOrientation__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_NotifySensorChange(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_NotifySensorChange__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_EnableSensorNotifications(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_EnableSensorNotifications__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_DisableSensorNotifications(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_DisableSensorNotifications__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg___delete__(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg___delete____ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply___delete__(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply___delete____ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}

} // namespace PHal
} // namespace hal_sandbox
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct BatteryInformation|
//
namespace mozilla {
namespace hal {
auto BatteryInformation::StaticAssertions() const -> void
{
    static_assert(
        (offsetof(BatteryInformation, remainingTime_) - offsetof(BatteryInformation, level_)) == 8,
        "Bad assumptions about field layout!");
}

} // namespace hal
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::hal::BatteryInformation>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).charging());
    // Sentinel = 'charging'
    (aMsg)->WriteSentinel(244450116);
    (aMsg)->WriteBytes((&((aVar).level())), 16);
    // Sentinel = 'level | remainingTime'
    (aMsg)->WriteSentinel(1480656926);
}

auto IPDLParamTraits<mozilla::hal::BatteryInformation>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->charging())))))) {
        aActor->FatalError("Error deserializing 'charging' (bool) member of 'BatteryInformation'");
        return false;
    }
    // Sentinel = 'charging'
    if ((!((aMsg)->ReadSentinel(aIter, 244450116)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'charging' (bool) member of 'BatteryInformation'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->level())), 16)))) {
        aActor->FatalError("Error bulk reading fields from double");
        return false;
    }
    // Sentinel = 'level | remainingTime'
    if ((!((aMsg)->ReadSentinel(aIter, 1480656926)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from double");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct SensorData|
//
namespace mozilla {
namespace hal {
} // namespace hal
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::hal::SensorData>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).sensor());
    // Sentinel = 'sensor'
    (aMsg)->WriteSentinel(152175259);
    WriteIPDLParam(aMsg, aActor, (aVar).timestamp());
    // Sentinel = 'timestamp'
    (aMsg)->WriteSentinel(322569173);
    WriteIPDLParam(aMsg, aActor, (aVar).values());
    // Sentinel = 'values'
    (aMsg)->WriteSentinel(150667921);
}

auto IPDLParamTraits<mozilla::hal::SensorData>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->sensor())))))) {
        aActor->FatalError("Error deserializing 'sensor' (SensorType) member of 'SensorData'");
        return false;
    }
    // Sentinel = 'sensor'
    if ((!((aMsg)->ReadSentinel(aIter, 152175259)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'sensor' (SensorType) member of 'SensorData'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->timestamp())))))) {
        aActor->FatalError("Error deserializing 'timestamp' (PRTime) member of 'SensorData'");
        return false;
    }
    // Sentinel = 'timestamp'
    if ((!((aMsg)->ReadSentinel(aIter, 322569173)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'timestamp' (PRTime) member of 'SensorData'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->values())))))) {
        aActor->FatalError("Error deserializing 'values' (float[]) member of 'SensorData'");
        return false;
    }
    // Sentinel = 'values'
    if ((!((aMsg)->ReadSentinel(aIter, 150667921)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'values' (float[]) member of 'SensorData'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct NetworkInformation|
//
namespace mozilla {
namespace hal {
auto NetworkInformation::StaticAssertions() const -> void
{
    static_assert(
        (offsetof(NetworkInformation, dhcpGateway_) - offsetof(NetworkInformation, type_)) == 4,
        "Bad assumptions about field layout!");
}

} // namespace hal
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::hal::NetworkInformation>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).isWifi());
    // Sentinel = 'isWifi'
    (aMsg)->WriteSentinel(143065708);
    (aMsg)->WriteBytes((&((aVar).type())), 8);
    // Sentinel = 'type | dhcpGateway'
    (aMsg)->WriteSentinel(1086326512);
}

auto IPDLParamTraits<mozilla::hal::NetworkInformation>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->isWifi())))))) {
        aActor->FatalError("Error deserializing 'isWifi' (bool) member of 'NetworkInformation'");
        return false;
    }
    // Sentinel = 'isWifi'
    if ((!((aMsg)->ReadSentinel(aIter, 143065708)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'isWifi' (bool) member of 'NetworkInformation'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->type())), 8)))) {
        aActor->FatalError("Error bulk reading fields from uint32_t");
        return false;
    }
    // Sentinel = 'type | dhcpGateway'
    if ((!((aMsg)->ReadSentinel(aIter, 1086326512)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint32_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct WakeLockInformation|
//
namespace mozilla {
namespace hal {
auto WakeLockInformation::StaticAssertions() const -> void
{
    static_assert(
        (offsetof(WakeLockInformation, numHidden_) - offsetof(WakeLockInformation, numLocks_)) == 4,
        "Bad assumptions about field layout!");
}

} // namespace hal
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::hal::WakeLockInformation>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).topic());
    // Sentinel = 'topic'
    (aMsg)->WriteSentinel(109707808);
    WriteIPDLParam(aMsg, aActor, (aVar).lockingProcesses());
    // Sentinel = 'lockingProcesses'
    (aMsg)->WriteSentinel(938215071);
    (aMsg)->WriteBytes((&((aVar).numLocks())), 8);
    // Sentinel = 'numLocks | numHidden'
    (aMsg)->WriteSentinel(1355089829);
}

auto IPDLParamTraits<mozilla::hal::WakeLockInformation>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->topic())))))) {
        aActor->FatalError("Error deserializing 'topic' (nsString) member of 'WakeLockInformation'");
        return false;
    }
    // Sentinel = 'topic'
    if ((!((aMsg)->ReadSentinel(aIter, 109707808)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'topic' (nsString) member of 'WakeLockInformation'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->lockingProcesses())))))) {
        aActor->FatalError("Error deserializing 'lockingProcesses' (uint64_t[]) member of 'WakeLockInformation'");
        return false;
    }
    // Sentinel = 'lockingProcesses'
    if ((!((aMsg)->ReadSentinel(aIter, 938215071)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'lockingProcesses' (uint64_t[]) member of 'WakeLockInformation'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->numLocks())), 8)))) {
        aActor->FatalError("Error bulk reading fields from uint32_t");
        return false;
    }
    // Sentinel = 'numLocks | numHidden'
    if ((!((aMsg)->ReadSentinel(aIter, 1355089829)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint32_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ScreenConfiguration|
//
namespace mozilla {
namespace hal {
auto ScreenConfiguration::StaticAssertions() const -> void
{
    static_assert(
        (offsetof(ScreenConfiguration, pixelDepth_) - offsetof(ScreenConfiguration, colorDepth_)) == 4,
        "Bad assumptions about field layout!");
}

} // namespace hal
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::hal::ScreenConfiguration>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).rect());
    // Sentinel = 'rect'
    (aMsg)->WriteSentinel(70582703);
    WriteIPDLParam(aMsg, aActor, (aVar).orientation());
    // Sentinel = 'orientation'
    (aMsg)->WriteSentinel(471008429);
    (aMsg)->WriteBytes((&((aVar).colorDepth())), 8);
    // Sentinel = 'colorDepth | pixelDepth'
    (aMsg)->WriteSentinel(1794181352);
    (aMsg)->WriteBytes((&((aVar).angle())), 2);
    // Sentinel = 'angle'
    (aMsg)->WriteSentinel(101974536);
}

auto IPDLParamTraits<mozilla::hal::ScreenConfiguration>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->rect())))))) {
        aActor->FatalError("Error deserializing 'rect' (nsIntRect) member of 'ScreenConfiguration'");
        return false;
    }
    // Sentinel = 'rect'
    if ((!((aMsg)->ReadSentinel(aIter, 70582703)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'rect' (nsIntRect) member of 'ScreenConfiguration'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->orientation())))))) {
        aActor->FatalError("Error deserializing 'orientation' (ScreenOrientation) member of 'ScreenConfiguration'");
        return false;
    }
    // Sentinel = 'orientation'
    if ((!((aMsg)->ReadSentinel(aIter, 471008429)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'orientation' (ScreenOrientation) member of 'ScreenConfiguration'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->colorDepth())), 8)))) {
        aActor->FatalError("Error bulk reading fields from uint32_t");
        return false;
    }
    // Sentinel = 'colorDepth | pixelDepth'
    if ((!((aMsg)->ReadSentinel(aIter, 1794181352)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint32_t");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->angle())), 2)))) {
        aActor->FatalError("Error bulk reading fields from uint16_t");
        return false;
    }
    // Sentinel = 'angle'
    if ((!((aMsg)->ReadSentinel(aIter, 101974536)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint16_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla
