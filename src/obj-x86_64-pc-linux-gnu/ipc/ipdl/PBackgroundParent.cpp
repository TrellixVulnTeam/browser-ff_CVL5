//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/ipc/PBackgroundParent.h"
#include "mozilla/ProfilerLabels.h"
#include "mozilla/dom/cache/IPCUtils.h"
#include "mozilla/dom/quota/SerializationHelpers.h"
#include "mozilla/layers/LayersMessageUtils.h"

#include "mozilla/net/PBackgroundDataBridgeParent.h"
#include "mozilla/dom/indexedDB/PBackgroundIDBFactoryParent.h"
#include "mozilla/dom/indexedDB/PBackgroundIndexedDBUtilsParent.h"
#include "mozilla/dom/PBackgroundSDBConnectionParent.h"
#include "mozilla/dom/PBackgroundLSDatabaseParent.h"
#include "mozilla/dom/PBackgroundLSObserverParent.h"
#include "mozilla/dom/PBackgroundLSRequestParent.h"
#include "mozilla/dom/PBackgroundLSSimpleRequestParent.h"
#include "mozilla/dom/PBackgroundLocalStorageCacheParent.h"
#include "mozilla/dom/PBackgroundSessionStorageManagerParent.h"
#include "mozilla/dom/PBackgroundStorageParent.h"
#include "mozilla/ipc/PBackgroundTestParent.h"
#include "mozilla/dom/PBroadcastChannelParent.h"
#include "mozilla/dom/cache/PCacheParent.h"
#include "mozilla/dom/cache/PCacheStorageParent.h"
#include "mozilla/dom/cache/PCacheStreamControlParent.h"
#include "mozilla/dom/PClientManagerParent.h"
#include "mozilla/dom/PEndpointForReportParent.h"
#include "mozilla/ipc/PFileDescriptorSetParent.h"
#include "mozilla/dom/PFileSystemRequestParent.h"
#include "mozilla/dom/PGamepadEventChannelParent.h"
#include "mozilla/dom/PGamepadTestChannelParent.h"
#include "mozilla/net/PHttpBackgroundChannelParent.h"
#include "mozilla/ipc/PIdleSchedulerParent.h"
#include "mozilla/PRemoteLazyInputStreamParent.h"
#include "mozilla/dom/PMediaTransportParent.h"
#include "mozilla/dom/PRemoteWorkerParent.h"
#include "mozilla/dom/PRemoteWorkerControllerParent.h"
#include "mozilla/dom/PRemoteWorkerServiceParent.h"
#include "mozilla/dom/PSharedWorkerParent.h"
#include "mozilla/dom/PTemporaryIPCBlobParent.h"
#include "mozilla/dom/PFileCreatorParent.h"
#include "mozilla/dom/PMessagePortParent.h"
#include "mozilla/camera/PCamerasParent.h"
#include "mozilla/dom/PMIDIManagerParent.h"
#include "mozilla/dom/PMIDIPortParent.h"
#include "mozilla/dom/quota/PQuotaParent.h"
#include "mozilla/ipc/PChildToParentStreamParent.h"
#include "mozilla/ipc/PParentToChildStreamParent.h"
#include "mozilla/dom/PServiceWorkerParent.h"
#include "mozilla/dom/PServiceWorkerContainerParent.h"
#include "mozilla/dom/PServiceWorkerManagerParent.h"
#include "mozilla/dom/PServiceWorkerRegistrationParent.h"
#include "mozilla/dom/PWebAuthnTransactionParent.h"
#include "mozilla/net/PUDPSocketParent.h"
#include "mozilla/psm/PVerifySSLServerCertParent.h"
#include "mozilla/dom/PVsyncParent.h"
#include "mozilla/PRemoteDecoderManagerParent.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace ipc {


auto PBackgroundParent::RecvPBackgroundTestConstructor(
        PBackgroundTestParent* actor,
        const nsCString& testArg) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPBackgroundDataBridgeConstructor(
        PBackgroundDataBridgeParent* actor,
        const uint64_t& channelID) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPBackgroundIDBFactoryConstructor(
        PBackgroundIDBFactoryParent* actor,
        const LoggingInfo& loggingInfo) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPBackgroundIndexedDBUtilsConstructor(PBackgroundIndexedDBUtilsParent* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPBackgroundSDBConnectionConstructor(
        PBackgroundSDBConnectionParent* actor,
        const PersistenceType& persistenceType,
        const PrincipalInfo& principalInfo) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPBackgroundLSDatabaseConstructor(
        PBackgroundLSDatabaseParent* actor,
        const PrincipalInfo& principalInfo,
        const uint32_t& privateBrowsingId,
        const uint64_t& datastoreId) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPBackgroundLSObserverConstructor(
        PBackgroundLSObserverParent* actor,
        const uint64_t& observerId) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPBackgroundLSRequestConstructor(
        PBackgroundLSRequestParent* actor,
        const LSRequestParams& params) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPBackgroundLSSimpleRequestConstructor(
        PBackgroundLSSimpleRequestParent* actor,
        const LSSimpleRequestParams& params) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPBackgroundLocalStorageCacheConstructor(
        PBackgroundLocalStorageCacheParent* actor,
        const PrincipalInfo& principalInfo,
        const nsCString& originKey,
        const uint32_t& privateBrowsingId) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPBackgroundSessionStorageManagerConstructor(
        PBackgroundSessionStorageManagerParent* actor,
        const uint64_t& aTopContextId) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPBackgroundStorageConstructor(
        PBackgroundStorageParent* actor,
        const nsString& profilePath,
        const uint32_t& privateBrowsingId) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPVsyncConstructor(PVsyncParent* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPCamerasConstructor(PCamerasParent* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPUDPSocketConstructor(
        PUDPSocketParent* actor,
        const mozilla::Maybe<PrincipalInfo>& pInfo,
        const nsCString& filter) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPBroadcastChannelConstructor(
        PBroadcastChannelParent* actor,
        const PrincipalInfo& pInfo,
        const nsCString& origin,
        const nsString& channel) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPServiceWorkerManagerConstructor(PServiceWorkerManagerParent* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPCacheStorageConstructor(
        PCacheStorageParent* actor,
        const Namespace& aNamespace,
        const PrincipalInfo& aPrincipalInfo) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPMessagePortConstructor(
        PMessagePortParent* actor,
        const nsID& uuid,
        const nsID& destinationUuid,
        const uint32_t& sequenceId) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPChildToParentStreamConstructor(PChildToParentStreamParent* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPQuotaConstructor(PQuotaParent* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPFileSystemRequestConstructor(
        PFileSystemRequestParent* actor,
        const FileSystemParams& params) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPGamepadEventChannelConstructor(PGamepadEventChannelParent* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPGamepadTestChannelConstructor(PGamepadTestChannelParent* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPHttpBackgroundChannelConstructor(
        PHttpBackgroundChannelParent* actor,
        const uint64_t& channelId) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPWebAuthnTransactionConstructor(PWebAuthnTransactionParent* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPSharedWorkerConstructor(
        PSharedWorkerParent* actor,
        const RemoteWorkerData& data,
        const uint64_t& windowID,
        const MessagePortIdentifier& portIdentifier) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPTemporaryIPCBlobConstructor(PTemporaryIPCBlobParent* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPFileCreatorConstructor(
        PFileCreatorParent* actor,
        const nsString& aFullPath,
        const nsString& aType,
        const nsString& aName,
        const mozilla::Maybe<int64_t>& lastModified,
        const bool& aExistenceCheck,
        const bool& aIsFromNsIFile) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPClientManagerConstructor(PClientManagerParent* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPMIDIManagerConstructor(PMIDIManagerParent* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPMIDIPortConstructor(
        PMIDIPortParent* actor,
        const MIDIPortInfo& portInfo,
        const bool& sysexEnabled) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPServiceWorkerConstructor(
        PServiceWorkerParent* actor,
        const IPCServiceWorkerDescriptor& aDescriptor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPRemoteWorkerControllerConstructor(
        PRemoteWorkerControllerParent* actor,
        const RemoteWorkerData& aData) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPRemoteWorkerServiceConstructor(PRemoteWorkerServiceParent* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPServiceWorkerContainerConstructor(PServiceWorkerContainerParent* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPServiceWorkerRegistrationConstructor(
        PServiceWorkerRegistrationParent* actor,
        const IPCServiceWorkerRegistrationDescriptor& aDescriptor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPEndpointForReportConstructor(
        PEndpointForReportParent* actor,
        const nsString& aGroupName,
        const PrincipalInfo& aPrincipalInfo) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPIdleSchedulerConstructor(PIdleSchedulerParent* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPMediaTransportConstructor(PMediaTransportParent* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPVerifySSLServerCertConstructor(
        PVerifySSLServerCertParent* actor,
        const ByteArray& aServerCert,
        nsTArray<ByteArray>&& aPeerCertChain,
        const nsCString& aHostName,
        const int32_t& aPort,
        const OriginAttributes& aOriginAttributes,
        const mozilla::Maybe<ByteArray>& aStapledOCSPResponse,
        const mozilla::Maybe<ByteArray>& aSctsFromTLSExtension,
        const mozilla::Maybe<DelegatedCredentialInfoArg>& aDcInfo,
        const uint32_t& aProviderFlags,
        const uint32_t& aCertVerifierFlags) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPRemoteLazyInputStreamConstructor(
        PRemoteLazyInputStreamParent* actor,
        const nsID& aID,
        const uint64_t& aSize) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::RecvPFileDescriptorSetConstructor(
        PFileDescriptorSetParent* actor,
        const FileDescriptor& fd) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundParent::ProcessingError(
        Result aCode,
        const char* aReason) -> void
{
}

auto PBackgroundParent::ShouldContinueFromReplyTimeout() -> bool
{
    return true;
}

auto PBackgroundParent::EnteredCxxStack() -> void
{
}

auto PBackgroundParent::ExitedCxxStack() -> void
{
}

auto PBackgroundParent::EnteredCall() -> void
{
}

auto PBackgroundParent::ExitedCall() -> void
{
}

MOZ_IMPLICIT PBackgroundParent::PBackgroundParent() :
    mozilla::ipc::IToplevelProtocol("PBackgroundParent", PBackgroundMsgStart, mozilla::ipc::ParentSide)
{
    MOZ_COUNT_CTOR(PBackgroundParent);
}

PBackgroundParent::~PBackgroundParent()
{
    MOZ_COUNT_DTOR(PBackgroundParent);
}

auto PBackgroundParent::ManagedPBackgroundDataBridgeParent(nsTArray<PBackgroundDataBridgeParent*>& aArr) const -> void
{
    mManagedPBackgroundDataBridgeParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPBackgroundDataBridgeParent() const -> const ManagedContainer<PBackgroundDataBridgeParent>&
{
    return mManagedPBackgroundDataBridgeParent;
}

auto PBackgroundParent::ManagedPBackgroundIDBFactoryParent(nsTArray<PBackgroundIDBFactoryParent*>& aArr) const -> void
{
    mManagedPBackgroundIDBFactoryParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPBackgroundIDBFactoryParent() const -> const ManagedContainer<PBackgroundIDBFactoryParent>&
{
    return mManagedPBackgroundIDBFactoryParent;
}

auto PBackgroundParent::ManagedPBackgroundIndexedDBUtilsParent(nsTArray<PBackgroundIndexedDBUtilsParent*>& aArr) const -> void
{
    mManagedPBackgroundIndexedDBUtilsParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPBackgroundIndexedDBUtilsParent() const -> const ManagedContainer<PBackgroundIndexedDBUtilsParent>&
{
    return mManagedPBackgroundIndexedDBUtilsParent;
}

auto PBackgroundParent::ManagedPBackgroundSDBConnectionParent(nsTArray<PBackgroundSDBConnectionParent*>& aArr) const -> void
{
    mManagedPBackgroundSDBConnectionParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPBackgroundSDBConnectionParent() const -> const ManagedContainer<PBackgroundSDBConnectionParent>&
{
    return mManagedPBackgroundSDBConnectionParent;
}

auto PBackgroundParent::ManagedPBackgroundLSDatabaseParent(nsTArray<PBackgroundLSDatabaseParent*>& aArr) const -> void
{
    mManagedPBackgroundLSDatabaseParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPBackgroundLSDatabaseParent() const -> const ManagedContainer<PBackgroundLSDatabaseParent>&
{
    return mManagedPBackgroundLSDatabaseParent;
}

auto PBackgroundParent::ManagedPBackgroundLSObserverParent(nsTArray<PBackgroundLSObserverParent*>& aArr) const -> void
{
    mManagedPBackgroundLSObserverParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPBackgroundLSObserverParent() const -> const ManagedContainer<PBackgroundLSObserverParent>&
{
    return mManagedPBackgroundLSObserverParent;
}

auto PBackgroundParent::ManagedPBackgroundLSRequestParent(nsTArray<PBackgroundLSRequestParent*>& aArr) const -> void
{
    mManagedPBackgroundLSRequestParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPBackgroundLSRequestParent() const -> const ManagedContainer<PBackgroundLSRequestParent>&
{
    return mManagedPBackgroundLSRequestParent;
}

auto PBackgroundParent::ManagedPBackgroundLSSimpleRequestParent(nsTArray<PBackgroundLSSimpleRequestParent*>& aArr) const -> void
{
    mManagedPBackgroundLSSimpleRequestParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPBackgroundLSSimpleRequestParent() const -> const ManagedContainer<PBackgroundLSSimpleRequestParent>&
{
    return mManagedPBackgroundLSSimpleRequestParent;
}

auto PBackgroundParent::ManagedPBackgroundLocalStorageCacheParent(nsTArray<PBackgroundLocalStorageCacheParent*>& aArr) const -> void
{
    mManagedPBackgroundLocalStorageCacheParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPBackgroundLocalStorageCacheParent() const -> const ManagedContainer<PBackgroundLocalStorageCacheParent>&
{
    return mManagedPBackgroundLocalStorageCacheParent;
}

auto PBackgroundParent::ManagedPBackgroundSessionStorageManagerParent(nsTArray<PBackgroundSessionStorageManagerParent*>& aArr) const -> void
{
    mManagedPBackgroundSessionStorageManagerParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPBackgroundSessionStorageManagerParent() const -> const ManagedContainer<PBackgroundSessionStorageManagerParent>&
{
    return mManagedPBackgroundSessionStorageManagerParent;
}

auto PBackgroundParent::ManagedPBackgroundStorageParent(nsTArray<PBackgroundStorageParent*>& aArr) const -> void
{
    mManagedPBackgroundStorageParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPBackgroundStorageParent() const -> const ManagedContainer<PBackgroundStorageParent>&
{
    return mManagedPBackgroundStorageParent;
}

auto PBackgroundParent::ManagedPBackgroundTestParent(nsTArray<PBackgroundTestParent*>& aArr) const -> void
{
    mManagedPBackgroundTestParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPBackgroundTestParent() const -> const ManagedContainer<PBackgroundTestParent>&
{
    return mManagedPBackgroundTestParent;
}

auto PBackgroundParent::ManagedPBroadcastChannelParent(nsTArray<PBroadcastChannelParent*>& aArr) const -> void
{
    mManagedPBroadcastChannelParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPBroadcastChannelParent() const -> const ManagedContainer<PBroadcastChannelParent>&
{
    return mManagedPBroadcastChannelParent;
}

auto PBackgroundParent::ManagedPCacheParent(nsTArray<PCacheParent*>& aArr) const -> void
{
    mManagedPCacheParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPCacheParent() const -> const ManagedContainer<PCacheParent>&
{
    return mManagedPCacheParent;
}

auto PBackgroundParent::ManagedPCacheStorageParent(nsTArray<PCacheStorageParent*>& aArr) const -> void
{
    mManagedPCacheStorageParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPCacheStorageParent() const -> const ManagedContainer<PCacheStorageParent>&
{
    return mManagedPCacheStorageParent;
}

auto PBackgroundParent::ManagedPCacheStreamControlParent(nsTArray<PCacheStreamControlParent*>& aArr) const -> void
{
    mManagedPCacheStreamControlParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPCacheStreamControlParent() const -> const ManagedContainer<PCacheStreamControlParent>&
{
    return mManagedPCacheStreamControlParent;
}

auto PBackgroundParent::ManagedPClientManagerParent(nsTArray<PClientManagerParent*>& aArr) const -> void
{
    mManagedPClientManagerParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPClientManagerParent() const -> const ManagedContainer<PClientManagerParent>&
{
    return mManagedPClientManagerParent;
}

auto PBackgroundParent::ManagedPEndpointForReportParent(nsTArray<PEndpointForReportParent*>& aArr) const -> void
{
    mManagedPEndpointForReportParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPEndpointForReportParent() const -> const ManagedContainer<PEndpointForReportParent>&
{
    return mManagedPEndpointForReportParent;
}

auto PBackgroundParent::ManagedPFileDescriptorSetParent(nsTArray<PFileDescriptorSetParent*>& aArr) const -> void
{
    mManagedPFileDescriptorSetParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPFileDescriptorSetParent() const -> const ManagedContainer<PFileDescriptorSetParent>&
{
    return mManagedPFileDescriptorSetParent;
}

auto PBackgroundParent::ManagedPFileSystemRequestParent(nsTArray<PFileSystemRequestParent*>& aArr) const -> void
{
    mManagedPFileSystemRequestParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPFileSystemRequestParent() const -> const ManagedContainer<PFileSystemRequestParent>&
{
    return mManagedPFileSystemRequestParent;
}

auto PBackgroundParent::ManagedPGamepadEventChannelParent(nsTArray<PGamepadEventChannelParent*>& aArr) const -> void
{
    mManagedPGamepadEventChannelParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPGamepadEventChannelParent() const -> const ManagedContainer<PGamepadEventChannelParent>&
{
    return mManagedPGamepadEventChannelParent;
}

auto PBackgroundParent::ManagedPGamepadTestChannelParent(nsTArray<PGamepadTestChannelParent*>& aArr) const -> void
{
    mManagedPGamepadTestChannelParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPGamepadTestChannelParent() const -> const ManagedContainer<PGamepadTestChannelParent>&
{
    return mManagedPGamepadTestChannelParent;
}

auto PBackgroundParent::ManagedPHttpBackgroundChannelParent(nsTArray<PHttpBackgroundChannelParent*>& aArr) const -> void
{
    mManagedPHttpBackgroundChannelParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPHttpBackgroundChannelParent() const -> const ManagedContainer<PHttpBackgroundChannelParent>&
{
    return mManagedPHttpBackgroundChannelParent;
}

auto PBackgroundParent::ManagedPIdleSchedulerParent(nsTArray<PIdleSchedulerParent*>& aArr) const -> void
{
    mManagedPIdleSchedulerParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPIdleSchedulerParent() const -> const ManagedContainer<PIdleSchedulerParent>&
{
    return mManagedPIdleSchedulerParent;
}

auto PBackgroundParent::ManagedPRemoteLazyInputStreamParent(nsTArray<PRemoteLazyInputStreamParent*>& aArr) const -> void
{
    mManagedPRemoteLazyInputStreamParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPRemoteLazyInputStreamParent() const -> const ManagedContainer<PRemoteLazyInputStreamParent>&
{
    return mManagedPRemoteLazyInputStreamParent;
}

auto PBackgroundParent::ManagedPMediaTransportParent(nsTArray<PMediaTransportParent*>& aArr) const -> void
{
    mManagedPMediaTransportParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPMediaTransportParent() const -> const ManagedContainer<PMediaTransportParent>&
{
    return mManagedPMediaTransportParent;
}

auto PBackgroundParent::ManagedPRemoteWorkerParent(nsTArray<PRemoteWorkerParent*>& aArr) const -> void
{
    mManagedPRemoteWorkerParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPRemoteWorkerParent() const -> const ManagedContainer<PRemoteWorkerParent>&
{
    return mManagedPRemoteWorkerParent;
}

auto PBackgroundParent::ManagedPRemoteWorkerControllerParent(nsTArray<PRemoteWorkerControllerParent*>& aArr) const -> void
{
    mManagedPRemoteWorkerControllerParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPRemoteWorkerControllerParent() const -> const ManagedContainer<PRemoteWorkerControllerParent>&
{
    return mManagedPRemoteWorkerControllerParent;
}

auto PBackgroundParent::ManagedPRemoteWorkerServiceParent(nsTArray<PRemoteWorkerServiceParent*>& aArr) const -> void
{
    mManagedPRemoteWorkerServiceParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPRemoteWorkerServiceParent() const -> const ManagedContainer<PRemoteWorkerServiceParent>&
{
    return mManagedPRemoteWorkerServiceParent;
}

auto PBackgroundParent::ManagedPSharedWorkerParent(nsTArray<PSharedWorkerParent*>& aArr) const -> void
{
    mManagedPSharedWorkerParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPSharedWorkerParent() const -> const ManagedContainer<PSharedWorkerParent>&
{
    return mManagedPSharedWorkerParent;
}

auto PBackgroundParent::ManagedPTemporaryIPCBlobParent(nsTArray<PTemporaryIPCBlobParent*>& aArr) const -> void
{
    mManagedPTemporaryIPCBlobParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPTemporaryIPCBlobParent() const -> const ManagedContainer<PTemporaryIPCBlobParent>&
{
    return mManagedPTemporaryIPCBlobParent;
}

auto PBackgroundParent::ManagedPFileCreatorParent(nsTArray<PFileCreatorParent*>& aArr) const -> void
{
    mManagedPFileCreatorParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPFileCreatorParent() const -> const ManagedContainer<PFileCreatorParent>&
{
    return mManagedPFileCreatorParent;
}

auto PBackgroundParent::ManagedPMessagePortParent(nsTArray<PMessagePortParent*>& aArr) const -> void
{
    mManagedPMessagePortParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPMessagePortParent() const -> const ManagedContainer<PMessagePortParent>&
{
    return mManagedPMessagePortParent;
}

auto PBackgroundParent::ManagedPCamerasParent(nsTArray<PCamerasParent*>& aArr) const -> void
{
    mManagedPCamerasParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPCamerasParent() const -> const ManagedContainer<PCamerasParent>&
{
    return mManagedPCamerasParent;
}

auto PBackgroundParent::ManagedPMIDIManagerParent(nsTArray<PMIDIManagerParent*>& aArr) const -> void
{
    mManagedPMIDIManagerParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPMIDIManagerParent() const -> const ManagedContainer<PMIDIManagerParent>&
{
    return mManagedPMIDIManagerParent;
}

auto PBackgroundParent::ManagedPMIDIPortParent(nsTArray<PMIDIPortParent*>& aArr) const -> void
{
    mManagedPMIDIPortParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPMIDIPortParent() const -> const ManagedContainer<PMIDIPortParent>&
{
    return mManagedPMIDIPortParent;
}

auto PBackgroundParent::ManagedPQuotaParent(nsTArray<PQuotaParent*>& aArr) const -> void
{
    mManagedPQuotaParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPQuotaParent() const -> const ManagedContainer<PQuotaParent>&
{
    return mManagedPQuotaParent;
}

auto PBackgroundParent::ManagedPChildToParentStreamParent(nsTArray<PChildToParentStreamParent*>& aArr) const -> void
{
    mManagedPChildToParentStreamParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPChildToParentStreamParent() const -> const ManagedContainer<PChildToParentStreamParent>&
{
    return mManagedPChildToParentStreamParent;
}

auto PBackgroundParent::ManagedPParentToChildStreamParent(nsTArray<PParentToChildStreamParent*>& aArr) const -> void
{
    mManagedPParentToChildStreamParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPParentToChildStreamParent() const -> const ManagedContainer<PParentToChildStreamParent>&
{
    return mManagedPParentToChildStreamParent;
}

auto PBackgroundParent::ManagedPServiceWorkerParent(nsTArray<PServiceWorkerParent*>& aArr) const -> void
{
    mManagedPServiceWorkerParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPServiceWorkerParent() const -> const ManagedContainer<PServiceWorkerParent>&
{
    return mManagedPServiceWorkerParent;
}

auto PBackgroundParent::ManagedPServiceWorkerContainerParent(nsTArray<PServiceWorkerContainerParent*>& aArr) const -> void
{
    mManagedPServiceWorkerContainerParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPServiceWorkerContainerParent() const -> const ManagedContainer<PServiceWorkerContainerParent>&
{
    return mManagedPServiceWorkerContainerParent;
}

auto PBackgroundParent::ManagedPServiceWorkerManagerParent(nsTArray<PServiceWorkerManagerParent*>& aArr) const -> void
{
    mManagedPServiceWorkerManagerParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPServiceWorkerManagerParent() const -> const ManagedContainer<PServiceWorkerManagerParent>&
{
    return mManagedPServiceWorkerManagerParent;
}

auto PBackgroundParent::ManagedPServiceWorkerRegistrationParent(nsTArray<PServiceWorkerRegistrationParent*>& aArr) const -> void
{
    mManagedPServiceWorkerRegistrationParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPServiceWorkerRegistrationParent() const -> const ManagedContainer<PServiceWorkerRegistrationParent>&
{
    return mManagedPServiceWorkerRegistrationParent;
}

auto PBackgroundParent::ManagedPWebAuthnTransactionParent(nsTArray<PWebAuthnTransactionParent*>& aArr) const -> void
{
    mManagedPWebAuthnTransactionParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPWebAuthnTransactionParent() const -> const ManagedContainer<PWebAuthnTransactionParent>&
{
    return mManagedPWebAuthnTransactionParent;
}

auto PBackgroundParent::ManagedPUDPSocketParent(nsTArray<PUDPSocketParent*>& aArr) const -> void
{
    mManagedPUDPSocketParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPUDPSocketParent() const -> const ManagedContainer<PUDPSocketParent>&
{
    return mManagedPUDPSocketParent;
}

auto PBackgroundParent::ManagedPVerifySSLServerCertParent(nsTArray<PVerifySSLServerCertParent*>& aArr) const -> void
{
    mManagedPVerifySSLServerCertParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPVerifySSLServerCertParent() const -> const ManagedContainer<PVerifySSLServerCertParent>&
{
    return mManagedPVerifySSLServerCertParent;
}

auto PBackgroundParent::ManagedPVsyncParent(nsTArray<PVsyncParent*>& aArr) const -> void
{
    mManagedPVsyncParent.ToArray(aArr);
}

auto PBackgroundParent::ManagedPVsyncParent() const -> const ManagedContainer<PVsyncParent>&
{
    return mManagedPVsyncParent;
}

auto PBackgroundParent::AllManagedActors(nsTArray<RefPtr<mozilla::ipc::ActorLifecycleProxy>>& arr__) const -> void
{
    uint32_t total = 0;
    total += mManagedPBackgroundDataBridgeParent.Count();
    total += mManagedPBackgroundIDBFactoryParent.Count();
    total += mManagedPBackgroundIndexedDBUtilsParent.Count();
    total += mManagedPBackgroundSDBConnectionParent.Count();
    total += mManagedPBackgroundLSDatabaseParent.Count();
    total += mManagedPBackgroundLSObserverParent.Count();
    total += mManagedPBackgroundLSRequestParent.Count();
    total += mManagedPBackgroundLSSimpleRequestParent.Count();
    total += mManagedPBackgroundLocalStorageCacheParent.Count();
    total += mManagedPBackgroundSessionStorageManagerParent.Count();
    total += mManagedPBackgroundStorageParent.Count();
    total += mManagedPBackgroundTestParent.Count();
    total += mManagedPBroadcastChannelParent.Count();
    total += mManagedPCacheParent.Count();
    total += mManagedPCacheStorageParent.Count();
    total += mManagedPCacheStreamControlParent.Count();
    total += mManagedPClientManagerParent.Count();
    total += mManagedPEndpointForReportParent.Count();
    total += mManagedPFileDescriptorSetParent.Count();
    total += mManagedPFileSystemRequestParent.Count();
    total += mManagedPGamepadEventChannelParent.Count();
    total += mManagedPGamepadTestChannelParent.Count();
    total += mManagedPHttpBackgroundChannelParent.Count();
    total += mManagedPIdleSchedulerParent.Count();
    total += mManagedPRemoteLazyInputStreamParent.Count();
    total += mManagedPMediaTransportParent.Count();
    total += mManagedPRemoteWorkerParent.Count();
    total += mManagedPRemoteWorkerControllerParent.Count();
    total += mManagedPRemoteWorkerServiceParent.Count();
    total += mManagedPSharedWorkerParent.Count();
    total += mManagedPTemporaryIPCBlobParent.Count();
    total += mManagedPFileCreatorParent.Count();
    total += mManagedPMessagePortParent.Count();
    total += mManagedPCamerasParent.Count();
    total += mManagedPMIDIManagerParent.Count();
    total += mManagedPMIDIPortParent.Count();
    total += mManagedPQuotaParent.Count();
    total += mManagedPChildToParentStreamParent.Count();
    total += mManagedPParentToChildStreamParent.Count();
    total += mManagedPServiceWorkerParent.Count();
    total += mManagedPServiceWorkerContainerParent.Count();
    total += mManagedPServiceWorkerManagerParent.Count();
    total += mManagedPServiceWorkerRegistrationParent.Count();
    total += mManagedPWebAuthnTransactionParent.Count();
    total += mManagedPUDPSocketParent.Count();
    total += mManagedPVerifySSLServerCertParent.Count();
    total += mManagedPVsyncParent.Count();
    arr__.SetCapacity(total);

    for (auto it = mManagedPBackgroundDataBridgeParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundIDBFactoryParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundIndexedDBUtilsParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundSDBConnectionParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundLSDatabaseParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundLSObserverParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundLSRequestParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundLSSimpleRequestParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundLocalStorageCacheParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundSessionStorageManagerParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundStorageParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundTestParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBroadcastChannelParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPCacheParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPCacheStorageParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPCacheStreamControlParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPClientManagerParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPEndpointForReportParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPFileDescriptorSetParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPFileSystemRequestParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPGamepadEventChannelParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPGamepadTestChannelParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPHttpBackgroundChannelParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPIdleSchedulerParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPRemoteLazyInputStreamParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPMediaTransportParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPRemoteWorkerParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPRemoteWorkerControllerParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPRemoteWorkerServiceParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPSharedWorkerParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPTemporaryIPCBlobParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPFileCreatorParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPMessagePortParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPCamerasParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPMIDIManagerParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPMIDIPortParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPQuotaParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPChildToParentStreamParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPParentToChildStreamParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPServiceWorkerParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPServiceWorkerContainerParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPServiceWorkerManagerParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPServiceWorkerRegistrationParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPWebAuthnTransactionParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPUDPSocketParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPVerifySSLServerCertParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPVsyncParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

}

auto PBackgroundParent::OpenPBackgroundDataBridgeEndpoint(PBackgroundDataBridgeParent* aActor) -> ManagedEndpoint<PBackgroundDataBridgeChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundDataBridgeParent actor");
        return ManagedEndpoint<PBackgroundDataBridgeChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundDataBridgeParent.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundDataBridgeChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPBackgroundDataBridgeEndpoint(
        ManagedEndpoint<PBackgroundDataBridgeParent> aEndpoint,
        PBackgroundDataBridgeParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundDataBridgeParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundDataBridgeParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPBackgroundIDBFactoryEndpoint(PBackgroundIDBFactoryParent* aActor) -> ManagedEndpoint<PBackgroundIDBFactoryChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundIDBFactoryParent actor");
        return ManagedEndpoint<PBackgroundIDBFactoryChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundIDBFactoryParent.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundIDBFactoryChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPBackgroundIDBFactoryEndpoint(
        ManagedEndpoint<PBackgroundIDBFactoryParent> aEndpoint,
        PBackgroundIDBFactoryParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundIDBFactoryParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundIDBFactoryParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPBackgroundIndexedDBUtilsEndpoint(PBackgroundIndexedDBUtilsParent* aActor) -> ManagedEndpoint<PBackgroundIndexedDBUtilsChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundIndexedDBUtilsParent actor");
        return ManagedEndpoint<PBackgroundIndexedDBUtilsChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundIndexedDBUtilsParent.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundIndexedDBUtilsChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPBackgroundIndexedDBUtilsEndpoint(
        ManagedEndpoint<PBackgroundIndexedDBUtilsParent> aEndpoint,
        PBackgroundIndexedDBUtilsParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundIndexedDBUtilsParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundIndexedDBUtilsParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPBackgroundSDBConnectionEndpoint(PBackgroundSDBConnectionParent* aActor) -> ManagedEndpoint<PBackgroundSDBConnectionChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundSDBConnectionParent actor");
        return ManagedEndpoint<PBackgroundSDBConnectionChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundSDBConnectionParent.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundSDBConnectionChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPBackgroundSDBConnectionEndpoint(
        ManagedEndpoint<PBackgroundSDBConnectionParent> aEndpoint,
        PBackgroundSDBConnectionParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundSDBConnectionParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundSDBConnectionParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPBackgroundLSDatabaseEndpoint(PBackgroundLSDatabaseParent* aActor) -> ManagedEndpoint<PBackgroundLSDatabaseChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundLSDatabaseParent actor");
        return ManagedEndpoint<PBackgroundLSDatabaseChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundLSDatabaseParent.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundLSDatabaseChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPBackgroundLSDatabaseEndpoint(
        ManagedEndpoint<PBackgroundLSDatabaseParent> aEndpoint,
        PBackgroundLSDatabaseParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundLSDatabaseParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundLSDatabaseParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPBackgroundLSObserverEndpoint(PBackgroundLSObserverParent* aActor) -> ManagedEndpoint<PBackgroundLSObserverChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundLSObserverParent actor");
        return ManagedEndpoint<PBackgroundLSObserverChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundLSObserverParent.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundLSObserverChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPBackgroundLSObserverEndpoint(
        ManagedEndpoint<PBackgroundLSObserverParent> aEndpoint,
        PBackgroundLSObserverParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundLSObserverParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundLSObserverParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPBackgroundLSRequestEndpoint(PBackgroundLSRequestParent* aActor) -> ManagedEndpoint<PBackgroundLSRequestChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundLSRequestParent actor");
        return ManagedEndpoint<PBackgroundLSRequestChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundLSRequestParent.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundLSRequestChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPBackgroundLSRequestEndpoint(
        ManagedEndpoint<PBackgroundLSRequestParent> aEndpoint,
        PBackgroundLSRequestParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundLSRequestParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundLSRequestParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPBackgroundLSSimpleRequestEndpoint(PBackgroundLSSimpleRequestParent* aActor) -> ManagedEndpoint<PBackgroundLSSimpleRequestChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundLSSimpleRequestParent actor");
        return ManagedEndpoint<PBackgroundLSSimpleRequestChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundLSSimpleRequestParent.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundLSSimpleRequestChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPBackgroundLSSimpleRequestEndpoint(
        ManagedEndpoint<PBackgroundLSSimpleRequestParent> aEndpoint,
        PBackgroundLSSimpleRequestParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundLSSimpleRequestParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundLSSimpleRequestParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPBackgroundLocalStorageCacheEndpoint(PBackgroundLocalStorageCacheParent* aActor) -> ManagedEndpoint<PBackgroundLocalStorageCacheChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundLocalStorageCacheParent actor");
        return ManagedEndpoint<PBackgroundLocalStorageCacheChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundLocalStorageCacheParent.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundLocalStorageCacheChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPBackgroundLocalStorageCacheEndpoint(
        ManagedEndpoint<PBackgroundLocalStorageCacheParent> aEndpoint,
        PBackgroundLocalStorageCacheParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundLocalStorageCacheParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundLocalStorageCacheParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPBackgroundSessionStorageManagerEndpoint(PBackgroundSessionStorageManagerParent* aActor) -> ManagedEndpoint<PBackgroundSessionStorageManagerChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundSessionStorageManagerParent actor");
        return ManagedEndpoint<PBackgroundSessionStorageManagerChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundSessionStorageManagerParent.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundSessionStorageManagerChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPBackgroundSessionStorageManagerEndpoint(
        ManagedEndpoint<PBackgroundSessionStorageManagerParent> aEndpoint,
        PBackgroundSessionStorageManagerParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundSessionStorageManagerParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundSessionStorageManagerParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPBackgroundStorageEndpoint(PBackgroundStorageParent* aActor) -> ManagedEndpoint<PBackgroundStorageChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundStorageParent actor");
        return ManagedEndpoint<PBackgroundStorageChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundStorageParent.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundStorageChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPBackgroundStorageEndpoint(
        ManagedEndpoint<PBackgroundStorageParent> aEndpoint,
        PBackgroundStorageParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundStorageParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundStorageParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPBackgroundTestEndpoint(PBackgroundTestParent* aActor) -> ManagedEndpoint<PBackgroundTestChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundTestParent actor");
        return ManagedEndpoint<PBackgroundTestChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundTestParent.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundTestChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPBackgroundTestEndpoint(
        ManagedEndpoint<PBackgroundTestParent> aEndpoint,
        PBackgroundTestParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundTestParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundTestParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPBroadcastChannelEndpoint(PBroadcastChannelParent* aActor) -> ManagedEndpoint<PBroadcastChannelChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBroadcastChannelParent actor");
        return ManagedEndpoint<PBroadcastChannelChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBroadcastChannelParent.PutEntry(aActor);

    return ManagedEndpoint<PBroadcastChannelChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPBroadcastChannelEndpoint(
        ManagedEndpoint<PBroadcastChannelParent> aEndpoint,
        PBroadcastChannelParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBroadcastChannelParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBroadcastChannelParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPCacheEndpoint(PCacheParent* aActor) -> ManagedEndpoint<PCacheChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PCacheParent actor");
        return ManagedEndpoint<PCacheChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPCacheParent.PutEntry(aActor);

    return ManagedEndpoint<PCacheChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPCacheEndpoint(
        ManagedEndpoint<PCacheParent> aEndpoint,
        PCacheParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PCacheParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPCacheParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPCacheStorageEndpoint(PCacheStorageParent* aActor) -> ManagedEndpoint<PCacheStorageChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PCacheStorageParent actor");
        return ManagedEndpoint<PCacheStorageChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPCacheStorageParent.PutEntry(aActor);

    return ManagedEndpoint<PCacheStorageChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPCacheStorageEndpoint(
        ManagedEndpoint<PCacheStorageParent> aEndpoint,
        PCacheStorageParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PCacheStorageParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPCacheStorageParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPCacheStreamControlEndpoint(PCacheStreamControlParent* aActor) -> ManagedEndpoint<PCacheStreamControlChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PCacheStreamControlParent actor");
        return ManagedEndpoint<PCacheStreamControlChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPCacheStreamControlParent.PutEntry(aActor);

    return ManagedEndpoint<PCacheStreamControlChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPCacheStreamControlEndpoint(
        ManagedEndpoint<PCacheStreamControlParent> aEndpoint,
        PCacheStreamControlParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PCacheStreamControlParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPCacheStreamControlParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPClientManagerEndpoint(PClientManagerParent* aActor) -> ManagedEndpoint<PClientManagerChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PClientManagerParent actor");
        return ManagedEndpoint<PClientManagerChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPClientManagerParent.PutEntry(aActor);

    return ManagedEndpoint<PClientManagerChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPClientManagerEndpoint(
        ManagedEndpoint<PClientManagerParent> aEndpoint,
        PClientManagerParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PClientManagerParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPClientManagerParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPEndpointForReportEndpoint(PEndpointForReportParent* aActor) -> ManagedEndpoint<PEndpointForReportChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PEndpointForReportParent actor");
        return ManagedEndpoint<PEndpointForReportChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPEndpointForReportParent.PutEntry(aActor);

    return ManagedEndpoint<PEndpointForReportChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPEndpointForReportEndpoint(
        ManagedEndpoint<PEndpointForReportParent> aEndpoint,
        PEndpointForReportParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PEndpointForReportParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPEndpointForReportParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPFileDescriptorSetEndpoint(PFileDescriptorSetParent* aActor) -> ManagedEndpoint<PFileDescriptorSetChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PFileDescriptorSetParent actor");
        return ManagedEndpoint<PFileDescriptorSetChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPFileDescriptorSetParent.PutEntry(aActor);

    return ManagedEndpoint<PFileDescriptorSetChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPFileDescriptorSetEndpoint(
        ManagedEndpoint<PFileDescriptorSetParent> aEndpoint,
        PFileDescriptorSetParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PFileDescriptorSetParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPFileDescriptorSetParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPFileSystemRequestEndpoint(PFileSystemRequestParent* aActor) -> ManagedEndpoint<PFileSystemRequestChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PFileSystemRequestParent actor");
        return ManagedEndpoint<PFileSystemRequestChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPFileSystemRequestParent.PutEntry(aActor);

    return ManagedEndpoint<PFileSystemRequestChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPFileSystemRequestEndpoint(
        ManagedEndpoint<PFileSystemRequestParent> aEndpoint,
        PFileSystemRequestParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PFileSystemRequestParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPFileSystemRequestParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPGamepadEventChannelEndpoint(PGamepadEventChannelParent* aActor) -> ManagedEndpoint<PGamepadEventChannelChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PGamepadEventChannelParent actor");
        return ManagedEndpoint<PGamepadEventChannelChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPGamepadEventChannelParent.PutEntry(aActor);

    return ManagedEndpoint<PGamepadEventChannelChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPGamepadEventChannelEndpoint(
        ManagedEndpoint<PGamepadEventChannelParent> aEndpoint,
        PGamepadEventChannelParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PGamepadEventChannelParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPGamepadEventChannelParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPGamepadTestChannelEndpoint(PGamepadTestChannelParent* aActor) -> ManagedEndpoint<PGamepadTestChannelChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PGamepadTestChannelParent actor");
        return ManagedEndpoint<PGamepadTestChannelChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPGamepadTestChannelParent.PutEntry(aActor);

    return ManagedEndpoint<PGamepadTestChannelChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPGamepadTestChannelEndpoint(
        ManagedEndpoint<PGamepadTestChannelParent> aEndpoint,
        PGamepadTestChannelParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PGamepadTestChannelParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPGamepadTestChannelParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPHttpBackgroundChannelEndpoint(PHttpBackgroundChannelParent* aActor) -> ManagedEndpoint<PHttpBackgroundChannelChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PHttpBackgroundChannelParent actor");
        return ManagedEndpoint<PHttpBackgroundChannelChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPHttpBackgroundChannelParent.PutEntry(aActor);

    return ManagedEndpoint<PHttpBackgroundChannelChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPHttpBackgroundChannelEndpoint(
        ManagedEndpoint<PHttpBackgroundChannelParent> aEndpoint,
        PHttpBackgroundChannelParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PHttpBackgroundChannelParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPHttpBackgroundChannelParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPIdleSchedulerEndpoint(PIdleSchedulerParent* aActor) -> ManagedEndpoint<PIdleSchedulerChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PIdleSchedulerParent actor");
        return ManagedEndpoint<PIdleSchedulerChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPIdleSchedulerParent.PutEntry(aActor);

    return ManagedEndpoint<PIdleSchedulerChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPIdleSchedulerEndpoint(
        ManagedEndpoint<PIdleSchedulerParent> aEndpoint,
        PIdleSchedulerParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PIdleSchedulerParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPIdleSchedulerParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPRemoteLazyInputStreamEndpoint(PRemoteLazyInputStreamParent* aActor) -> ManagedEndpoint<PRemoteLazyInputStreamChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PRemoteLazyInputStreamParent actor");
        return ManagedEndpoint<PRemoteLazyInputStreamChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPRemoteLazyInputStreamParent.PutEntry(aActor);

    return ManagedEndpoint<PRemoteLazyInputStreamChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPRemoteLazyInputStreamEndpoint(
        ManagedEndpoint<PRemoteLazyInputStreamParent> aEndpoint,
        PRemoteLazyInputStreamParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PRemoteLazyInputStreamParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPRemoteLazyInputStreamParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPMediaTransportEndpoint(PMediaTransportParent* aActor) -> ManagedEndpoint<PMediaTransportChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PMediaTransportParent actor");
        return ManagedEndpoint<PMediaTransportChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPMediaTransportParent.PutEntry(aActor);

    return ManagedEndpoint<PMediaTransportChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPMediaTransportEndpoint(
        ManagedEndpoint<PMediaTransportParent> aEndpoint,
        PMediaTransportParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PMediaTransportParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPMediaTransportParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPRemoteWorkerEndpoint(PRemoteWorkerParent* aActor) -> ManagedEndpoint<PRemoteWorkerChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PRemoteWorkerParent actor");
        return ManagedEndpoint<PRemoteWorkerChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPRemoteWorkerParent.PutEntry(aActor);

    return ManagedEndpoint<PRemoteWorkerChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPRemoteWorkerEndpoint(
        ManagedEndpoint<PRemoteWorkerParent> aEndpoint,
        PRemoteWorkerParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PRemoteWorkerParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPRemoteWorkerParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPRemoteWorkerControllerEndpoint(PRemoteWorkerControllerParent* aActor) -> ManagedEndpoint<PRemoteWorkerControllerChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PRemoteWorkerControllerParent actor");
        return ManagedEndpoint<PRemoteWorkerControllerChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPRemoteWorkerControllerParent.PutEntry(aActor);

    return ManagedEndpoint<PRemoteWorkerControllerChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPRemoteWorkerControllerEndpoint(
        ManagedEndpoint<PRemoteWorkerControllerParent> aEndpoint,
        PRemoteWorkerControllerParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PRemoteWorkerControllerParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPRemoteWorkerControllerParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPRemoteWorkerServiceEndpoint(PRemoteWorkerServiceParent* aActor) -> ManagedEndpoint<PRemoteWorkerServiceChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PRemoteWorkerServiceParent actor");
        return ManagedEndpoint<PRemoteWorkerServiceChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPRemoteWorkerServiceParent.PutEntry(aActor);

    return ManagedEndpoint<PRemoteWorkerServiceChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPRemoteWorkerServiceEndpoint(
        ManagedEndpoint<PRemoteWorkerServiceParent> aEndpoint,
        PRemoteWorkerServiceParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PRemoteWorkerServiceParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPRemoteWorkerServiceParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPSharedWorkerEndpoint(PSharedWorkerParent* aActor) -> ManagedEndpoint<PSharedWorkerChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PSharedWorkerParent actor");
        return ManagedEndpoint<PSharedWorkerChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPSharedWorkerParent.PutEntry(aActor);

    return ManagedEndpoint<PSharedWorkerChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPSharedWorkerEndpoint(
        ManagedEndpoint<PSharedWorkerParent> aEndpoint,
        PSharedWorkerParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PSharedWorkerParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPSharedWorkerParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPTemporaryIPCBlobEndpoint(PTemporaryIPCBlobParent* aActor) -> ManagedEndpoint<PTemporaryIPCBlobChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PTemporaryIPCBlobParent actor");
        return ManagedEndpoint<PTemporaryIPCBlobChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPTemporaryIPCBlobParent.PutEntry(aActor);

    return ManagedEndpoint<PTemporaryIPCBlobChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPTemporaryIPCBlobEndpoint(
        ManagedEndpoint<PTemporaryIPCBlobParent> aEndpoint,
        PTemporaryIPCBlobParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PTemporaryIPCBlobParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPTemporaryIPCBlobParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPFileCreatorEndpoint(PFileCreatorParent* aActor) -> ManagedEndpoint<PFileCreatorChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PFileCreatorParent actor");
        return ManagedEndpoint<PFileCreatorChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPFileCreatorParent.PutEntry(aActor);

    return ManagedEndpoint<PFileCreatorChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPFileCreatorEndpoint(
        ManagedEndpoint<PFileCreatorParent> aEndpoint,
        PFileCreatorParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PFileCreatorParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPFileCreatorParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPMessagePortEndpoint(PMessagePortParent* aActor) -> ManagedEndpoint<PMessagePortChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PMessagePortParent actor");
        return ManagedEndpoint<PMessagePortChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPMessagePortParent.PutEntry(aActor);

    return ManagedEndpoint<PMessagePortChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPMessagePortEndpoint(
        ManagedEndpoint<PMessagePortParent> aEndpoint,
        PMessagePortParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PMessagePortParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPMessagePortParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPCamerasEndpoint(PCamerasParent* aActor) -> ManagedEndpoint<PCamerasChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PCamerasParent actor");
        return ManagedEndpoint<PCamerasChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPCamerasParent.PutEntry(aActor);

    return ManagedEndpoint<PCamerasChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPCamerasEndpoint(
        ManagedEndpoint<PCamerasParent> aEndpoint,
        PCamerasParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PCamerasParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPCamerasParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPMIDIManagerEndpoint(PMIDIManagerParent* aActor) -> ManagedEndpoint<PMIDIManagerChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PMIDIManagerParent actor");
        return ManagedEndpoint<PMIDIManagerChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPMIDIManagerParent.PutEntry(aActor);

    return ManagedEndpoint<PMIDIManagerChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPMIDIManagerEndpoint(
        ManagedEndpoint<PMIDIManagerParent> aEndpoint,
        PMIDIManagerParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PMIDIManagerParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPMIDIManagerParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPMIDIPortEndpoint(PMIDIPortParent* aActor) -> ManagedEndpoint<PMIDIPortChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PMIDIPortParent actor");
        return ManagedEndpoint<PMIDIPortChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPMIDIPortParent.PutEntry(aActor);

    return ManagedEndpoint<PMIDIPortChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPMIDIPortEndpoint(
        ManagedEndpoint<PMIDIPortParent> aEndpoint,
        PMIDIPortParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PMIDIPortParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPMIDIPortParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPQuotaEndpoint(PQuotaParent* aActor) -> ManagedEndpoint<PQuotaChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PQuotaParent actor");
        return ManagedEndpoint<PQuotaChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPQuotaParent.PutEntry(aActor);

    return ManagedEndpoint<PQuotaChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPQuotaEndpoint(
        ManagedEndpoint<PQuotaParent> aEndpoint,
        PQuotaParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PQuotaParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPQuotaParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPChildToParentStreamEndpoint(PChildToParentStreamParent* aActor) -> ManagedEndpoint<PChildToParentStreamChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PChildToParentStreamParent actor");
        return ManagedEndpoint<PChildToParentStreamChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPChildToParentStreamParent.PutEntry(aActor);

    return ManagedEndpoint<PChildToParentStreamChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPChildToParentStreamEndpoint(
        ManagedEndpoint<PChildToParentStreamParent> aEndpoint,
        PChildToParentStreamParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PChildToParentStreamParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPChildToParentStreamParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPParentToChildStreamEndpoint(PParentToChildStreamParent* aActor) -> ManagedEndpoint<PParentToChildStreamChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PParentToChildStreamParent actor");
        return ManagedEndpoint<PParentToChildStreamChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPParentToChildStreamParent.PutEntry(aActor);

    return ManagedEndpoint<PParentToChildStreamChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPParentToChildStreamEndpoint(
        ManagedEndpoint<PParentToChildStreamParent> aEndpoint,
        PParentToChildStreamParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PParentToChildStreamParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPParentToChildStreamParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPServiceWorkerEndpoint(PServiceWorkerParent* aActor) -> ManagedEndpoint<PServiceWorkerChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PServiceWorkerParent actor");
        return ManagedEndpoint<PServiceWorkerChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPServiceWorkerParent.PutEntry(aActor);

    return ManagedEndpoint<PServiceWorkerChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPServiceWorkerEndpoint(
        ManagedEndpoint<PServiceWorkerParent> aEndpoint,
        PServiceWorkerParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PServiceWorkerParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPServiceWorkerParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPServiceWorkerContainerEndpoint(PServiceWorkerContainerParent* aActor) -> ManagedEndpoint<PServiceWorkerContainerChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PServiceWorkerContainerParent actor");
        return ManagedEndpoint<PServiceWorkerContainerChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPServiceWorkerContainerParent.PutEntry(aActor);

    return ManagedEndpoint<PServiceWorkerContainerChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPServiceWorkerContainerEndpoint(
        ManagedEndpoint<PServiceWorkerContainerParent> aEndpoint,
        PServiceWorkerContainerParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PServiceWorkerContainerParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPServiceWorkerContainerParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPServiceWorkerManagerEndpoint(PServiceWorkerManagerParent* aActor) -> ManagedEndpoint<PServiceWorkerManagerChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PServiceWorkerManagerParent actor");
        return ManagedEndpoint<PServiceWorkerManagerChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPServiceWorkerManagerParent.PutEntry(aActor);

    return ManagedEndpoint<PServiceWorkerManagerChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPServiceWorkerManagerEndpoint(
        ManagedEndpoint<PServiceWorkerManagerParent> aEndpoint,
        PServiceWorkerManagerParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PServiceWorkerManagerParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPServiceWorkerManagerParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPServiceWorkerRegistrationEndpoint(PServiceWorkerRegistrationParent* aActor) -> ManagedEndpoint<PServiceWorkerRegistrationChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PServiceWorkerRegistrationParent actor");
        return ManagedEndpoint<PServiceWorkerRegistrationChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPServiceWorkerRegistrationParent.PutEntry(aActor);

    return ManagedEndpoint<PServiceWorkerRegistrationChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPServiceWorkerRegistrationEndpoint(
        ManagedEndpoint<PServiceWorkerRegistrationParent> aEndpoint,
        PServiceWorkerRegistrationParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PServiceWorkerRegistrationParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPServiceWorkerRegistrationParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPWebAuthnTransactionEndpoint(PWebAuthnTransactionParent* aActor) -> ManagedEndpoint<PWebAuthnTransactionChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebAuthnTransactionParent actor");
        return ManagedEndpoint<PWebAuthnTransactionChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPWebAuthnTransactionParent.PutEntry(aActor);

    return ManagedEndpoint<PWebAuthnTransactionChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPWebAuthnTransactionEndpoint(
        ManagedEndpoint<PWebAuthnTransactionParent> aEndpoint,
        PWebAuthnTransactionParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebAuthnTransactionParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPWebAuthnTransactionParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPUDPSocketEndpoint(PUDPSocketParent* aActor) -> ManagedEndpoint<PUDPSocketChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PUDPSocketParent actor");
        return ManagedEndpoint<PUDPSocketChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPUDPSocketParent.PutEntry(aActor);

    return ManagedEndpoint<PUDPSocketChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPUDPSocketEndpoint(
        ManagedEndpoint<PUDPSocketParent> aEndpoint,
        PUDPSocketParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PUDPSocketParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPUDPSocketParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPVerifySSLServerCertEndpoint(PVerifySSLServerCertParent* aActor) -> ManagedEndpoint<PVerifySSLServerCertChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PVerifySSLServerCertParent actor");
        return ManagedEndpoint<PVerifySSLServerCertChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPVerifySSLServerCertParent.PutEntry(aActor);

    return ManagedEndpoint<PVerifySSLServerCertChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPVerifySSLServerCertEndpoint(
        ManagedEndpoint<PVerifySSLServerCertParent> aEndpoint,
        PVerifySSLServerCertParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PVerifySSLServerCertParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPVerifySSLServerCertParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::OpenPVsyncEndpoint(PVsyncParent* aActor) -> ManagedEndpoint<PVsyncChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PVsyncParent actor");
        return ManagedEndpoint<PVsyncChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPVsyncParent.PutEntry(aActor);

    return ManagedEndpoint<PVsyncChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundParent::BindPVsyncEndpoint(
        ManagedEndpoint<PVsyncParent> aEndpoint,
        PVsyncParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PVsyncParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPVsyncParent.PutEntry(aActor);

    return true;
}

auto PBackgroundParent::SendPCacheConstructor() -> PCacheParent*
{
    PCacheParent* actor = (this)->AllocPCacheParent();
    return SendPCacheConstructor(actor);
}

auto PBackgroundParent::SendPCacheConstructor(PCacheParent* actor) -> PCacheParent*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PCacheParent actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPCacheParent.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PCacheConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PCacheConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PCacheParent constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PCacheMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundParent::SendPCacheStreamControlConstructor(PCacheStreamControlParent* actor) -> PCacheStreamControlParent*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PCacheStreamControlParent actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPCacheStreamControlParent.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PCacheStreamControlConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PCacheStreamControlConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PCacheStreamControlParent constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PCacheStreamControlMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundParent::SendPParentToChildStreamConstructor() -> PParentToChildStreamParent*
{
    PParentToChildStreamParent* actor = (this)->AllocPParentToChildStreamParent();
    return SendPParentToChildStreamConstructor(actor);
}

auto PBackgroundParent::SendPParentToChildStreamConstructor(PParentToChildStreamParent* actor) -> PParentToChildStreamParent*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PParentToChildStreamParent actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPParentToChildStreamParent.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PParentToChildStreamConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PParentToChildStreamConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PParentToChildStreamParent constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PParentToChildStreamMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundParent::SendPRemoteWorkerConstructor(const RemoteWorkerData& data) -> PRemoteWorkerParent*
{
    PRemoteWorkerParent* actor = (this)->AllocPRemoteWorkerParent(data);
    return SendPRemoteWorkerConstructor(actor, data);
}

auto PBackgroundParent::SendPRemoteWorkerConstructor(
        PRemoteWorkerParent* actor,
        const RemoteWorkerData& data) -> PRemoteWorkerParent*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PRemoteWorkerParent actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPRemoteWorkerParent.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PRemoteWorkerConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, data);
    // Sentinel = 'data'
    (msg__)->WriteSentinel(67109275);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PRemoteWorkerConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PRemoteWorkerParent constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PRemoteWorkerMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundParent::SendPRemoteLazyInputStreamConstructor(
        PRemoteLazyInputStreamParent* actor,
        const nsID& aID,
        const uint64_t& aSize) -> PRemoteLazyInputStreamParent*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PRemoteLazyInputStreamParent actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPRemoteLazyInputStreamParent.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PRemoteLazyInputStreamConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, aID);
    // Sentinel = 'aID'
    (msg__)->WriteSentinel(33292527);
    WriteIPDLParam(msg__, this, aSize);
    // Sentinel = 'aSize'
    (msg__)->WriteSentinel(97124861);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PRemoteLazyInputStreamConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PRemoteLazyInputStreamParent constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PRemoteLazyInputStreamMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundParent::SendPFileDescriptorSetConstructor(const FileDescriptor& fd) -> PFileDescriptorSetParent*
{
    PFileDescriptorSetParent* actor = (this)->AllocPFileDescriptorSetParent(fd);
    return SendPFileDescriptorSetConstructor(actor, fd);
}

auto PBackgroundParent::SendPFileDescriptorSetConstructor(
        PFileDescriptorSetParent* actor,
        const FileDescriptor& fd) -> PFileDescriptorSetParent*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PFileDescriptorSetParent actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPFileDescriptorSetParent.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PFileDescriptorSetConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, fd);
    // Sentinel = 'fd'
    (msg__)->WriteSentinel(20054219);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PFileDescriptorSetConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PFileDescriptorSetParent constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PFileDescriptorSetMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundParent::RemoveManagee(
        int32_t aProtocolId,
        IProtocol* aListener) -> void
{
    switch (aProtocolId) {
    case PBackgroundDataBridgeMsgStart:
{
            PBackgroundDataBridgeParent* actor = static_cast<PBackgroundDataBridgeParent*>(aListener);
            auto& container = mManagedPBackgroundDataBridgeParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundIDBFactoryMsgStart:
{
            PBackgroundIDBFactoryParent* actor = static_cast<PBackgroundIDBFactoryParent*>(aListener);
            auto& container = mManagedPBackgroundIDBFactoryParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundIndexedDBUtilsMsgStart:
{
            PBackgroundIndexedDBUtilsParent* actor = static_cast<PBackgroundIndexedDBUtilsParent*>(aListener);
            auto& container = mManagedPBackgroundIndexedDBUtilsParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundSDBConnectionMsgStart:
{
            PBackgroundSDBConnectionParent* actor = static_cast<PBackgroundSDBConnectionParent*>(aListener);
            auto& container = mManagedPBackgroundSDBConnectionParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundLSDatabaseMsgStart:
{
            PBackgroundLSDatabaseParent* actor = static_cast<PBackgroundLSDatabaseParent*>(aListener);
            auto& container = mManagedPBackgroundLSDatabaseParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundLSObserverMsgStart:
{
            PBackgroundLSObserverParent* actor = static_cast<PBackgroundLSObserverParent*>(aListener);
            auto& container = mManagedPBackgroundLSObserverParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundLSRequestMsgStart:
{
            PBackgroundLSRequestParent* actor = static_cast<PBackgroundLSRequestParent*>(aListener);
            auto& container = mManagedPBackgroundLSRequestParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundLSSimpleRequestMsgStart:
{
            PBackgroundLSSimpleRequestParent* actor = static_cast<PBackgroundLSSimpleRequestParent*>(aListener);
            auto& container = mManagedPBackgroundLSSimpleRequestParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundLocalStorageCacheMsgStart:
{
            PBackgroundLocalStorageCacheParent* actor = static_cast<PBackgroundLocalStorageCacheParent*>(aListener);
            auto& container = mManagedPBackgroundLocalStorageCacheParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundSessionStorageManagerMsgStart:
{
            PBackgroundSessionStorageManagerParent* actor = static_cast<PBackgroundSessionStorageManagerParent*>(aListener);
            auto& container = mManagedPBackgroundSessionStorageManagerParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundStorageMsgStart:
{
            PBackgroundStorageParent* actor = static_cast<PBackgroundStorageParent*>(aListener);
            auto& container = mManagedPBackgroundStorageParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundTestMsgStart:
{
            PBackgroundTestParent* actor = static_cast<PBackgroundTestParent*>(aListener);
            auto& container = mManagedPBackgroundTestParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBroadcastChannelMsgStart:
{
            PBroadcastChannelParent* actor = static_cast<PBroadcastChannelParent*>(aListener);
            auto& container = mManagedPBroadcastChannelParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PCacheMsgStart:
{
            PCacheParent* actor = static_cast<PCacheParent*>(aListener);
            auto& container = mManagedPCacheParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PCacheStorageMsgStart:
{
            PCacheStorageParent* actor = static_cast<PCacheStorageParent*>(aListener);
            auto& container = mManagedPCacheStorageParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PCacheStreamControlMsgStart:
{
            PCacheStreamControlParent* actor = static_cast<PCacheStreamControlParent*>(aListener);
            auto& container = mManagedPCacheStreamControlParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PClientManagerMsgStart:
{
            PClientManagerParent* actor = static_cast<PClientManagerParent*>(aListener);
            auto& container = mManagedPClientManagerParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PEndpointForReportMsgStart:
{
            PEndpointForReportParent* actor = static_cast<PEndpointForReportParent*>(aListener);
            auto& container = mManagedPEndpointForReportParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PFileDescriptorSetMsgStart:
{
            PFileDescriptorSetParent* actor = static_cast<PFileDescriptorSetParent*>(aListener);
            auto& container = mManagedPFileDescriptorSetParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PFileSystemRequestMsgStart:
{
            PFileSystemRequestParent* actor = static_cast<PFileSystemRequestParent*>(aListener);
            auto& container = mManagedPFileSystemRequestParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PGamepadEventChannelMsgStart:
{
            PGamepadEventChannelParent* actor = static_cast<PGamepadEventChannelParent*>(aListener);
            auto& container = mManagedPGamepadEventChannelParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PGamepadTestChannelMsgStart:
{
            PGamepadTestChannelParent* actor = static_cast<PGamepadTestChannelParent*>(aListener);
            auto& container = mManagedPGamepadTestChannelParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PHttpBackgroundChannelMsgStart:
{
            PHttpBackgroundChannelParent* actor = static_cast<PHttpBackgroundChannelParent*>(aListener);
            auto& container = mManagedPHttpBackgroundChannelParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PIdleSchedulerMsgStart:
{
            PIdleSchedulerParent* actor = static_cast<PIdleSchedulerParent*>(aListener);
            auto& container = mManagedPIdleSchedulerParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PRemoteLazyInputStreamMsgStart:
{
            PRemoteLazyInputStreamParent* actor = static_cast<PRemoteLazyInputStreamParent*>(aListener);
            auto& container = mManagedPRemoteLazyInputStreamParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PMediaTransportMsgStart:
{
            PMediaTransportParent* actor = static_cast<PMediaTransportParent*>(aListener);
            auto& container = mManagedPMediaTransportParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PRemoteWorkerMsgStart:
{
            PRemoteWorkerParent* actor = static_cast<PRemoteWorkerParent*>(aListener);
            auto& container = mManagedPRemoteWorkerParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PRemoteWorkerControllerMsgStart:
{
            PRemoteWorkerControllerParent* actor = static_cast<PRemoteWorkerControllerParent*>(aListener);
            auto& container = mManagedPRemoteWorkerControllerParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PRemoteWorkerServiceMsgStart:
{
            PRemoteWorkerServiceParent* actor = static_cast<PRemoteWorkerServiceParent*>(aListener);
            auto& container = mManagedPRemoteWorkerServiceParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PSharedWorkerMsgStart:
{
            PSharedWorkerParent* actor = static_cast<PSharedWorkerParent*>(aListener);
            auto& container = mManagedPSharedWorkerParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PTemporaryIPCBlobMsgStart:
{
            PTemporaryIPCBlobParent* actor = static_cast<PTemporaryIPCBlobParent*>(aListener);
            auto& container = mManagedPTemporaryIPCBlobParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PFileCreatorMsgStart:
{
            PFileCreatorParent* actor = static_cast<PFileCreatorParent*>(aListener);
            auto& container = mManagedPFileCreatorParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PMessagePortMsgStart:
{
            PMessagePortParent* actor = static_cast<PMessagePortParent*>(aListener);
            auto& container = mManagedPMessagePortParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PCamerasMsgStart:
{
            PCamerasParent* actor = static_cast<PCamerasParent*>(aListener);
            auto& container = mManagedPCamerasParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PMIDIManagerMsgStart:
{
            PMIDIManagerParent* actor = static_cast<PMIDIManagerParent*>(aListener);
            auto& container = mManagedPMIDIManagerParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PMIDIPortMsgStart:
{
            PMIDIPortParent* actor = static_cast<PMIDIPortParent*>(aListener);
            auto& container = mManagedPMIDIPortParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PQuotaMsgStart:
{
            PQuotaParent* actor = static_cast<PQuotaParent*>(aListener);
            auto& container = mManagedPQuotaParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PChildToParentStreamMsgStart:
{
            PChildToParentStreamParent* actor = static_cast<PChildToParentStreamParent*>(aListener);
            auto& container = mManagedPChildToParentStreamParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PParentToChildStreamMsgStart:
{
            PParentToChildStreamParent* actor = static_cast<PParentToChildStreamParent*>(aListener);
            auto& container = mManagedPParentToChildStreamParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PServiceWorkerMsgStart:
{
            PServiceWorkerParent* actor = static_cast<PServiceWorkerParent*>(aListener);
            auto& container = mManagedPServiceWorkerParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PServiceWorkerContainerMsgStart:
{
            PServiceWorkerContainerParent* actor = static_cast<PServiceWorkerContainerParent*>(aListener);
            auto& container = mManagedPServiceWorkerContainerParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PServiceWorkerManagerMsgStart:
{
            PServiceWorkerManagerParent* actor = static_cast<PServiceWorkerManagerParent*>(aListener);
            auto& container = mManagedPServiceWorkerManagerParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PServiceWorkerRegistrationMsgStart:
{
            PServiceWorkerRegistrationParent* actor = static_cast<PServiceWorkerRegistrationParent*>(aListener);
            auto& container = mManagedPServiceWorkerRegistrationParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PWebAuthnTransactionMsgStart:
{
            PWebAuthnTransactionParent* actor = static_cast<PWebAuthnTransactionParent*>(aListener);
            auto& container = mManagedPWebAuthnTransactionParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PUDPSocketMsgStart:
{
            PUDPSocketParent* actor = static_cast<PUDPSocketParent*>(aListener);
            auto& container = mManagedPUDPSocketParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PVerifySSLServerCertMsgStart:
{
            PVerifySSLServerCertParent* actor = static_cast<PVerifySSLServerCertParent*>(aListener);
            auto& container = mManagedPVerifySSLServerCertParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PVsyncMsgStart:
{
            PVsyncParent* actor = static_cast<PVsyncParent*>(aListener);
            auto& container = mManagedPVsyncParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    default:
FatalError("unreached");
        return;    }
}

auto PBackgroundParent::DeallocManagee(
        int32_t aProtocolId,
        IProtocol* aListener) -> void
{
    switch (aProtocolId) {
    case PBackgroundIndexedDBUtilsMsgStart:
        this->DeallocPBackgroundIndexedDBUtilsParent(static_cast<PBackgroundIndexedDBUtilsParent*>(aListener));
        return;
    case PBackgroundSDBConnectionMsgStart:
        this->DeallocPBackgroundSDBConnectionParent(static_cast<PBackgroundSDBConnectionParent*>(aListener));
        return;
    case PBackgroundLSDatabaseMsgStart:
        this->DeallocPBackgroundLSDatabaseParent(static_cast<PBackgroundLSDatabaseParent*>(aListener));
        return;
    case PBackgroundLSObserverMsgStart:
        this->DeallocPBackgroundLSObserverParent(static_cast<PBackgroundLSObserverParent*>(aListener));
        return;
    case PBackgroundLSRequestMsgStart:
        this->DeallocPBackgroundLSRequestParent(static_cast<PBackgroundLSRequestParent*>(aListener));
        return;
    case PBackgroundLSSimpleRequestMsgStart:
        this->DeallocPBackgroundLSSimpleRequestParent(static_cast<PBackgroundLSSimpleRequestParent*>(aListener));
        return;
    case PBackgroundLocalStorageCacheMsgStart:
        this->DeallocPBackgroundLocalStorageCacheParent(static_cast<PBackgroundLocalStorageCacheParent*>(aListener));
        return;
    case PBackgroundStorageMsgStart:
        this->DeallocPBackgroundStorageParent(static_cast<PBackgroundStorageParent*>(aListener));
        return;
    case PBackgroundTestMsgStart:
        this->DeallocPBackgroundTestParent(static_cast<PBackgroundTestParent*>(aListener));
        return;
    case PBroadcastChannelMsgStart:
        this->DeallocPBroadcastChannelParent(static_cast<PBroadcastChannelParent*>(aListener));
        return;
    case PCacheMsgStart:
        this->DeallocPCacheParent(static_cast<PCacheParent*>(aListener));
        return;
    case PCacheStorageMsgStart:
        this->DeallocPCacheStorageParent(static_cast<PCacheStorageParent*>(aListener));
        return;
    case PClientManagerMsgStart:
        this->DeallocPClientManagerParent(static_cast<PClientManagerParent*>(aListener));
        return;
    case PEndpointForReportMsgStart:
        this->DeallocPEndpointForReportParent(static_cast<PEndpointForReportParent*>(aListener));
        return;
    case PFileDescriptorSetMsgStart:
        this->DeallocPFileDescriptorSetParent(static_cast<PFileDescriptorSetParent*>(aListener));
        return;
    case PMediaTransportMsgStart:
        this->DeallocPMediaTransportParent(static_cast<PMediaTransportParent*>(aListener));
        return;
    case PRemoteWorkerMsgStart:
        this->DeallocPRemoteWorkerParent(static_cast<PRemoteWorkerParent*>(aListener));
        return;
    case PRemoteWorkerControllerMsgStart:
        this->DeallocPRemoteWorkerControllerParent(static_cast<PRemoteWorkerControllerParent*>(aListener));
        return;
    case PRemoteWorkerServiceMsgStart:
        this->DeallocPRemoteWorkerServiceParent(static_cast<PRemoteWorkerServiceParent*>(aListener));
        return;
    case PSharedWorkerMsgStart:
        this->DeallocPSharedWorkerParent(static_cast<PSharedWorkerParent*>(aListener));
        return;
    case PTemporaryIPCBlobMsgStart:
        this->DeallocPTemporaryIPCBlobParent(static_cast<PTemporaryIPCBlobParent*>(aListener));
        return;
    case PFileCreatorMsgStart:
        this->DeallocPFileCreatorParent(static_cast<PFileCreatorParent*>(aListener));
        return;
    case PMessagePortMsgStart:
        this->DeallocPMessagePortParent(static_cast<PMessagePortParent*>(aListener));
        return;
    case PCamerasMsgStart:
        this->DeallocPCamerasParent(static_cast<PCamerasParent*>(aListener));
        return;
    case PMIDIManagerMsgStart:
        this->DeallocPMIDIManagerParent(static_cast<PMIDIManagerParent*>(aListener));
        return;
    case PMIDIPortMsgStart:
        this->DeallocPMIDIPortParent(static_cast<PMIDIPortParent*>(aListener));
        return;
    case PQuotaMsgStart:
        this->DeallocPQuotaParent(static_cast<PQuotaParent*>(aListener));
        return;
    case PChildToParentStreamMsgStart:
        this->DeallocPChildToParentStreamParent(static_cast<PChildToParentStreamParent*>(aListener));
        return;
    case PParentToChildStreamMsgStart:
        this->DeallocPParentToChildStreamParent(static_cast<PParentToChildStreamParent*>(aListener));
        return;
    case PServiceWorkerManagerMsgStart:
        this->DeallocPServiceWorkerManagerParent(static_cast<PServiceWorkerManagerParent*>(aListener));
        return;
    case PWebAuthnTransactionMsgStart:
        this->DeallocPWebAuthnTransactionParent(static_cast<PWebAuthnTransactionParent*>(aListener));
        return;
    case PUDPSocketMsgStart:
        this->DeallocPUDPSocketParent(static_cast<PUDPSocketParent*>(aListener));
        return;
    case PVsyncMsgStart:
        this->DeallocPVsyncParent(static_cast<PVsyncParent*>(aListener));
        return;
    default:
        FatalError("unreached");
        return;
    }
}

auto PBackgroundParent::OnMessageReceived(const Message& msg__) -> PBackgroundParent::Result
{
    int32_t route__ = msg__.routing_id();
    if (MSG_ROUTING_CONTROL != route__) {
        IProtocol* routed__ = Lookup(route__);
        if (!routed__ || !routed__->GetLifecycleProxy()) {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Ignored message for dead actor",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eSending);
            }

            return MsgProcessed;
        }

        RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
            routed__->GetLifecycleProxy();
        return proxy__->Get()->OnMessageReceived(msg__);
    }

    switch (msg__.type()) {
    case PBackground::Msg_PBackgroundTestConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundTestConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            nsCString testArg{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(testArg)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'testArg'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 195953371)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PBackgroundTestParent* actor = (this)->AllocPBackgroundTestParent(testArg);
            if (!actor) {
                NS_WARNING("Cannot bind null PBackgroundTestParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPBackgroundTestParent.PutEntry(actor);

            if ((!((this)->RecvPBackgroundTestConstructor(std::move(actor), std::move(testArg))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PBackgroundDataBridgeConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundDataBridgeConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            uint64_t channelID{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(channelID)))))) {
                FatalError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            // Sentinel = 'channelID'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 299041639)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PBackgroundDataBridgeParent> actor = (this)->AllocPBackgroundDataBridgeParent(channelID);
            if (!actor) {
                NS_WARNING("Cannot bind null PBackgroundDataBridgeParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPBackgroundDataBridgeParent.PutEntry(actor);

            if ((!((this)->RecvPBackgroundDataBridgeConstructor(actor, std::move(channelID))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PBackgroundIDBFactoryConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundIDBFactoryConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            LoggingInfo loggingInfo{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(loggingInfo)))))) {
                FatalError("Error deserializing 'LoggingInfo'");
                return MsgValueError;
            }
            // Sentinel = 'loggingInfo'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 452658292)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'LoggingInfo'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PBackgroundIDBFactoryParent> actor = (this)->AllocPBackgroundIDBFactoryParent(loggingInfo);
            if (!actor) {
                NS_WARNING("Cannot bind null PBackgroundIDBFactoryParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPBackgroundIDBFactoryParent.PutEntry(actor);

            if ((!((this)->RecvPBackgroundIDBFactoryConstructor(actor, std::move(loggingInfo))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PBackgroundIndexedDBUtilsConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundIndexedDBUtilsConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PBackgroundIndexedDBUtilsParent* actor = (this)->AllocPBackgroundIndexedDBUtilsParent();
            if (!actor) {
                NS_WARNING("Cannot bind null PBackgroundIndexedDBUtilsParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPBackgroundIndexedDBUtilsParent.PutEntry(actor);

            if ((!((this)->RecvPBackgroundIndexedDBUtilsConstructor(std::move(actor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_FlushPendingFileDeletions__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_FlushPendingFileDeletions", OTHER);

            if ((!((this)->RecvFlushPendingFileDeletions()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PBackgroundSDBConnectionConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundSDBConnectionConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            PersistenceType persistenceType{};
            PrincipalInfo principalInfo{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(persistenceType)))))) {
                FatalError("Error deserializing 'PersistenceType'");
                return MsgValueError;
            }
            // Sentinel = 'persistenceType'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 853345864)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'PersistenceType'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(principalInfo)))))) {
                FatalError("Error deserializing 'PrincipalInfo'");
                return MsgValueError;
            }
            // Sentinel = 'principalInfo'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 633472335)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'PrincipalInfo'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PBackgroundSDBConnectionParent* actor = (this)->AllocPBackgroundSDBConnectionParent(persistenceType, principalInfo);
            if (!actor) {
                NS_WARNING("Cannot bind null PBackgroundSDBConnectionParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPBackgroundSDBConnectionParent.PutEntry(actor);

            if ((!((this)->RecvPBackgroundSDBConnectionConstructor(std::move(actor), std::move(persistenceType), std::move(principalInfo))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PBackgroundLSDatabaseConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundLSDatabaseConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            PrincipalInfo principalInfo{};
            uint32_t privateBrowsingId{};
            uint64_t datastoreId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(principalInfo)))))) {
                FatalError("Error deserializing 'PrincipalInfo'");
                return MsgValueError;
            }
            // Sentinel = 'principalInfo'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 633472335)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'PrincipalInfo'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(privateBrowsingId)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'privateBrowsingId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 1071711988)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(datastoreId)))))) {
                FatalError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            // Sentinel = 'datastoreId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 456262773)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PBackgroundLSDatabaseParent* actor = (this)->AllocPBackgroundLSDatabaseParent(principalInfo, privateBrowsingId, datastoreId);
            if (!actor) {
                NS_WARNING("Cannot bind null PBackgroundLSDatabaseParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPBackgroundLSDatabaseParent.PutEntry(actor);

            if ((!((this)->RecvPBackgroundLSDatabaseConstructor(std::move(actor), std::move(principalInfo), std::move(privateBrowsingId), std::move(datastoreId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PBackgroundLSObserverConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundLSObserverConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            uint64_t observerId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(observerId)))))) {
                FatalError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            // Sentinel = 'observerId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 386335766)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PBackgroundLSObserverParent* actor = (this)->AllocPBackgroundLSObserverParent(observerId);
            if (!actor) {
                NS_WARNING("Cannot bind null PBackgroundLSObserverParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPBackgroundLSObserverParent.PutEntry(actor);

            if ((!((this)->RecvPBackgroundLSObserverConstructor(std::move(actor), std::move(observerId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PBackgroundLSRequestConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundLSRequestConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            LSRequestParams params{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(params)))))) {
                FatalError("Error deserializing 'LSRequestParams'");
                return MsgValueError;
            }
            // Sentinel = 'params'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 146997893)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'LSRequestParams'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PBackgroundLSRequestParent* actor = (this)->AllocPBackgroundLSRequestParent(params);
            if (!actor) {
                NS_WARNING("Cannot bind null PBackgroundLSRequestParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPBackgroundLSRequestParent.PutEntry(actor);

            if ((!((this)->RecvPBackgroundLSRequestConstructor(std::move(actor), std::move(params))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PBackgroundLSSimpleRequestConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundLSSimpleRequestConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            LSSimpleRequestParams params{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(params)))))) {
                FatalError("Error deserializing 'LSSimpleRequestParams'");
                return MsgValueError;
            }
            // Sentinel = 'params'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 146997893)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'LSSimpleRequestParams'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PBackgroundLSSimpleRequestParent* actor = (this)->AllocPBackgroundLSSimpleRequestParent(params);
            if (!actor) {
                NS_WARNING("Cannot bind null PBackgroundLSSimpleRequestParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPBackgroundLSSimpleRequestParent.PutEntry(actor);

            if ((!((this)->RecvPBackgroundLSSimpleRequestConstructor(std::move(actor), std::move(params))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_LSClearPrivateBrowsing__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_LSClearPrivateBrowsing", OTHER);

            if ((!((this)->RecvLSClearPrivateBrowsing()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PBackgroundLocalStorageCacheConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundLocalStorageCacheConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            PrincipalInfo principalInfo{};
            nsCString originKey{};
            uint32_t privateBrowsingId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(principalInfo)))))) {
                FatalError("Error deserializing 'PrincipalInfo'");
                return MsgValueError;
            }
            // Sentinel = 'principalInfo'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 633472335)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'PrincipalInfo'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(originKey)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'originKey'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 313656242)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(privateBrowsingId)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'privateBrowsingId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 1071711988)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PBackgroundLocalStorageCacheParent* actor = (this)->AllocPBackgroundLocalStorageCacheParent(principalInfo, originKey, privateBrowsingId);
            if (!actor) {
                NS_WARNING("Cannot bind null PBackgroundLocalStorageCacheParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPBackgroundLocalStorageCacheParent.PutEntry(actor);

            if ((!((this)->RecvPBackgroundLocalStorageCacheConstructor(std::move(actor), std::move(principalInfo), std::move(originKey), std::move(privateBrowsingId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PBackgroundSessionStorageManagerConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundSessionStorageManagerConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            uint64_t aTopContextId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aTopContextId)))))) {
                FatalError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            // Sentinel = 'aTopContextId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 600245543)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PBackgroundSessionStorageManagerParent> actor = (this)->AllocPBackgroundSessionStorageManagerParent(aTopContextId);
            if (!actor) {
                NS_WARNING("Cannot bind null PBackgroundSessionStorageManagerParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPBackgroundSessionStorageManagerParent.PutEntry(actor);

            if ((!((this)->RecvPBackgroundSessionStorageManagerConstructor(actor, std::move(aTopContextId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PBackgroundStorageConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundStorageConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            nsString profilePath{};
            uint32_t privateBrowsingId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(profilePath)))))) {
                FatalError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            // Sentinel = 'profilePath'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 460915839)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(privateBrowsingId)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'privateBrowsingId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 1071711988)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PBackgroundStorageParent* actor = (this)->AllocPBackgroundStorageParent(profilePath, privateBrowsingId);
            if (!actor) {
                NS_WARNING("Cannot bind null PBackgroundStorageParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPBackgroundStorageParent.PutEntry(actor);

            if ((!((this)->RecvPBackgroundStorageConstructor(std::move(actor), std::move(profilePath), std::move(privateBrowsingId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PVsyncConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PVsyncConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PVsyncParent* actor = (this)->AllocPVsyncParent();
            if (!actor) {
                NS_WARNING("Cannot bind null PVsyncParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPVsyncParent.PutEntry(actor);

            if ((!((this)->RecvPVsyncConstructor(std::move(actor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PCamerasConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PCamerasConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PCamerasParent* actor = (this)->AllocPCamerasParent();
            if (!actor) {
                NS_WARNING("Cannot bind null PCamerasParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPCamerasParent.PutEntry(actor);

            if ((!((this)->RecvPCamerasConstructor(std::move(actor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PUDPSocketConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PUDPSocketConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            mozilla::Maybe<PrincipalInfo> pInfo{};
            nsCString filter{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(pInfo)))))) {
                FatalError("Error deserializing 'PrincipalInfo?'");
                return MsgValueError;
            }
            // Sentinel = 'pInfo'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 98435581)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'PrincipalInfo?'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(filter)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'filter'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 146735751)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PUDPSocketParent* actor = (this)->AllocPUDPSocketParent(pInfo, filter);
            if (!actor) {
                NS_WARNING("Cannot bind null PUDPSocketParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPUDPSocketParent.PutEntry(actor);

            if ((!((this)->RecvPUDPSocketConstructor(std::move(actor), std::move(pInfo), std::move(filter))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PBroadcastChannelConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PBroadcastChannelConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            PrincipalInfo pInfo{};
            nsCString origin{};
            nsString channel{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(pInfo)))))) {
                FatalError("Error deserializing 'PrincipalInfo'");
                return MsgValueError;
            }
            // Sentinel = 'pInfo'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 98435581)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'PrincipalInfo'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(origin)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'origin'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 150143625)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(channel)))))) {
                FatalError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            // Sentinel = 'channel'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 189334234)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PBroadcastChannelParent* actor = (this)->AllocPBroadcastChannelParent(pInfo, origin, channel);
            if (!actor) {
                NS_WARNING("Cannot bind null PBroadcastChannelParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPBroadcastChannelParent.PutEntry(actor);

            if ((!((this)->RecvPBroadcastChannelConstructor(std::move(actor), std::move(pInfo), std::move(origin), std::move(channel))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PServiceWorkerManagerConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PServiceWorkerManagerConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PServiceWorkerManagerParent* actor = (this)->AllocPServiceWorkerManagerParent();
            if (!actor) {
                NS_WARNING("Cannot bind null PServiceWorkerManagerParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPServiceWorkerManagerParent.PutEntry(actor);

            if ((!((this)->RecvPServiceWorkerManagerConstructor(std::move(actor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_ShutdownServiceWorkerRegistrar__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_ShutdownServiceWorkerRegistrar", OTHER);

            if ((!((this)->RecvShutdownServiceWorkerRegistrar()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PCacheStorageConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PCacheStorageConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            Namespace aNamespace{};
            PrincipalInfo aPrincipalInfo{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aNamespace)))))) {
                FatalError("Error deserializing 'Namespace'");
                return MsgValueError;
            }
            // Sentinel = 'aNamespace'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 356516847)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'Namespace'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aPrincipalInfo)))))) {
                FatalError("Error deserializing 'PrincipalInfo'");
                return MsgValueError;
            }
            // Sentinel = 'aPrincipalInfo'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 695272848)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'PrincipalInfo'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PCacheStorageParent* actor = (this)->AllocPCacheStorageParent(aNamespace, aPrincipalInfo);
            if (!actor) {
                NS_WARNING("Cannot bind null PCacheStorageParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPCacheStorageParent.PutEntry(actor);

            if ((!((this)->RecvPCacheStorageConstructor(std::move(actor), std::move(aNamespace), std::move(aPrincipalInfo))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PMessagePortConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PMessagePortConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            nsID uuid{};
            nsID destinationUuid{};
            uint32_t sequenceId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(uuid)))))) {
                FatalError("Error deserializing 'nsID'");
                return MsgValueError;
            }
            // Sentinel = 'uuid'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 74252728)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsID'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(destinationUuid)))))) {
                FatalError("Error deserializing 'nsID'");
                return MsgValueError;
            }
            // Sentinel = 'destinationUuid'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 840435258)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsID'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(sequenceId)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'sequenceId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 386204679)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PMessagePortParent* actor = (this)->AllocPMessagePortParent(uuid, destinationUuid, sequenceId);
            if (!actor) {
                NS_WARNING("Cannot bind null PMessagePortParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPMessagePortParent.PutEntry(actor);

            if ((!((this)->RecvPMessagePortConstructor(std::move(actor), std::move(uuid), std::move(destinationUuid), std::move(sequenceId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PChildToParentStreamConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PChildToParentStreamConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PChildToParentStreamParent* actor = (this)->AllocPChildToParentStreamParent();
            if (!actor) {
                NS_WARNING("Cannot bind null PChildToParentStreamParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPChildToParentStreamParent.PutEntry(actor);

            if ((!((this)->RecvPChildToParentStreamConstructor(std::move(actor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_MessagePortForceClose__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_MessagePortForceClose", OTHER);

            PickleIterator iter__{msg__};
            nsID uuid{};
            nsID destinationUuid{};
            uint32_t sequenceId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(uuid)))))) {
                FatalError("Error deserializing 'nsID'");
                return MsgValueError;
            }
            // Sentinel = 'uuid'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 74252728)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsID'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(destinationUuid)))))) {
                FatalError("Error deserializing 'nsID'");
                return MsgValueError;
            }
            // Sentinel = 'destinationUuid'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 840435258)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsID'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(sequenceId)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'sequenceId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 386204679)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((this)->RecvMessagePortForceClose(std::move(uuid), std::move(destinationUuid), std::move(sequenceId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PQuotaConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PQuotaConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PQuotaParent* actor = (this)->AllocPQuotaParent();
            if (!actor) {
                NS_WARNING("Cannot bind null PQuotaParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPQuotaParent.PutEntry(actor);

            if ((!((this)->RecvPQuotaConstructor(std::move(actor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_ShutdownQuotaManager__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_ShutdownQuotaManager", OTHER);

            if ((!((this)->RecvShutdownQuotaManager()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_ShutdownBackgroundSessionStorageManagers__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_ShutdownBackgroundSessionStorageManagers", OTHER);

            if ((!((this)->RecvShutdownBackgroundSessionStorageManagers()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PropagateBackgroundSessionStorageManager__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PropagateBackgroundSessionStorageManager", OTHER);

            PickleIterator iter__{msg__};
            uint64_t currentTopContextId{};
            uint64_t targetTopContextId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(currentTopContextId)))))) {
                FatalError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            // Sentinel = 'currentTopContextId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 1324877769)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(targetTopContextId)))))) {
                FatalError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            // Sentinel = 'targetTopContextId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 1175127885)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((this)->RecvPropagateBackgroundSessionStorageManager(std::move(currentTopContextId), std::move(targetTopContextId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_RemoveBackgroundSessionStorageManager__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_RemoveBackgroundSessionStorageManager", OTHER);

            PickleIterator iter__{msg__};
            uint64_t topContextId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(topContextId)))))) {
                FatalError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            // Sentinel = 'topContextId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 542704870)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((this)->RecvRemoveBackgroundSessionStorageManager(std::move(topContextId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PFileSystemRequestConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PFileSystemRequestConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            FileSystemParams params{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(params)))))) {
                FatalError("Error deserializing 'FileSystemParams'");
                return MsgValueError;
            }
            // Sentinel = 'params'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 146997893)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'FileSystemParams'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PFileSystemRequestParent> actor = (this)->AllocPFileSystemRequestParent(params);
            if (!actor) {
                NS_WARNING("Cannot bind null PFileSystemRequestParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPFileSystemRequestParent.PutEntry(actor);

            if ((!((this)->RecvPFileSystemRequestConstructor(actor, std::move(params))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PGamepadEventChannelConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PGamepadEventChannelConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PGamepadEventChannelParent> actor = (this)->AllocPGamepadEventChannelParent();
            if (!actor) {
                NS_WARNING("Cannot bind null PGamepadEventChannelParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPGamepadEventChannelParent.PutEntry(actor);

            if ((!((this)->RecvPGamepadEventChannelConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PGamepadTestChannelConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PGamepadTestChannelConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PGamepadTestChannelParent> actor = (this)->AllocPGamepadTestChannelParent();
            if (!actor) {
                NS_WARNING("Cannot bind null PGamepadTestChannelParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPGamepadTestChannelParent.PutEntry(actor);

            if ((!((this)->RecvPGamepadTestChannelConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PHttpBackgroundChannelConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PHttpBackgroundChannelConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            uint64_t channelId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(channelId)))))) {
                FatalError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            // Sentinel = 'channelId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 301138823)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PHttpBackgroundChannelParent> actor = (this)->AllocPHttpBackgroundChannelParent(channelId);
            if (!actor) {
                NS_WARNING("Cannot bind null PHttpBackgroundChannelParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPHttpBackgroundChannelParent.PutEntry(actor);

            if ((!((this)->RecvPHttpBackgroundChannelConstructor(actor, std::move(channelId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PWebAuthnTransactionConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PWebAuthnTransactionConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PWebAuthnTransactionParent* actor = (this)->AllocPWebAuthnTransactionParent();
            if (!actor) {
                NS_WARNING("Cannot bind null PWebAuthnTransactionParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPWebAuthnTransactionParent.PutEntry(actor);

            if ((!((this)->RecvPWebAuthnTransactionConstructor(std::move(actor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PSharedWorkerConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PSharedWorkerConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            RemoteWorkerData data{};
            uint64_t windowID{};
            MessagePortIdentifier portIdentifier{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(data)))))) {
                FatalError("Error deserializing 'RemoteWorkerData'");
                return MsgValueError;
            }
            // Sentinel = 'data'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 67109275)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'RemoteWorkerData'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(windowID)))))) {
                FatalError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            // Sentinel = 'windowID'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 253625126)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(portIdentifier)))))) {
                FatalError("Error deserializing 'MessagePortIdentifier'");
                return MsgValueError;
            }
            // Sentinel = 'portIdentifier'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 729875913)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'MessagePortIdentifier'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PSharedWorkerParent* actor = (this)->AllocPSharedWorkerParent(data, windowID, portIdentifier);
            if (!actor) {
                NS_WARNING("Cannot bind null PSharedWorkerParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPSharedWorkerParent.PutEntry(actor);

            if ((!((this)->RecvPSharedWorkerConstructor(std::move(actor), std::move(data), std::move(windowID), std::move(portIdentifier))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PTemporaryIPCBlobConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PTemporaryIPCBlobConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PTemporaryIPCBlobParent* actor = (this)->AllocPTemporaryIPCBlobParent();
            if (!actor) {
                NS_WARNING("Cannot bind null PTemporaryIPCBlobParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPTemporaryIPCBlobParent.PutEntry(actor);

            if ((!((this)->RecvPTemporaryIPCBlobConstructor(std::move(actor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PFileCreatorConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PFileCreatorConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            nsString aFullPath{};
            nsString aType{};
            nsString aName{};
            mozilla::Maybe<int64_t> lastModified{};
            bool aExistenceCheck{};
            bool aIsFromNsIFile{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aFullPath)))))) {
                FatalError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            // Sentinel = 'aFullPath'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 288097154)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aType)))))) {
                FatalError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            // Sentinel = 'aType'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 99222020)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aName)))))) {
                FatalError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            // Sentinel = 'aName'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 92537315)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(lastModified)))))) {
                FatalError("Error deserializing 'int64_t?'");
                return MsgValueError;
            }
            // Sentinel = 'lastModified'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 531629270)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'int64_t?'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aExistenceCheck)))))) {
                FatalError("Error deserializing 'bool'");
                return MsgValueError;
            }
            // Sentinel = 'aExistenceCheck'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 794822120)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aIsFromNsIFile)))))) {
                FatalError("Error deserializing 'bool'");
                return MsgValueError;
            }
            // Sentinel = 'aIsFromNsIFile'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 655033660)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PFileCreatorParent* actor = (this)->AllocPFileCreatorParent(aFullPath, aType, aName, lastModified, aExistenceCheck, aIsFromNsIFile);
            if (!actor) {
                NS_WARNING("Cannot bind null PFileCreatorParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPFileCreatorParent.PutEntry(actor);

            if ((!((this)->RecvPFileCreatorConstructor(std::move(actor), std::move(aFullPath), std::move(aType), std::move(aName), std::move(lastModified), std::move(aExistenceCheck), std::move(aIsFromNsIFile))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PClientManagerConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PClientManagerConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PClientManagerParent* actor = (this)->AllocPClientManagerParent();
            if (!actor) {
                NS_WARNING("Cannot bind null PClientManagerParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPClientManagerParent.PutEntry(actor);

            if ((!((this)->RecvPClientManagerConstructor(std::move(actor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PMIDIManagerConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PMIDIManagerConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PMIDIManagerParent* actor = (this)->AllocPMIDIManagerParent();
            if (!actor) {
                NS_WARNING("Cannot bind null PMIDIManagerParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPMIDIManagerParent.PutEntry(actor);

            if ((!((this)->RecvPMIDIManagerConstructor(std::move(actor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PMIDIPortConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PMIDIPortConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            MIDIPortInfo portInfo{};
            bool sysexEnabled{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(portInfo)))))) {
                FatalError("Error deserializing 'MIDIPortInfo'");
                return MsgValueError;
            }
            // Sentinel = 'portInfo'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 254411602)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'MIDIPortInfo'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(sysexEnabled)))))) {
                FatalError("Error deserializing 'bool'");
                return MsgValueError;
            }
            // Sentinel = 'sysexEnabled'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 549717224)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PMIDIPortParent* actor = (this)->AllocPMIDIPortParent(portInfo, sysexEnabled);
            if (!actor) {
                NS_WARNING("Cannot bind null PMIDIPortParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPMIDIPortParent.PutEntry(actor);

            if ((!((this)->RecvPMIDIPortConstructor(std::move(actor), std::move(portInfo), std::move(sysexEnabled))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_StorageActivity__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_StorageActivity", OTHER);

            PickleIterator iter__{msg__};
            PrincipalInfo principalInfo{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(principalInfo)))))) {
                FatalError("Error deserializing 'PrincipalInfo'");
                return MsgValueError;
            }
            // Sentinel = 'principalInfo'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 633472335)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'PrincipalInfo'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((this)->RecvStorageActivity(std::move(principalInfo))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PServiceWorkerConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PServiceWorkerConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            IPCServiceWorkerDescriptor aDescriptor{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aDescriptor)))))) {
                FatalError("Error deserializing 'IPCServiceWorkerDescriptor'");
                return MsgValueError;
            }
            // Sentinel = 'aDescriptor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 433915009)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'IPCServiceWorkerDescriptor'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PServiceWorkerParent> actor = (this)->AllocPServiceWorkerParent(aDescriptor);
            if (!actor) {
                NS_WARNING("Cannot bind null PServiceWorkerParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPServiceWorkerParent.PutEntry(actor);

            if ((!((this)->RecvPServiceWorkerConstructor(actor, std::move(aDescriptor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PRemoteWorkerControllerConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PRemoteWorkerControllerConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            RemoteWorkerData aData{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aData)))))) {
                FatalError("Error deserializing 'RemoteWorkerData'");
                return MsgValueError;
            }
            // Sentinel = 'aData'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 90571228)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'RemoteWorkerData'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PRemoteWorkerControllerParent* actor = (this)->AllocPRemoteWorkerControllerParent(aData);
            if (!actor) {
                NS_WARNING("Cannot bind null PRemoteWorkerControllerParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPRemoteWorkerControllerParent.PutEntry(actor);

            if ((!((this)->RecvPRemoteWorkerControllerConstructor(std::move(actor), std::move(aData))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PRemoteWorkerServiceConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PRemoteWorkerServiceConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PRemoteWorkerServiceParent* actor = (this)->AllocPRemoteWorkerServiceParent();
            if (!actor) {
                NS_WARNING("Cannot bind null PRemoteWorkerServiceParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPRemoteWorkerServiceParent.PutEntry(actor);

            if ((!((this)->RecvPRemoteWorkerServiceConstructor(std::move(actor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PServiceWorkerContainerConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PServiceWorkerContainerConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PServiceWorkerContainerParent> actor = (this)->AllocPServiceWorkerContainerParent();
            if (!actor) {
                NS_WARNING("Cannot bind null PServiceWorkerContainerParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPServiceWorkerContainerParent.PutEntry(actor);

            if ((!((this)->RecvPServiceWorkerContainerConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PServiceWorkerRegistrationConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PServiceWorkerRegistrationConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            IPCServiceWorkerRegistrationDescriptor aDescriptor{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aDescriptor)))))) {
                FatalError("Error deserializing 'IPCServiceWorkerRegistrationDescriptor'");
                return MsgValueError;
            }
            // Sentinel = 'aDescriptor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 433915009)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'IPCServiceWorkerRegistrationDescriptor'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PServiceWorkerRegistrationParent> actor = (this)->AllocPServiceWorkerRegistrationParent(aDescriptor);
            if (!actor) {
                NS_WARNING("Cannot bind null PServiceWorkerRegistrationParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPServiceWorkerRegistrationParent.PutEntry(actor);

            if ((!((this)->RecvPServiceWorkerRegistrationConstructor(actor, std::move(aDescriptor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PEndpointForReportConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PEndpointForReportConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            nsString aGroupName{};
            PrincipalInfo aPrincipalInfo{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aGroupName)))))) {
                FatalError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            // Sentinel = 'aGroupName'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 359924720)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aPrincipalInfo)))))) {
                FatalError("Error deserializing 'PrincipalInfo'");
                return MsgValueError;
            }
            // Sentinel = 'aPrincipalInfo'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 695272848)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'PrincipalInfo'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PEndpointForReportParent* actor = (this)->AllocPEndpointForReportParent(aGroupName, aPrincipalInfo);
            if (!actor) {
                NS_WARNING("Cannot bind null PEndpointForReportParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPEndpointForReportParent.PutEntry(actor);

            if ((!((this)->RecvPEndpointForReportConstructor(std::move(actor), std::move(aGroupName), std::move(aPrincipalInfo))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_RemoveEndpoint__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_RemoveEndpoint", OTHER);

            PickleIterator iter__{msg__};
            nsString aGroupName{};
            nsCString aEndpointURL{};
            PrincipalInfo aPrincipalInfo{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aGroupName)))))) {
                FatalError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            // Sentinel = 'aGroupName'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 359924720)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aEndpointURL)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'aEndpointURL'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 507708566)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aPrincipalInfo)))))) {
                FatalError("Error deserializing 'PrincipalInfo'");
                return MsgValueError;
            }
            // Sentinel = 'aPrincipalInfo'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 695272848)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'PrincipalInfo'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((this)->RecvRemoveEndpoint(std::move(aGroupName), std::move(aEndpointURL), std::move(aPrincipalInfo))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PIdleSchedulerConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PIdleSchedulerConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PIdleSchedulerParent> actor = (this)->AllocPIdleSchedulerParent();
            if (!actor) {
                NS_WARNING("Cannot bind null PIdleSchedulerParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPIdleSchedulerParent.PutEntry(actor);

            if ((!((this)->RecvPIdleSchedulerConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PMediaTransportConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PMediaTransportConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PMediaTransportParent* actor = (this)->AllocPMediaTransportParent();
            if (!actor) {
                NS_WARNING("Cannot bind null PMediaTransportParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPMediaTransportParent.PutEntry(actor);

            if ((!((this)->RecvPMediaTransportConstructor(std::move(actor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PVerifySSLServerCertConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PVerifySSLServerCertConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            ByteArray aServerCert{};
            nsTArray<ByteArray> aPeerCertChain{};
            nsCString aHostName{};
            int32_t aPort{};
            OriginAttributes aOriginAttributes{};
            mozilla::Maybe<ByteArray> aStapledOCSPResponse{};
            mozilla::Maybe<ByteArray> aSctsFromTLSExtension{};
            mozilla::Maybe<DelegatedCredentialInfoArg> aDcInfo{};
            uint32_t aProviderFlags{};
            uint32_t aCertVerifierFlags{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aServerCert)))))) {
                FatalError("Error deserializing 'ByteArray'");
                return MsgValueError;
            }
            // Sentinel = 'aServerCert'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 435553383)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ByteArray'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aPeerCertChain)))))) {
                FatalError("Error deserializing 'ByteArray[]'");
                return MsgValueError;
            }
            // Sentinel = 'aPeerCertChain'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 664667487)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ByteArray[]'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aHostName)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'aHostName'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 290128769)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aPort)))))) {
                FatalError("Error deserializing 'int32_t'");
                return MsgValueError;
            }
            // Sentinel = 'aPort'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 97452551)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'int32_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aOriginAttributes)))))) {
                FatalError("Error deserializing 'OriginAttributes'");
                return MsgValueError;
            }
            // Sentinel = 'aOriginAttributes'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 1021839089)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'OriginAttributes'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aStapledOCSPResponse)))))) {
                FatalError("Error deserializing 'ByteArray?'");
                return MsgValueError;
            }
            // Sentinel = 'aStapledOCSPResponse'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 1333856179)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ByteArray?'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aSctsFromTLSExtension)))))) {
                FatalError("Error deserializing 'ByteArray?'");
                return MsgValueError;
            }
            // Sentinel = 'aSctsFromTLSExtension'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 1492453443)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ByteArray?'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aDcInfo)))))) {
                FatalError("Error deserializing 'DelegatedCredentialInfoArg?'");
                return MsgValueError;
            }
            // Sentinel = 'aDcInfo'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 165544597)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'DelegatedCredentialInfoArg?'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aProviderFlags)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'aProviderFlags'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 701957530)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aCertVerifierFlags)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'aCertVerifierFlags'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 1116079897)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PVerifySSLServerCertParent> actor = (this)->AllocPVerifySSLServerCertParent(aServerCert, aPeerCertChain, aHostName, aPort, aOriginAttributes, aStapledOCSPResponse, aSctsFromTLSExtension, aDcInfo, aProviderFlags, aCertVerifierFlags);
            if (!actor) {
                NS_WARNING("Cannot bind null PVerifySSLServerCertParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPVerifySSLServerCertParent.PutEntry(actor);

            if ((!((this)->RecvPVerifySSLServerCertConstructor(actor, std::move(aServerCert), std::move(aPeerCertChain), std::move(aHostName), std::move(aPort), std::move(aOriginAttributes), std::move(aStapledOCSPResponse), std::move(aSctsFromTLSExtension), std::move(aDcInfo), std::move(aProviderFlags), std::move(aCertVerifierFlags))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_EnsureRDDProcessAndCreateBridge__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_EnsureRDDProcessAndCreateBridge", OTHER);

            int32_t id__ = MSG_ROUTING_CONTROL;
            int32_t seqno__ = msg__.seqno();
            RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
                GetLifecycleProxy();

            EnsureRDDProcessAndCreateBridgeResolver resolver = [proxy__, seqno__, id__](Tuple<const nsresult&, Endpoint<mozilla::PRemoteDecoderManagerChild>&&> aParam) {
                if (!proxy__->Get()) {
                    NS_WARNING("Not resolving response because actor is dead.");
                    return;
                }
                PBackgroundParent* self__ = static_cast<PBackgroundParent*>(proxy__->Get());

                IPC::Message* reply__ = PBackground::Reply_EnsureRDDProcessAndCreateBridge(id__);
                reply__->set_seqno(seqno__);

                bool resolve__ = true;
                WriteIPDLParam(reply__, self__, resolve__);
                // Sentinel = 'resolve__'
                (reply__)->WriteSentinel(322044863);
                WriteIPDLParam(reply__, self__, mozilla::Get<0>(aParam));
                // Sentinel = 'rv'
                (reply__)->WriteSentinel(22806761);
                WriteIPDLParam(reply__, self__, std::move(mozilla::Get<1>(aParam)));
                // Sentinel = 'aEndpoint'
                (reply__)->WriteSentinel(292225955);

                if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                    mozilla::ipc::LogMessageForProtocol(
                        "PBackgroundParent",
                        (self__)->OtherPid(),
                        "Sending reply ",
                        reply__->type(),
                        mozilla::ipc::MessageDirection::eSending);
                }

                bool sendok__ = self__->ChannelSend(reply__);
                if (!sendok__) {
                    NS_WARNING("Error sending reply");
                }
            };
            if ((!((this)->RecvEnsureRDDProcessAndCreateBridge(std::move(resolver))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Reply_PCacheConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PCacheStreamControlConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PParentToChildStreamConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PRemoteWorkerConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PRemoteLazyInputStreamConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Msg_PRemoteLazyInputStreamConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PRemoteLazyInputStreamConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            nsID aID{};
            uint64_t aSize{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aID)))))) {
                FatalError("Error deserializing 'nsID'");
                return MsgValueError;
            }
            // Sentinel = 'aID'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 33292527)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsID'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aSize)))))) {
                FatalError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            // Sentinel = 'aSize'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 97124861)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PRemoteLazyInputStreamParent> actor = (this)->AllocPRemoteLazyInputStreamParent(aID, aSize);
            if (!actor) {
                NS_WARNING("Cannot bind null PRemoteLazyInputStreamParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPRemoteLazyInputStreamParent.PutEntry(actor);

            if ((!((this)->RecvPRemoteLazyInputStreamConstructor(actor, std::move(aID), std::move(aSize))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Reply_PFileDescriptorSetConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Msg_PFileDescriptorSetConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PFileDescriptorSetConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            FileDescriptor fd{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(fd)))))) {
                FatalError("Error deserializing 'FileDescriptor'");
                return MsgValueError;
            }
            // Sentinel = 'fd'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 20054219)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'FileDescriptor'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PFileDescriptorSetParent* actor = (this)->AllocPFileDescriptorSetParent(fd);
            if (!actor) {
                NS_WARNING("Cannot bind null PFileDescriptorSetParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPFileDescriptorSetParent.PutEntry(actor);

            if ((!((this)->RecvPFileDescriptorSetConstructor(std::move(actor), std::move(fd))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    default:
        return MsgNotKnown;
    case SHMEM_CREATED_MESSAGE_TYPE:
        {
            if (!ShmemCreated(msg__)) {
                return MsgPayloadError;
            }
            return MsgProcessed;
        }
    case SHMEM_DESTROYED_MESSAGE_TYPE:
        {
            if (!ShmemDestroyed(msg__)) {
                return MsgPayloadError;
            }
            return MsgProcessed;
        }
    }
}

auto PBackgroundParent::OnMessageReceived(
        const Message& msg__,
        Message*& reply__) -> PBackgroundParent::Result
{
    int32_t route__ = msg__.routing_id();
    if (MSG_ROUTING_CONTROL != route__) {
        IProtocol* routed__ = Lookup(route__);
        if (!routed__ || !routed__->GetLifecycleProxy()) {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundParent",
                    OtherPid(),
                    "Ignored message for dead actor",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eSending);
            }

            return MsgProcessed;
        }

        RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
            routed__->GetLifecycleProxy();
        return proxy__->Get()->OnMessageReceived(msg__, reply__);
    }

    return MsgNotKnown;
}

auto PBackgroundParent::OnCallReceived(
        const Message& msg__,
        Message*& reply__) -> PBackgroundParent::Result
{
    MOZ_ASSERT_UNREACHABLE("message protocol not supported");
    return MsgNotKnown;
}

auto PBackgroundParent::OnChannelClose() -> void
{
    DestroySubtree(NormalShutdown);
    ClearSubtree();
    DeallocShmems();
    if (GetLifecycleProxy()) {
        GetLifecycleProxy()->Release();
    }
}

auto PBackgroundParent::OnChannelError() -> void
{
    DestroySubtree(AbnormalShutdown);
    ClearSubtree();
    DeallocShmems();
    if (GetLifecycleProxy()) {
        GetLifecycleProxy()->Release();
    }
}

auto PBackgroundParent::ClearSubtree() -> void
{
    for (auto it = mManagedPBackgroundDataBridgeParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundDataBridgeParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundDataBridgeParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundDataBridgeParent.Clear();

    for (auto it = mManagedPBackgroundIDBFactoryParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundIDBFactoryParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundIDBFactoryParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundIDBFactoryParent.Clear();

    for (auto it = mManagedPBackgroundIndexedDBUtilsParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundIndexedDBUtilsParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundIndexedDBUtilsParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundIndexedDBUtilsParent.Clear();

    for (auto it = mManagedPBackgroundSDBConnectionParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundSDBConnectionParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundSDBConnectionParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundSDBConnectionParent.Clear();

    for (auto it = mManagedPBackgroundLSDatabaseParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundLSDatabaseParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundLSDatabaseParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundLSDatabaseParent.Clear();

    for (auto it = mManagedPBackgroundLSObserverParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundLSObserverParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundLSObserverParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundLSObserverParent.Clear();

    for (auto it = mManagedPBackgroundLSRequestParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundLSRequestParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundLSRequestParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundLSRequestParent.Clear();

    for (auto it = mManagedPBackgroundLSSimpleRequestParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundLSSimpleRequestParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundLSSimpleRequestParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundLSSimpleRequestParent.Clear();

    for (auto it = mManagedPBackgroundLocalStorageCacheParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundLocalStorageCacheParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundLocalStorageCacheParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundLocalStorageCacheParent.Clear();

    for (auto it = mManagedPBackgroundSessionStorageManagerParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundSessionStorageManagerParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundSessionStorageManagerParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundSessionStorageManagerParent.Clear();

    for (auto it = mManagedPBackgroundStorageParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundStorageParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundStorageParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundStorageParent.Clear();

    for (auto it = mManagedPBackgroundTestParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundTestParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundTestParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundTestParent.Clear();

    for (auto it = mManagedPBroadcastChannelParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBroadcastChannelParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBroadcastChannelParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBroadcastChannelParent.Clear();

    for (auto it = mManagedPCacheParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPCacheParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPCacheParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPCacheParent.Clear();

    for (auto it = mManagedPCacheStorageParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPCacheStorageParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPCacheStorageParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPCacheStorageParent.Clear();

    for (auto it = mManagedPCacheStreamControlParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPCacheStreamControlParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPCacheStreamControlParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPCacheStreamControlParent.Clear();

    for (auto it = mManagedPClientManagerParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPClientManagerParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPClientManagerParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPClientManagerParent.Clear();

    for (auto it = mManagedPEndpointForReportParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPEndpointForReportParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPEndpointForReportParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPEndpointForReportParent.Clear();

    for (auto it = mManagedPFileDescriptorSetParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPFileDescriptorSetParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPFileDescriptorSetParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPFileDescriptorSetParent.Clear();

    for (auto it = mManagedPFileSystemRequestParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPFileSystemRequestParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPFileSystemRequestParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPFileSystemRequestParent.Clear();

    for (auto it = mManagedPGamepadEventChannelParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPGamepadEventChannelParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPGamepadEventChannelParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPGamepadEventChannelParent.Clear();

    for (auto it = mManagedPGamepadTestChannelParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPGamepadTestChannelParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPGamepadTestChannelParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPGamepadTestChannelParent.Clear();

    for (auto it = mManagedPHttpBackgroundChannelParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPHttpBackgroundChannelParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPHttpBackgroundChannelParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPHttpBackgroundChannelParent.Clear();

    for (auto it = mManagedPIdleSchedulerParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPIdleSchedulerParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPIdleSchedulerParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPIdleSchedulerParent.Clear();

    for (auto it = mManagedPRemoteLazyInputStreamParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPRemoteLazyInputStreamParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPRemoteLazyInputStreamParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPRemoteLazyInputStreamParent.Clear();

    for (auto it = mManagedPMediaTransportParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPMediaTransportParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPMediaTransportParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPMediaTransportParent.Clear();

    for (auto it = mManagedPRemoteWorkerParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPRemoteWorkerParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPRemoteWorkerParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPRemoteWorkerParent.Clear();

    for (auto it = mManagedPRemoteWorkerControllerParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPRemoteWorkerControllerParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPRemoteWorkerControllerParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPRemoteWorkerControllerParent.Clear();

    for (auto it = mManagedPRemoteWorkerServiceParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPRemoteWorkerServiceParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPRemoteWorkerServiceParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPRemoteWorkerServiceParent.Clear();

    for (auto it = mManagedPSharedWorkerParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPSharedWorkerParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPSharedWorkerParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPSharedWorkerParent.Clear();

    for (auto it = mManagedPTemporaryIPCBlobParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPTemporaryIPCBlobParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPTemporaryIPCBlobParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPTemporaryIPCBlobParent.Clear();

    for (auto it = mManagedPFileCreatorParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPFileCreatorParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPFileCreatorParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPFileCreatorParent.Clear();

    for (auto it = mManagedPMessagePortParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPMessagePortParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPMessagePortParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPMessagePortParent.Clear();

    for (auto it = mManagedPCamerasParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPCamerasParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPCamerasParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPCamerasParent.Clear();

    for (auto it = mManagedPMIDIManagerParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPMIDIManagerParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPMIDIManagerParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPMIDIManagerParent.Clear();

    for (auto it = mManagedPMIDIPortParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPMIDIPortParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPMIDIPortParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPMIDIPortParent.Clear();

    for (auto it = mManagedPQuotaParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPQuotaParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPQuotaParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPQuotaParent.Clear();

    for (auto it = mManagedPChildToParentStreamParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPChildToParentStreamParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPChildToParentStreamParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPChildToParentStreamParent.Clear();

    for (auto it = mManagedPParentToChildStreamParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPParentToChildStreamParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPParentToChildStreamParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPParentToChildStreamParent.Clear();

    for (auto it = mManagedPServiceWorkerParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPServiceWorkerParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPServiceWorkerParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPServiceWorkerParent.Clear();

    for (auto it = mManagedPServiceWorkerContainerParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPServiceWorkerContainerParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPServiceWorkerContainerParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPServiceWorkerContainerParent.Clear();

    for (auto it = mManagedPServiceWorkerManagerParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPServiceWorkerManagerParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPServiceWorkerManagerParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPServiceWorkerManagerParent.Clear();

    for (auto it = mManagedPServiceWorkerRegistrationParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPServiceWorkerRegistrationParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPServiceWorkerRegistrationParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPServiceWorkerRegistrationParent.Clear();

    for (auto it = mManagedPWebAuthnTransactionParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPWebAuthnTransactionParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPWebAuthnTransactionParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPWebAuthnTransactionParent.Clear();

    for (auto it = mManagedPUDPSocketParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPUDPSocketParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPUDPSocketParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPUDPSocketParent.Clear();

    for (auto it = mManagedPVerifySSLServerCertParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPVerifySSLServerCertParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPVerifySSLServerCertParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPVerifySSLServerCertParent.Clear();

    for (auto it = mManagedPVsyncParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPVsyncParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPVsyncParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPVsyncParent.Clear();

}



} // namespace ipc
} // namespace mozilla
namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::ipc::PBackgroundParent*>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    int32_t id;
    if (!aVar) {
        id = 0;  // kNullActorId
    } else {
        id = aVar->Id();
        if (id == 1) {  // kFreedActorId
            aVar->FatalError("Actor has been |delete|d");
        }
        MOZ_RELEASE_ASSERT(
            aActor->GetIPCChannel() == aVar->GetIPCChannel(),
            "Actor must be from the same channel as the"
            " actor it's being sent over");
        MOZ_RELEASE_ASSERT(
            aVar->CanSend(),
            "Actor must still be open when sending");
    }

    WriteIPDLParam(aMsg, aActor, id);
}

auto IPDLParamTraits<mozilla::ipc::PBackgroundParent*>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    mozilla::Maybe<mozilla::ipc::IProtocol*> actor =
        aActor->ReadActor(aMsg, aIter, true, "PBackground", PBackgroundMsgStart);
    if (actor.isNothing()) {
        return false;
    }

    *aVar = static_cast<mozilla::ipc::PBackgroundParent*>(actor.value());
    return true;
}

} // namespace ipc
} // namespace mozilla
