//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/ipc/PBackgroundChild.h"
#include "mozilla/ProfilerLabels.h"
#include "mozilla/dom/cache/IPCUtils.h"
#include "mozilla/dom/quota/SerializationHelpers.h"
#include "mozilla/layers/LayersMessageUtils.h"

#include "mozilla/net/PBackgroundDataBridgeChild.h"
#include "mozilla/dom/indexedDB/PBackgroundIDBFactoryChild.h"
#include "mozilla/dom/indexedDB/PBackgroundIndexedDBUtilsChild.h"
#include "mozilla/dom/PBackgroundSDBConnectionChild.h"
#include "mozilla/dom/PBackgroundLSDatabaseChild.h"
#include "mozilla/dom/PBackgroundLSObserverChild.h"
#include "mozilla/dom/PBackgroundLSRequestChild.h"
#include "mozilla/dom/PBackgroundLSSimpleRequestChild.h"
#include "mozilla/dom/PBackgroundLocalStorageCacheChild.h"
#include "mozilla/dom/PBackgroundSessionStorageManagerChild.h"
#include "mozilla/dom/PBackgroundStorageChild.h"
#include "mozilla/ipc/PBackgroundTestChild.h"
#include "mozilla/dom/PBroadcastChannelChild.h"
#include "mozilla/dom/cache/PCacheChild.h"
#include "mozilla/dom/cache/PCacheStorageChild.h"
#include "mozilla/dom/cache/PCacheStreamControlChild.h"
#include "mozilla/dom/PClientManagerChild.h"
#include "mozilla/dom/PEndpointForReportChild.h"
#include "mozilla/ipc/PFileDescriptorSetChild.h"
#include "mozilla/dom/PFileSystemRequestChild.h"
#include "mozilla/dom/PGamepadEventChannelChild.h"
#include "mozilla/dom/PGamepadTestChannelChild.h"
#include "mozilla/net/PHttpBackgroundChannelChild.h"
#include "mozilla/ipc/PIdleSchedulerChild.h"
#include "mozilla/PRemoteLazyInputStreamChild.h"
#include "mozilla/dom/PMediaTransportChild.h"
#include "mozilla/dom/PRemoteWorkerChild.h"
#include "mozilla/dom/PRemoteWorkerControllerChild.h"
#include "mozilla/dom/PRemoteWorkerServiceChild.h"
#include "mozilla/dom/PSharedWorkerChild.h"
#include "mozilla/dom/PTemporaryIPCBlobChild.h"
#include "mozilla/dom/PFileCreatorChild.h"
#include "mozilla/dom/PMessagePortChild.h"
#include "mozilla/camera/PCamerasChild.h"
#include "mozilla/dom/PMIDIManagerChild.h"
#include "mozilla/dom/PMIDIPortChild.h"
#include "mozilla/dom/quota/PQuotaChild.h"
#include "mozilla/ipc/PChildToParentStreamChild.h"
#include "mozilla/ipc/PParentToChildStreamChild.h"
#include "mozilla/dom/PServiceWorkerChild.h"
#include "mozilla/dom/PServiceWorkerContainerChild.h"
#include "mozilla/dom/PServiceWorkerManagerChild.h"
#include "mozilla/dom/PServiceWorkerRegistrationChild.h"
#include "mozilla/dom/PWebAuthnTransactionChild.h"
#include "mozilla/net/PUDPSocketChild.h"
#include "mozilla/psm/PVerifySSLServerCertChild.h"
#include "mozilla/dom/PVsyncChild.h"
#include "mozilla/PRemoteDecoderManagerChild.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace ipc {


auto PBackgroundChild::RecvPCacheConstructor(PCacheChild* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundChild::RecvPCacheStreamControlConstructor(PCacheStreamControlChild* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundChild::RecvPParentToChildStreamConstructor(PParentToChildStreamChild* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundChild::RecvPRemoteWorkerConstructor(
        PRemoteWorkerChild* actor,
        const RemoteWorkerData& data) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundChild::RecvPRemoteLazyInputStreamConstructor(
        PRemoteLazyInputStreamChild* actor,
        const nsID& aID,
        const uint64_t& aSize) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundChild::RecvPFileDescriptorSetConstructor(
        PFileDescriptorSetChild* actor,
        const FileDescriptor& fd) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PBackgroundChild::ProcessingError(
        Result aCode,
        const char* aReason) -> void
{
}

auto PBackgroundChild::ShouldContinueFromReplyTimeout() -> bool
{
    return true;
}

auto PBackgroundChild::EnteredCxxStack() -> void
{
}

auto PBackgroundChild::ExitedCxxStack() -> void
{
}

auto PBackgroundChild::EnteredCall() -> void
{
}

auto PBackgroundChild::ExitedCall() -> void
{
}

MOZ_IMPLICIT PBackgroundChild::PBackgroundChild() :
    mozilla::ipc::IToplevelProtocol("PBackgroundChild", PBackgroundMsgStart, mozilla::ipc::ChildSide)
{
    MOZ_COUNT_CTOR(PBackgroundChild);
}

PBackgroundChild::~PBackgroundChild()
{
    MOZ_COUNT_DTOR(PBackgroundChild);
}

auto PBackgroundChild::ManagedPBackgroundDataBridgeChild(nsTArray<PBackgroundDataBridgeChild*>& aArr) const -> void
{
    mManagedPBackgroundDataBridgeChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPBackgroundDataBridgeChild() const -> const ManagedContainer<PBackgroundDataBridgeChild>&
{
    return mManagedPBackgroundDataBridgeChild;
}

auto PBackgroundChild::ManagedPBackgroundIDBFactoryChild(nsTArray<PBackgroundIDBFactoryChild*>& aArr) const -> void
{
    mManagedPBackgroundIDBFactoryChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPBackgroundIDBFactoryChild() const -> const ManagedContainer<PBackgroundIDBFactoryChild>&
{
    return mManagedPBackgroundIDBFactoryChild;
}

auto PBackgroundChild::ManagedPBackgroundIndexedDBUtilsChild(nsTArray<PBackgroundIndexedDBUtilsChild*>& aArr) const -> void
{
    mManagedPBackgroundIndexedDBUtilsChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPBackgroundIndexedDBUtilsChild() const -> const ManagedContainer<PBackgroundIndexedDBUtilsChild>&
{
    return mManagedPBackgroundIndexedDBUtilsChild;
}

auto PBackgroundChild::ManagedPBackgroundSDBConnectionChild(nsTArray<PBackgroundSDBConnectionChild*>& aArr) const -> void
{
    mManagedPBackgroundSDBConnectionChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPBackgroundSDBConnectionChild() const -> const ManagedContainer<PBackgroundSDBConnectionChild>&
{
    return mManagedPBackgroundSDBConnectionChild;
}

auto PBackgroundChild::ManagedPBackgroundLSDatabaseChild(nsTArray<PBackgroundLSDatabaseChild*>& aArr) const -> void
{
    mManagedPBackgroundLSDatabaseChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPBackgroundLSDatabaseChild() const -> const ManagedContainer<PBackgroundLSDatabaseChild>&
{
    return mManagedPBackgroundLSDatabaseChild;
}

auto PBackgroundChild::ManagedPBackgroundLSObserverChild(nsTArray<PBackgroundLSObserverChild*>& aArr) const -> void
{
    mManagedPBackgroundLSObserverChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPBackgroundLSObserverChild() const -> const ManagedContainer<PBackgroundLSObserverChild>&
{
    return mManagedPBackgroundLSObserverChild;
}

auto PBackgroundChild::ManagedPBackgroundLSRequestChild(nsTArray<PBackgroundLSRequestChild*>& aArr) const -> void
{
    mManagedPBackgroundLSRequestChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPBackgroundLSRequestChild() const -> const ManagedContainer<PBackgroundLSRequestChild>&
{
    return mManagedPBackgroundLSRequestChild;
}

auto PBackgroundChild::ManagedPBackgroundLSSimpleRequestChild(nsTArray<PBackgroundLSSimpleRequestChild*>& aArr) const -> void
{
    mManagedPBackgroundLSSimpleRequestChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPBackgroundLSSimpleRequestChild() const -> const ManagedContainer<PBackgroundLSSimpleRequestChild>&
{
    return mManagedPBackgroundLSSimpleRequestChild;
}

auto PBackgroundChild::ManagedPBackgroundLocalStorageCacheChild(nsTArray<PBackgroundLocalStorageCacheChild*>& aArr) const -> void
{
    mManagedPBackgroundLocalStorageCacheChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPBackgroundLocalStorageCacheChild() const -> const ManagedContainer<PBackgroundLocalStorageCacheChild>&
{
    return mManagedPBackgroundLocalStorageCacheChild;
}

auto PBackgroundChild::ManagedPBackgroundSessionStorageManagerChild(nsTArray<PBackgroundSessionStorageManagerChild*>& aArr) const -> void
{
    mManagedPBackgroundSessionStorageManagerChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPBackgroundSessionStorageManagerChild() const -> const ManagedContainer<PBackgroundSessionStorageManagerChild>&
{
    return mManagedPBackgroundSessionStorageManagerChild;
}

auto PBackgroundChild::ManagedPBackgroundStorageChild(nsTArray<PBackgroundStorageChild*>& aArr) const -> void
{
    mManagedPBackgroundStorageChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPBackgroundStorageChild() const -> const ManagedContainer<PBackgroundStorageChild>&
{
    return mManagedPBackgroundStorageChild;
}

auto PBackgroundChild::ManagedPBackgroundTestChild(nsTArray<PBackgroundTestChild*>& aArr) const -> void
{
    mManagedPBackgroundTestChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPBackgroundTestChild() const -> const ManagedContainer<PBackgroundTestChild>&
{
    return mManagedPBackgroundTestChild;
}

auto PBackgroundChild::ManagedPBroadcastChannelChild(nsTArray<PBroadcastChannelChild*>& aArr) const -> void
{
    mManagedPBroadcastChannelChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPBroadcastChannelChild() const -> const ManagedContainer<PBroadcastChannelChild>&
{
    return mManagedPBroadcastChannelChild;
}

auto PBackgroundChild::ManagedPCacheChild(nsTArray<PCacheChild*>& aArr) const -> void
{
    mManagedPCacheChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPCacheChild() const -> const ManagedContainer<PCacheChild>&
{
    return mManagedPCacheChild;
}

auto PBackgroundChild::ManagedPCacheStorageChild(nsTArray<PCacheStorageChild*>& aArr) const -> void
{
    mManagedPCacheStorageChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPCacheStorageChild() const -> const ManagedContainer<PCacheStorageChild>&
{
    return mManagedPCacheStorageChild;
}

auto PBackgroundChild::ManagedPCacheStreamControlChild(nsTArray<PCacheStreamControlChild*>& aArr) const -> void
{
    mManagedPCacheStreamControlChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPCacheStreamControlChild() const -> const ManagedContainer<PCacheStreamControlChild>&
{
    return mManagedPCacheStreamControlChild;
}

auto PBackgroundChild::ManagedPClientManagerChild(nsTArray<PClientManagerChild*>& aArr) const -> void
{
    mManagedPClientManagerChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPClientManagerChild() const -> const ManagedContainer<PClientManagerChild>&
{
    return mManagedPClientManagerChild;
}

auto PBackgroundChild::ManagedPEndpointForReportChild(nsTArray<PEndpointForReportChild*>& aArr) const -> void
{
    mManagedPEndpointForReportChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPEndpointForReportChild() const -> const ManagedContainer<PEndpointForReportChild>&
{
    return mManagedPEndpointForReportChild;
}

auto PBackgroundChild::ManagedPFileDescriptorSetChild(nsTArray<PFileDescriptorSetChild*>& aArr) const -> void
{
    mManagedPFileDescriptorSetChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPFileDescriptorSetChild() const -> const ManagedContainer<PFileDescriptorSetChild>&
{
    return mManagedPFileDescriptorSetChild;
}

auto PBackgroundChild::ManagedPFileSystemRequestChild(nsTArray<PFileSystemRequestChild*>& aArr) const -> void
{
    mManagedPFileSystemRequestChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPFileSystemRequestChild() const -> const ManagedContainer<PFileSystemRequestChild>&
{
    return mManagedPFileSystemRequestChild;
}

auto PBackgroundChild::ManagedPGamepadEventChannelChild(nsTArray<PGamepadEventChannelChild*>& aArr) const -> void
{
    mManagedPGamepadEventChannelChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPGamepadEventChannelChild() const -> const ManagedContainer<PGamepadEventChannelChild>&
{
    return mManagedPGamepadEventChannelChild;
}

auto PBackgroundChild::ManagedPGamepadTestChannelChild(nsTArray<PGamepadTestChannelChild*>& aArr) const -> void
{
    mManagedPGamepadTestChannelChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPGamepadTestChannelChild() const -> const ManagedContainer<PGamepadTestChannelChild>&
{
    return mManagedPGamepadTestChannelChild;
}

auto PBackgroundChild::ManagedPHttpBackgroundChannelChild(nsTArray<PHttpBackgroundChannelChild*>& aArr) const -> void
{
    mManagedPHttpBackgroundChannelChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPHttpBackgroundChannelChild() const -> const ManagedContainer<PHttpBackgroundChannelChild>&
{
    return mManagedPHttpBackgroundChannelChild;
}

auto PBackgroundChild::ManagedPIdleSchedulerChild(nsTArray<PIdleSchedulerChild*>& aArr) const -> void
{
    mManagedPIdleSchedulerChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPIdleSchedulerChild() const -> const ManagedContainer<PIdleSchedulerChild>&
{
    return mManagedPIdleSchedulerChild;
}

auto PBackgroundChild::ManagedPRemoteLazyInputStreamChild(nsTArray<PRemoteLazyInputStreamChild*>& aArr) const -> void
{
    mManagedPRemoteLazyInputStreamChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPRemoteLazyInputStreamChild() const -> const ManagedContainer<PRemoteLazyInputStreamChild>&
{
    return mManagedPRemoteLazyInputStreamChild;
}

auto PBackgroundChild::ManagedPMediaTransportChild(nsTArray<PMediaTransportChild*>& aArr) const -> void
{
    mManagedPMediaTransportChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPMediaTransportChild() const -> const ManagedContainer<PMediaTransportChild>&
{
    return mManagedPMediaTransportChild;
}

auto PBackgroundChild::ManagedPRemoteWorkerChild(nsTArray<PRemoteWorkerChild*>& aArr) const -> void
{
    mManagedPRemoteWorkerChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPRemoteWorkerChild() const -> const ManagedContainer<PRemoteWorkerChild>&
{
    return mManagedPRemoteWorkerChild;
}

auto PBackgroundChild::ManagedPRemoteWorkerControllerChild(nsTArray<PRemoteWorkerControllerChild*>& aArr) const -> void
{
    mManagedPRemoteWorkerControllerChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPRemoteWorkerControllerChild() const -> const ManagedContainer<PRemoteWorkerControllerChild>&
{
    return mManagedPRemoteWorkerControllerChild;
}

auto PBackgroundChild::ManagedPRemoteWorkerServiceChild(nsTArray<PRemoteWorkerServiceChild*>& aArr) const -> void
{
    mManagedPRemoteWorkerServiceChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPRemoteWorkerServiceChild() const -> const ManagedContainer<PRemoteWorkerServiceChild>&
{
    return mManagedPRemoteWorkerServiceChild;
}

auto PBackgroundChild::ManagedPSharedWorkerChild(nsTArray<PSharedWorkerChild*>& aArr) const -> void
{
    mManagedPSharedWorkerChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPSharedWorkerChild() const -> const ManagedContainer<PSharedWorkerChild>&
{
    return mManagedPSharedWorkerChild;
}

auto PBackgroundChild::ManagedPTemporaryIPCBlobChild(nsTArray<PTemporaryIPCBlobChild*>& aArr) const -> void
{
    mManagedPTemporaryIPCBlobChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPTemporaryIPCBlobChild() const -> const ManagedContainer<PTemporaryIPCBlobChild>&
{
    return mManagedPTemporaryIPCBlobChild;
}

auto PBackgroundChild::ManagedPFileCreatorChild(nsTArray<PFileCreatorChild*>& aArr) const -> void
{
    mManagedPFileCreatorChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPFileCreatorChild() const -> const ManagedContainer<PFileCreatorChild>&
{
    return mManagedPFileCreatorChild;
}

auto PBackgroundChild::ManagedPMessagePortChild(nsTArray<PMessagePortChild*>& aArr) const -> void
{
    mManagedPMessagePortChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPMessagePortChild() const -> const ManagedContainer<PMessagePortChild>&
{
    return mManagedPMessagePortChild;
}

auto PBackgroundChild::ManagedPCamerasChild(nsTArray<PCamerasChild*>& aArr) const -> void
{
    mManagedPCamerasChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPCamerasChild() const -> const ManagedContainer<PCamerasChild>&
{
    return mManagedPCamerasChild;
}

auto PBackgroundChild::ManagedPMIDIManagerChild(nsTArray<PMIDIManagerChild*>& aArr) const -> void
{
    mManagedPMIDIManagerChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPMIDIManagerChild() const -> const ManagedContainer<PMIDIManagerChild>&
{
    return mManagedPMIDIManagerChild;
}

auto PBackgroundChild::ManagedPMIDIPortChild(nsTArray<PMIDIPortChild*>& aArr) const -> void
{
    mManagedPMIDIPortChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPMIDIPortChild() const -> const ManagedContainer<PMIDIPortChild>&
{
    return mManagedPMIDIPortChild;
}

auto PBackgroundChild::ManagedPQuotaChild(nsTArray<PQuotaChild*>& aArr) const -> void
{
    mManagedPQuotaChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPQuotaChild() const -> const ManagedContainer<PQuotaChild>&
{
    return mManagedPQuotaChild;
}

auto PBackgroundChild::ManagedPChildToParentStreamChild(nsTArray<PChildToParentStreamChild*>& aArr) const -> void
{
    mManagedPChildToParentStreamChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPChildToParentStreamChild() const -> const ManagedContainer<PChildToParentStreamChild>&
{
    return mManagedPChildToParentStreamChild;
}

auto PBackgroundChild::ManagedPParentToChildStreamChild(nsTArray<PParentToChildStreamChild*>& aArr) const -> void
{
    mManagedPParentToChildStreamChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPParentToChildStreamChild() const -> const ManagedContainer<PParentToChildStreamChild>&
{
    return mManagedPParentToChildStreamChild;
}

auto PBackgroundChild::ManagedPServiceWorkerChild(nsTArray<PServiceWorkerChild*>& aArr) const -> void
{
    mManagedPServiceWorkerChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPServiceWorkerChild() const -> const ManagedContainer<PServiceWorkerChild>&
{
    return mManagedPServiceWorkerChild;
}

auto PBackgroundChild::ManagedPServiceWorkerContainerChild(nsTArray<PServiceWorkerContainerChild*>& aArr) const -> void
{
    mManagedPServiceWorkerContainerChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPServiceWorkerContainerChild() const -> const ManagedContainer<PServiceWorkerContainerChild>&
{
    return mManagedPServiceWorkerContainerChild;
}

auto PBackgroundChild::ManagedPServiceWorkerManagerChild(nsTArray<PServiceWorkerManagerChild*>& aArr) const -> void
{
    mManagedPServiceWorkerManagerChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPServiceWorkerManagerChild() const -> const ManagedContainer<PServiceWorkerManagerChild>&
{
    return mManagedPServiceWorkerManagerChild;
}

auto PBackgroundChild::ManagedPServiceWorkerRegistrationChild(nsTArray<PServiceWorkerRegistrationChild*>& aArr) const -> void
{
    mManagedPServiceWorkerRegistrationChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPServiceWorkerRegistrationChild() const -> const ManagedContainer<PServiceWorkerRegistrationChild>&
{
    return mManagedPServiceWorkerRegistrationChild;
}

auto PBackgroundChild::ManagedPWebAuthnTransactionChild(nsTArray<PWebAuthnTransactionChild*>& aArr) const -> void
{
    mManagedPWebAuthnTransactionChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPWebAuthnTransactionChild() const -> const ManagedContainer<PWebAuthnTransactionChild>&
{
    return mManagedPWebAuthnTransactionChild;
}

auto PBackgroundChild::ManagedPUDPSocketChild(nsTArray<PUDPSocketChild*>& aArr) const -> void
{
    mManagedPUDPSocketChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPUDPSocketChild() const -> const ManagedContainer<PUDPSocketChild>&
{
    return mManagedPUDPSocketChild;
}

auto PBackgroundChild::ManagedPVerifySSLServerCertChild(nsTArray<PVerifySSLServerCertChild*>& aArr) const -> void
{
    mManagedPVerifySSLServerCertChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPVerifySSLServerCertChild() const -> const ManagedContainer<PVerifySSLServerCertChild>&
{
    return mManagedPVerifySSLServerCertChild;
}

auto PBackgroundChild::ManagedPVsyncChild(nsTArray<PVsyncChild*>& aArr) const -> void
{
    mManagedPVsyncChild.ToArray(aArr);
}

auto PBackgroundChild::ManagedPVsyncChild() const -> const ManagedContainer<PVsyncChild>&
{
    return mManagedPVsyncChild;
}

auto PBackgroundChild::AllManagedActors(nsTArray<RefPtr<mozilla::ipc::ActorLifecycleProxy>>& arr__) const -> void
{
    uint32_t total = 0;
    total += mManagedPBackgroundDataBridgeChild.Count();
    total += mManagedPBackgroundIDBFactoryChild.Count();
    total += mManagedPBackgroundIndexedDBUtilsChild.Count();
    total += mManagedPBackgroundSDBConnectionChild.Count();
    total += mManagedPBackgroundLSDatabaseChild.Count();
    total += mManagedPBackgroundLSObserverChild.Count();
    total += mManagedPBackgroundLSRequestChild.Count();
    total += mManagedPBackgroundLSSimpleRequestChild.Count();
    total += mManagedPBackgroundLocalStorageCacheChild.Count();
    total += mManagedPBackgroundSessionStorageManagerChild.Count();
    total += mManagedPBackgroundStorageChild.Count();
    total += mManagedPBackgroundTestChild.Count();
    total += mManagedPBroadcastChannelChild.Count();
    total += mManagedPCacheChild.Count();
    total += mManagedPCacheStorageChild.Count();
    total += mManagedPCacheStreamControlChild.Count();
    total += mManagedPClientManagerChild.Count();
    total += mManagedPEndpointForReportChild.Count();
    total += mManagedPFileDescriptorSetChild.Count();
    total += mManagedPFileSystemRequestChild.Count();
    total += mManagedPGamepadEventChannelChild.Count();
    total += mManagedPGamepadTestChannelChild.Count();
    total += mManagedPHttpBackgroundChannelChild.Count();
    total += mManagedPIdleSchedulerChild.Count();
    total += mManagedPRemoteLazyInputStreamChild.Count();
    total += mManagedPMediaTransportChild.Count();
    total += mManagedPRemoteWorkerChild.Count();
    total += mManagedPRemoteWorkerControllerChild.Count();
    total += mManagedPRemoteWorkerServiceChild.Count();
    total += mManagedPSharedWorkerChild.Count();
    total += mManagedPTemporaryIPCBlobChild.Count();
    total += mManagedPFileCreatorChild.Count();
    total += mManagedPMessagePortChild.Count();
    total += mManagedPCamerasChild.Count();
    total += mManagedPMIDIManagerChild.Count();
    total += mManagedPMIDIPortChild.Count();
    total += mManagedPQuotaChild.Count();
    total += mManagedPChildToParentStreamChild.Count();
    total += mManagedPParentToChildStreamChild.Count();
    total += mManagedPServiceWorkerChild.Count();
    total += mManagedPServiceWorkerContainerChild.Count();
    total += mManagedPServiceWorkerManagerChild.Count();
    total += mManagedPServiceWorkerRegistrationChild.Count();
    total += mManagedPWebAuthnTransactionChild.Count();
    total += mManagedPUDPSocketChild.Count();
    total += mManagedPVerifySSLServerCertChild.Count();
    total += mManagedPVsyncChild.Count();
    arr__.SetCapacity(total);

    for (auto it = mManagedPBackgroundDataBridgeChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundIDBFactoryChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundIndexedDBUtilsChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundSDBConnectionChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundLSDatabaseChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundLSObserverChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundLSRequestChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundLSSimpleRequestChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundLocalStorageCacheChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundSessionStorageManagerChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundStorageChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBackgroundTestChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPBroadcastChannelChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPCacheChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPCacheStorageChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPCacheStreamControlChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPClientManagerChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPEndpointForReportChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPFileDescriptorSetChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPFileSystemRequestChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPGamepadEventChannelChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPGamepadTestChannelChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPHttpBackgroundChannelChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPIdleSchedulerChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPRemoteLazyInputStreamChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPMediaTransportChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPRemoteWorkerChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPRemoteWorkerControllerChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPRemoteWorkerServiceChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPSharedWorkerChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPTemporaryIPCBlobChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPFileCreatorChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPMessagePortChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPCamerasChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPMIDIManagerChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPMIDIPortChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPQuotaChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPChildToParentStreamChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPParentToChildStreamChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPServiceWorkerChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPServiceWorkerContainerChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPServiceWorkerManagerChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPServiceWorkerRegistrationChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPWebAuthnTransactionChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPUDPSocketChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPVerifySSLServerCertChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPVsyncChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

}

auto PBackgroundChild::OpenPBackgroundDataBridgeEndpoint(PBackgroundDataBridgeChild* aActor) -> ManagedEndpoint<PBackgroundDataBridgeParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundDataBridgeChild actor");
        return ManagedEndpoint<PBackgroundDataBridgeParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundDataBridgeChild.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundDataBridgeParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPBackgroundDataBridgeEndpoint(
        ManagedEndpoint<PBackgroundDataBridgeChild> aEndpoint,
        PBackgroundDataBridgeChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundDataBridgeChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundDataBridgeChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPBackgroundIDBFactoryEndpoint(PBackgroundIDBFactoryChild* aActor) -> ManagedEndpoint<PBackgroundIDBFactoryParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundIDBFactoryChild actor");
        return ManagedEndpoint<PBackgroundIDBFactoryParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundIDBFactoryChild.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundIDBFactoryParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPBackgroundIDBFactoryEndpoint(
        ManagedEndpoint<PBackgroundIDBFactoryChild> aEndpoint,
        PBackgroundIDBFactoryChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundIDBFactoryChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundIDBFactoryChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPBackgroundIndexedDBUtilsEndpoint(PBackgroundIndexedDBUtilsChild* aActor) -> ManagedEndpoint<PBackgroundIndexedDBUtilsParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundIndexedDBUtilsChild actor");
        return ManagedEndpoint<PBackgroundIndexedDBUtilsParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundIndexedDBUtilsChild.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundIndexedDBUtilsParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPBackgroundIndexedDBUtilsEndpoint(
        ManagedEndpoint<PBackgroundIndexedDBUtilsChild> aEndpoint,
        PBackgroundIndexedDBUtilsChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundIndexedDBUtilsChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundIndexedDBUtilsChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPBackgroundSDBConnectionEndpoint(PBackgroundSDBConnectionChild* aActor) -> ManagedEndpoint<PBackgroundSDBConnectionParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundSDBConnectionChild actor");
        return ManagedEndpoint<PBackgroundSDBConnectionParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundSDBConnectionChild.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundSDBConnectionParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPBackgroundSDBConnectionEndpoint(
        ManagedEndpoint<PBackgroundSDBConnectionChild> aEndpoint,
        PBackgroundSDBConnectionChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundSDBConnectionChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundSDBConnectionChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPBackgroundLSDatabaseEndpoint(PBackgroundLSDatabaseChild* aActor) -> ManagedEndpoint<PBackgroundLSDatabaseParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundLSDatabaseChild actor");
        return ManagedEndpoint<PBackgroundLSDatabaseParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundLSDatabaseChild.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundLSDatabaseParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPBackgroundLSDatabaseEndpoint(
        ManagedEndpoint<PBackgroundLSDatabaseChild> aEndpoint,
        PBackgroundLSDatabaseChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundLSDatabaseChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundLSDatabaseChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPBackgroundLSObserverEndpoint(PBackgroundLSObserverChild* aActor) -> ManagedEndpoint<PBackgroundLSObserverParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundLSObserverChild actor");
        return ManagedEndpoint<PBackgroundLSObserverParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundLSObserverChild.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundLSObserverParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPBackgroundLSObserverEndpoint(
        ManagedEndpoint<PBackgroundLSObserverChild> aEndpoint,
        PBackgroundLSObserverChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundLSObserverChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundLSObserverChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPBackgroundLSRequestEndpoint(PBackgroundLSRequestChild* aActor) -> ManagedEndpoint<PBackgroundLSRequestParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundLSRequestChild actor");
        return ManagedEndpoint<PBackgroundLSRequestParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundLSRequestChild.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundLSRequestParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPBackgroundLSRequestEndpoint(
        ManagedEndpoint<PBackgroundLSRequestChild> aEndpoint,
        PBackgroundLSRequestChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundLSRequestChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundLSRequestChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPBackgroundLSSimpleRequestEndpoint(PBackgroundLSSimpleRequestChild* aActor) -> ManagedEndpoint<PBackgroundLSSimpleRequestParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundLSSimpleRequestChild actor");
        return ManagedEndpoint<PBackgroundLSSimpleRequestParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundLSSimpleRequestChild.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundLSSimpleRequestParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPBackgroundLSSimpleRequestEndpoint(
        ManagedEndpoint<PBackgroundLSSimpleRequestChild> aEndpoint,
        PBackgroundLSSimpleRequestChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundLSSimpleRequestChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundLSSimpleRequestChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPBackgroundLocalStorageCacheEndpoint(PBackgroundLocalStorageCacheChild* aActor) -> ManagedEndpoint<PBackgroundLocalStorageCacheParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundLocalStorageCacheChild actor");
        return ManagedEndpoint<PBackgroundLocalStorageCacheParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundLocalStorageCacheChild.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundLocalStorageCacheParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPBackgroundLocalStorageCacheEndpoint(
        ManagedEndpoint<PBackgroundLocalStorageCacheChild> aEndpoint,
        PBackgroundLocalStorageCacheChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundLocalStorageCacheChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundLocalStorageCacheChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPBackgroundSessionStorageManagerEndpoint(PBackgroundSessionStorageManagerChild* aActor) -> ManagedEndpoint<PBackgroundSessionStorageManagerParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundSessionStorageManagerChild actor");
        return ManagedEndpoint<PBackgroundSessionStorageManagerParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundSessionStorageManagerChild.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundSessionStorageManagerParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPBackgroundSessionStorageManagerEndpoint(
        ManagedEndpoint<PBackgroundSessionStorageManagerChild> aEndpoint,
        PBackgroundSessionStorageManagerChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundSessionStorageManagerChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundSessionStorageManagerChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPBackgroundStorageEndpoint(PBackgroundStorageChild* aActor) -> ManagedEndpoint<PBackgroundStorageParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundStorageChild actor");
        return ManagedEndpoint<PBackgroundStorageParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundStorageChild.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundStorageParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPBackgroundStorageEndpoint(
        ManagedEndpoint<PBackgroundStorageChild> aEndpoint,
        PBackgroundStorageChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundStorageChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundStorageChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPBackgroundTestEndpoint(PBackgroundTestChild* aActor) -> ManagedEndpoint<PBackgroundTestParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundTestChild actor");
        return ManagedEndpoint<PBackgroundTestParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBackgroundTestChild.PutEntry(aActor);

    return ManagedEndpoint<PBackgroundTestParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPBackgroundTestEndpoint(
        ManagedEndpoint<PBackgroundTestChild> aEndpoint,
        PBackgroundTestChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBackgroundTestChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBackgroundTestChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPBroadcastChannelEndpoint(PBroadcastChannelChild* aActor) -> ManagedEndpoint<PBroadcastChannelParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PBroadcastChannelChild actor");
        return ManagedEndpoint<PBroadcastChannelParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPBroadcastChannelChild.PutEntry(aActor);

    return ManagedEndpoint<PBroadcastChannelParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPBroadcastChannelEndpoint(
        ManagedEndpoint<PBroadcastChannelChild> aEndpoint,
        PBroadcastChannelChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PBroadcastChannelChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPBroadcastChannelChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPCacheEndpoint(PCacheChild* aActor) -> ManagedEndpoint<PCacheParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PCacheChild actor");
        return ManagedEndpoint<PCacheParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPCacheChild.PutEntry(aActor);

    return ManagedEndpoint<PCacheParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPCacheEndpoint(
        ManagedEndpoint<PCacheChild> aEndpoint,
        PCacheChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PCacheChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPCacheChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPCacheStorageEndpoint(PCacheStorageChild* aActor) -> ManagedEndpoint<PCacheStorageParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PCacheStorageChild actor");
        return ManagedEndpoint<PCacheStorageParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPCacheStorageChild.PutEntry(aActor);

    return ManagedEndpoint<PCacheStorageParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPCacheStorageEndpoint(
        ManagedEndpoint<PCacheStorageChild> aEndpoint,
        PCacheStorageChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PCacheStorageChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPCacheStorageChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPCacheStreamControlEndpoint(PCacheStreamControlChild* aActor) -> ManagedEndpoint<PCacheStreamControlParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PCacheStreamControlChild actor");
        return ManagedEndpoint<PCacheStreamControlParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPCacheStreamControlChild.PutEntry(aActor);

    return ManagedEndpoint<PCacheStreamControlParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPCacheStreamControlEndpoint(
        ManagedEndpoint<PCacheStreamControlChild> aEndpoint,
        PCacheStreamControlChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PCacheStreamControlChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPCacheStreamControlChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPClientManagerEndpoint(PClientManagerChild* aActor) -> ManagedEndpoint<PClientManagerParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PClientManagerChild actor");
        return ManagedEndpoint<PClientManagerParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPClientManagerChild.PutEntry(aActor);

    return ManagedEndpoint<PClientManagerParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPClientManagerEndpoint(
        ManagedEndpoint<PClientManagerChild> aEndpoint,
        PClientManagerChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PClientManagerChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPClientManagerChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPEndpointForReportEndpoint(PEndpointForReportChild* aActor) -> ManagedEndpoint<PEndpointForReportParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PEndpointForReportChild actor");
        return ManagedEndpoint<PEndpointForReportParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPEndpointForReportChild.PutEntry(aActor);

    return ManagedEndpoint<PEndpointForReportParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPEndpointForReportEndpoint(
        ManagedEndpoint<PEndpointForReportChild> aEndpoint,
        PEndpointForReportChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PEndpointForReportChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPEndpointForReportChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPFileDescriptorSetEndpoint(PFileDescriptorSetChild* aActor) -> ManagedEndpoint<PFileDescriptorSetParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PFileDescriptorSetChild actor");
        return ManagedEndpoint<PFileDescriptorSetParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPFileDescriptorSetChild.PutEntry(aActor);

    return ManagedEndpoint<PFileDescriptorSetParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPFileDescriptorSetEndpoint(
        ManagedEndpoint<PFileDescriptorSetChild> aEndpoint,
        PFileDescriptorSetChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PFileDescriptorSetChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPFileDescriptorSetChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPFileSystemRequestEndpoint(PFileSystemRequestChild* aActor) -> ManagedEndpoint<PFileSystemRequestParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PFileSystemRequestChild actor");
        return ManagedEndpoint<PFileSystemRequestParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPFileSystemRequestChild.PutEntry(aActor);

    return ManagedEndpoint<PFileSystemRequestParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPFileSystemRequestEndpoint(
        ManagedEndpoint<PFileSystemRequestChild> aEndpoint,
        PFileSystemRequestChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PFileSystemRequestChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPFileSystemRequestChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPGamepadEventChannelEndpoint(PGamepadEventChannelChild* aActor) -> ManagedEndpoint<PGamepadEventChannelParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PGamepadEventChannelChild actor");
        return ManagedEndpoint<PGamepadEventChannelParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPGamepadEventChannelChild.PutEntry(aActor);

    return ManagedEndpoint<PGamepadEventChannelParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPGamepadEventChannelEndpoint(
        ManagedEndpoint<PGamepadEventChannelChild> aEndpoint,
        PGamepadEventChannelChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PGamepadEventChannelChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPGamepadEventChannelChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPGamepadTestChannelEndpoint(PGamepadTestChannelChild* aActor) -> ManagedEndpoint<PGamepadTestChannelParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PGamepadTestChannelChild actor");
        return ManagedEndpoint<PGamepadTestChannelParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPGamepadTestChannelChild.PutEntry(aActor);

    return ManagedEndpoint<PGamepadTestChannelParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPGamepadTestChannelEndpoint(
        ManagedEndpoint<PGamepadTestChannelChild> aEndpoint,
        PGamepadTestChannelChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PGamepadTestChannelChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPGamepadTestChannelChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPHttpBackgroundChannelEndpoint(PHttpBackgroundChannelChild* aActor) -> ManagedEndpoint<PHttpBackgroundChannelParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PHttpBackgroundChannelChild actor");
        return ManagedEndpoint<PHttpBackgroundChannelParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPHttpBackgroundChannelChild.PutEntry(aActor);

    return ManagedEndpoint<PHttpBackgroundChannelParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPHttpBackgroundChannelEndpoint(
        ManagedEndpoint<PHttpBackgroundChannelChild> aEndpoint,
        PHttpBackgroundChannelChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PHttpBackgroundChannelChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPHttpBackgroundChannelChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPIdleSchedulerEndpoint(PIdleSchedulerChild* aActor) -> ManagedEndpoint<PIdleSchedulerParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PIdleSchedulerChild actor");
        return ManagedEndpoint<PIdleSchedulerParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPIdleSchedulerChild.PutEntry(aActor);

    return ManagedEndpoint<PIdleSchedulerParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPIdleSchedulerEndpoint(
        ManagedEndpoint<PIdleSchedulerChild> aEndpoint,
        PIdleSchedulerChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PIdleSchedulerChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPIdleSchedulerChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPRemoteLazyInputStreamEndpoint(PRemoteLazyInputStreamChild* aActor) -> ManagedEndpoint<PRemoteLazyInputStreamParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PRemoteLazyInputStreamChild actor");
        return ManagedEndpoint<PRemoteLazyInputStreamParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPRemoteLazyInputStreamChild.PutEntry(aActor);

    return ManagedEndpoint<PRemoteLazyInputStreamParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPRemoteLazyInputStreamEndpoint(
        ManagedEndpoint<PRemoteLazyInputStreamChild> aEndpoint,
        PRemoteLazyInputStreamChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PRemoteLazyInputStreamChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPRemoteLazyInputStreamChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPMediaTransportEndpoint(PMediaTransportChild* aActor) -> ManagedEndpoint<PMediaTransportParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PMediaTransportChild actor");
        return ManagedEndpoint<PMediaTransportParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPMediaTransportChild.PutEntry(aActor);

    return ManagedEndpoint<PMediaTransportParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPMediaTransportEndpoint(
        ManagedEndpoint<PMediaTransportChild> aEndpoint,
        PMediaTransportChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PMediaTransportChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPMediaTransportChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPRemoteWorkerEndpoint(PRemoteWorkerChild* aActor) -> ManagedEndpoint<PRemoteWorkerParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PRemoteWorkerChild actor");
        return ManagedEndpoint<PRemoteWorkerParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPRemoteWorkerChild.PutEntry(aActor);

    return ManagedEndpoint<PRemoteWorkerParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPRemoteWorkerEndpoint(
        ManagedEndpoint<PRemoteWorkerChild> aEndpoint,
        PRemoteWorkerChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PRemoteWorkerChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPRemoteWorkerChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPRemoteWorkerControllerEndpoint(PRemoteWorkerControllerChild* aActor) -> ManagedEndpoint<PRemoteWorkerControllerParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PRemoteWorkerControllerChild actor");
        return ManagedEndpoint<PRemoteWorkerControllerParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPRemoteWorkerControllerChild.PutEntry(aActor);

    return ManagedEndpoint<PRemoteWorkerControllerParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPRemoteWorkerControllerEndpoint(
        ManagedEndpoint<PRemoteWorkerControllerChild> aEndpoint,
        PRemoteWorkerControllerChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PRemoteWorkerControllerChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPRemoteWorkerControllerChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPRemoteWorkerServiceEndpoint(PRemoteWorkerServiceChild* aActor) -> ManagedEndpoint<PRemoteWorkerServiceParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PRemoteWorkerServiceChild actor");
        return ManagedEndpoint<PRemoteWorkerServiceParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPRemoteWorkerServiceChild.PutEntry(aActor);

    return ManagedEndpoint<PRemoteWorkerServiceParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPRemoteWorkerServiceEndpoint(
        ManagedEndpoint<PRemoteWorkerServiceChild> aEndpoint,
        PRemoteWorkerServiceChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PRemoteWorkerServiceChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPRemoteWorkerServiceChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPSharedWorkerEndpoint(PSharedWorkerChild* aActor) -> ManagedEndpoint<PSharedWorkerParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PSharedWorkerChild actor");
        return ManagedEndpoint<PSharedWorkerParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPSharedWorkerChild.PutEntry(aActor);

    return ManagedEndpoint<PSharedWorkerParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPSharedWorkerEndpoint(
        ManagedEndpoint<PSharedWorkerChild> aEndpoint,
        PSharedWorkerChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PSharedWorkerChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPSharedWorkerChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPTemporaryIPCBlobEndpoint(PTemporaryIPCBlobChild* aActor) -> ManagedEndpoint<PTemporaryIPCBlobParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PTemporaryIPCBlobChild actor");
        return ManagedEndpoint<PTemporaryIPCBlobParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPTemporaryIPCBlobChild.PutEntry(aActor);

    return ManagedEndpoint<PTemporaryIPCBlobParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPTemporaryIPCBlobEndpoint(
        ManagedEndpoint<PTemporaryIPCBlobChild> aEndpoint,
        PTemporaryIPCBlobChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PTemporaryIPCBlobChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPTemporaryIPCBlobChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPFileCreatorEndpoint(PFileCreatorChild* aActor) -> ManagedEndpoint<PFileCreatorParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PFileCreatorChild actor");
        return ManagedEndpoint<PFileCreatorParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPFileCreatorChild.PutEntry(aActor);

    return ManagedEndpoint<PFileCreatorParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPFileCreatorEndpoint(
        ManagedEndpoint<PFileCreatorChild> aEndpoint,
        PFileCreatorChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PFileCreatorChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPFileCreatorChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPMessagePortEndpoint(PMessagePortChild* aActor) -> ManagedEndpoint<PMessagePortParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PMessagePortChild actor");
        return ManagedEndpoint<PMessagePortParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPMessagePortChild.PutEntry(aActor);

    return ManagedEndpoint<PMessagePortParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPMessagePortEndpoint(
        ManagedEndpoint<PMessagePortChild> aEndpoint,
        PMessagePortChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PMessagePortChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPMessagePortChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPCamerasEndpoint(PCamerasChild* aActor) -> ManagedEndpoint<PCamerasParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PCamerasChild actor");
        return ManagedEndpoint<PCamerasParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPCamerasChild.PutEntry(aActor);

    return ManagedEndpoint<PCamerasParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPCamerasEndpoint(
        ManagedEndpoint<PCamerasChild> aEndpoint,
        PCamerasChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PCamerasChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPCamerasChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPMIDIManagerEndpoint(PMIDIManagerChild* aActor) -> ManagedEndpoint<PMIDIManagerParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PMIDIManagerChild actor");
        return ManagedEndpoint<PMIDIManagerParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPMIDIManagerChild.PutEntry(aActor);

    return ManagedEndpoint<PMIDIManagerParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPMIDIManagerEndpoint(
        ManagedEndpoint<PMIDIManagerChild> aEndpoint,
        PMIDIManagerChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PMIDIManagerChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPMIDIManagerChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPMIDIPortEndpoint(PMIDIPortChild* aActor) -> ManagedEndpoint<PMIDIPortParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PMIDIPortChild actor");
        return ManagedEndpoint<PMIDIPortParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPMIDIPortChild.PutEntry(aActor);

    return ManagedEndpoint<PMIDIPortParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPMIDIPortEndpoint(
        ManagedEndpoint<PMIDIPortChild> aEndpoint,
        PMIDIPortChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PMIDIPortChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPMIDIPortChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPQuotaEndpoint(PQuotaChild* aActor) -> ManagedEndpoint<PQuotaParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PQuotaChild actor");
        return ManagedEndpoint<PQuotaParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPQuotaChild.PutEntry(aActor);

    return ManagedEndpoint<PQuotaParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPQuotaEndpoint(
        ManagedEndpoint<PQuotaChild> aEndpoint,
        PQuotaChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PQuotaChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPQuotaChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPChildToParentStreamEndpoint(PChildToParentStreamChild* aActor) -> ManagedEndpoint<PChildToParentStreamParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PChildToParentStreamChild actor");
        return ManagedEndpoint<PChildToParentStreamParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPChildToParentStreamChild.PutEntry(aActor);

    return ManagedEndpoint<PChildToParentStreamParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPChildToParentStreamEndpoint(
        ManagedEndpoint<PChildToParentStreamChild> aEndpoint,
        PChildToParentStreamChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PChildToParentStreamChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPChildToParentStreamChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPParentToChildStreamEndpoint(PParentToChildStreamChild* aActor) -> ManagedEndpoint<PParentToChildStreamParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PParentToChildStreamChild actor");
        return ManagedEndpoint<PParentToChildStreamParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPParentToChildStreamChild.PutEntry(aActor);

    return ManagedEndpoint<PParentToChildStreamParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPParentToChildStreamEndpoint(
        ManagedEndpoint<PParentToChildStreamChild> aEndpoint,
        PParentToChildStreamChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PParentToChildStreamChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPParentToChildStreamChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPServiceWorkerEndpoint(PServiceWorkerChild* aActor) -> ManagedEndpoint<PServiceWorkerParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PServiceWorkerChild actor");
        return ManagedEndpoint<PServiceWorkerParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPServiceWorkerChild.PutEntry(aActor);

    return ManagedEndpoint<PServiceWorkerParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPServiceWorkerEndpoint(
        ManagedEndpoint<PServiceWorkerChild> aEndpoint,
        PServiceWorkerChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PServiceWorkerChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPServiceWorkerChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPServiceWorkerContainerEndpoint(PServiceWorkerContainerChild* aActor) -> ManagedEndpoint<PServiceWorkerContainerParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PServiceWorkerContainerChild actor");
        return ManagedEndpoint<PServiceWorkerContainerParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPServiceWorkerContainerChild.PutEntry(aActor);

    return ManagedEndpoint<PServiceWorkerContainerParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPServiceWorkerContainerEndpoint(
        ManagedEndpoint<PServiceWorkerContainerChild> aEndpoint,
        PServiceWorkerContainerChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PServiceWorkerContainerChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPServiceWorkerContainerChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPServiceWorkerManagerEndpoint(PServiceWorkerManagerChild* aActor) -> ManagedEndpoint<PServiceWorkerManagerParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PServiceWorkerManagerChild actor");
        return ManagedEndpoint<PServiceWorkerManagerParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPServiceWorkerManagerChild.PutEntry(aActor);

    return ManagedEndpoint<PServiceWorkerManagerParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPServiceWorkerManagerEndpoint(
        ManagedEndpoint<PServiceWorkerManagerChild> aEndpoint,
        PServiceWorkerManagerChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PServiceWorkerManagerChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPServiceWorkerManagerChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPServiceWorkerRegistrationEndpoint(PServiceWorkerRegistrationChild* aActor) -> ManagedEndpoint<PServiceWorkerRegistrationParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PServiceWorkerRegistrationChild actor");
        return ManagedEndpoint<PServiceWorkerRegistrationParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPServiceWorkerRegistrationChild.PutEntry(aActor);

    return ManagedEndpoint<PServiceWorkerRegistrationParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPServiceWorkerRegistrationEndpoint(
        ManagedEndpoint<PServiceWorkerRegistrationChild> aEndpoint,
        PServiceWorkerRegistrationChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PServiceWorkerRegistrationChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPServiceWorkerRegistrationChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPWebAuthnTransactionEndpoint(PWebAuthnTransactionChild* aActor) -> ManagedEndpoint<PWebAuthnTransactionParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebAuthnTransactionChild actor");
        return ManagedEndpoint<PWebAuthnTransactionParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPWebAuthnTransactionChild.PutEntry(aActor);

    return ManagedEndpoint<PWebAuthnTransactionParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPWebAuthnTransactionEndpoint(
        ManagedEndpoint<PWebAuthnTransactionChild> aEndpoint,
        PWebAuthnTransactionChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebAuthnTransactionChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPWebAuthnTransactionChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPUDPSocketEndpoint(PUDPSocketChild* aActor) -> ManagedEndpoint<PUDPSocketParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PUDPSocketChild actor");
        return ManagedEndpoint<PUDPSocketParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPUDPSocketChild.PutEntry(aActor);

    return ManagedEndpoint<PUDPSocketParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPUDPSocketEndpoint(
        ManagedEndpoint<PUDPSocketChild> aEndpoint,
        PUDPSocketChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PUDPSocketChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPUDPSocketChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPVerifySSLServerCertEndpoint(PVerifySSLServerCertChild* aActor) -> ManagedEndpoint<PVerifySSLServerCertParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PVerifySSLServerCertChild actor");
        return ManagedEndpoint<PVerifySSLServerCertParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPVerifySSLServerCertChild.PutEntry(aActor);

    return ManagedEndpoint<PVerifySSLServerCertParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPVerifySSLServerCertEndpoint(
        ManagedEndpoint<PVerifySSLServerCertChild> aEndpoint,
        PVerifySSLServerCertChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PVerifySSLServerCertChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPVerifySSLServerCertChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::OpenPVsyncEndpoint(PVsyncChild* aActor) -> ManagedEndpoint<PVsyncParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PVsyncChild actor");
        return ManagedEndpoint<PVsyncParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPVsyncChild.PutEntry(aActor);

    return ManagedEndpoint<PVsyncParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PBackgroundChild::BindPVsyncEndpoint(
        ManagedEndpoint<PVsyncChild> aEndpoint,
        PVsyncChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PVsyncChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPVsyncChild.PutEntry(aActor);

    return true;
}

auto PBackgroundChild::SendPBackgroundTestConstructor(const nsCString& testArg) -> PBackgroundTestChild*
{
    PBackgroundTestChild* actor = (this)->AllocPBackgroundTestChild(testArg);
    return SendPBackgroundTestConstructor(actor, testArg);
}

auto PBackgroundChild::SendPBackgroundTestConstructor(
        PBackgroundTestChild* actor,
        const nsCString& testArg) -> PBackgroundTestChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PBackgroundTestChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPBackgroundTestChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PBackgroundTestConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, testArg);
    // Sentinel = 'testArg'
    (msg__)->WriteSentinel(195953371);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundTestConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PBackgroundTestChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PBackgroundTestMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPBackgroundDataBridgeConstructor(
        PBackgroundDataBridgeChild* actor,
        const uint64_t& channelID) -> PBackgroundDataBridgeChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PBackgroundDataBridgeChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPBackgroundDataBridgeChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PBackgroundDataBridgeConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, channelID);
    // Sentinel = 'channelID'
    (msg__)->WriteSentinel(299041639);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundDataBridgeConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PBackgroundDataBridgeChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PBackgroundDataBridgeMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPBackgroundIDBFactoryConstructor(
        PBackgroundIDBFactoryChild* actor,
        const LoggingInfo& loggingInfo) -> PBackgroundIDBFactoryChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PBackgroundIDBFactoryChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPBackgroundIDBFactoryChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PBackgroundIDBFactoryConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, loggingInfo);
    // Sentinel = 'loggingInfo'
    (msg__)->WriteSentinel(452658292);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundIDBFactoryConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PBackgroundIDBFactoryChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PBackgroundIDBFactoryMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPBackgroundIndexedDBUtilsConstructor() -> PBackgroundIndexedDBUtilsChild*
{
    PBackgroundIndexedDBUtilsChild* actor = (this)->AllocPBackgroundIndexedDBUtilsChild();
    return SendPBackgroundIndexedDBUtilsConstructor(actor);
}

auto PBackgroundChild::SendPBackgroundIndexedDBUtilsConstructor(PBackgroundIndexedDBUtilsChild* actor) -> PBackgroundIndexedDBUtilsChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PBackgroundIndexedDBUtilsChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPBackgroundIndexedDBUtilsChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PBackgroundIndexedDBUtilsConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundIndexedDBUtilsConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PBackgroundIndexedDBUtilsChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PBackgroundIndexedDBUtilsMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendFlushPendingFileDeletions() -> bool
{
    IPC::Message* msg__ = PBackground::Msg_FlushPendingFileDeletions(MSG_ROUTING_CONTROL);





    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_FlushPendingFileDeletions", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PBackgroundChild::SendPBackgroundSDBConnectionConstructor(
        const PersistenceType& persistenceType,
        const PrincipalInfo& principalInfo) -> PBackgroundSDBConnectionChild*
{
    PBackgroundSDBConnectionChild* actor = (this)->AllocPBackgroundSDBConnectionChild(persistenceType, principalInfo);
    return SendPBackgroundSDBConnectionConstructor(actor, persistenceType, principalInfo);
}

auto PBackgroundChild::SendPBackgroundSDBConnectionConstructor(
        PBackgroundSDBConnectionChild* actor,
        const PersistenceType& persistenceType,
        const PrincipalInfo& principalInfo) -> PBackgroundSDBConnectionChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PBackgroundSDBConnectionChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPBackgroundSDBConnectionChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PBackgroundSDBConnectionConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, persistenceType);
    // Sentinel = 'persistenceType'
    (msg__)->WriteSentinel(853345864);
    WriteIPDLParam(msg__, this, principalInfo);
    // Sentinel = 'principalInfo'
    (msg__)->WriteSentinel(633472335);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundSDBConnectionConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PBackgroundSDBConnectionChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PBackgroundSDBConnectionMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPBackgroundLSDatabaseConstructor(
        const PrincipalInfo& principalInfo,
        const uint32_t& privateBrowsingId,
        const uint64_t& datastoreId) -> PBackgroundLSDatabaseChild*
{
    PBackgroundLSDatabaseChild* actor = (this)->AllocPBackgroundLSDatabaseChild(principalInfo, privateBrowsingId, datastoreId);
    return SendPBackgroundLSDatabaseConstructor(actor, principalInfo, privateBrowsingId, datastoreId);
}

auto PBackgroundChild::SendPBackgroundLSDatabaseConstructor(
        PBackgroundLSDatabaseChild* actor,
        const PrincipalInfo& principalInfo,
        const uint32_t& privateBrowsingId,
        const uint64_t& datastoreId) -> PBackgroundLSDatabaseChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PBackgroundLSDatabaseChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPBackgroundLSDatabaseChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PBackgroundLSDatabaseConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, principalInfo);
    // Sentinel = 'principalInfo'
    (msg__)->WriteSentinel(633472335);
    WriteIPDLParam(msg__, this, privateBrowsingId);
    // Sentinel = 'privateBrowsingId'
    (msg__)->WriteSentinel(1071711988);
    WriteIPDLParam(msg__, this, datastoreId);
    // Sentinel = 'datastoreId'
    (msg__)->WriteSentinel(456262773);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundLSDatabaseConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PBackgroundLSDatabaseChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PBackgroundLSDatabaseMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPBackgroundLSObserverConstructor(const uint64_t& observerId) -> PBackgroundLSObserverChild*
{
    PBackgroundLSObserverChild* actor = (this)->AllocPBackgroundLSObserverChild(observerId);
    return SendPBackgroundLSObserverConstructor(actor, observerId);
}

auto PBackgroundChild::SendPBackgroundLSObserverConstructor(
        PBackgroundLSObserverChild* actor,
        const uint64_t& observerId) -> PBackgroundLSObserverChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PBackgroundLSObserverChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPBackgroundLSObserverChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PBackgroundLSObserverConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, observerId);
    // Sentinel = 'observerId'
    (msg__)->WriteSentinel(386335766);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundLSObserverConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PBackgroundLSObserverChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PBackgroundLSObserverMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPBackgroundLSRequestConstructor(const LSRequestParams& params) -> PBackgroundLSRequestChild*
{
    PBackgroundLSRequestChild* actor = (this)->AllocPBackgroundLSRequestChild(params);
    return SendPBackgroundLSRequestConstructor(actor, params);
}

auto PBackgroundChild::SendPBackgroundLSRequestConstructor(
        PBackgroundLSRequestChild* actor,
        const LSRequestParams& params) -> PBackgroundLSRequestChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PBackgroundLSRequestChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPBackgroundLSRequestChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PBackgroundLSRequestConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, params);
    // Sentinel = 'params'
    (msg__)->WriteSentinel(146997893);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundLSRequestConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PBackgroundLSRequestChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PBackgroundLSRequestMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPBackgroundLSSimpleRequestConstructor(const LSSimpleRequestParams& params) -> PBackgroundLSSimpleRequestChild*
{
    PBackgroundLSSimpleRequestChild* actor = (this)->AllocPBackgroundLSSimpleRequestChild(params);
    return SendPBackgroundLSSimpleRequestConstructor(actor, params);
}

auto PBackgroundChild::SendPBackgroundLSSimpleRequestConstructor(
        PBackgroundLSSimpleRequestChild* actor,
        const LSSimpleRequestParams& params) -> PBackgroundLSSimpleRequestChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PBackgroundLSSimpleRequestChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPBackgroundLSSimpleRequestChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PBackgroundLSSimpleRequestConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, params);
    // Sentinel = 'params'
    (msg__)->WriteSentinel(146997893);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundLSSimpleRequestConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PBackgroundLSSimpleRequestChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PBackgroundLSSimpleRequestMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendLSClearPrivateBrowsing() -> bool
{
    IPC::Message* msg__ = PBackground::Msg_LSClearPrivateBrowsing(MSG_ROUTING_CONTROL);





    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_LSClearPrivateBrowsing", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PBackgroundChild::SendPBackgroundLocalStorageCacheConstructor(
        const PrincipalInfo& principalInfo,
        const nsCString& originKey,
        const uint32_t& privateBrowsingId) -> PBackgroundLocalStorageCacheChild*
{
    PBackgroundLocalStorageCacheChild* actor = (this)->AllocPBackgroundLocalStorageCacheChild(principalInfo, originKey, privateBrowsingId);
    return SendPBackgroundLocalStorageCacheConstructor(actor, principalInfo, originKey, privateBrowsingId);
}

auto PBackgroundChild::SendPBackgroundLocalStorageCacheConstructor(
        PBackgroundLocalStorageCacheChild* actor,
        const PrincipalInfo& principalInfo,
        const nsCString& originKey,
        const uint32_t& privateBrowsingId) -> PBackgroundLocalStorageCacheChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PBackgroundLocalStorageCacheChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPBackgroundLocalStorageCacheChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PBackgroundLocalStorageCacheConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, principalInfo);
    // Sentinel = 'principalInfo'
    (msg__)->WriteSentinel(633472335);
    WriteIPDLParam(msg__, this, originKey);
    // Sentinel = 'originKey'
    (msg__)->WriteSentinel(313656242);
    WriteIPDLParam(msg__, this, privateBrowsingId);
    // Sentinel = 'privateBrowsingId'
    (msg__)->WriteSentinel(1071711988);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundLocalStorageCacheConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PBackgroundLocalStorageCacheChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PBackgroundLocalStorageCacheMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPBackgroundSessionStorageManagerConstructor(
        PBackgroundSessionStorageManagerChild* actor,
        const uint64_t& aTopContextId) -> PBackgroundSessionStorageManagerChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PBackgroundSessionStorageManagerChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPBackgroundSessionStorageManagerChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PBackgroundSessionStorageManagerConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, aTopContextId);
    // Sentinel = 'aTopContextId'
    (msg__)->WriteSentinel(600245543);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundSessionStorageManagerConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PBackgroundSessionStorageManagerChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PBackgroundSessionStorageManagerMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPBackgroundStorageConstructor(
        const nsString& profilePath,
        const uint32_t& privateBrowsingId) -> PBackgroundStorageChild*
{
    PBackgroundStorageChild* actor = (this)->AllocPBackgroundStorageChild(profilePath, privateBrowsingId);
    return SendPBackgroundStorageConstructor(actor, profilePath, privateBrowsingId);
}

auto PBackgroundChild::SendPBackgroundStorageConstructor(
        PBackgroundStorageChild* actor,
        const nsString& profilePath,
        const uint32_t& privateBrowsingId) -> PBackgroundStorageChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PBackgroundStorageChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPBackgroundStorageChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PBackgroundStorageConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, profilePath);
    // Sentinel = 'profilePath'
    (msg__)->WriteSentinel(460915839);
    WriteIPDLParam(msg__, this, privateBrowsingId);
    // Sentinel = 'privateBrowsingId'
    (msg__)->WriteSentinel(1071711988);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PBackgroundStorageConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PBackgroundStorageChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PBackgroundStorageMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPVsyncConstructor() -> PVsyncChild*
{
    PVsyncChild* actor = (this)->AllocPVsyncChild();
    return SendPVsyncConstructor(actor);
}

auto PBackgroundChild::SendPVsyncConstructor(PVsyncChild* actor) -> PVsyncChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PVsyncChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPVsyncChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PVsyncConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PVsyncConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PVsyncChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PVsyncMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPCamerasConstructor() -> PCamerasChild*
{
    PCamerasChild* actor = (this)->AllocPCamerasChild();
    return SendPCamerasConstructor(actor);
}

auto PBackgroundChild::SendPCamerasConstructor(PCamerasChild* actor) -> PCamerasChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PCamerasChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPCamerasChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PCamerasConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PCamerasConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PCamerasChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PCamerasMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPUDPSocketConstructor(
        const mozilla::Maybe<PrincipalInfo>& pInfo,
        const nsCString& filter) -> PUDPSocketChild*
{
    PUDPSocketChild* actor = (this)->AllocPUDPSocketChild(pInfo, filter);
    return SendPUDPSocketConstructor(actor, pInfo, filter);
}

auto PBackgroundChild::SendPUDPSocketConstructor(
        PUDPSocketChild* actor,
        const mozilla::Maybe<PrincipalInfo>& pInfo,
        const nsCString& filter) -> PUDPSocketChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PUDPSocketChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPUDPSocketChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PUDPSocketConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, pInfo);
    // Sentinel = 'pInfo'
    (msg__)->WriteSentinel(98435581);
    WriteIPDLParam(msg__, this, filter);
    // Sentinel = 'filter'
    (msg__)->WriteSentinel(146735751);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PUDPSocketConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PUDPSocketChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PUDPSocketMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPBroadcastChannelConstructor(
        const PrincipalInfo& pInfo,
        const nsCString& origin,
        const nsString& channel) -> PBroadcastChannelChild*
{
    PBroadcastChannelChild* actor = (this)->AllocPBroadcastChannelChild(pInfo, origin, channel);
    return SendPBroadcastChannelConstructor(actor, pInfo, origin, channel);
}

auto PBackgroundChild::SendPBroadcastChannelConstructor(
        PBroadcastChannelChild* actor,
        const PrincipalInfo& pInfo,
        const nsCString& origin,
        const nsString& channel) -> PBroadcastChannelChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PBroadcastChannelChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPBroadcastChannelChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PBroadcastChannelConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, pInfo);
    // Sentinel = 'pInfo'
    (msg__)->WriteSentinel(98435581);
    WriteIPDLParam(msg__, this, origin);
    // Sentinel = 'origin'
    (msg__)->WriteSentinel(150143625);
    WriteIPDLParam(msg__, this, channel);
    // Sentinel = 'channel'
    (msg__)->WriteSentinel(189334234);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PBroadcastChannelConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PBroadcastChannelChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PBroadcastChannelMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPServiceWorkerManagerConstructor() -> PServiceWorkerManagerChild*
{
    PServiceWorkerManagerChild* actor = (this)->AllocPServiceWorkerManagerChild();
    return SendPServiceWorkerManagerConstructor(actor);
}

auto PBackgroundChild::SendPServiceWorkerManagerConstructor(PServiceWorkerManagerChild* actor) -> PServiceWorkerManagerChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PServiceWorkerManagerChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPServiceWorkerManagerChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PServiceWorkerManagerConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PServiceWorkerManagerConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PServiceWorkerManagerChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PServiceWorkerManagerMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendShutdownServiceWorkerRegistrar() -> bool
{
    IPC::Message* msg__ = PBackground::Msg_ShutdownServiceWorkerRegistrar(MSG_ROUTING_CONTROL);





    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_ShutdownServiceWorkerRegistrar", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PBackgroundChild::SendPCacheStorageConstructor(
        const Namespace& aNamespace,
        const PrincipalInfo& aPrincipalInfo) -> PCacheStorageChild*
{
    PCacheStorageChild* actor = (this)->AllocPCacheStorageChild(aNamespace, aPrincipalInfo);
    return SendPCacheStorageConstructor(actor, aNamespace, aPrincipalInfo);
}

auto PBackgroundChild::SendPCacheStorageConstructor(
        PCacheStorageChild* actor,
        const Namespace& aNamespace,
        const PrincipalInfo& aPrincipalInfo) -> PCacheStorageChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PCacheStorageChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPCacheStorageChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PCacheStorageConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, aNamespace);
    // Sentinel = 'aNamespace'
    (msg__)->WriteSentinel(356516847);
    WriteIPDLParam(msg__, this, aPrincipalInfo);
    // Sentinel = 'aPrincipalInfo'
    (msg__)->WriteSentinel(695272848);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PCacheStorageConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PCacheStorageChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PCacheStorageMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPMessagePortConstructor(
        const nsID& uuid,
        const nsID& destinationUuid,
        const uint32_t& sequenceId) -> PMessagePortChild*
{
    PMessagePortChild* actor = (this)->AllocPMessagePortChild(uuid, destinationUuid, sequenceId);
    return SendPMessagePortConstructor(actor, uuid, destinationUuid, sequenceId);
}

auto PBackgroundChild::SendPMessagePortConstructor(
        PMessagePortChild* actor,
        const nsID& uuid,
        const nsID& destinationUuid,
        const uint32_t& sequenceId) -> PMessagePortChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PMessagePortChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPMessagePortChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PMessagePortConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, uuid);
    // Sentinel = 'uuid'
    (msg__)->WriteSentinel(74252728);
    WriteIPDLParam(msg__, this, destinationUuid);
    // Sentinel = 'destinationUuid'
    (msg__)->WriteSentinel(840435258);
    WriteIPDLParam(msg__, this, sequenceId);
    // Sentinel = 'sequenceId'
    (msg__)->WriteSentinel(386204679);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PMessagePortConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PMessagePortChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PMessagePortMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPChildToParentStreamConstructor() -> PChildToParentStreamChild*
{
    PChildToParentStreamChild* actor = (this)->AllocPChildToParentStreamChild();
    return SendPChildToParentStreamConstructor(actor);
}

auto PBackgroundChild::SendPChildToParentStreamConstructor(PChildToParentStreamChild* actor) -> PChildToParentStreamChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PChildToParentStreamChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPChildToParentStreamChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PChildToParentStreamConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PChildToParentStreamConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PChildToParentStreamChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PChildToParentStreamMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendMessagePortForceClose(
        const nsID& uuid,
        const nsID& destinationUuid,
        const uint32_t& sequenceId) -> bool
{
    IPC::Message* msg__ = PBackground::Msg_MessagePortForceClose(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, uuid);
    // Sentinel = 'uuid'
    (msg__)->WriteSentinel(74252728);
    WriteIPDLParam(msg__, this, destinationUuid);
    // Sentinel = 'destinationUuid'
    (msg__)->WriteSentinel(840435258);
    WriteIPDLParam(msg__, this, sequenceId);
    // Sentinel = 'sequenceId'
    (msg__)->WriteSentinel(386204679);




    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_MessagePortForceClose", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PBackgroundChild::SendPQuotaConstructor() -> PQuotaChild*
{
    PQuotaChild* actor = (this)->AllocPQuotaChild();
    return SendPQuotaConstructor(actor);
}

auto PBackgroundChild::SendPQuotaConstructor(PQuotaChild* actor) -> PQuotaChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PQuotaChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPQuotaChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PQuotaConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PQuotaConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PQuotaChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PQuotaMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendShutdownQuotaManager() -> bool
{
    IPC::Message* msg__ = PBackground::Msg_ShutdownQuotaManager(MSG_ROUTING_CONTROL);





    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_ShutdownQuotaManager", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PBackgroundChild::SendShutdownBackgroundSessionStorageManagers() -> bool
{
    IPC::Message* msg__ = PBackground::Msg_ShutdownBackgroundSessionStorageManagers(MSG_ROUTING_CONTROL);





    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_ShutdownBackgroundSessionStorageManagers", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PBackgroundChild::SendPropagateBackgroundSessionStorageManager(
        const uint64_t& currentTopContextId,
        const uint64_t& targetTopContextId) -> bool
{
    IPC::Message* msg__ = PBackground::Msg_PropagateBackgroundSessionStorageManager(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, currentTopContextId);
    // Sentinel = 'currentTopContextId'
    (msg__)->WriteSentinel(1324877769);
    WriteIPDLParam(msg__, this, targetTopContextId);
    // Sentinel = 'targetTopContextId'
    (msg__)->WriteSentinel(1175127885);




    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PropagateBackgroundSessionStorageManager", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PBackgroundChild::SendRemoveBackgroundSessionStorageManager(const uint64_t& topContextId) -> bool
{
    IPC::Message* msg__ = PBackground::Msg_RemoveBackgroundSessionStorageManager(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, topContextId);
    // Sentinel = 'topContextId'
    (msg__)->WriteSentinel(542704870);




    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_RemoveBackgroundSessionStorageManager", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PBackgroundChild::SendPFileSystemRequestConstructor(
        PFileSystemRequestChild* actor,
        const FileSystemParams& params) -> PFileSystemRequestChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PFileSystemRequestChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPFileSystemRequestChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PFileSystemRequestConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, params);
    // Sentinel = 'params'
    (msg__)->WriteSentinel(146997893);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PFileSystemRequestConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PFileSystemRequestChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PFileSystemRequestMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPGamepadEventChannelConstructor(PGamepadEventChannelChild* actor) -> PGamepadEventChannelChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PGamepadEventChannelChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPGamepadEventChannelChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PGamepadEventChannelConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PGamepadEventChannelConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PGamepadEventChannelChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PGamepadEventChannelMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPGamepadTestChannelConstructor(PGamepadTestChannelChild* actor) -> PGamepadTestChannelChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PGamepadTestChannelChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPGamepadTestChannelChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PGamepadTestChannelConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PGamepadTestChannelConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PGamepadTestChannelChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PGamepadTestChannelMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPHttpBackgroundChannelConstructor(
        PHttpBackgroundChannelChild* actor,
        const uint64_t& channelId) -> PHttpBackgroundChannelChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PHttpBackgroundChannelChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPHttpBackgroundChannelChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PHttpBackgroundChannelConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, channelId);
    // Sentinel = 'channelId'
    (msg__)->WriteSentinel(301138823);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PHttpBackgroundChannelConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PHttpBackgroundChannelChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PHttpBackgroundChannelMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPWebAuthnTransactionConstructor() -> PWebAuthnTransactionChild*
{
    PWebAuthnTransactionChild* actor = (this)->AllocPWebAuthnTransactionChild();
    return SendPWebAuthnTransactionConstructor(actor);
}

auto PBackgroundChild::SendPWebAuthnTransactionConstructor(PWebAuthnTransactionChild* actor) -> PWebAuthnTransactionChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PWebAuthnTransactionChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPWebAuthnTransactionChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PWebAuthnTransactionConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PWebAuthnTransactionConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PWebAuthnTransactionChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PWebAuthnTransactionMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPSharedWorkerConstructor(
        const RemoteWorkerData& data,
        const uint64_t& windowID,
        const MessagePortIdentifier& portIdentifier) -> PSharedWorkerChild*
{
    PSharedWorkerChild* actor = (this)->AllocPSharedWorkerChild(data, windowID, portIdentifier);
    return SendPSharedWorkerConstructor(actor, data, windowID, portIdentifier);
}

auto PBackgroundChild::SendPSharedWorkerConstructor(
        PSharedWorkerChild* actor,
        const RemoteWorkerData& data,
        const uint64_t& windowID,
        const MessagePortIdentifier& portIdentifier) -> PSharedWorkerChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PSharedWorkerChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPSharedWorkerChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PSharedWorkerConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, data);
    // Sentinel = 'data'
    (msg__)->WriteSentinel(67109275);
    WriteIPDLParam(msg__, this, windowID);
    // Sentinel = 'windowID'
    (msg__)->WriteSentinel(253625126);
    WriteIPDLParam(msg__, this, portIdentifier);
    // Sentinel = 'portIdentifier'
    (msg__)->WriteSentinel(729875913);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PSharedWorkerConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PSharedWorkerChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PSharedWorkerMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPTemporaryIPCBlobConstructor() -> PTemporaryIPCBlobChild*
{
    PTemporaryIPCBlobChild* actor = (this)->AllocPTemporaryIPCBlobChild();
    return SendPTemporaryIPCBlobConstructor(actor);
}

auto PBackgroundChild::SendPTemporaryIPCBlobConstructor(PTemporaryIPCBlobChild* actor) -> PTemporaryIPCBlobChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PTemporaryIPCBlobChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPTemporaryIPCBlobChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PTemporaryIPCBlobConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PTemporaryIPCBlobConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PTemporaryIPCBlobChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PTemporaryIPCBlobMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPFileCreatorConstructor(
        const nsString& aFullPath,
        const nsString& aType,
        const nsString& aName,
        const mozilla::Maybe<int64_t>& lastModified,
        const bool& aExistenceCheck,
        const bool& aIsFromNsIFile) -> PFileCreatorChild*
{
    PFileCreatorChild* actor = (this)->AllocPFileCreatorChild(aFullPath, aType, aName, lastModified, aExistenceCheck, aIsFromNsIFile);
    return SendPFileCreatorConstructor(actor, aFullPath, aType, aName, lastModified, aExistenceCheck, aIsFromNsIFile);
}

auto PBackgroundChild::SendPFileCreatorConstructor(
        PFileCreatorChild* actor,
        const nsString& aFullPath,
        const nsString& aType,
        const nsString& aName,
        const mozilla::Maybe<int64_t>& lastModified,
        const bool& aExistenceCheck,
        const bool& aIsFromNsIFile) -> PFileCreatorChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PFileCreatorChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPFileCreatorChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PFileCreatorConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, aFullPath);
    // Sentinel = 'aFullPath'
    (msg__)->WriteSentinel(288097154);
    WriteIPDLParam(msg__, this, aType);
    // Sentinel = 'aType'
    (msg__)->WriteSentinel(99222020);
    WriteIPDLParam(msg__, this, aName);
    // Sentinel = 'aName'
    (msg__)->WriteSentinel(92537315);
    WriteIPDLParam(msg__, this, lastModified);
    // Sentinel = 'lastModified'
    (msg__)->WriteSentinel(531629270);
    WriteIPDLParam(msg__, this, aExistenceCheck);
    // Sentinel = 'aExistenceCheck'
    (msg__)->WriteSentinel(794822120);
    WriteIPDLParam(msg__, this, aIsFromNsIFile);
    // Sentinel = 'aIsFromNsIFile'
    (msg__)->WriteSentinel(655033660);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PFileCreatorConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PFileCreatorChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PFileCreatorMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPClientManagerConstructor() -> PClientManagerChild*
{
    PClientManagerChild* actor = (this)->AllocPClientManagerChild();
    return SendPClientManagerConstructor(actor);
}

auto PBackgroundChild::SendPClientManagerConstructor(PClientManagerChild* actor) -> PClientManagerChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PClientManagerChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPClientManagerChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PClientManagerConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PClientManagerConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PClientManagerChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PClientManagerMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPMIDIManagerConstructor() -> PMIDIManagerChild*
{
    PMIDIManagerChild* actor = (this)->AllocPMIDIManagerChild();
    return SendPMIDIManagerConstructor(actor);
}

auto PBackgroundChild::SendPMIDIManagerConstructor(PMIDIManagerChild* actor) -> PMIDIManagerChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PMIDIManagerChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPMIDIManagerChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PMIDIManagerConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PMIDIManagerConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PMIDIManagerChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PMIDIManagerMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPMIDIPortConstructor(
        const MIDIPortInfo& portInfo,
        const bool& sysexEnabled) -> PMIDIPortChild*
{
    PMIDIPortChild* actor = (this)->AllocPMIDIPortChild(portInfo, sysexEnabled);
    return SendPMIDIPortConstructor(actor, portInfo, sysexEnabled);
}

auto PBackgroundChild::SendPMIDIPortConstructor(
        PMIDIPortChild* actor,
        const MIDIPortInfo& portInfo,
        const bool& sysexEnabled) -> PMIDIPortChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PMIDIPortChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPMIDIPortChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PMIDIPortConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, portInfo);
    // Sentinel = 'portInfo'
    (msg__)->WriteSentinel(254411602);
    WriteIPDLParam(msg__, this, sysexEnabled);
    // Sentinel = 'sysexEnabled'
    (msg__)->WriteSentinel(549717224);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PMIDIPortConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PMIDIPortChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PMIDIPortMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendStorageActivity(const PrincipalInfo& principalInfo) -> bool
{
    IPC::Message* msg__ = PBackground::Msg_StorageActivity(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, principalInfo);
    // Sentinel = 'principalInfo'
    (msg__)->WriteSentinel(633472335);




    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_StorageActivity", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PBackgroundChild::SendPServiceWorkerConstructor(
        PServiceWorkerChild* actor,
        const IPCServiceWorkerDescriptor& aDescriptor) -> PServiceWorkerChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PServiceWorkerChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPServiceWorkerChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PServiceWorkerConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, aDescriptor);
    // Sentinel = 'aDescriptor'
    (msg__)->WriteSentinel(433915009);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PServiceWorkerConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PServiceWorkerChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PServiceWorkerMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPRemoteWorkerControllerConstructor(const RemoteWorkerData& aData) -> PRemoteWorkerControllerChild*
{
    PRemoteWorkerControllerChild* actor = (this)->AllocPRemoteWorkerControllerChild(aData);
    return SendPRemoteWorkerControllerConstructor(actor, aData);
}

auto PBackgroundChild::SendPRemoteWorkerControllerConstructor(
        PRemoteWorkerControllerChild* actor,
        const RemoteWorkerData& aData) -> PRemoteWorkerControllerChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PRemoteWorkerControllerChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPRemoteWorkerControllerChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PRemoteWorkerControllerConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, aData);
    // Sentinel = 'aData'
    (msg__)->WriteSentinel(90571228);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PRemoteWorkerControllerConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PRemoteWorkerControllerChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PRemoteWorkerControllerMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPRemoteWorkerServiceConstructor() -> PRemoteWorkerServiceChild*
{
    PRemoteWorkerServiceChild* actor = (this)->AllocPRemoteWorkerServiceChild();
    return SendPRemoteWorkerServiceConstructor(actor);
}

auto PBackgroundChild::SendPRemoteWorkerServiceConstructor(PRemoteWorkerServiceChild* actor) -> PRemoteWorkerServiceChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PRemoteWorkerServiceChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPRemoteWorkerServiceChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PRemoteWorkerServiceConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PRemoteWorkerServiceConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PRemoteWorkerServiceChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PRemoteWorkerServiceMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPServiceWorkerContainerConstructor(PServiceWorkerContainerChild* actor) -> PServiceWorkerContainerChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PServiceWorkerContainerChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPServiceWorkerContainerChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PServiceWorkerContainerConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PServiceWorkerContainerConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PServiceWorkerContainerChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PServiceWorkerContainerMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPServiceWorkerRegistrationConstructor(
        PServiceWorkerRegistrationChild* actor,
        const IPCServiceWorkerRegistrationDescriptor& aDescriptor) -> PServiceWorkerRegistrationChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PServiceWorkerRegistrationChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPServiceWorkerRegistrationChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PServiceWorkerRegistrationConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, aDescriptor);
    // Sentinel = 'aDescriptor'
    (msg__)->WriteSentinel(433915009);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PServiceWorkerRegistrationConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PServiceWorkerRegistrationChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PServiceWorkerRegistrationMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPEndpointForReportConstructor(
        const nsString& aGroupName,
        const PrincipalInfo& aPrincipalInfo) -> PEndpointForReportChild*
{
    PEndpointForReportChild* actor = (this)->AllocPEndpointForReportChild(aGroupName, aPrincipalInfo);
    return SendPEndpointForReportConstructor(actor, aGroupName, aPrincipalInfo);
}

auto PBackgroundChild::SendPEndpointForReportConstructor(
        PEndpointForReportChild* actor,
        const nsString& aGroupName,
        const PrincipalInfo& aPrincipalInfo) -> PEndpointForReportChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PEndpointForReportChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPEndpointForReportChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PEndpointForReportConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, aGroupName);
    // Sentinel = 'aGroupName'
    (msg__)->WriteSentinel(359924720);
    WriteIPDLParam(msg__, this, aPrincipalInfo);
    // Sentinel = 'aPrincipalInfo'
    (msg__)->WriteSentinel(695272848);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PEndpointForReportConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PEndpointForReportChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PEndpointForReportMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendRemoveEndpoint(
        const nsString& aGroupName,
        const nsCString& aEndpointURL,
        const PrincipalInfo& aPrincipalInfo) -> bool
{
    IPC::Message* msg__ = PBackground::Msg_RemoveEndpoint(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, aGroupName);
    // Sentinel = 'aGroupName'
    (msg__)->WriteSentinel(359924720);
    WriteIPDLParam(msg__, this, aEndpointURL);
    // Sentinel = 'aEndpointURL'
    (msg__)->WriteSentinel(507708566);
    WriteIPDLParam(msg__, this, aPrincipalInfo);
    // Sentinel = 'aPrincipalInfo'
    (msg__)->WriteSentinel(695272848);




    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_RemoveEndpoint", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PBackgroundChild::SendPIdleSchedulerConstructor(PIdleSchedulerChild* actor) -> PIdleSchedulerChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PIdleSchedulerChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPIdleSchedulerChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PIdleSchedulerConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PIdleSchedulerConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PIdleSchedulerChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PIdleSchedulerMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPMediaTransportConstructor() -> PMediaTransportChild*
{
    PMediaTransportChild* actor = (this)->AllocPMediaTransportChild();
    return SendPMediaTransportConstructor(actor);
}

auto PBackgroundChild::SendPMediaTransportConstructor(PMediaTransportChild* actor) -> PMediaTransportChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PMediaTransportChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPMediaTransportChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PMediaTransportConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PMediaTransportConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PMediaTransportChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PMediaTransportMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPVerifySSLServerCertConstructor(
        PVerifySSLServerCertChild* actor,
        const ByteArray& aServerCert,
        const nsTArray<ByteArray>& aPeerCertChain,
        const nsCString& aHostName,
        const int32_t& aPort,
        const OriginAttributes& aOriginAttributes,
        const mozilla::Maybe<ByteArray>& aStapledOCSPResponse,
        const mozilla::Maybe<ByteArray>& aSctsFromTLSExtension,
        const mozilla::Maybe<DelegatedCredentialInfoArg>& aDcInfo,
        const uint32_t& aProviderFlags,
        const uint32_t& aCertVerifierFlags) -> PVerifySSLServerCertChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PVerifySSLServerCertChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPVerifySSLServerCertChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PVerifySSLServerCertConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, aServerCert);
    // Sentinel = 'aServerCert'
    (msg__)->WriteSentinel(435553383);
    WriteIPDLParam(msg__, this, aPeerCertChain);
    // Sentinel = 'aPeerCertChain'
    (msg__)->WriteSentinel(664667487);
    WriteIPDLParam(msg__, this, aHostName);
    // Sentinel = 'aHostName'
    (msg__)->WriteSentinel(290128769);
    WriteIPDLParam(msg__, this, aPort);
    // Sentinel = 'aPort'
    (msg__)->WriteSentinel(97452551);
    WriteIPDLParam(msg__, this, aOriginAttributes);
    // Sentinel = 'aOriginAttributes'
    (msg__)->WriteSentinel(1021839089);
    WriteIPDLParam(msg__, this, aStapledOCSPResponse);
    // Sentinel = 'aStapledOCSPResponse'
    (msg__)->WriteSentinel(1333856179);
    WriteIPDLParam(msg__, this, aSctsFromTLSExtension);
    // Sentinel = 'aSctsFromTLSExtension'
    (msg__)->WriteSentinel(1492453443);
    WriteIPDLParam(msg__, this, aDcInfo);
    // Sentinel = 'aDcInfo'
    (msg__)->WriteSentinel(165544597);
    WriteIPDLParam(msg__, this, aProviderFlags);
    // Sentinel = 'aProviderFlags'
    (msg__)->WriteSentinel(701957530);
    WriteIPDLParam(msg__, this, aCertVerifierFlags);
    // Sentinel = 'aCertVerifierFlags'
    (msg__)->WriteSentinel(1116079897);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PVerifySSLServerCertConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PVerifySSLServerCertChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PVerifySSLServerCertMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendEnsureRDDProcessAndCreateBridge(
        mozilla::ipc::ResolveCallback<Tuple<nsresult, Endpoint<mozilla::PRemoteDecoderManagerChild>>>&& aResolve,
        mozilla::ipc::RejectCallback&& aReject) -> void
{
    IPC::Message* msg__ = PBackground::Msg_EnsureRDDProcessAndCreateBridge(MSG_ROUTING_CONTROL);





    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_EnsureRDDProcessAndCreateBridge", OTHER);

    ChannelSend(msg__, std::move(aResolve), std::move(aReject));
    return;
}

auto PBackgroundChild::SendEnsureRDDProcessAndCreateBridge() -> RefPtr<EnsureRDDProcessAndCreateBridgePromise>
{
    RefPtr<MozPromise<Tuple<nsresult, Endpoint<mozilla::PRemoteDecoderManagerChild>>, ResponseRejectReason, true>::Private> promise__ = new MozPromise<Tuple<nsresult, Endpoint<mozilla::PRemoteDecoderManagerChild>>, ResponseRejectReason, true>::Private(__func__);
    promise__->UseDirectTaskDispatch(__func__);
    SendEnsureRDDProcessAndCreateBridge([promise__](Tuple<nsresult, Endpoint<mozilla::PRemoteDecoderManagerChild>>&& aValue) {
        promise__->Resolve(std::move(aValue), __func__);
    }, [promise__](ResponseRejectReason&& aReason) {
        promise__->Reject(std::move(aReason), __func__);
    });
    return promise__;
}

auto PBackgroundChild::SendPRemoteLazyInputStreamConstructor(
        PRemoteLazyInputStreamChild* actor,
        const nsID& aID,
        const uint64_t& aSize) -> PRemoteLazyInputStreamChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PRemoteLazyInputStreamChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPRemoteLazyInputStreamChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PRemoteLazyInputStreamConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, aID);
    // Sentinel = 'aID'
    (msg__)->WriteSentinel(33292527);
    WriteIPDLParam(msg__, this, aSize);
    // Sentinel = 'aSize'
    (msg__)->WriteSentinel(97124861);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PRemoteLazyInputStreamConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PRemoteLazyInputStreamChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PRemoteLazyInputStreamMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::SendPFileDescriptorSetConstructor(const FileDescriptor& fd) -> PFileDescriptorSetChild*
{
    PFileDescriptorSetChild* actor = (this)->AllocPFileDescriptorSetChild(fd);
    return SendPFileDescriptorSetConstructor(actor, fd);
}

auto PBackgroundChild::SendPFileDescriptorSetConstructor(
        PFileDescriptorSetChild* actor,
        const FileDescriptor& fd) -> PFileDescriptorSetChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PFileDescriptorSetChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPFileDescriptorSetChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PBackground::Msg_PFileDescriptorSetConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, fd);
    // Sentinel = 'fd'
    (msg__)->WriteSentinel(20054219);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PBackgroundChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PBackground::Msg_PFileDescriptorSetConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PFileDescriptorSetChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PFileDescriptorSetMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PBackgroundChild::RemoveManagee(
        int32_t aProtocolId,
        IProtocol* aListener) -> void
{
    switch (aProtocolId) {
    case PBackgroundDataBridgeMsgStart:
{
            PBackgroundDataBridgeChild* actor = static_cast<PBackgroundDataBridgeChild*>(aListener);
            auto& container = mManagedPBackgroundDataBridgeChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundIDBFactoryMsgStart:
{
            PBackgroundIDBFactoryChild* actor = static_cast<PBackgroundIDBFactoryChild*>(aListener);
            auto& container = mManagedPBackgroundIDBFactoryChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundIndexedDBUtilsMsgStart:
{
            PBackgroundIndexedDBUtilsChild* actor = static_cast<PBackgroundIndexedDBUtilsChild*>(aListener);
            auto& container = mManagedPBackgroundIndexedDBUtilsChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundSDBConnectionMsgStart:
{
            PBackgroundSDBConnectionChild* actor = static_cast<PBackgroundSDBConnectionChild*>(aListener);
            auto& container = mManagedPBackgroundSDBConnectionChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundLSDatabaseMsgStart:
{
            PBackgroundLSDatabaseChild* actor = static_cast<PBackgroundLSDatabaseChild*>(aListener);
            auto& container = mManagedPBackgroundLSDatabaseChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundLSObserverMsgStart:
{
            PBackgroundLSObserverChild* actor = static_cast<PBackgroundLSObserverChild*>(aListener);
            auto& container = mManagedPBackgroundLSObserverChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundLSRequestMsgStart:
{
            PBackgroundLSRequestChild* actor = static_cast<PBackgroundLSRequestChild*>(aListener);
            auto& container = mManagedPBackgroundLSRequestChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundLSSimpleRequestMsgStart:
{
            PBackgroundLSSimpleRequestChild* actor = static_cast<PBackgroundLSSimpleRequestChild*>(aListener);
            auto& container = mManagedPBackgroundLSSimpleRequestChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundLocalStorageCacheMsgStart:
{
            PBackgroundLocalStorageCacheChild* actor = static_cast<PBackgroundLocalStorageCacheChild*>(aListener);
            auto& container = mManagedPBackgroundLocalStorageCacheChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundSessionStorageManagerMsgStart:
{
            PBackgroundSessionStorageManagerChild* actor = static_cast<PBackgroundSessionStorageManagerChild*>(aListener);
            auto& container = mManagedPBackgroundSessionStorageManagerChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundStorageMsgStart:
{
            PBackgroundStorageChild* actor = static_cast<PBackgroundStorageChild*>(aListener);
            auto& container = mManagedPBackgroundStorageChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBackgroundTestMsgStart:
{
            PBackgroundTestChild* actor = static_cast<PBackgroundTestChild*>(aListener);
            auto& container = mManagedPBackgroundTestChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PBroadcastChannelMsgStart:
{
            PBroadcastChannelChild* actor = static_cast<PBroadcastChannelChild*>(aListener);
            auto& container = mManagedPBroadcastChannelChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PCacheMsgStart:
{
            PCacheChild* actor = static_cast<PCacheChild*>(aListener);
            auto& container = mManagedPCacheChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PCacheStorageMsgStart:
{
            PCacheStorageChild* actor = static_cast<PCacheStorageChild*>(aListener);
            auto& container = mManagedPCacheStorageChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PCacheStreamControlMsgStart:
{
            PCacheStreamControlChild* actor = static_cast<PCacheStreamControlChild*>(aListener);
            auto& container = mManagedPCacheStreamControlChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PClientManagerMsgStart:
{
            PClientManagerChild* actor = static_cast<PClientManagerChild*>(aListener);
            auto& container = mManagedPClientManagerChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PEndpointForReportMsgStart:
{
            PEndpointForReportChild* actor = static_cast<PEndpointForReportChild*>(aListener);
            auto& container = mManagedPEndpointForReportChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PFileDescriptorSetMsgStart:
{
            PFileDescriptorSetChild* actor = static_cast<PFileDescriptorSetChild*>(aListener);
            auto& container = mManagedPFileDescriptorSetChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PFileSystemRequestMsgStart:
{
            PFileSystemRequestChild* actor = static_cast<PFileSystemRequestChild*>(aListener);
            auto& container = mManagedPFileSystemRequestChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PGamepadEventChannelMsgStart:
{
            PGamepadEventChannelChild* actor = static_cast<PGamepadEventChannelChild*>(aListener);
            auto& container = mManagedPGamepadEventChannelChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PGamepadTestChannelMsgStart:
{
            PGamepadTestChannelChild* actor = static_cast<PGamepadTestChannelChild*>(aListener);
            auto& container = mManagedPGamepadTestChannelChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PHttpBackgroundChannelMsgStart:
{
            PHttpBackgroundChannelChild* actor = static_cast<PHttpBackgroundChannelChild*>(aListener);
            auto& container = mManagedPHttpBackgroundChannelChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PIdleSchedulerMsgStart:
{
            PIdleSchedulerChild* actor = static_cast<PIdleSchedulerChild*>(aListener);
            auto& container = mManagedPIdleSchedulerChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PRemoteLazyInputStreamMsgStart:
{
            PRemoteLazyInputStreamChild* actor = static_cast<PRemoteLazyInputStreamChild*>(aListener);
            auto& container = mManagedPRemoteLazyInputStreamChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PMediaTransportMsgStart:
{
            PMediaTransportChild* actor = static_cast<PMediaTransportChild*>(aListener);
            auto& container = mManagedPMediaTransportChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PRemoteWorkerMsgStart:
{
            PRemoteWorkerChild* actor = static_cast<PRemoteWorkerChild*>(aListener);
            auto& container = mManagedPRemoteWorkerChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PRemoteWorkerControllerMsgStart:
{
            PRemoteWorkerControllerChild* actor = static_cast<PRemoteWorkerControllerChild*>(aListener);
            auto& container = mManagedPRemoteWorkerControllerChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PRemoteWorkerServiceMsgStart:
{
            PRemoteWorkerServiceChild* actor = static_cast<PRemoteWorkerServiceChild*>(aListener);
            auto& container = mManagedPRemoteWorkerServiceChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PSharedWorkerMsgStart:
{
            PSharedWorkerChild* actor = static_cast<PSharedWorkerChild*>(aListener);
            auto& container = mManagedPSharedWorkerChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PTemporaryIPCBlobMsgStart:
{
            PTemporaryIPCBlobChild* actor = static_cast<PTemporaryIPCBlobChild*>(aListener);
            auto& container = mManagedPTemporaryIPCBlobChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PFileCreatorMsgStart:
{
            PFileCreatorChild* actor = static_cast<PFileCreatorChild*>(aListener);
            auto& container = mManagedPFileCreatorChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PMessagePortMsgStart:
{
            PMessagePortChild* actor = static_cast<PMessagePortChild*>(aListener);
            auto& container = mManagedPMessagePortChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PCamerasMsgStart:
{
            PCamerasChild* actor = static_cast<PCamerasChild*>(aListener);
            auto& container = mManagedPCamerasChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PMIDIManagerMsgStart:
{
            PMIDIManagerChild* actor = static_cast<PMIDIManagerChild*>(aListener);
            auto& container = mManagedPMIDIManagerChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PMIDIPortMsgStart:
{
            PMIDIPortChild* actor = static_cast<PMIDIPortChild*>(aListener);
            auto& container = mManagedPMIDIPortChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PQuotaMsgStart:
{
            PQuotaChild* actor = static_cast<PQuotaChild*>(aListener);
            auto& container = mManagedPQuotaChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PChildToParentStreamMsgStart:
{
            PChildToParentStreamChild* actor = static_cast<PChildToParentStreamChild*>(aListener);
            auto& container = mManagedPChildToParentStreamChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PParentToChildStreamMsgStart:
{
            PParentToChildStreamChild* actor = static_cast<PParentToChildStreamChild*>(aListener);
            auto& container = mManagedPParentToChildStreamChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PServiceWorkerMsgStart:
{
            PServiceWorkerChild* actor = static_cast<PServiceWorkerChild*>(aListener);
            auto& container = mManagedPServiceWorkerChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PServiceWorkerContainerMsgStart:
{
            PServiceWorkerContainerChild* actor = static_cast<PServiceWorkerContainerChild*>(aListener);
            auto& container = mManagedPServiceWorkerContainerChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PServiceWorkerManagerMsgStart:
{
            PServiceWorkerManagerChild* actor = static_cast<PServiceWorkerManagerChild*>(aListener);
            auto& container = mManagedPServiceWorkerManagerChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PServiceWorkerRegistrationMsgStart:
{
            PServiceWorkerRegistrationChild* actor = static_cast<PServiceWorkerRegistrationChild*>(aListener);
            auto& container = mManagedPServiceWorkerRegistrationChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PWebAuthnTransactionMsgStart:
{
            PWebAuthnTransactionChild* actor = static_cast<PWebAuthnTransactionChild*>(aListener);
            auto& container = mManagedPWebAuthnTransactionChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PUDPSocketMsgStart:
{
            PUDPSocketChild* actor = static_cast<PUDPSocketChild*>(aListener);
            auto& container = mManagedPUDPSocketChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PVerifySSLServerCertMsgStart:
{
            PVerifySSLServerCertChild* actor = static_cast<PVerifySSLServerCertChild*>(aListener);
            auto& container = mManagedPVerifySSLServerCertChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PVsyncMsgStart:
{
            PVsyncChild* actor = static_cast<PVsyncChild*>(aListener);
            auto& container = mManagedPVsyncChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    default:
FatalError("unreached");
        return;    }
}

auto PBackgroundChild::DeallocManagee(
        int32_t aProtocolId,
        IProtocol* aListener) -> void
{
    switch (aProtocolId) {
    case PBackgroundIndexedDBUtilsMsgStart:
        this->DeallocPBackgroundIndexedDBUtilsChild(static_cast<PBackgroundIndexedDBUtilsChild*>(aListener));
        return;
    case PBackgroundSDBConnectionMsgStart:
        this->DeallocPBackgroundSDBConnectionChild(static_cast<PBackgroundSDBConnectionChild*>(aListener));
        return;
    case PBackgroundLSDatabaseMsgStart:
        this->DeallocPBackgroundLSDatabaseChild(static_cast<PBackgroundLSDatabaseChild*>(aListener));
        return;
    case PBackgroundLSObserverMsgStart:
        this->DeallocPBackgroundLSObserverChild(static_cast<PBackgroundLSObserverChild*>(aListener));
        return;
    case PBackgroundLSRequestMsgStart:
        this->DeallocPBackgroundLSRequestChild(static_cast<PBackgroundLSRequestChild*>(aListener));
        return;
    case PBackgroundLSSimpleRequestMsgStart:
        this->DeallocPBackgroundLSSimpleRequestChild(static_cast<PBackgroundLSSimpleRequestChild*>(aListener));
        return;
    case PBackgroundLocalStorageCacheMsgStart:
        this->DeallocPBackgroundLocalStorageCacheChild(static_cast<PBackgroundLocalStorageCacheChild*>(aListener));
        return;
    case PBackgroundStorageMsgStart:
        this->DeallocPBackgroundStorageChild(static_cast<PBackgroundStorageChild*>(aListener));
        return;
    case PBackgroundTestMsgStart:
        this->DeallocPBackgroundTestChild(static_cast<PBackgroundTestChild*>(aListener));
        return;
    case PBroadcastChannelMsgStart:
        this->DeallocPBroadcastChannelChild(static_cast<PBroadcastChannelChild*>(aListener));
        return;
    case PCacheMsgStart:
        this->DeallocPCacheChild(static_cast<PCacheChild*>(aListener));
        return;
    case PCacheStorageMsgStart:
        this->DeallocPCacheStorageChild(static_cast<PCacheStorageChild*>(aListener));
        return;
    case PClientManagerMsgStart:
        this->DeallocPClientManagerChild(static_cast<PClientManagerChild*>(aListener));
        return;
    case PEndpointForReportMsgStart:
        this->DeallocPEndpointForReportChild(static_cast<PEndpointForReportChild*>(aListener));
        return;
    case PFileDescriptorSetMsgStart:
        this->DeallocPFileDescriptorSetChild(static_cast<PFileDescriptorSetChild*>(aListener));
        return;
    case PMediaTransportMsgStart:
        this->DeallocPMediaTransportChild(static_cast<PMediaTransportChild*>(aListener));
        return;
    case PRemoteWorkerMsgStart:
        this->DeallocPRemoteWorkerChild(static_cast<PRemoteWorkerChild*>(aListener));
        return;
    case PRemoteWorkerControllerMsgStart:
        this->DeallocPRemoteWorkerControllerChild(static_cast<PRemoteWorkerControllerChild*>(aListener));
        return;
    case PRemoteWorkerServiceMsgStart:
        this->DeallocPRemoteWorkerServiceChild(static_cast<PRemoteWorkerServiceChild*>(aListener));
        return;
    case PSharedWorkerMsgStart:
        this->DeallocPSharedWorkerChild(static_cast<PSharedWorkerChild*>(aListener));
        return;
    case PTemporaryIPCBlobMsgStart:
        this->DeallocPTemporaryIPCBlobChild(static_cast<PTemporaryIPCBlobChild*>(aListener));
        return;
    case PFileCreatorMsgStart:
        this->DeallocPFileCreatorChild(static_cast<PFileCreatorChild*>(aListener));
        return;
    case PMessagePortMsgStart:
        this->DeallocPMessagePortChild(static_cast<PMessagePortChild*>(aListener));
        return;
    case PCamerasMsgStart:
        this->DeallocPCamerasChild(static_cast<PCamerasChild*>(aListener));
        return;
    case PMIDIManagerMsgStart:
        this->DeallocPMIDIManagerChild(static_cast<PMIDIManagerChild*>(aListener));
        return;
    case PMIDIPortMsgStart:
        this->DeallocPMIDIPortChild(static_cast<PMIDIPortChild*>(aListener));
        return;
    case PQuotaMsgStart:
        this->DeallocPQuotaChild(static_cast<PQuotaChild*>(aListener));
        return;
    case PChildToParentStreamMsgStart:
        this->DeallocPChildToParentStreamChild(static_cast<PChildToParentStreamChild*>(aListener));
        return;
    case PParentToChildStreamMsgStart:
        this->DeallocPParentToChildStreamChild(static_cast<PParentToChildStreamChild*>(aListener));
        return;
    case PServiceWorkerManagerMsgStart:
        this->DeallocPServiceWorkerManagerChild(static_cast<PServiceWorkerManagerChild*>(aListener));
        return;
    case PWebAuthnTransactionMsgStart:
        this->DeallocPWebAuthnTransactionChild(static_cast<PWebAuthnTransactionChild*>(aListener));
        return;
    case PUDPSocketMsgStart:
        this->DeallocPUDPSocketChild(static_cast<PUDPSocketChild*>(aListener));
        return;
    case PVsyncMsgStart:
        this->DeallocPVsyncChild(static_cast<PVsyncChild*>(aListener));
        return;
    default:
        FatalError("unreached");
        return;
    }
}

auto PBackgroundChild::OnMessageReceived(const Message& msg__) -> PBackgroundChild::Result
{
    int32_t route__ = msg__.routing_id();
    if (MSG_ROUTING_CONTROL != route__) {
        IProtocol* routed__ = Lookup(route__);
        if (!routed__ || !routed__->GetLifecycleProxy()) {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundChild",
                    OtherPid(),
                    "Ignored message for dead actor",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eSending);
            }

            return MsgProcessed;
        }

        RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
            routed__->GetLifecycleProxy();
        return proxy__->Get()->OnMessageReceived(msg__);
    }

    switch (msg__.type()) {
    case PBackground::Reply_PBackgroundTestConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PBackgroundDataBridgeConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PBackgroundIDBFactoryConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PBackgroundIndexedDBUtilsConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PBackgroundSDBConnectionConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PBackgroundLSDatabaseConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PBackgroundLSObserverConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PBackgroundLSRequestConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PBackgroundLSSimpleRequestConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PBackgroundLocalStorageCacheConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PBackgroundSessionStorageManagerConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PBackgroundStorageConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PVsyncConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PCamerasConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PUDPSocketConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PBroadcastChannelConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PServiceWorkerManagerConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PCacheStorageConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PMessagePortConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PChildToParentStreamConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PQuotaConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PFileSystemRequestConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PGamepadEventChannelConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PGamepadTestChannelConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PHttpBackgroundChannelConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PWebAuthnTransactionConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PSharedWorkerConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PTemporaryIPCBlobConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PFileCreatorConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PClientManagerConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PMIDIManagerConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PMIDIPortConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PServiceWorkerConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PRemoteWorkerControllerConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PRemoteWorkerServiceConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PServiceWorkerContainerConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PServiceWorkerRegistrationConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PEndpointForReportConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PIdleSchedulerConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PMediaTransportConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_PVerifySSLServerCertConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Reply_EnsureRDDProcessAndCreateBridge__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_EnsureRDDProcessAndCreateBridge", OTHER);

            PickleIterator iter__{msg__};
            bool resolve__ = false;
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(resolve__)))))) {
                FatalError("Error deserializing 'resolve__'");
                return MsgValueError;
            }
            // Sentinel = 'resolve__'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 322044863)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'resolve__'");
                return MsgValueError;
            }


            UniquePtr<MessageChannel::UntypedCallbackHolder> untypedCallback =
                GetIPCChannel()->PopCallback(msg__);

            typedef MessageChannel::CallbackHolder<Tuple<nsresult, Endpoint<mozilla::PRemoteDecoderManagerChild>>> CallbackHolder;
            auto* callback = static_cast<CallbackHolder*>(untypedCallback.get());
            if (!callback) {
                FatalError("Error unknown callback");
                return MsgProcessingError;
            }

            if (resolve__) {
                nsresult rv{};
                Endpoint<mozilla::PRemoteDecoderManagerChild> aEndpoint{};

                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(rv)))))) {
                    FatalError("Error deserializing 'nsresult'");
                    return MsgValueError;
                }
                // Sentinel = 'rv'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 22806761)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'nsresult'");
                    return MsgValueError;
                }
                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aEndpoint)))))) {
                    FatalError("Error deserializing 'Endpoint<mozilla::PRemoteDecoderManagerChild>'");
                    return MsgValueError;
                }
                // Sentinel = 'aEndpoint'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 292225955)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'Endpoint<mozilla::PRemoteDecoderManagerChild>'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Resolve(MakeTuple(std::move(rv), std::move(aEndpoint)));
            } else {
                ResponseRejectReason reason__{};
                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(reason__)))))) {
                    FatalError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                // Sentinel = 'reason__'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 251855687)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Reject(std::move(reason__));
            }
            return MsgProcessed;
        }
    case PBackground::Msg_PCacheConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PCacheConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PCacheChild* actor = (this)->AllocPCacheChild();
            if (!actor) {
                NS_WARNING("Cannot bind null PCacheChild actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPCacheChild.PutEntry(actor);

            if ((!((this)->RecvPCacheConstructor(std::move(actor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PCacheStreamControlConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PCacheStreamControlConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PCacheStreamControlChild> actor = (this)->AllocPCacheStreamControlChild();
            if (!actor) {
                NS_WARNING("Cannot bind null PCacheStreamControlChild actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPCacheStreamControlChild.PutEntry(actor);

            if ((!((this)->RecvPCacheStreamControlConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PParentToChildStreamConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PParentToChildStreamConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PParentToChildStreamChild* actor = (this)->AllocPParentToChildStreamChild();
            if (!actor) {
                NS_WARNING("Cannot bind null PParentToChildStreamChild actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPParentToChildStreamChild.PutEntry(actor);

            if ((!((this)->RecvPParentToChildStreamConstructor(std::move(actor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Msg_PRemoteWorkerConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PRemoteWorkerConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            RemoteWorkerData data{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(data)))))) {
                FatalError("Error deserializing 'RemoteWorkerData'");
                return MsgValueError;
            }
            // Sentinel = 'data'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 67109275)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'RemoteWorkerData'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PRemoteWorkerChild* actor = (this)->AllocPRemoteWorkerChild(data);
            if (!actor) {
                NS_WARNING("Cannot bind null PRemoteWorkerChild actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPRemoteWorkerChild.PutEntry(actor);

            if ((!((this)->RecvPRemoteWorkerConstructor(std::move(actor), std::move(data))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Reply_PRemoteLazyInputStreamConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Msg_PRemoteLazyInputStreamConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PRemoteLazyInputStreamConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            nsID aID{};
            uint64_t aSize{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aID)))))) {
                FatalError("Error deserializing 'nsID'");
                return MsgValueError;
            }
            // Sentinel = 'aID'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 33292527)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsID'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aSize)))))) {
                FatalError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            // Sentinel = 'aSize'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 97124861)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PRemoteLazyInputStreamChild> actor = (this)->AllocPRemoteLazyInputStreamChild(aID, aSize);
            if (!actor) {
                NS_WARNING("Cannot bind null PRemoteLazyInputStreamChild actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPRemoteLazyInputStreamChild.PutEntry(actor);

            if ((!((this)->RecvPRemoteLazyInputStreamConstructor(actor, std::move(aID), std::move(aSize))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PBackground::Reply_PFileDescriptorSetConstructor__ID:
        {
            return MsgProcessed;
        }
    case PBackground::Msg_PFileDescriptorSetConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PBackground::Msg_PFileDescriptorSetConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            FileDescriptor fd{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(fd)))))) {
                FatalError("Error deserializing 'FileDescriptor'");
                return MsgValueError;
            }
            // Sentinel = 'fd'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 20054219)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'FileDescriptor'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PFileDescriptorSetChild* actor = (this)->AllocPFileDescriptorSetChild(fd);
            if (!actor) {
                NS_WARNING("Cannot bind null PFileDescriptorSetChild actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPFileDescriptorSetChild.PutEntry(actor);

            if ((!((this)->RecvPFileDescriptorSetConstructor(std::move(actor), std::move(fd))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    default:
        return MsgNotKnown;
    case SHMEM_CREATED_MESSAGE_TYPE:
        {
            if (!ShmemCreated(msg__)) {
                return MsgPayloadError;
            }
            return MsgProcessed;
        }
    case SHMEM_DESTROYED_MESSAGE_TYPE:
        {
            if (!ShmemDestroyed(msg__)) {
                return MsgPayloadError;
            }
            return MsgProcessed;
        }
    }
}

auto PBackgroundChild::OnMessageReceived(
        const Message& msg__,
        Message*& reply__) -> PBackgroundChild::Result
{
    int32_t route__ = msg__.routing_id();
    if (MSG_ROUTING_CONTROL != route__) {
        IProtocol* routed__ = Lookup(route__);
        if (!routed__ || !routed__->GetLifecycleProxy()) {
            if (mozilla::ipc::LoggingEnabledFor("PBackgroundChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PBackgroundChild",
                    OtherPid(),
                    "Ignored message for dead actor",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eSending);
            }

            return MsgProcessed;
        }

        RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
            routed__->GetLifecycleProxy();
        return proxy__->Get()->OnMessageReceived(msg__, reply__);
    }

    return MsgNotKnown;
}

auto PBackgroundChild::OnCallReceived(
        const Message& msg__,
        Message*& reply__) -> PBackgroundChild::Result
{
    MOZ_ASSERT_UNREACHABLE("message protocol not supported");
    return MsgNotKnown;
}

auto PBackgroundChild::OnChannelClose() -> void
{
    DestroySubtree(NormalShutdown);
    ClearSubtree();
    DeallocShmems();
    if (GetLifecycleProxy()) {
        GetLifecycleProxy()->Release();
    }
}

auto PBackgroundChild::OnChannelError() -> void
{
    DestroySubtree(AbnormalShutdown);
    ClearSubtree();
    DeallocShmems();
    if (GetLifecycleProxy()) {
        GetLifecycleProxy()->Release();
    }
}

auto PBackgroundChild::ClearSubtree() -> void
{
    for (auto it = mManagedPBackgroundDataBridgeChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundDataBridgeChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundDataBridgeChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundDataBridgeChild.Clear();

    for (auto it = mManagedPBackgroundIDBFactoryChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundIDBFactoryChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundIDBFactoryChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundIDBFactoryChild.Clear();

    for (auto it = mManagedPBackgroundIndexedDBUtilsChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundIndexedDBUtilsChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundIndexedDBUtilsChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundIndexedDBUtilsChild.Clear();

    for (auto it = mManagedPBackgroundSDBConnectionChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundSDBConnectionChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundSDBConnectionChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundSDBConnectionChild.Clear();

    for (auto it = mManagedPBackgroundLSDatabaseChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundLSDatabaseChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundLSDatabaseChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundLSDatabaseChild.Clear();

    for (auto it = mManagedPBackgroundLSObserverChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundLSObserverChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundLSObserverChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundLSObserverChild.Clear();

    for (auto it = mManagedPBackgroundLSRequestChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundLSRequestChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundLSRequestChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundLSRequestChild.Clear();

    for (auto it = mManagedPBackgroundLSSimpleRequestChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundLSSimpleRequestChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundLSSimpleRequestChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundLSSimpleRequestChild.Clear();

    for (auto it = mManagedPBackgroundLocalStorageCacheChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundLocalStorageCacheChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundLocalStorageCacheChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundLocalStorageCacheChild.Clear();

    for (auto it = mManagedPBackgroundSessionStorageManagerChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundSessionStorageManagerChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundSessionStorageManagerChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundSessionStorageManagerChild.Clear();

    for (auto it = mManagedPBackgroundStorageChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundStorageChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundStorageChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundStorageChild.Clear();

    for (auto it = mManagedPBackgroundTestChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBackgroundTestChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBackgroundTestChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBackgroundTestChild.Clear();

    for (auto it = mManagedPBroadcastChannelChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPBroadcastChannelChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPBroadcastChannelChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPBroadcastChannelChild.Clear();

    for (auto it = mManagedPCacheChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPCacheChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPCacheChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPCacheChild.Clear();

    for (auto it = mManagedPCacheStorageChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPCacheStorageChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPCacheStorageChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPCacheStorageChild.Clear();

    for (auto it = mManagedPCacheStreamControlChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPCacheStreamControlChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPCacheStreamControlChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPCacheStreamControlChild.Clear();

    for (auto it = mManagedPClientManagerChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPClientManagerChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPClientManagerChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPClientManagerChild.Clear();

    for (auto it = mManagedPEndpointForReportChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPEndpointForReportChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPEndpointForReportChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPEndpointForReportChild.Clear();

    for (auto it = mManagedPFileDescriptorSetChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPFileDescriptorSetChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPFileDescriptorSetChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPFileDescriptorSetChild.Clear();

    for (auto it = mManagedPFileSystemRequestChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPFileSystemRequestChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPFileSystemRequestChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPFileSystemRequestChild.Clear();

    for (auto it = mManagedPGamepadEventChannelChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPGamepadEventChannelChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPGamepadEventChannelChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPGamepadEventChannelChild.Clear();

    for (auto it = mManagedPGamepadTestChannelChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPGamepadTestChannelChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPGamepadTestChannelChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPGamepadTestChannelChild.Clear();

    for (auto it = mManagedPHttpBackgroundChannelChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPHttpBackgroundChannelChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPHttpBackgroundChannelChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPHttpBackgroundChannelChild.Clear();

    for (auto it = mManagedPIdleSchedulerChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPIdleSchedulerChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPIdleSchedulerChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPIdleSchedulerChild.Clear();

    for (auto it = mManagedPRemoteLazyInputStreamChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPRemoteLazyInputStreamChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPRemoteLazyInputStreamChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPRemoteLazyInputStreamChild.Clear();

    for (auto it = mManagedPMediaTransportChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPMediaTransportChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPMediaTransportChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPMediaTransportChild.Clear();

    for (auto it = mManagedPRemoteWorkerChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPRemoteWorkerChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPRemoteWorkerChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPRemoteWorkerChild.Clear();

    for (auto it = mManagedPRemoteWorkerControllerChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPRemoteWorkerControllerChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPRemoteWorkerControllerChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPRemoteWorkerControllerChild.Clear();

    for (auto it = mManagedPRemoteWorkerServiceChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPRemoteWorkerServiceChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPRemoteWorkerServiceChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPRemoteWorkerServiceChild.Clear();

    for (auto it = mManagedPSharedWorkerChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPSharedWorkerChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPSharedWorkerChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPSharedWorkerChild.Clear();

    for (auto it = mManagedPTemporaryIPCBlobChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPTemporaryIPCBlobChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPTemporaryIPCBlobChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPTemporaryIPCBlobChild.Clear();

    for (auto it = mManagedPFileCreatorChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPFileCreatorChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPFileCreatorChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPFileCreatorChild.Clear();

    for (auto it = mManagedPMessagePortChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPMessagePortChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPMessagePortChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPMessagePortChild.Clear();

    for (auto it = mManagedPCamerasChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPCamerasChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPCamerasChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPCamerasChild.Clear();

    for (auto it = mManagedPMIDIManagerChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPMIDIManagerChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPMIDIManagerChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPMIDIManagerChild.Clear();

    for (auto it = mManagedPMIDIPortChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPMIDIPortChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPMIDIPortChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPMIDIPortChild.Clear();

    for (auto it = mManagedPQuotaChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPQuotaChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPQuotaChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPQuotaChild.Clear();

    for (auto it = mManagedPChildToParentStreamChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPChildToParentStreamChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPChildToParentStreamChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPChildToParentStreamChild.Clear();

    for (auto it = mManagedPParentToChildStreamChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPParentToChildStreamChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPParentToChildStreamChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPParentToChildStreamChild.Clear();

    for (auto it = mManagedPServiceWorkerChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPServiceWorkerChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPServiceWorkerChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPServiceWorkerChild.Clear();

    for (auto it = mManagedPServiceWorkerContainerChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPServiceWorkerContainerChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPServiceWorkerContainerChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPServiceWorkerContainerChild.Clear();

    for (auto it = mManagedPServiceWorkerManagerChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPServiceWorkerManagerChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPServiceWorkerManagerChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPServiceWorkerManagerChild.Clear();

    for (auto it = mManagedPServiceWorkerRegistrationChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPServiceWorkerRegistrationChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPServiceWorkerRegistrationChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPServiceWorkerRegistrationChild.Clear();

    for (auto it = mManagedPWebAuthnTransactionChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPWebAuthnTransactionChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPWebAuthnTransactionChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPWebAuthnTransactionChild.Clear();

    for (auto it = mManagedPUDPSocketChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPUDPSocketChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPUDPSocketChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPUDPSocketChild.Clear();

    for (auto it = mManagedPVerifySSLServerCertChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPVerifySSLServerCertChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPVerifySSLServerCertChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPVerifySSLServerCertChild.Clear();

    for (auto it = mManagedPVsyncChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPVsyncChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPVsyncChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPVsyncChild.Clear();

}



} // namespace ipc
} // namespace mozilla
namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::ipc::PBackgroundChild*>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    int32_t id;
    if (!aVar) {
        id = 0;  // kNullActorId
    } else {
        id = aVar->Id();
        if (id == 1) {  // kFreedActorId
            aVar->FatalError("Actor has been |delete|d");
        }
        MOZ_RELEASE_ASSERT(
            aActor->GetIPCChannel() == aVar->GetIPCChannel(),
            "Actor must be from the same channel as the"
            " actor it's being sent over");
        MOZ_RELEASE_ASSERT(
            aVar->CanSend(),
            "Actor must still be open when sending");
    }

    WriteIPDLParam(aMsg, aActor, id);
}

auto IPDLParamTraits<mozilla::ipc::PBackgroundChild*>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    mozilla::Maybe<mozilla::ipc::IProtocol*> actor =
        aActor->ReadActor(aMsg, aIter, true, "PBackground", PBackgroundMsgStart);
    if (actor.isNothing()) {
        return false;
    }

    *aVar = static_cast<mozilla::ipc::PBackgroundChild*>(actor.value());
    return true;
}

} // namespace ipc
} // namespace mozilla
