//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/ipc/PBackgroundParent.h"
#include "mozilla/ipc/PBackgroundChild.h"
#include "mozilla/dom/PBackgroundLSRequest.h"
#include "mozilla/dom/PBackgroundLSRequestParent.h"
#include "mozilla/dom/PBackgroundLSRequestChild.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace dom {
namespace PBackgroundLSRequest {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::dom::PBackgroundLSRequestParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::dom::PBackgroundLSRequestChild>* aChild)
{
    return mozilla::ipc::CreateEndpoints(
        mozilla::ipc::PrivateIPDLInterface(),
        aParentDestPid, aChildDestPid,
        aParent, aChild);
}
IPC::Message*
Msg_Cancel(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Cancel__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_Finish(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Finish__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg___delete__(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg___delete____ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply___delete__(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply___delete____ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg_Ready(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Ready__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}

} // namespace PBackgroundLSRequest
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct LSRequestPreloadDatastoreResponse|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::LSRequestPreloadDatastoreResponse>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
}

auto IPDLParamTraits<mozilla::dom::LSRequestPreloadDatastoreResponse>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct LSRequestPrepareDatastoreResponse|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::LSRequestPrepareDatastoreResponse>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    (aMsg)->WriteBytes((&((aVar).datastoreId())), 8);
    // Sentinel = 'datastoreId'
    (aMsg)->WriteSentinel(456262773);
}

auto IPDLParamTraits<mozilla::dom::LSRequestPrepareDatastoreResponse>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->datastoreId())), 8)))) {
        aActor->FatalError("Error bulk reading fields from uint64_t");
        return false;
    }
    // Sentinel = 'datastoreId'
    if ((!((aMsg)->ReadSentinel(aIter, 456262773)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint64_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct LSRequestPrepareObserverResponse|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::LSRequestPrepareObserverResponse>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    (aMsg)->WriteBytes((&((aVar).observerId())), 8);
    // Sentinel = 'observerId'
    (aMsg)->WriteSentinel(386335766);
}

auto IPDLParamTraits<mozilla::dom::LSRequestPrepareObserverResponse>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->observerId())), 8)))) {
        aActor->FatalError("Error bulk reading fields from uint64_t");
        return false;
    }
    // Sentinel = 'observerId'
    if ((!((aMsg)->ReadSentinel(aIter, 386335766)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint64_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union LSRequestResponse|
//
namespace mozilla {
namespace dom {
auto LSRequestResponse::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case Tnsresult:
        {
            (ptr_nsresult())->~nsresult__tdef();
            break;
        }
    case TLSRequestPreloadDatastoreResponse:
        {
            (ptr_LSRequestPreloadDatastoreResponse())->~LSRequestPreloadDatastoreResponse__tdef();
            break;
        }
    case TLSRequestPrepareDatastoreResponse:
        {
            (ptr_LSRequestPrepareDatastoreResponse())->~LSRequestPrepareDatastoreResponse__tdef();
            break;
        }
    case TLSRequestPrepareObserverResponse:
        {
            (ptr_LSRequestPrepareObserverResponse())->~LSRequestPrepareObserverResponse__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT LSRequestResponse::LSRequestResponse(const nsresult& aOther)
{
    new (mozilla::KnownNotNull, ptr_nsresult()) nsresult(aOther);
    mType = Tnsresult;
}

MOZ_IMPLICIT LSRequestResponse::LSRequestResponse(nsresult&& aOther)
{
    new (mozilla::KnownNotNull, ptr_nsresult()) nsresult(std::move(aOther));
    mType = Tnsresult;
}

MOZ_IMPLICIT LSRequestResponse::LSRequestResponse(const LSRequestPreloadDatastoreResponse& aOther)
{
    new (mozilla::KnownNotNull, ptr_LSRequestPreloadDatastoreResponse()) LSRequestPreloadDatastoreResponse(aOther);
    mType = TLSRequestPreloadDatastoreResponse;
}

MOZ_IMPLICIT LSRequestResponse::LSRequestResponse(LSRequestPreloadDatastoreResponse&& aOther)
{
    new (mozilla::KnownNotNull, ptr_LSRequestPreloadDatastoreResponse()) LSRequestPreloadDatastoreResponse(std::move(aOther));
    mType = TLSRequestPreloadDatastoreResponse;
}

MOZ_IMPLICIT LSRequestResponse::LSRequestResponse(const LSRequestPrepareDatastoreResponse& aOther)
{
    new (mozilla::KnownNotNull, ptr_LSRequestPrepareDatastoreResponse()) LSRequestPrepareDatastoreResponse(aOther);
    mType = TLSRequestPrepareDatastoreResponse;
}

MOZ_IMPLICIT LSRequestResponse::LSRequestResponse(LSRequestPrepareDatastoreResponse&& aOther)
{
    new (mozilla::KnownNotNull, ptr_LSRequestPrepareDatastoreResponse()) LSRequestPrepareDatastoreResponse(std::move(aOther));
    mType = TLSRequestPrepareDatastoreResponse;
}

MOZ_IMPLICIT LSRequestResponse::LSRequestResponse(const LSRequestPrepareObserverResponse& aOther)
{
    new (mozilla::KnownNotNull, ptr_LSRequestPrepareObserverResponse()) LSRequestPrepareObserverResponse(aOther);
    mType = TLSRequestPrepareObserverResponse;
}

MOZ_IMPLICIT LSRequestResponse::LSRequestResponse(LSRequestPrepareObserverResponse&& aOther)
{
    new (mozilla::KnownNotNull, ptr_LSRequestPrepareObserverResponse()) LSRequestPrepareObserverResponse(std::move(aOther));
    mType = TLSRequestPrepareObserverResponse;
}

MOZ_IMPLICIT LSRequestResponse::LSRequestResponse(const LSRequestResponse& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case Tnsresult:
        {
            new (mozilla::KnownNotNull, ptr_nsresult()) nsresult((aOther).get_nsresult());
            break;
        }
    case TLSRequestPreloadDatastoreResponse:
        {
            new (mozilla::KnownNotNull, ptr_LSRequestPreloadDatastoreResponse()) LSRequestPreloadDatastoreResponse((aOther).get_LSRequestPreloadDatastoreResponse());
            break;
        }
    case TLSRequestPrepareDatastoreResponse:
        {
            new (mozilla::KnownNotNull, ptr_LSRequestPrepareDatastoreResponse()) LSRequestPrepareDatastoreResponse((aOther).get_LSRequestPrepareDatastoreResponse());
            break;
        }
    case TLSRequestPrepareObserverResponse:
        {
            new (mozilla::KnownNotNull, ptr_LSRequestPrepareObserverResponse()) LSRequestPrepareObserverResponse((aOther).get_LSRequestPrepareObserverResponse());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT LSRequestResponse::LSRequestResponse(LSRequestResponse&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case Tnsresult:
        {
            new (mozilla::KnownNotNull, ptr_nsresult()) nsresult(std::move((aOther).get_nsresult()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TLSRequestPreloadDatastoreResponse:
        {
            new (mozilla::KnownNotNull, ptr_LSRequestPreloadDatastoreResponse()) LSRequestPreloadDatastoreResponse(std::move((aOther).get_LSRequestPreloadDatastoreResponse()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TLSRequestPrepareDatastoreResponse:
        {
            new (mozilla::KnownNotNull, ptr_LSRequestPrepareDatastoreResponse()) LSRequestPrepareDatastoreResponse(std::move((aOther).get_LSRequestPrepareDatastoreResponse()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TLSRequestPrepareObserverResponse:
        {
            new (mozilla::KnownNotNull, ptr_LSRequestPrepareObserverResponse()) LSRequestPrepareObserverResponse(std::move((aOther).get_LSRequestPrepareObserverResponse()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

LSRequestResponse::~LSRequestResponse()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto LSRequestResponse::operator=(const nsresult& aRhs) -> LSRequestResponse&
{
    if (MaybeDestroy(Tnsresult)) {
        new (mozilla::KnownNotNull, ptr_nsresult()) nsresult;
    }
    (*(ptr_nsresult())) = aRhs;
    mType = Tnsresult;
    return (*(this));
}

auto LSRequestResponse::operator=(nsresult&& aRhs) -> LSRequestResponse&
{
    if (MaybeDestroy(Tnsresult)) {
        new (mozilla::KnownNotNull, ptr_nsresult()) nsresult;
    }
    (*(ptr_nsresult())) = std::move(aRhs);
    mType = Tnsresult;
    return (*(this));
}

auto LSRequestResponse::operator=(const LSRequestPreloadDatastoreResponse& aRhs) -> LSRequestResponse&
{
    if (MaybeDestroy(TLSRequestPreloadDatastoreResponse)) {
        new (mozilla::KnownNotNull, ptr_LSRequestPreloadDatastoreResponse()) LSRequestPreloadDatastoreResponse;
    }
    (*(ptr_LSRequestPreloadDatastoreResponse())) = aRhs;
    mType = TLSRequestPreloadDatastoreResponse;
    return (*(this));
}

auto LSRequestResponse::operator=(LSRequestPreloadDatastoreResponse&& aRhs) -> LSRequestResponse&
{
    if (MaybeDestroy(TLSRequestPreloadDatastoreResponse)) {
        new (mozilla::KnownNotNull, ptr_LSRequestPreloadDatastoreResponse()) LSRequestPreloadDatastoreResponse;
    }
    (*(ptr_LSRequestPreloadDatastoreResponse())) = std::move(aRhs);
    mType = TLSRequestPreloadDatastoreResponse;
    return (*(this));
}

auto LSRequestResponse::operator=(const LSRequestPrepareDatastoreResponse& aRhs) -> LSRequestResponse&
{
    if (MaybeDestroy(TLSRequestPrepareDatastoreResponse)) {
        new (mozilla::KnownNotNull, ptr_LSRequestPrepareDatastoreResponse()) LSRequestPrepareDatastoreResponse;
    }
    (*(ptr_LSRequestPrepareDatastoreResponse())) = aRhs;
    mType = TLSRequestPrepareDatastoreResponse;
    return (*(this));
}

auto LSRequestResponse::operator=(LSRequestPrepareDatastoreResponse&& aRhs) -> LSRequestResponse&
{
    if (MaybeDestroy(TLSRequestPrepareDatastoreResponse)) {
        new (mozilla::KnownNotNull, ptr_LSRequestPrepareDatastoreResponse()) LSRequestPrepareDatastoreResponse;
    }
    (*(ptr_LSRequestPrepareDatastoreResponse())) = std::move(aRhs);
    mType = TLSRequestPrepareDatastoreResponse;
    return (*(this));
}

auto LSRequestResponse::operator=(const LSRequestPrepareObserverResponse& aRhs) -> LSRequestResponse&
{
    if (MaybeDestroy(TLSRequestPrepareObserverResponse)) {
        new (mozilla::KnownNotNull, ptr_LSRequestPrepareObserverResponse()) LSRequestPrepareObserverResponse;
    }
    (*(ptr_LSRequestPrepareObserverResponse())) = aRhs;
    mType = TLSRequestPrepareObserverResponse;
    return (*(this));
}

auto LSRequestResponse::operator=(LSRequestPrepareObserverResponse&& aRhs) -> LSRequestResponse&
{
    if (MaybeDestroy(TLSRequestPrepareObserverResponse)) {
        new (mozilla::KnownNotNull, ptr_LSRequestPrepareObserverResponse()) LSRequestPrepareObserverResponse;
    }
    (*(ptr_LSRequestPrepareObserverResponse())) = std::move(aRhs);
    mType = TLSRequestPrepareObserverResponse;
    return (*(this));
}

auto LSRequestResponse::operator=(const LSRequestResponse& aRhs) -> LSRequestResponse&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case Tnsresult:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_nsresult()) nsresult;
            }
            (*(ptr_nsresult())) = (aRhs).get_nsresult();
            break;
        }
    case TLSRequestPreloadDatastoreResponse:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_LSRequestPreloadDatastoreResponse()) LSRequestPreloadDatastoreResponse;
            }
            (*(ptr_LSRequestPreloadDatastoreResponse())) = (aRhs).get_LSRequestPreloadDatastoreResponse();
            break;
        }
    case TLSRequestPrepareDatastoreResponse:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_LSRequestPrepareDatastoreResponse()) LSRequestPrepareDatastoreResponse;
            }
            (*(ptr_LSRequestPrepareDatastoreResponse())) = (aRhs).get_LSRequestPrepareDatastoreResponse();
            break;
        }
    case TLSRequestPrepareObserverResponse:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_LSRequestPrepareObserverResponse()) LSRequestPrepareObserverResponse;
            }
            (*(ptr_LSRequestPrepareObserverResponse())) = (aRhs).get_LSRequestPrepareObserverResponse();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto LSRequestResponse::operator=(LSRequestResponse&& aRhs) -> LSRequestResponse&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case Tnsresult:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_nsresult()) nsresult;
            }
            (*(ptr_nsresult())) = std::move((aRhs).get_nsresult());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TLSRequestPreloadDatastoreResponse:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_LSRequestPreloadDatastoreResponse()) LSRequestPreloadDatastoreResponse;
            }
            (*(ptr_LSRequestPreloadDatastoreResponse())) = std::move((aRhs).get_LSRequestPreloadDatastoreResponse());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TLSRequestPrepareDatastoreResponse:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_LSRequestPrepareDatastoreResponse()) LSRequestPrepareDatastoreResponse;
            }
            (*(ptr_LSRequestPrepareDatastoreResponse())) = std::move((aRhs).get_LSRequestPrepareDatastoreResponse());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TLSRequestPrepareObserverResponse:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_LSRequestPrepareObserverResponse()) LSRequestPrepareObserverResponse;
            }
            (*(ptr_LSRequestPrepareObserverResponse())) = std::move((aRhs).get_LSRequestPrepareObserverResponse());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::LSRequestResponse>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::dom::LSRequestResponse union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'LSRequestResponse'
    (aMsg)->WriteSentinel(994641624);

    switch (type) {
    case union__::Tnsresult:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_nsresult());
            // Sentinel = 'Tnsresult'
            (aMsg)->WriteSentinel(313394133);
            return;
        }
    case union__::TLSRequestPreloadDatastoreResponse:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_LSRequestPreloadDatastoreResponse());
            // Sentinel = 'TLSRequestPreloadDatastoreResponse'
            (aMsg)->WriteSentinel(3891006874);
            return;
        }
    case union__::TLSRequestPrepareDatastoreResponse:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_LSRequestPrepareDatastoreResponse());
            // Sentinel = 'TLSRequestPrepareDatastoreResponse'
            (aMsg)->WriteSentinel(3900509602);
            return;
        }
    case union__::TLSRequestPrepareObserverResponse:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_LSRequestPrepareObserverResponse());
            // Sentinel = 'TLSRequestPrepareObserverResponse'
            (aMsg)->WriteSentinel(3683454275);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::dom::LSRequestResponse>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::dom::LSRequestResponse union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union LSRequestResponse");
        return false;
    }
    // Sentinel = 'LSRequestResponse'
    if ((!((aMsg)->ReadSentinel(aIter, 994641624)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union LSRequestResponse");
        return false;
    }

    switch (type) {
    case union__::Tnsresult:
        {
            nsresult tmp = nsresult();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_nsresult())))))) {
                aActor->FatalError("Error deserializing variant Tnsresult of union LSRequestResponse");
                return false;
            }
            // Sentinel = 'Tnsresult'
            if ((!((aMsg)->ReadSentinel(aIter, 313394133)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant Tnsresult of union LSRequestResponse");
                return false;
            }
            return true;
        }
    case union__::TLSRequestPreloadDatastoreResponse:
        {
            mozilla::dom::LSRequestPreloadDatastoreResponse tmp = mozilla::dom::LSRequestPreloadDatastoreResponse();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_LSRequestPreloadDatastoreResponse())))))) {
                aActor->FatalError("Error deserializing variant TLSRequestPreloadDatastoreResponse of union LSRequestResponse");
                return false;
            }
            // Sentinel = 'TLSRequestPreloadDatastoreResponse'
            if ((!((aMsg)->ReadSentinel(aIter, 3891006874)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TLSRequestPreloadDatastoreResponse of union LSRequestResponse");
                return false;
            }
            return true;
        }
    case union__::TLSRequestPrepareDatastoreResponse:
        {
            mozilla::dom::LSRequestPrepareDatastoreResponse tmp = mozilla::dom::LSRequestPrepareDatastoreResponse();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_LSRequestPrepareDatastoreResponse())))))) {
                aActor->FatalError("Error deserializing variant TLSRequestPrepareDatastoreResponse of union LSRequestResponse");
                return false;
            }
            // Sentinel = 'TLSRequestPrepareDatastoreResponse'
            if ((!((aMsg)->ReadSentinel(aIter, 3900509602)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TLSRequestPrepareDatastoreResponse of union LSRequestResponse");
                return false;
            }
            return true;
        }
    case union__::TLSRequestPrepareObserverResponse:
        {
            mozilla::dom::LSRequestPrepareObserverResponse tmp = mozilla::dom::LSRequestPrepareObserverResponse();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_LSRequestPrepareObserverResponse())))))) {
                aActor->FatalError("Error deserializing variant TLSRequestPrepareObserverResponse of union LSRequestResponse");
                return false;
            }
            // Sentinel = 'TLSRequestPrepareObserverResponse'
            if ((!((aMsg)->ReadSentinel(aIter, 3683454275)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TLSRequestPrepareObserverResponse of union LSRequestResponse");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla
