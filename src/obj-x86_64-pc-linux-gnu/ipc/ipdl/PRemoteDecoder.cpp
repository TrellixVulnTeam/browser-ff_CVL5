//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/MediaIPCUtils.h"
#include "mozilla/PRemoteDecoderManagerParent.h"
#include "mozilla/PRemoteDecoderManagerChild.h"
#include "mozilla/PRemoteDecoder.h"
#include "mozilla/PRemoteDecoderParent.h"
#include "mozilla/PRemoteDecoderChild.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace PRemoteDecoder {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::PRemoteDecoderParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::PRemoteDecoderChild>* aChild)
{
    return mozilla::ipc::CreateEndpoints(
        mozilla::ipc::PrivateIPDLInterface(),
        aParentDestPid, aChildDestPid,
        aParent, aChild);
}
IPC::Message*
Msg_Construct(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Construct__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply_Construct(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply_Construct__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg_Init(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Init__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply_Init(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply_Init__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg_Decode(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Decode__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply_Decode(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply_Decode__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg_Flush(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Flush__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply_Flush(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply_Flush__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg_Drain(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Drain__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply_Drain(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply_Drain__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg_Shutdown(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Shutdown__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply_Shutdown(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply_Shutdown__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg_SetSeekThreshold(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_SetSeekThreshold__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg___delete__(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg___delete____ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply___delete__(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply___delete____ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}

} // namespace PRemoteDecoder
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union DecodedOutputIPDL|
//
namespace mozilla {
auto DecodedOutputIPDL::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TArrayOfRemoteAudioData:
        {
            (ptr_ArrayOfRemoteAudioData())->~ArrayOfRemoteAudioData__tdef();
            break;
        }
    case TArrayOfRemoteVideoData:
        {
            (ptr_ArrayOfRemoteVideoData())->~ArrayOfRemoteVideoData__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT DecodedOutputIPDL::DecodedOutputIPDL(ArrayOfRemoteAudioData* aOther)
{
    new (mozilla::KnownNotNull, ptr_ArrayOfRemoteAudioData()) RefPtr<ArrayOfRemoteAudioData>(aOther);
    mType = TArrayOfRemoteAudioData;
}

MOZ_IMPLICIT DecodedOutputIPDL::DecodedOutputIPDL(RefPtr<ArrayOfRemoteAudioData>&& aOther)
{
    new (mozilla::KnownNotNull, ptr_ArrayOfRemoteAudioData()) RefPtr<ArrayOfRemoteAudioData>(std::move(aOther));
    mType = TArrayOfRemoteAudioData;
}

MOZ_IMPLICIT DecodedOutputIPDL::DecodedOutputIPDL(ArrayOfRemoteVideoData* aOther)
{
    new (mozilla::KnownNotNull, ptr_ArrayOfRemoteVideoData()) RefPtr<ArrayOfRemoteVideoData>(aOther);
    mType = TArrayOfRemoteVideoData;
}

MOZ_IMPLICIT DecodedOutputIPDL::DecodedOutputIPDL(RefPtr<ArrayOfRemoteVideoData>&& aOther)
{
    new (mozilla::KnownNotNull, ptr_ArrayOfRemoteVideoData()) RefPtr<ArrayOfRemoteVideoData>(std::move(aOther));
    mType = TArrayOfRemoteVideoData;
}

MOZ_IMPLICIT DecodedOutputIPDL::DecodedOutputIPDL(const DecodedOutputIPDL& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TArrayOfRemoteAudioData:
        {
            new (mozilla::KnownNotNull, ptr_ArrayOfRemoteAudioData()) RefPtr<ArrayOfRemoteAudioData>((aOther).get_ArrayOfRemoteAudioData());
            break;
        }
    case TArrayOfRemoteVideoData:
        {
            new (mozilla::KnownNotNull, ptr_ArrayOfRemoteVideoData()) RefPtr<ArrayOfRemoteVideoData>((aOther).get_ArrayOfRemoteVideoData());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT DecodedOutputIPDL::DecodedOutputIPDL(DecodedOutputIPDL&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TArrayOfRemoteAudioData:
        {
            new (mozilla::KnownNotNull, ptr_ArrayOfRemoteAudioData()) RefPtr<ArrayOfRemoteAudioData>(std::move((aOther).get_ArrayOfRemoteAudioData()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TArrayOfRemoteVideoData:
        {
            new (mozilla::KnownNotNull, ptr_ArrayOfRemoteVideoData()) RefPtr<ArrayOfRemoteVideoData>(std::move((aOther).get_ArrayOfRemoteVideoData()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

DecodedOutputIPDL::~DecodedOutputIPDL()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto DecodedOutputIPDL::operator=(ArrayOfRemoteAudioData* aRhs) -> DecodedOutputIPDL&
{
    if (MaybeDestroy(TArrayOfRemoteAudioData)) {
        new (mozilla::KnownNotNull, ptr_ArrayOfRemoteAudioData()) RefPtr<ArrayOfRemoteAudioData>;
    }
    (*(ptr_ArrayOfRemoteAudioData())) = aRhs;
    mType = TArrayOfRemoteAudioData;
    return (*(this));
}

auto DecodedOutputIPDL::operator=(RefPtr<ArrayOfRemoteAudioData>&& aRhs) -> DecodedOutputIPDL&
{
    if (MaybeDestroy(TArrayOfRemoteAudioData)) {
        new (mozilla::KnownNotNull, ptr_ArrayOfRemoteAudioData()) RefPtr<ArrayOfRemoteAudioData>;
    }
    (*(ptr_ArrayOfRemoteAudioData())) = std::move(aRhs);
    mType = TArrayOfRemoteAudioData;
    return (*(this));
}

auto DecodedOutputIPDL::operator=(ArrayOfRemoteVideoData* aRhs) -> DecodedOutputIPDL&
{
    if (MaybeDestroy(TArrayOfRemoteVideoData)) {
        new (mozilla::KnownNotNull, ptr_ArrayOfRemoteVideoData()) RefPtr<ArrayOfRemoteVideoData>;
    }
    (*(ptr_ArrayOfRemoteVideoData())) = aRhs;
    mType = TArrayOfRemoteVideoData;
    return (*(this));
}

auto DecodedOutputIPDL::operator=(RefPtr<ArrayOfRemoteVideoData>&& aRhs) -> DecodedOutputIPDL&
{
    if (MaybeDestroy(TArrayOfRemoteVideoData)) {
        new (mozilla::KnownNotNull, ptr_ArrayOfRemoteVideoData()) RefPtr<ArrayOfRemoteVideoData>;
    }
    (*(ptr_ArrayOfRemoteVideoData())) = std::move(aRhs);
    mType = TArrayOfRemoteVideoData;
    return (*(this));
}

auto DecodedOutputIPDL::operator=(const DecodedOutputIPDL& aRhs) -> DecodedOutputIPDL&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TArrayOfRemoteAudioData:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ArrayOfRemoteAudioData()) RefPtr<ArrayOfRemoteAudioData>;
            }
            (*(ptr_ArrayOfRemoteAudioData())) = (aRhs).get_ArrayOfRemoteAudioData();
            break;
        }
    case TArrayOfRemoteVideoData:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ArrayOfRemoteVideoData()) RefPtr<ArrayOfRemoteVideoData>;
            }
            (*(ptr_ArrayOfRemoteVideoData())) = (aRhs).get_ArrayOfRemoteVideoData();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto DecodedOutputIPDL::operator=(DecodedOutputIPDL&& aRhs) -> DecodedOutputIPDL&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TArrayOfRemoteAudioData:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ArrayOfRemoteAudioData()) RefPtr<ArrayOfRemoteAudioData>;
            }
            (*(ptr_ArrayOfRemoteAudioData())) = std::move((aRhs).get_ArrayOfRemoteAudioData());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TArrayOfRemoteVideoData:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ArrayOfRemoteVideoData()) RefPtr<ArrayOfRemoteVideoData>;
            }
            (*(ptr_ArrayOfRemoteVideoData())) = std::move((aRhs).get_ArrayOfRemoteVideoData());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::DecodedOutputIPDL>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::DecodedOutputIPDL union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'DecodedOutputIPDL'
    (aMsg)->WriteSentinel(984417891);

    switch (type) {
    case union__::TArrayOfRemoteAudioData:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_ArrayOfRemoteAudioData());
            // Sentinel = 'TArrayOfRemoteAudioData'
            (aMsg)->WriteSentinel(1771571425);
            return;
        }
    case union__::TArrayOfRemoteVideoData:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_ArrayOfRemoteVideoData());
            // Sentinel = 'TArrayOfRemoteVideoData'
            (aMsg)->WriteSentinel(1776093414);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::DecodedOutputIPDL>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::DecodedOutputIPDL union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union DecodedOutputIPDL");
        return false;
    }
    // Sentinel = 'DecodedOutputIPDL'
    if ((!((aMsg)->ReadSentinel(aIter, 984417891)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union DecodedOutputIPDL");
        return false;
    }

    switch (type) {
    case union__::TArrayOfRemoteAudioData:
        {
            RefPtr<mozilla::ArrayOfRemoteAudioData> tmp = RefPtr<mozilla::ArrayOfRemoteAudioData>();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_ArrayOfRemoteAudioData())))))) {
                aActor->FatalError("Error deserializing variant TArrayOfRemoteAudioData of union DecodedOutputIPDL");
                return false;
            }
            // Sentinel = 'TArrayOfRemoteAudioData'
            if ((!((aMsg)->ReadSentinel(aIter, 1771571425)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TArrayOfRemoteAudioData of union DecodedOutputIPDL");
                return false;
            }
            return true;
        }
    case union__::TArrayOfRemoteVideoData:
        {
            RefPtr<mozilla::ArrayOfRemoteVideoData> tmp = RefPtr<mozilla::ArrayOfRemoteVideoData>();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_ArrayOfRemoteVideoData())))))) {
                aActor->FatalError("Error deserializing variant TArrayOfRemoteVideoData of union DecodedOutputIPDL");
                return false;
            }
            // Sentinel = 'TArrayOfRemoteVideoData'
            if ((!((aMsg)->ReadSentinel(aIter, 1776093414)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TArrayOfRemoteVideoData of union DecodedOutputIPDL");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct InitCompletionIPDL|
//
namespace mozilla {
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::InitCompletionIPDL>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).type());
    // Sentinel = 'type'
    (aMsg)->WriteSentinel(75760067);
    WriteIPDLParam(aMsg, aActor, (aVar).decoderDescription());
    // Sentinel = 'decoderDescription'
    (aMsg)->WriteSentinel(1150093147);
    WriteIPDLParam(aMsg, aActor, (aVar).hardware());
    // Sentinel = 'hardware'
    (aMsg)->WriteSentinel(248972111);
    WriteIPDLParam(aMsg, aActor, (aVar).hardwareReason());
    // Sentinel = 'hardwareReason'
    (aMsg)->WriteSentinel(717161911);
    WriteIPDLParam(aMsg, aActor, (aVar).conversion());
    // Sentinel = 'conversion'
    (aMsg)->WriteSentinel(392430663);
}

auto IPDLParamTraits<mozilla::InitCompletionIPDL>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->type())))))) {
        aActor->FatalError("Error deserializing 'type' (TrackType) member of 'InitCompletionIPDL'");
        return false;
    }
    // Sentinel = 'type'
    if ((!((aMsg)->ReadSentinel(aIter, 75760067)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'type' (TrackType) member of 'InitCompletionIPDL'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->decoderDescription())))))) {
        aActor->FatalError("Error deserializing 'decoderDescription' (nsCString) member of 'InitCompletionIPDL'");
        return false;
    }
    // Sentinel = 'decoderDescription'
    if ((!((aMsg)->ReadSentinel(aIter, 1150093147)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'decoderDescription' (nsCString) member of 'InitCompletionIPDL'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->hardware())))))) {
        aActor->FatalError("Error deserializing 'hardware' (bool) member of 'InitCompletionIPDL'");
        return false;
    }
    // Sentinel = 'hardware'
    if ((!((aMsg)->ReadSentinel(aIter, 248972111)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'hardware' (bool) member of 'InitCompletionIPDL'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->hardwareReason())))))) {
        aActor->FatalError("Error deserializing 'hardwareReason' (nsCString) member of 'InitCompletionIPDL'");
        return false;
    }
    // Sentinel = 'hardwareReason'
    if ((!((aMsg)->ReadSentinel(aIter, 717161911)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'hardwareReason' (nsCString) member of 'InitCompletionIPDL'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->conversion())))))) {
        aActor->FatalError("Error deserializing 'conversion' (ConversionRequired) member of 'InitCompletionIPDL'");
        return false;
    }
    // Sentinel = 'conversion'
    if ((!((aMsg)->ReadSentinel(aIter, 392430663)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'conversion' (ConversionRequired) member of 'InitCompletionIPDL'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union InitResultIPDL|
//
namespace mozilla {
auto InitResultIPDL::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TMediaResult:
        {
            (ptr_MediaResult())->~MediaResult__tdef();
            break;
        }
    case TInitCompletionIPDL:
        {
            (ptr_InitCompletionIPDL())->~InitCompletionIPDL__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT InitResultIPDL::InitResultIPDL(const MediaResult& aOther)
{
    new (mozilla::KnownNotNull, ptr_MediaResult()) MediaResult(aOther);
    mType = TMediaResult;
}

MOZ_IMPLICIT InitResultIPDL::InitResultIPDL(MediaResult&& aOther)
{
    new (mozilla::KnownNotNull, ptr_MediaResult()) MediaResult(std::move(aOther));
    mType = TMediaResult;
}

MOZ_IMPLICIT InitResultIPDL::InitResultIPDL(const InitCompletionIPDL& aOther)
{
    new (mozilla::KnownNotNull, ptr_InitCompletionIPDL()) InitCompletionIPDL(aOther);
    mType = TInitCompletionIPDL;
}

MOZ_IMPLICIT InitResultIPDL::InitResultIPDL(InitCompletionIPDL&& aOther)
{
    new (mozilla::KnownNotNull, ptr_InitCompletionIPDL()) InitCompletionIPDL(std::move(aOther));
    mType = TInitCompletionIPDL;
}

MOZ_IMPLICIT InitResultIPDL::InitResultIPDL(const InitResultIPDL& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TMediaResult:
        {
            new (mozilla::KnownNotNull, ptr_MediaResult()) MediaResult((aOther).get_MediaResult());
            break;
        }
    case TInitCompletionIPDL:
        {
            new (mozilla::KnownNotNull, ptr_InitCompletionIPDL()) InitCompletionIPDL((aOther).get_InitCompletionIPDL());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT InitResultIPDL::InitResultIPDL(InitResultIPDL&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TMediaResult:
        {
            new (mozilla::KnownNotNull, ptr_MediaResult()) MediaResult(std::move((aOther).get_MediaResult()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TInitCompletionIPDL:
        {
            new (mozilla::KnownNotNull, ptr_InitCompletionIPDL()) InitCompletionIPDL(std::move((aOther).get_InitCompletionIPDL()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

InitResultIPDL::~InitResultIPDL()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto InitResultIPDL::operator=(const MediaResult& aRhs) -> InitResultIPDL&
{
    if (MaybeDestroy(TMediaResult)) {
        new (mozilla::KnownNotNull, ptr_MediaResult()) MediaResult;
    }
    (*(ptr_MediaResult())) = aRhs;
    mType = TMediaResult;
    return (*(this));
}

auto InitResultIPDL::operator=(MediaResult&& aRhs) -> InitResultIPDL&
{
    if (MaybeDestroy(TMediaResult)) {
        new (mozilla::KnownNotNull, ptr_MediaResult()) MediaResult;
    }
    (*(ptr_MediaResult())) = std::move(aRhs);
    mType = TMediaResult;
    return (*(this));
}

auto InitResultIPDL::operator=(const InitCompletionIPDL& aRhs) -> InitResultIPDL&
{
    if (MaybeDestroy(TInitCompletionIPDL)) {
        new (mozilla::KnownNotNull, ptr_InitCompletionIPDL()) InitCompletionIPDL;
    }
    (*(ptr_InitCompletionIPDL())) = aRhs;
    mType = TInitCompletionIPDL;
    return (*(this));
}

auto InitResultIPDL::operator=(InitCompletionIPDL&& aRhs) -> InitResultIPDL&
{
    if (MaybeDestroy(TInitCompletionIPDL)) {
        new (mozilla::KnownNotNull, ptr_InitCompletionIPDL()) InitCompletionIPDL;
    }
    (*(ptr_InitCompletionIPDL())) = std::move(aRhs);
    mType = TInitCompletionIPDL;
    return (*(this));
}

auto InitResultIPDL::operator=(const InitResultIPDL& aRhs) -> InitResultIPDL&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TMediaResult:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_MediaResult()) MediaResult;
            }
            (*(ptr_MediaResult())) = (aRhs).get_MediaResult();
            break;
        }
    case TInitCompletionIPDL:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_InitCompletionIPDL()) InitCompletionIPDL;
            }
            (*(ptr_InitCompletionIPDL())) = (aRhs).get_InitCompletionIPDL();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto InitResultIPDL::operator=(InitResultIPDL&& aRhs) -> InitResultIPDL&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TMediaResult:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_MediaResult()) MediaResult;
            }
            (*(ptr_MediaResult())) = std::move((aRhs).get_MediaResult());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TInitCompletionIPDL:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_InitCompletionIPDL()) InitCompletionIPDL;
            }
            (*(ptr_InitCompletionIPDL())) = std::move((aRhs).get_InitCompletionIPDL());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::InitResultIPDL>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::InitResultIPDL union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'InitResultIPDL'
    (aMsg)->WriteSentinel(684328253);

    switch (type) {
    case union__::TMediaResult:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_MediaResult());
            // Sentinel = 'TMediaResult'
            (aMsg)->WriteSentinel(487326900);
            return;
        }
    case union__::TInitCompletionIPDL:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_InitCompletionIPDL());
            // Sentinel = 'TInitCompletionIPDL'
            (aMsg)->WriteSentinel(1228932908);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::InitResultIPDL>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::InitResultIPDL union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union InitResultIPDL");
        return false;
    }
    // Sentinel = 'InitResultIPDL'
    if ((!((aMsg)->ReadSentinel(aIter, 684328253)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union InitResultIPDL");
        return false;
    }

    switch (type) {
    case union__::TMediaResult:
        {
            mozilla::MediaResult tmp = mozilla::MediaResult();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_MediaResult())))))) {
                aActor->FatalError("Error deserializing variant TMediaResult of union InitResultIPDL");
                return false;
            }
            // Sentinel = 'TMediaResult'
            if ((!((aMsg)->ReadSentinel(aIter, 487326900)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TMediaResult of union InitResultIPDL");
                return false;
            }
            return true;
        }
    case union__::TInitCompletionIPDL:
        {
            mozilla::InitCompletionIPDL tmp = mozilla::InitCompletionIPDL();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_InitCompletionIPDL())))))) {
                aActor->FatalError("Error deserializing variant TInitCompletionIPDL of union InitResultIPDL");
                return false;
            }
            // Sentinel = 'TInitCompletionIPDL'
            if ((!((aMsg)->ReadSentinel(aIter, 1228932908)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TInitCompletionIPDL of union InitResultIPDL");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union DecodeResultIPDL|
//
namespace mozilla {
auto DecodeResultIPDL::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TMediaResult:
        {
            (ptr_MediaResult())->~MediaResult__tdef();
            break;
        }
    case TDecodedOutputIPDL:
        {
            (ptr_DecodedOutputIPDL())->~DecodedOutputIPDL__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT DecodeResultIPDL::DecodeResultIPDL(const MediaResult& aOther)
{
    new (mozilla::KnownNotNull, ptr_MediaResult()) MediaResult(aOther);
    mType = TMediaResult;
}

MOZ_IMPLICIT DecodeResultIPDL::DecodeResultIPDL(MediaResult&& aOther)
{
    new (mozilla::KnownNotNull, ptr_MediaResult()) MediaResult(std::move(aOther));
    mType = TMediaResult;
}

MOZ_IMPLICIT DecodeResultIPDL::DecodeResultIPDL(const DecodedOutputIPDL& aOther)
{
    new (mozilla::KnownNotNull, ptr_DecodedOutputIPDL()) DecodedOutputIPDL(aOther);
    mType = TDecodedOutputIPDL;
}

MOZ_IMPLICIT DecodeResultIPDL::DecodeResultIPDL(DecodedOutputIPDL&& aOther)
{
    new (mozilla::KnownNotNull, ptr_DecodedOutputIPDL()) DecodedOutputIPDL(std::move(aOther));
    mType = TDecodedOutputIPDL;
}

MOZ_IMPLICIT DecodeResultIPDL::DecodeResultIPDL(const DecodeResultIPDL& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TMediaResult:
        {
            new (mozilla::KnownNotNull, ptr_MediaResult()) MediaResult((aOther).get_MediaResult());
            break;
        }
    case TDecodedOutputIPDL:
        {
            new (mozilla::KnownNotNull, ptr_DecodedOutputIPDL()) DecodedOutputIPDL((aOther).get_DecodedOutputIPDL());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT DecodeResultIPDL::DecodeResultIPDL(DecodeResultIPDL&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TMediaResult:
        {
            new (mozilla::KnownNotNull, ptr_MediaResult()) MediaResult(std::move((aOther).get_MediaResult()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TDecodedOutputIPDL:
        {
            new (mozilla::KnownNotNull, ptr_DecodedOutputIPDL()) DecodedOutputIPDL(std::move((aOther).get_DecodedOutputIPDL()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

DecodeResultIPDL::~DecodeResultIPDL()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto DecodeResultIPDL::operator=(const MediaResult& aRhs) -> DecodeResultIPDL&
{
    if (MaybeDestroy(TMediaResult)) {
        new (mozilla::KnownNotNull, ptr_MediaResult()) MediaResult;
    }
    (*(ptr_MediaResult())) = aRhs;
    mType = TMediaResult;
    return (*(this));
}

auto DecodeResultIPDL::operator=(MediaResult&& aRhs) -> DecodeResultIPDL&
{
    if (MaybeDestroy(TMediaResult)) {
        new (mozilla::KnownNotNull, ptr_MediaResult()) MediaResult;
    }
    (*(ptr_MediaResult())) = std::move(aRhs);
    mType = TMediaResult;
    return (*(this));
}

auto DecodeResultIPDL::operator=(const DecodedOutputIPDL& aRhs) -> DecodeResultIPDL&
{
    if (MaybeDestroy(TDecodedOutputIPDL)) {
        new (mozilla::KnownNotNull, ptr_DecodedOutputIPDL()) DecodedOutputIPDL;
    }
    (*(ptr_DecodedOutputIPDL())) = aRhs;
    mType = TDecodedOutputIPDL;
    return (*(this));
}

auto DecodeResultIPDL::operator=(DecodedOutputIPDL&& aRhs) -> DecodeResultIPDL&
{
    if (MaybeDestroy(TDecodedOutputIPDL)) {
        new (mozilla::KnownNotNull, ptr_DecodedOutputIPDL()) DecodedOutputIPDL;
    }
    (*(ptr_DecodedOutputIPDL())) = std::move(aRhs);
    mType = TDecodedOutputIPDL;
    return (*(this));
}

auto DecodeResultIPDL::operator=(const DecodeResultIPDL& aRhs) -> DecodeResultIPDL&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TMediaResult:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_MediaResult()) MediaResult;
            }
            (*(ptr_MediaResult())) = (aRhs).get_MediaResult();
            break;
        }
    case TDecodedOutputIPDL:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_DecodedOutputIPDL()) DecodedOutputIPDL;
            }
            (*(ptr_DecodedOutputIPDL())) = (aRhs).get_DecodedOutputIPDL();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto DecodeResultIPDL::operator=(DecodeResultIPDL&& aRhs) -> DecodeResultIPDL&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TMediaResult:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_MediaResult()) MediaResult;
            }
            (*(ptr_MediaResult())) = std::move((aRhs).get_MediaResult());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TDecodedOutputIPDL:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_DecodedOutputIPDL()) DecodedOutputIPDL;
            }
            (*(ptr_DecodedOutputIPDL())) = std::move((aRhs).get_DecodedOutputIPDL());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::DecodeResultIPDL>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::DecodeResultIPDL union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'DecodeResultIPDL'
    (aMsg)->WriteSentinel(865011181);

    switch (type) {
    case union__::TMediaResult:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_MediaResult());
            // Sentinel = 'TMediaResult'
            (aMsg)->WriteSentinel(487326900);
            return;
        }
    case union__::TDecodedOutputIPDL:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_DecodedOutputIPDL());
            // Sentinel = 'TDecodedOutputIPDL'
            (aMsg)->WriteSentinel(1083573943);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::DecodeResultIPDL>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::DecodeResultIPDL union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union DecodeResultIPDL");
        return false;
    }
    // Sentinel = 'DecodeResultIPDL'
    if ((!((aMsg)->ReadSentinel(aIter, 865011181)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union DecodeResultIPDL");
        return false;
    }

    switch (type) {
    case union__::TMediaResult:
        {
            mozilla::MediaResult tmp = mozilla::MediaResult();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_MediaResult())))))) {
                aActor->FatalError("Error deserializing variant TMediaResult of union DecodeResultIPDL");
                return false;
            }
            // Sentinel = 'TMediaResult'
            if ((!((aMsg)->ReadSentinel(aIter, 487326900)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TMediaResult of union DecodeResultIPDL");
                return false;
            }
            return true;
        }
    case union__::TDecodedOutputIPDL:
        {
            mozilla::DecodedOutputIPDL tmp = mozilla::DecodedOutputIPDL();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_DecodedOutputIPDL())))))) {
                aActor->FatalError("Error deserializing variant TDecodedOutputIPDL of union DecodeResultIPDL");
                return false;
            }
            // Sentinel = 'TDecodedOutputIPDL'
            if ((!((aMsg)->ReadSentinel(aIter, 1083573943)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TDecodedOutputIPDL of union DecodeResultIPDL");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla
