//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/net/PDNSRequestParams.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"


//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct DNSRecord|
//
namespace mozilla {
namespace net {
auto DNSRecord::StaticAssertions() const -> void
{
    static_assert(
        (offsetof(DNSRecord, trrFetchDurationNetworkOnly_) - offsetof(DNSRecord, trrFetchDuration_)) == 8,
        "Bad assumptions about field layout!");
}

} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::net::DNSRecord>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).canonicalName());
    // Sentinel = 'canonicalName'
    (aMsg)->WriteSentinel(612828458);
    WriteIPDLParam(aMsg, aActor, (aVar).addrs());
    // Sentinel = 'addrs'
    (aMsg)->WriteSentinel(100467215);
    WriteIPDLParam(aMsg, aActor, (aVar).isTRR());
    // Sentinel = 'isTRR'
    (aMsg)->WriteSentinel(97518037);
    (aMsg)->WriteBytes((&((aVar).trrFetchDuration())), 16);
    // Sentinel = 'trrFetchDuration | trrFetchDurationNetworkOnly'
    (aMsg)->WriteSentinel(2859340377);
    (aMsg)->WriteBytes((&((aVar).effectiveTRRMode())), 4);
    // Sentinel = 'effectiveTRRMode'
    (aMsg)->WriteSentinel(899089967);
}

auto IPDLParamTraits<mozilla::net::DNSRecord>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->canonicalName())))))) {
        aActor->FatalError("Error deserializing 'canonicalName' (nsCString) member of 'DNSRecord'");
        return false;
    }
    // Sentinel = 'canonicalName'
    if ((!((aMsg)->ReadSentinel(aIter, 612828458)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'canonicalName' (nsCString) member of 'DNSRecord'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->addrs())))))) {
        aActor->FatalError("Error deserializing 'addrs' (NetAddr[]) member of 'DNSRecord'");
        return false;
    }
    // Sentinel = 'addrs'
    if ((!((aMsg)->ReadSentinel(aIter, 100467215)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'addrs' (NetAddr[]) member of 'DNSRecord'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->isTRR())))))) {
        aActor->FatalError("Error deserializing 'isTRR' (bool) member of 'DNSRecord'");
        return false;
    }
    // Sentinel = 'isTRR'
    if ((!((aMsg)->ReadSentinel(aIter, 97518037)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'isTRR' (bool) member of 'DNSRecord'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->trrFetchDuration())), 16)))) {
        aActor->FatalError("Error bulk reading fields from double");
        return false;
    }
    // Sentinel = 'trrFetchDuration | trrFetchDurationNetworkOnly'
    if ((!((aMsg)->ReadSentinel(aIter, 2859340377)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from double");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->effectiveTRRMode())), 4)))) {
        aActor->FatalError("Error bulk reading fields from uint32_t");
        return false;
    }
    // Sentinel = 'effectiveTRRMode'
    if ((!((aMsg)->ReadSentinel(aIter, 899089967)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint32_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union DNSRequestResponse|
//
namespace mozilla {
namespace net {
auto DNSRequestResponse::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TDNSRecord:
        {
            (ptr_DNSRecord())->~DNSRecord__tdef();
            break;
        }
    case TIPCTypeRecord:
        {
            (ptr_IPCTypeRecord())->~IPCTypeRecord__tdef();
            break;
        }
    case Tnsresult:
        {
            (ptr_nsresult())->~nsresult__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT DNSRequestResponse::DNSRequestResponse(const DNSRecord& aOther)
{
    new (mozilla::KnownNotNull, ptr_DNSRecord()) DNSRecord(aOther);
    mType = TDNSRecord;
}

MOZ_IMPLICIT DNSRequestResponse::DNSRequestResponse(DNSRecord&& aOther)
{
    new (mozilla::KnownNotNull, ptr_DNSRecord()) DNSRecord(std::move(aOther));
    mType = TDNSRecord;
}

MOZ_IMPLICIT DNSRequestResponse::DNSRequestResponse(const IPCTypeRecord& aOther)
{
    new (mozilla::KnownNotNull, ptr_IPCTypeRecord()) IPCTypeRecord(aOther);
    mType = TIPCTypeRecord;
}

MOZ_IMPLICIT DNSRequestResponse::DNSRequestResponse(IPCTypeRecord&& aOther)
{
    new (mozilla::KnownNotNull, ptr_IPCTypeRecord()) IPCTypeRecord(std::move(aOther));
    mType = TIPCTypeRecord;
}

MOZ_IMPLICIT DNSRequestResponse::DNSRequestResponse(const nsresult& aOther)
{
    new (mozilla::KnownNotNull, ptr_nsresult()) nsresult(aOther);
    mType = Tnsresult;
}

MOZ_IMPLICIT DNSRequestResponse::DNSRequestResponse(nsresult&& aOther)
{
    new (mozilla::KnownNotNull, ptr_nsresult()) nsresult(std::move(aOther));
    mType = Tnsresult;
}

MOZ_IMPLICIT DNSRequestResponse::DNSRequestResponse(const DNSRequestResponse& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TDNSRecord:
        {
            new (mozilla::KnownNotNull, ptr_DNSRecord()) DNSRecord((aOther).get_DNSRecord());
            break;
        }
    case TIPCTypeRecord:
        {
            new (mozilla::KnownNotNull, ptr_IPCTypeRecord()) IPCTypeRecord((aOther).get_IPCTypeRecord());
            break;
        }
    case Tnsresult:
        {
            new (mozilla::KnownNotNull, ptr_nsresult()) nsresult((aOther).get_nsresult());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT DNSRequestResponse::DNSRequestResponse(DNSRequestResponse&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TDNSRecord:
        {
            new (mozilla::KnownNotNull, ptr_DNSRecord()) DNSRecord(std::move((aOther).get_DNSRecord()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TIPCTypeRecord:
        {
            new (mozilla::KnownNotNull, ptr_IPCTypeRecord()) IPCTypeRecord(std::move((aOther).get_IPCTypeRecord()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case Tnsresult:
        {
            new (mozilla::KnownNotNull, ptr_nsresult()) nsresult(std::move((aOther).get_nsresult()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

DNSRequestResponse::~DNSRequestResponse()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto DNSRequestResponse::operator=(const DNSRecord& aRhs) -> DNSRequestResponse&
{
    if (MaybeDestroy(TDNSRecord)) {
        new (mozilla::KnownNotNull, ptr_DNSRecord()) DNSRecord;
    }
    (*(ptr_DNSRecord())) = aRhs;
    mType = TDNSRecord;
    return (*(this));
}

auto DNSRequestResponse::operator=(DNSRecord&& aRhs) -> DNSRequestResponse&
{
    if (MaybeDestroy(TDNSRecord)) {
        new (mozilla::KnownNotNull, ptr_DNSRecord()) DNSRecord;
    }
    (*(ptr_DNSRecord())) = std::move(aRhs);
    mType = TDNSRecord;
    return (*(this));
}

auto DNSRequestResponse::operator=(const IPCTypeRecord& aRhs) -> DNSRequestResponse&
{
    if (MaybeDestroy(TIPCTypeRecord)) {
        new (mozilla::KnownNotNull, ptr_IPCTypeRecord()) IPCTypeRecord;
    }
    (*(ptr_IPCTypeRecord())) = aRhs;
    mType = TIPCTypeRecord;
    return (*(this));
}

auto DNSRequestResponse::operator=(IPCTypeRecord&& aRhs) -> DNSRequestResponse&
{
    if (MaybeDestroy(TIPCTypeRecord)) {
        new (mozilla::KnownNotNull, ptr_IPCTypeRecord()) IPCTypeRecord;
    }
    (*(ptr_IPCTypeRecord())) = std::move(aRhs);
    mType = TIPCTypeRecord;
    return (*(this));
}

auto DNSRequestResponse::operator=(const nsresult& aRhs) -> DNSRequestResponse&
{
    if (MaybeDestroy(Tnsresult)) {
        new (mozilla::KnownNotNull, ptr_nsresult()) nsresult;
    }
    (*(ptr_nsresult())) = aRhs;
    mType = Tnsresult;
    return (*(this));
}

auto DNSRequestResponse::operator=(nsresult&& aRhs) -> DNSRequestResponse&
{
    if (MaybeDestroy(Tnsresult)) {
        new (mozilla::KnownNotNull, ptr_nsresult()) nsresult;
    }
    (*(ptr_nsresult())) = std::move(aRhs);
    mType = Tnsresult;
    return (*(this));
}

auto DNSRequestResponse::operator=(const DNSRequestResponse& aRhs) -> DNSRequestResponse&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TDNSRecord:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_DNSRecord()) DNSRecord;
            }
            (*(ptr_DNSRecord())) = (aRhs).get_DNSRecord();
            break;
        }
    case TIPCTypeRecord:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_IPCTypeRecord()) IPCTypeRecord;
            }
            (*(ptr_IPCTypeRecord())) = (aRhs).get_IPCTypeRecord();
            break;
        }
    case Tnsresult:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_nsresult()) nsresult;
            }
            (*(ptr_nsresult())) = (aRhs).get_nsresult();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto DNSRequestResponse::operator=(DNSRequestResponse&& aRhs) -> DNSRequestResponse&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TDNSRecord:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_DNSRecord()) DNSRecord;
            }
            (*(ptr_DNSRecord())) = std::move((aRhs).get_DNSRecord());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TIPCTypeRecord:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_IPCTypeRecord()) IPCTypeRecord;
            }
            (*(ptr_IPCTypeRecord())) = std::move((aRhs).get_IPCTypeRecord());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case Tnsresult:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_nsresult()) nsresult;
            }
            (*(ptr_nsresult())) = std::move((aRhs).get_nsresult());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace net
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::net::DNSRequestResponse>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::net::DNSRequestResponse union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'DNSRequestResponse'
    (aMsg)->WriteSentinel(1077151518);

    switch (type) {
    case union__::TDNSRecord:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_DNSRecord());
            // Sentinel = 'TDNSRecord'
            (aMsg)->WriteSentinel(309396377);
            return;
        }
    case union__::TIPCTypeRecord:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_IPCTypeRecord());
            // Sentinel = 'TIPCTypeRecord'
            (aMsg)->WriteSentinel(617481522);
            return;
        }
    case union__::Tnsresult:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_nsresult());
            // Sentinel = 'Tnsresult'
            (aMsg)->WriteSentinel(313394133);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::net::DNSRequestResponse>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::net::DNSRequestResponse union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union DNSRequestResponse");
        return false;
    }
    // Sentinel = 'DNSRequestResponse'
    if ((!((aMsg)->ReadSentinel(aIter, 1077151518)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union DNSRequestResponse");
        return false;
    }

    switch (type) {
    case union__::TDNSRecord:
        {
            mozilla::net::DNSRecord tmp = mozilla::net::DNSRecord();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_DNSRecord())))))) {
                aActor->FatalError("Error deserializing variant TDNSRecord of union DNSRequestResponse");
                return false;
            }
            // Sentinel = 'TDNSRecord'
            if ((!((aMsg)->ReadSentinel(aIter, 309396377)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TDNSRecord of union DNSRequestResponse");
                return false;
            }
            return true;
        }
    case union__::TIPCTypeRecord:
        {
            mozilla::net::IPCTypeRecord tmp = mozilla::net::IPCTypeRecord();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_IPCTypeRecord())))))) {
                aActor->FatalError("Error deserializing variant TIPCTypeRecord of union DNSRequestResponse");
                return false;
            }
            // Sentinel = 'TIPCTypeRecord'
            if ((!((aMsg)->ReadSentinel(aIter, 617481522)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TIPCTypeRecord of union DNSRequestResponse");
                return false;
            }
            return true;
        }
    case union__::Tnsresult:
        {
            nsresult tmp = nsresult();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_nsresult())))))) {
                aActor->FatalError("Error deserializing variant Tnsresult of union DNSRequestResponse");
                return false;
            }
            // Sentinel = 'Tnsresult'
            if ((!((aMsg)->ReadSentinel(aIter, 313394133)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant Tnsresult of union DNSRequestResponse");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla
