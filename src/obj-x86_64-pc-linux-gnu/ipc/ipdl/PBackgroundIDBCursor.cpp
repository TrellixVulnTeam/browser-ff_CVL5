//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/indexedDB/SerializationHelpers.h"
#include "mozilla/dom/indexedDB/PBackgroundIDBTransactionParent.h"
#include "mozilla/dom/indexedDB/PBackgroundIDBTransactionChild.h"
#include "mozilla/dom/indexedDB/PBackgroundIDBVersionChangeTransactionParent.h"
#include "mozilla/dom/indexedDB/PBackgroundIDBVersionChangeTransactionChild.h"
#include "mozilla/dom/PBackgroundMutableFileParent.h"
#include "mozilla/dom/PBackgroundMutableFileChild.h"
#include "mozilla/ipc/PChildToParentStreamParent.h"
#include "mozilla/ipc/PChildToParentStreamChild.h"
#include "mozilla/ipc/PFileDescriptorSetParent.h"
#include "mozilla/ipc/PFileDescriptorSetChild.h"
#include "mozilla/ipc/PParentToChildStreamParent.h"
#include "mozilla/ipc/PParentToChildStreamChild.h"
#include "mozilla/PRemoteLazyInputStreamParent.h"
#include "mozilla/PRemoteLazyInputStreamChild.h"
#include "mozilla/dom/indexedDB/PBackgroundIDBCursor.h"
#include "mozilla/dom/indexedDB/PBackgroundIDBCursorParent.h"
#include "mozilla/dom/indexedDB/PBackgroundIDBCursorChild.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace dom {
namespace indexedDB {
namespace PBackgroundIDBCursor {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::dom::indexedDB::PBackgroundIDBCursorParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::dom::indexedDB::PBackgroundIDBCursorChild>* aChild)
{
    return mozilla::ipc::CreateEndpoints(
        mozilla::ipc::PrivateIPDLInterface(),
        aParentDestPid, aChildDestPid,
        aParent, aChild);
}
IPC::Message*
Msg_DeleteMe(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_DeleteMe__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_Continue(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Continue__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg___delete__(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg___delete____ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply___delete__(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply___delete____ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg_Response(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Response__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}

} // namespace PBackgroundIDBCursor
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ContinueParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::indexedDB::ContinueParams>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).key());
    // Sentinel = 'key'
    (aMsg)->WriteSentinel(42402122);
}

auto IPDLParamTraits<mozilla::dom::indexedDB::ContinueParams>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->key())))))) {
        aActor->FatalError("Error deserializing 'key' (Key) member of 'ContinueParams'");
        return false;
    }
    // Sentinel = 'key'
    if ((!((aMsg)->ReadSentinel(aIter, 42402122)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'key' (Key) member of 'ContinueParams'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ContinuePrimaryKeyParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::indexedDB::ContinuePrimaryKeyParams>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).key());
    // Sentinel = 'key'
    (aMsg)->WriteSentinel(42402122);
    WriteIPDLParam(aMsg, aActor, (aVar).primaryKey());
    // Sentinel = 'primaryKey'
    (aMsg)->WriteSentinel(389481518);
}

auto IPDLParamTraits<mozilla::dom::indexedDB::ContinuePrimaryKeyParams>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->key())))))) {
        aActor->FatalError("Error deserializing 'key' (Key) member of 'ContinuePrimaryKeyParams'");
        return false;
    }
    // Sentinel = 'key'
    if ((!((aMsg)->ReadSentinel(aIter, 42402122)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'key' (Key) member of 'ContinuePrimaryKeyParams'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->primaryKey())))))) {
        aActor->FatalError("Error deserializing 'primaryKey' (Key) member of 'ContinuePrimaryKeyParams'");
        return false;
    }
    // Sentinel = 'primaryKey'
    if ((!((aMsg)->ReadSentinel(aIter, 389481518)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'primaryKey' (Key) member of 'ContinuePrimaryKeyParams'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct AdvanceParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::indexedDB::AdvanceParams>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    (aMsg)->WriteBytes((&((aVar).count())), 4);
    // Sentinel = 'count'
    (aMsg)->WriteSentinel(106889770);
}

auto IPDLParamTraits<mozilla::dom::indexedDB::AdvanceParams>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->count())), 4)))) {
        aActor->FatalError("Error bulk reading fields from uint32_t");
        return false;
    }
    // Sentinel = 'count'
    if ((!((aMsg)->ReadSentinel(aIter, 106889770)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint32_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union CursorRequestParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
auto CursorRequestParams::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TContinueParams:
        {
            (ptr_ContinueParams())->~ContinueParams__tdef();
            break;
        }
    case TContinuePrimaryKeyParams:
        {
            (ptr_ContinuePrimaryKeyParams())->~ContinuePrimaryKeyParams__tdef();
            break;
        }
    case TAdvanceParams:
        {
            (ptr_AdvanceParams())->~AdvanceParams__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT CursorRequestParams::CursorRequestParams(const ContinueParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_ContinueParams()) ContinueParams(aOther);
    mType = TContinueParams;
}

MOZ_IMPLICIT CursorRequestParams::CursorRequestParams(ContinueParams&& aOther)
{
    new (mozilla::KnownNotNull, ptr_ContinueParams()) ContinueParams(std::move(aOther));
    mType = TContinueParams;
}

MOZ_IMPLICIT CursorRequestParams::CursorRequestParams(const ContinuePrimaryKeyParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_ContinuePrimaryKeyParams()) ContinuePrimaryKeyParams(aOther);
    mType = TContinuePrimaryKeyParams;
}

MOZ_IMPLICIT CursorRequestParams::CursorRequestParams(ContinuePrimaryKeyParams&& aOther)
{
    new (mozilla::KnownNotNull, ptr_ContinuePrimaryKeyParams()) ContinuePrimaryKeyParams(std::move(aOther));
    mType = TContinuePrimaryKeyParams;
}

MOZ_IMPLICIT CursorRequestParams::CursorRequestParams(const AdvanceParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_AdvanceParams()) AdvanceParams(aOther);
    mType = TAdvanceParams;
}

MOZ_IMPLICIT CursorRequestParams::CursorRequestParams(AdvanceParams&& aOther)
{
    new (mozilla::KnownNotNull, ptr_AdvanceParams()) AdvanceParams(std::move(aOther));
    mType = TAdvanceParams;
}

MOZ_IMPLICIT CursorRequestParams::CursorRequestParams(const CursorRequestParams& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TContinueParams:
        {
            new (mozilla::KnownNotNull, ptr_ContinueParams()) ContinueParams((aOther).get_ContinueParams());
            break;
        }
    case TContinuePrimaryKeyParams:
        {
            new (mozilla::KnownNotNull, ptr_ContinuePrimaryKeyParams()) ContinuePrimaryKeyParams((aOther).get_ContinuePrimaryKeyParams());
            break;
        }
    case TAdvanceParams:
        {
            new (mozilla::KnownNotNull, ptr_AdvanceParams()) AdvanceParams((aOther).get_AdvanceParams());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT CursorRequestParams::CursorRequestParams(CursorRequestParams&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TContinueParams:
        {
            new (mozilla::KnownNotNull, ptr_ContinueParams()) ContinueParams(std::move((aOther).get_ContinueParams()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TContinuePrimaryKeyParams:
        {
            new (mozilla::KnownNotNull, ptr_ContinuePrimaryKeyParams()) ContinuePrimaryKeyParams(std::move((aOther).get_ContinuePrimaryKeyParams()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TAdvanceParams:
        {
            new (mozilla::KnownNotNull, ptr_AdvanceParams()) AdvanceParams(std::move((aOther).get_AdvanceParams()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

CursorRequestParams::~CursorRequestParams()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto CursorRequestParams::operator=(const ContinueParams& aRhs) -> CursorRequestParams&
{
    if (MaybeDestroy(TContinueParams)) {
        new (mozilla::KnownNotNull, ptr_ContinueParams()) ContinueParams;
    }
    (*(ptr_ContinueParams())) = aRhs;
    mType = TContinueParams;
    return (*(this));
}

auto CursorRequestParams::operator=(ContinueParams&& aRhs) -> CursorRequestParams&
{
    if (MaybeDestroy(TContinueParams)) {
        new (mozilla::KnownNotNull, ptr_ContinueParams()) ContinueParams;
    }
    (*(ptr_ContinueParams())) = std::move(aRhs);
    mType = TContinueParams;
    return (*(this));
}

auto CursorRequestParams::operator=(const ContinuePrimaryKeyParams& aRhs) -> CursorRequestParams&
{
    if (MaybeDestroy(TContinuePrimaryKeyParams)) {
        new (mozilla::KnownNotNull, ptr_ContinuePrimaryKeyParams()) ContinuePrimaryKeyParams;
    }
    (*(ptr_ContinuePrimaryKeyParams())) = aRhs;
    mType = TContinuePrimaryKeyParams;
    return (*(this));
}

auto CursorRequestParams::operator=(ContinuePrimaryKeyParams&& aRhs) -> CursorRequestParams&
{
    if (MaybeDestroy(TContinuePrimaryKeyParams)) {
        new (mozilla::KnownNotNull, ptr_ContinuePrimaryKeyParams()) ContinuePrimaryKeyParams;
    }
    (*(ptr_ContinuePrimaryKeyParams())) = std::move(aRhs);
    mType = TContinuePrimaryKeyParams;
    return (*(this));
}

auto CursorRequestParams::operator=(const AdvanceParams& aRhs) -> CursorRequestParams&
{
    if (MaybeDestroy(TAdvanceParams)) {
        new (mozilla::KnownNotNull, ptr_AdvanceParams()) AdvanceParams;
    }
    (*(ptr_AdvanceParams())) = aRhs;
    mType = TAdvanceParams;
    return (*(this));
}

auto CursorRequestParams::operator=(AdvanceParams&& aRhs) -> CursorRequestParams&
{
    if (MaybeDestroy(TAdvanceParams)) {
        new (mozilla::KnownNotNull, ptr_AdvanceParams()) AdvanceParams;
    }
    (*(ptr_AdvanceParams())) = std::move(aRhs);
    mType = TAdvanceParams;
    return (*(this));
}

auto CursorRequestParams::operator=(const CursorRequestParams& aRhs) -> CursorRequestParams&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TContinueParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ContinueParams()) ContinueParams;
            }
            (*(ptr_ContinueParams())) = (aRhs).get_ContinueParams();
            break;
        }
    case TContinuePrimaryKeyParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ContinuePrimaryKeyParams()) ContinuePrimaryKeyParams;
            }
            (*(ptr_ContinuePrimaryKeyParams())) = (aRhs).get_ContinuePrimaryKeyParams();
            break;
        }
    case TAdvanceParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_AdvanceParams()) AdvanceParams;
            }
            (*(ptr_AdvanceParams())) = (aRhs).get_AdvanceParams();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto CursorRequestParams::operator=(CursorRequestParams&& aRhs) -> CursorRequestParams&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TContinueParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ContinueParams()) ContinueParams;
            }
            (*(ptr_ContinueParams())) = std::move((aRhs).get_ContinueParams());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TContinuePrimaryKeyParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ContinuePrimaryKeyParams()) ContinuePrimaryKeyParams;
            }
            (*(ptr_ContinuePrimaryKeyParams())) = std::move((aRhs).get_ContinuePrimaryKeyParams());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TAdvanceParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_AdvanceParams()) AdvanceParams;
            }
            (*(ptr_AdvanceParams())) = std::move((aRhs).get_AdvanceParams());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::indexedDB::CursorRequestParams>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::dom::indexedDB::CursorRequestParams union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'CursorRequestParams'
    (aMsg)->WriteSentinel(1298532300);

    switch (type) {
    case union__::TContinueParams:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_ContinueParams());
            // Sentinel = 'TContinueParams'
            (aMsg)->WriteSentinel(785122814);
            return;
        }
    case union__::TContinuePrimaryKeyParams:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_ContinuePrimaryKeyParams());
            // Sentinel = 'TContinuePrimaryKeyParams'
            (aMsg)->WriteSentinel(2164984331);
            return;
        }
    case union__::TAdvanceParams:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_AdvanceParams());
            // Sentinel = 'TAdvanceParams'
            (aMsg)->WriteSentinel(657786219);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::dom::indexedDB::CursorRequestParams>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::dom::indexedDB::CursorRequestParams union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union CursorRequestParams");
        return false;
    }
    // Sentinel = 'CursorRequestParams'
    if ((!((aMsg)->ReadSentinel(aIter, 1298532300)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union CursorRequestParams");
        return false;
    }

    switch (type) {
    case union__::TContinueParams:
        {
            mozilla::dom::indexedDB::ContinueParams tmp = mozilla::dom::indexedDB::ContinueParams();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_ContinueParams())))))) {
                aActor->FatalError("Error deserializing variant TContinueParams of union CursorRequestParams");
                return false;
            }
            // Sentinel = 'TContinueParams'
            if ((!((aMsg)->ReadSentinel(aIter, 785122814)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TContinueParams of union CursorRequestParams");
                return false;
            }
            return true;
        }
    case union__::TContinuePrimaryKeyParams:
        {
            mozilla::dom::indexedDB::ContinuePrimaryKeyParams tmp = mozilla::dom::indexedDB::ContinuePrimaryKeyParams();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_ContinuePrimaryKeyParams())))))) {
                aActor->FatalError("Error deserializing variant TContinuePrimaryKeyParams of union CursorRequestParams");
                return false;
            }
            // Sentinel = 'TContinuePrimaryKeyParams'
            if ((!((aMsg)->ReadSentinel(aIter, 2164984331)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TContinuePrimaryKeyParams of union CursorRequestParams");
                return false;
            }
            return true;
        }
    case union__::TAdvanceParams:
        {
            mozilla::dom::indexedDB::AdvanceParams tmp = mozilla::dom::indexedDB::AdvanceParams();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_AdvanceParams())))))) {
                aActor->FatalError("Error deserializing variant TAdvanceParams of union CursorRequestParams");
                return false;
            }
            // Sentinel = 'TAdvanceParams'
            if ((!((aMsg)->ReadSentinel(aIter, 657786219)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TAdvanceParams of union CursorRequestParams");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ObjectStoreCursorResponse|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::indexedDB::ObjectStoreCursorResponse>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).key());
    // Sentinel = 'key'
    (aMsg)->WriteSentinel(42402122);
    WriteIPDLParam(aMsg, aActor, (aVar).cloneInfo());
    // Sentinel = 'cloneInfo'
    (aMsg)->WriteSentinel(304284574);
}

auto IPDLParamTraits<mozilla::dom::indexedDB::ObjectStoreCursorResponse>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->key())))))) {
        aActor->FatalError("Error deserializing 'key' (Key) member of 'ObjectStoreCursorResponse'");
        return false;
    }
    // Sentinel = 'key'
    if ((!((aMsg)->ReadSentinel(aIter, 42402122)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'key' (Key) member of 'ObjectStoreCursorResponse'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->cloneInfo())))))) {
        aActor->FatalError("Error deserializing 'cloneInfo' (SerializedStructuredCloneReadInfo) member of 'ObjectStoreCursorResponse'");
        return false;
    }
    // Sentinel = 'cloneInfo'
    if ((!((aMsg)->ReadSentinel(aIter, 304284574)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'cloneInfo' (SerializedStructuredCloneReadInfo) member of 'ObjectStoreCursorResponse'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ObjectStoreKeyCursorResponse|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::indexedDB::ObjectStoreKeyCursorResponse>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).key());
    // Sentinel = 'key'
    (aMsg)->WriteSentinel(42402122);
}

auto IPDLParamTraits<mozilla::dom::indexedDB::ObjectStoreKeyCursorResponse>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->key())))))) {
        aActor->FatalError("Error deserializing 'key' (Key) member of 'ObjectStoreKeyCursorResponse'");
        return false;
    }
    // Sentinel = 'key'
    if ((!((aMsg)->ReadSentinel(aIter, 42402122)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'key' (Key) member of 'ObjectStoreKeyCursorResponse'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct IndexCursorResponse|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::indexedDB::IndexCursorResponse>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).key());
    // Sentinel = 'key'
    (aMsg)->WriteSentinel(42402122);
    WriteIPDLParam(aMsg, aActor, (aVar).sortKey());
    // Sentinel = 'sortKey'
    (aMsg)->WriteSentinel(200540914);
    WriteIPDLParam(aMsg, aActor, (aVar).objectKey());
    // Sentinel = 'objectKey'
    (aMsg)->WriteSentinel(304546721);
    WriteIPDLParam(aMsg, aActor, (aVar).cloneInfo());
    // Sentinel = 'cloneInfo'
    (aMsg)->WriteSentinel(304284574);
}

auto IPDLParamTraits<mozilla::dom::indexedDB::IndexCursorResponse>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->key())))))) {
        aActor->FatalError("Error deserializing 'key' (Key) member of 'IndexCursorResponse'");
        return false;
    }
    // Sentinel = 'key'
    if ((!((aMsg)->ReadSentinel(aIter, 42402122)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'key' (Key) member of 'IndexCursorResponse'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->sortKey())))))) {
        aActor->FatalError("Error deserializing 'sortKey' (Key) member of 'IndexCursorResponse'");
        return false;
    }
    // Sentinel = 'sortKey'
    if ((!((aMsg)->ReadSentinel(aIter, 200540914)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'sortKey' (Key) member of 'IndexCursorResponse'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->objectKey())))))) {
        aActor->FatalError("Error deserializing 'objectKey' (Key) member of 'IndexCursorResponse'");
        return false;
    }
    // Sentinel = 'objectKey'
    if ((!((aMsg)->ReadSentinel(aIter, 304546721)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'objectKey' (Key) member of 'IndexCursorResponse'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->cloneInfo())))))) {
        aActor->FatalError("Error deserializing 'cloneInfo' (SerializedStructuredCloneReadInfo) member of 'IndexCursorResponse'");
        return false;
    }
    // Sentinel = 'cloneInfo'
    if ((!((aMsg)->ReadSentinel(aIter, 304284574)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'cloneInfo' (SerializedStructuredCloneReadInfo) member of 'IndexCursorResponse'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct IndexKeyCursorResponse|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
} // namespace indexedDB
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::indexedDB::IndexKeyCursorResponse>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).key());
    // Sentinel = 'key'
    (aMsg)->WriteSentinel(42402122);
    WriteIPDLParam(aMsg, aActor, (aVar).sortKey());
    // Sentinel = 'sortKey'
    (aMsg)->WriteSentinel(200540914);
    WriteIPDLParam(aMsg, aActor, (aVar).objectKey());
    // Sentinel = 'objectKey'
    (aMsg)->WriteSentinel(304546721);
}

auto IPDLParamTraits<mozilla::dom::indexedDB::IndexKeyCursorResponse>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->key())))))) {
        aActor->FatalError("Error deserializing 'key' (Key) member of 'IndexKeyCursorResponse'");
        return false;
    }
    // Sentinel = 'key'
    if ((!((aMsg)->ReadSentinel(aIter, 42402122)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'key' (Key) member of 'IndexKeyCursorResponse'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->sortKey())))))) {
        aActor->FatalError("Error deserializing 'sortKey' (Key) member of 'IndexKeyCursorResponse'");
        return false;
    }
    // Sentinel = 'sortKey'
    if ((!((aMsg)->ReadSentinel(aIter, 200540914)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'sortKey' (Key) member of 'IndexKeyCursorResponse'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->objectKey())))))) {
        aActor->FatalError("Error deserializing 'objectKey' (Key) member of 'IndexKeyCursorResponse'");
        return false;
    }
    // Sentinel = 'objectKey'
    if ((!((aMsg)->ReadSentinel(aIter, 304546721)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'objectKey' (Key) member of 'IndexKeyCursorResponse'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union CursorResponse|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
auto CursorResponse::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case Tvoid_t:
        {
            (ptr_void_t())->~void_t__tdef();
            break;
        }
    case Tnsresult:
        {
            (ptr_nsresult())->~nsresult__tdef();
            break;
        }
    case TArrayOfObjectStoreCursorResponse:
        {
            (ptr_ArrayOfObjectStoreCursorResponse())->~ArrayOfObjectStoreCursorResponse__tdef();
            break;
        }
    case TArrayOfObjectStoreKeyCursorResponse:
        {
            (ptr_ArrayOfObjectStoreKeyCursorResponse())->~ArrayOfObjectStoreKeyCursorResponse__tdef();
            break;
        }
    case TArrayOfIndexCursorResponse:
        {
            (ptr_ArrayOfIndexCursorResponse())->~ArrayOfIndexCursorResponse__tdef();
            break;
        }
    case TArrayOfIndexKeyCursorResponse:
        {
            (ptr_ArrayOfIndexKeyCursorResponse())->~ArrayOfIndexKeyCursorResponse__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT CursorResponse::CursorResponse(const void_t& aOther)
{
    new (mozilla::KnownNotNull, ptr_void_t()) void_t(aOther);
    mType = Tvoid_t;
}

MOZ_IMPLICIT CursorResponse::CursorResponse(void_t&& aOther)
{
    new (mozilla::KnownNotNull, ptr_void_t()) void_t(std::move(aOther));
    mType = Tvoid_t;
}

MOZ_IMPLICIT CursorResponse::CursorResponse(const nsresult& aOther)
{
    new (mozilla::KnownNotNull, ptr_nsresult()) nsresult(aOther);
    mType = Tnsresult;
}

MOZ_IMPLICIT CursorResponse::CursorResponse(nsresult&& aOther)
{
    new (mozilla::KnownNotNull, ptr_nsresult()) nsresult(std::move(aOther));
    mType = Tnsresult;
}

MOZ_IMPLICIT CursorResponse::CursorResponse(nsTArray<ObjectStoreCursorResponse>&& aOther)
{
    new (mozilla::KnownNotNull, ptr_ArrayOfObjectStoreCursorResponse()) nsTArray<ObjectStoreCursorResponse>(std::move(aOther));
    mType = TArrayOfObjectStoreCursorResponse;
}

MOZ_IMPLICIT CursorResponse::CursorResponse(const nsTArray<ObjectStoreKeyCursorResponse>& aOther)
{
    new (mozilla::KnownNotNull, ptr_ArrayOfObjectStoreKeyCursorResponse()) nsTArray<ObjectStoreKeyCursorResponse>((aOther).Clone());
    mType = TArrayOfObjectStoreKeyCursorResponse;
}

MOZ_IMPLICIT CursorResponse::CursorResponse(nsTArray<ObjectStoreKeyCursorResponse>&& aOther)
{
    new (mozilla::KnownNotNull, ptr_ArrayOfObjectStoreKeyCursorResponse()) nsTArray<ObjectStoreKeyCursorResponse>(std::move(aOther));
    mType = TArrayOfObjectStoreKeyCursorResponse;
}

MOZ_IMPLICIT CursorResponse::CursorResponse(nsTArray<IndexCursorResponse>&& aOther)
{
    new (mozilla::KnownNotNull, ptr_ArrayOfIndexCursorResponse()) nsTArray<IndexCursorResponse>(std::move(aOther));
    mType = TArrayOfIndexCursorResponse;
}

MOZ_IMPLICIT CursorResponse::CursorResponse(const nsTArray<IndexKeyCursorResponse>& aOther)
{
    new (mozilla::KnownNotNull, ptr_ArrayOfIndexKeyCursorResponse()) nsTArray<IndexKeyCursorResponse>((aOther).Clone());
    mType = TArrayOfIndexKeyCursorResponse;
}

MOZ_IMPLICIT CursorResponse::CursorResponse(nsTArray<IndexKeyCursorResponse>&& aOther)
{
    new (mozilla::KnownNotNull, ptr_ArrayOfIndexKeyCursorResponse()) nsTArray<IndexKeyCursorResponse>(std::move(aOther));
    mType = TArrayOfIndexKeyCursorResponse;
}

MOZ_IMPLICIT CursorResponse::CursorResponse(CursorResponse&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case Tvoid_t:
        {
            new (mozilla::KnownNotNull, ptr_void_t()) void_t(std::move((aOther).get_void_t()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case Tnsresult:
        {
            new (mozilla::KnownNotNull, ptr_nsresult()) nsresult(std::move((aOther).get_nsresult()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TArrayOfObjectStoreCursorResponse:
        {
            new (mozilla::KnownNotNull, ptr_ArrayOfObjectStoreCursorResponse()) nsTArray<ObjectStoreCursorResponse>(std::move((aOther).get_ArrayOfObjectStoreCursorResponse()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TArrayOfObjectStoreKeyCursorResponse:
        {
            new (mozilla::KnownNotNull, ptr_ArrayOfObjectStoreKeyCursorResponse()) nsTArray<ObjectStoreKeyCursorResponse>(std::move((aOther).get_ArrayOfObjectStoreKeyCursorResponse()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TArrayOfIndexCursorResponse:
        {
            new (mozilla::KnownNotNull, ptr_ArrayOfIndexCursorResponse()) nsTArray<IndexCursorResponse>(std::move((aOther).get_ArrayOfIndexCursorResponse()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TArrayOfIndexKeyCursorResponse:
        {
            new (mozilla::KnownNotNull, ptr_ArrayOfIndexKeyCursorResponse()) nsTArray<IndexKeyCursorResponse>(std::move((aOther).get_ArrayOfIndexKeyCursorResponse()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

CursorResponse::~CursorResponse()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto CursorResponse::operator=(const void_t& aRhs) -> CursorResponse&
{
    if (MaybeDestroy(Tvoid_t)) {
        new (mozilla::KnownNotNull, ptr_void_t()) void_t;
    }
    (*(ptr_void_t())) = aRhs;
    mType = Tvoid_t;
    return (*(this));
}

auto CursorResponse::operator=(void_t&& aRhs) -> CursorResponse&
{
    if (MaybeDestroy(Tvoid_t)) {
        new (mozilla::KnownNotNull, ptr_void_t()) void_t;
    }
    (*(ptr_void_t())) = std::move(aRhs);
    mType = Tvoid_t;
    return (*(this));
}

auto CursorResponse::operator=(const nsresult& aRhs) -> CursorResponse&
{
    if (MaybeDestroy(Tnsresult)) {
        new (mozilla::KnownNotNull, ptr_nsresult()) nsresult;
    }
    (*(ptr_nsresult())) = aRhs;
    mType = Tnsresult;
    return (*(this));
}

auto CursorResponse::operator=(nsresult&& aRhs) -> CursorResponse&
{
    if (MaybeDestroy(Tnsresult)) {
        new (mozilla::KnownNotNull, ptr_nsresult()) nsresult;
    }
    (*(ptr_nsresult())) = std::move(aRhs);
    mType = Tnsresult;
    return (*(this));
}

auto CursorResponse::operator=(nsTArray<ObjectStoreCursorResponse>&& aRhs) -> CursorResponse&
{
    if (MaybeDestroy(TArrayOfObjectStoreCursorResponse)) {
        new (mozilla::KnownNotNull, ptr_ArrayOfObjectStoreCursorResponse()) nsTArray<ObjectStoreCursorResponse>;
    }
    (*(ptr_ArrayOfObjectStoreCursorResponse())) = std::move(aRhs);
    mType = TArrayOfObjectStoreCursorResponse;
    return (*(this));
}

auto CursorResponse::operator=(const nsTArray<ObjectStoreKeyCursorResponse>& aRhs) -> CursorResponse&
{
    if (MaybeDestroy(TArrayOfObjectStoreKeyCursorResponse)) {
        new (mozilla::KnownNotNull, ptr_ArrayOfObjectStoreKeyCursorResponse()) nsTArray<ObjectStoreKeyCursorResponse>;
    }
    (*(ptr_ArrayOfObjectStoreKeyCursorResponse())) = (aRhs).Clone();
    mType = TArrayOfObjectStoreKeyCursorResponse;
    return (*(this));
}

auto CursorResponse::operator=(nsTArray<ObjectStoreKeyCursorResponse>&& aRhs) -> CursorResponse&
{
    if (MaybeDestroy(TArrayOfObjectStoreKeyCursorResponse)) {
        new (mozilla::KnownNotNull, ptr_ArrayOfObjectStoreKeyCursorResponse()) nsTArray<ObjectStoreKeyCursorResponse>;
    }
    (*(ptr_ArrayOfObjectStoreKeyCursorResponse())) = std::move(aRhs);
    mType = TArrayOfObjectStoreKeyCursorResponse;
    return (*(this));
}

auto CursorResponse::operator=(nsTArray<IndexCursorResponse>&& aRhs) -> CursorResponse&
{
    if (MaybeDestroy(TArrayOfIndexCursorResponse)) {
        new (mozilla::KnownNotNull, ptr_ArrayOfIndexCursorResponse()) nsTArray<IndexCursorResponse>;
    }
    (*(ptr_ArrayOfIndexCursorResponse())) = std::move(aRhs);
    mType = TArrayOfIndexCursorResponse;
    return (*(this));
}

auto CursorResponse::operator=(const nsTArray<IndexKeyCursorResponse>& aRhs) -> CursorResponse&
{
    if (MaybeDestroy(TArrayOfIndexKeyCursorResponse)) {
        new (mozilla::KnownNotNull, ptr_ArrayOfIndexKeyCursorResponse()) nsTArray<IndexKeyCursorResponse>;
    }
    (*(ptr_ArrayOfIndexKeyCursorResponse())) = (aRhs).Clone();
    mType = TArrayOfIndexKeyCursorResponse;
    return (*(this));
}

auto CursorResponse::operator=(nsTArray<IndexKeyCursorResponse>&& aRhs) -> CursorResponse&
{
    if (MaybeDestroy(TArrayOfIndexKeyCursorResponse)) {
        new (mozilla::KnownNotNull, ptr_ArrayOfIndexKeyCursorResponse()) nsTArray<IndexKeyCursorResponse>;
    }
    (*(ptr_ArrayOfIndexKeyCursorResponse())) = std::move(aRhs);
    mType = TArrayOfIndexKeyCursorResponse;
    return (*(this));
}

auto CursorResponse::operator=(CursorResponse&& aRhs) -> CursorResponse&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case Tvoid_t:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_void_t()) void_t;
            }
            (*(ptr_void_t())) = std::move((aRhs).get_void_t());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case Tnsresult:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_nsresult()) nsresult;
            }
            (*(ptr_nsresult())) = std::move((aRhs).get_nsresult());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TArrayOfObjectStoreCursorResponse:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ArrayOfObjectStoreCursorResponse()) nsTArray<ObjectStoreCursorResponse>;
            }
            (*(ptr_ArrayOfObjectStoreCursorResponse())) = std::move((aRhs).get_ArrayOfObjectStoreCursorResponse());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TArrayOfObjectStoreKeyCursorResponse:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ArrayOfObjectStoreKeyCursorResponse()) nsTArray<ObjectStoreKeyCursorResponse>;
            }
            (*(ptr_ArrayOfObjectStoreKeyCursorResponse())) = std::move((aRhs).get_ArrayOfObjectStoreKeyCursorResponse());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TArrayOfIndexCursorResponse:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ArrayOfIndexCursorResponse()) nsTArray<IndexCursorResponse>;
            }
            (*(ptr_ArrayOfIndexCursorResponse())) = std::move((aRhs).get_ArrayOfIndexCursorResponse());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TArrayOfIndexKeyCursorResponse:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ArrayOfIndexKeyCursorResponse()) nsTArray<IndexKeyCursorResponse>;
            }
            (*(ptr_ArrayOfIndexKeyCursorResponse())) = std::move((aRhs).get_ArrayOfIndexKeyCursorResponse());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::indexedDB::CursorResponse>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::dom::indexedDB::CursorResponse union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'CursorResponse'
    (aMsg)->WriteSentinel(718276046);

    switch (type) {
    case union__::Tvoid_t:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_void_t());
            // Sentinel = 'Tvoid_t'
            (aMsg)->WriteSentinel(189006554);
            return;
        }
    case union__::Tnsresult:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_nsresult());
            // Sentinel = 'Tnsresult'
            (aMsg)->WriteSentinel(313394133);
            return;
        }
    case union__::TArrayOfObjectStoreCursorResponse:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_ArrayOfObjectStoreCursorResponse());
            // Sentinel = 'TArrayOfObjectStoreCursorResponse'
            (aMsg)->WriteSentinel(3673165114);
            return;
        }
    case union__::TArrayOfObjectStoreKeyCursorResponse:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_ArrayOfObjectStoreKeyCursorResponse());
            // Sentinel = 'TArrayOfObjectStoreKeyCursorResponse'
            (aMsg)->WriteSentinel(61345379);
            return;
        }
    case union__::TArrayOfIndexCursorResponse:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_ArrayOfIndexCursorResponse());
            // Sentinel = 'TArrayOfIndexCursorResponse'
            (aMsg)->WriteSentinel(2463632078);
            return;
        }
    case union__::TArrayOfIndexKeyCursorResponse:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_ArrayOfIndexKeyCursorResponse());
            // Sentinel = 'TArrayOfIndexKeyCursorResponse'
            (aMsg)->WriteSentinel(3023899639);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::dom::indexedDB::CursorResponse>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::dom::indexedDB::CursorResponse union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union CursorResponse");
        return false;
    }
    // Sentinel = 'CursorResponse'
    if ((!((aMsg)->ReadSentinel(aIter, 718276046)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union CursorResponse");
        return false;
    }

    switch (type) {
    case union__::Tvoid_t:
        {
            mozilla::void_t tmp = mozilla::void_t();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_void_t())))))) {
                aActor->FatalError("Error deserializing variant Tvoid_t of union CursorResponse");
                return false;
            }
            // Sentinel = 'Tvoid_t'
            if ((!((aMsg)->ReadSentinel(aIter, 189006554)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant Tvoid_t of union CursorResponse");
                return false;
            }
            return true;
        }
    case union__::Tnsresult:
        {
            nsresult tmp = nsresult();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_nsresult())))))) {
                aActor->FatalError("Error deserializing variant Tnsresult of union CursorResponse");
                return false;
            }
            // Sentinel = 'Tnsresult'
            if ((!((aMsg)->ReadSentinel(aIter, 313394133)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant Tnsresult of union CursorResponse");
                return false;
            }
            return true;
        }
    case union__::TArrayOfObjectStoreCursorResponse:
        {
            nsTArray<mozilla::dom::indexedDB::ObjectStoreCursorResponse> tmp;
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_ArrayOfObjectStoreCursorResponse())))))) {
                aActor->FatalError("Error deserializing variant TArrayOfObjectStoreCursorResponse of union CursorResponse");
                return false;
            }
            // Sentinel = 'TArrayOfObjectStoreCursorResponse'
            if ((!((aMsg)->ReadSentinel(aIter, 3673165114)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TArrayOfObjectStoreCursorResponse of union CursorResponse");
                return false;
            }
            return true;
        }
    case union__::TArrayOfObjectStoreKeyCursorResponse:
        {
            nsTArray<mozilla::dom::indexedDB::ObjectStoreKeyCursorResponse> tmp;
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_ArrayOfObjectStoreKeyCursorResponse())))))) {
                aActor->FatalError("Error deserializing variant TArrayOfObjectStoreKeyCursorResponse of union CursorResponse");
                return false;
            }
            // Sentinel = 'TArrayOfObjectStoreKeyCursorResponse'
            if ((!((aMsg)->ReadSentinel(aIter, 61345379)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TArrayOfObjectStoreKeyCursorResponse of union CursorResponse");
                return false;
            }
            return true;
        }
    case union__::TArrayOfIndexCursorResponse:
        {
            nsTArray<mozilla::dom::indexedDB::IndexCursorResponse> tmp;
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_ArrayOfIndexCursorResponse())))))) {
                aActor->FatalError("Error deserializing variant TArrayOfIndexCursorResponse of union CursorResponse");
                return false;
            }
            // Sentinel = 'TArrayOfIndexCursorResponse'
            if ((!((aMsg)->ReadSentinel(aIter, 2463632078)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TArrayOfIndexCursorResponse of union CursorResponse");
                return false;
            }
            return true;
        }
    case union__::TArrayOfIndexKeyCursorResponse:
        {
            nsTArray<mozilla::dom::indexedDB::IndexKeyCursorResponse> tmp;
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_ArrayOfIndexKeyCursorResponse())))))) {
                aActor->FatalError("Error deserializing variant TArrayOfIndexKeyCursorResponse of union CursorResponse");
                return false;
            }
            // Sentinel = 'TArrayOfIndexKeyCursorResponse'
            if ((!((aMsg)->ReadSentinel(aIter, 3023899639)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TArrayOfIndexKeyCursorResponse of union CursorResponse");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla
