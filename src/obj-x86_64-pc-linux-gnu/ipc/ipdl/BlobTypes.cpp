//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/PFileDescriptorSetParent.h"
#include "mozilla/ipc/PFileDescriptorSetChild.h"
#include "mozilla/dom/BlobTypes.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"


//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union OptionalFileDescriptorSet|
//
namespace mozilla {
namespace dom {
auto OptionalFileDescriptorSet::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TPFileDescriptorSetParent:
        {
            (ptr_PFileDescriptorSetParent())->~PFileDescriptorSetParent__tdef();
            break;
        }
    case TPFileDescriptorSetChild:
        {
            (ptr_PFileDescriptorSetChild())->~PFileDescriptorSetChild__tdef();
            break;
        }
    case TArrayOfFileDescriptor:
        {
            (ptr_ArrayOfFileDescriptor())->~ArrayOfFileDescriptor__tdef();
            break;
        }
    case Tvoid_t:
        {
            (ptr_void_t())->~void_t__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT OptionalFileDescriptorSet::OptionalFileDescriptorSet(PFileDescriptorSetParent* aOther)
{
    new (mozilla::KnownNotNull, ptr_PFileDescriptorSetParent()) PFileDescriptorSetParent*(const_cast<PFileDescriptorSetParent*>(aOther));
    mType = TPFileDescriptorSetParent;
}

MOZ_IMPLICIT OptionalFileDescriptorSet::OptionalFileDescriptorSet(PFileDescriptorSetChild* aOther)
{
    new (mozilla::KnownNotNull, ptr_PFileDescriptorSetChild()) PFileDescriptorSetChild*(const_cast<PFileDescriptorSetChild*>(aOther));
    mType = TPFileDescriptorSetChild;
}

MOZ_IMPLICIT OptionalFileDescriptorSet::OptionalFileDescriptorSet(const nsTArray<FileDescriptor>& aOther)
{
    new (mozilla::KnownNotNull, ptr_ArrayOfFileDescriptor()) nsTArray<FileDescriptor>((aOther).Clone());
    mType = TArrayOfFileDescriptor;
}

MOZ_IMPLICIT OptionalFileDescriptorSet::OptionalFileDescriptorSet(nsTArray<FileDescriptor>&& aOther)
{
    new (mozilla::KnownNotNull, ptr_ArrayOfFileDescriptor()) nsTArray<FileDescriptor>(std::move(aOther));
    mType = TArrayOfFileDescriptor;
}

MOZ_IMPLICIT OptionalFileDescriptorSet::OptionalFileDescriptorSet(const void_t& aOther)
{
    new (mozilla::KnownNotNull, ptr_void_t()) void_t(aOther);
    mType = Tvoid_t;
}

MOZ_IMPLICIT OptionalFileDescriptorSet::OptionalFileDescriptorSet(void_t&& aOther)
{
    new (mozilla::KnownNotNull, ptr_void_t()) void_t(std::move(aOther));
    mType = Tvoid_t;
}

MOZ_IMPLICIT OptionalFileDescriptorSet::OptionalFileDescriptorSet(const OptionalFileDescriptorSet& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TPFileDescriptorSetParent:
        {
            new (mozilla::KnownNotNull, ptr_PFileDescriptorSetParent()) PFileDescriptorSetParent*(const_cast<PFileDescriptorSetParent*>((aOther).get_PFileDescriptorSetParent()));
            break;
        }
    case TPFileDescriptorSetChild:
        {
            new (mozilla::KnownNotNull, ptr_PFileDescriptorSetChild()) PFileDescriptorSetChild*(const_cast<PFileDescriptorSetChild*>((aOther).get_PFileDescriptorSetChild()));
            break;
        }
    case TArrayOfFileDescriptor:
        {
            new (mozilla::KnownNotNull, ptr_ArrayOfFileDescriptor()) nsTArray<FileDescriptor>(((aOther).get_ArrayOfFileDescriptor()).Clone());
            break;
        }
    case Tvoid_t:
        {
            new (mozilla::KnownNotNull, ptr_void_t()) void_t((aOther).get_void_t());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT OptionalFileDescriptorSet::OptionalFileDescriptorSet(OptionalFileDescriptorSet&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TPFileDescriptorSetParent:
        {
            new (mozilla::KnownNotNull, ptr_PFileDescriptorSetParent()) PFileDescriptorSetParent*(const_cast<PFileDescriptorSetParent*>(std::move((aOther).get_PFileDescriptorSetParent())));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TPFileDescriptorSetChild:
        {
            new (mozilla::KnownNotNull, ptr_PFileDescriptorSetChild()) PFileDescriptorSetChild*(const_cast<PFileDescriptorSetChild*>(std::move((aOther).get_PFileDescriptorSetChild())));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TArrayOfFileDescriptor:
        {
            new (mozilla::KnownNotNull, ptr_ArrayOfFileDescriptor()) nsTArray<FileDescriptor>(std::move((aOther).get_ArrayOfFileDescriptor()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case Tvoid_t:
        {
            new (mozilla::KnownNotNull, ptr_void_t()) void_t(std::move((aOther).get_void_t()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

OptionalFileDescriptorSet::~OptionalFileDescriptorSet()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto OptionalFileDescriptorSet::operator=(PFileDescriptorSetParent* aRhs) -> OptionalFileDescriptorSet&
{
    if (MaybeDestroy(TPFileDescriptorSetParent)) {
        new (mozilla::KnownNotNull, ptr_PFileDescriptorSetParent()) PFileDescriptorSetParent*;
    }
    (*(ptr_PFileDescriptorSetParent())) = const_cast<PFileDescriptorSetParent*>(aRhs);
    mType = TPFileDescriptorSetParent;
    return (*(this));
}

auto OptionalFileDescriptorSet::operator=(PFileDescriptorSetChild* aRhs) -> OptionalFileDescriptorSet&
{
    if (MaybeDestroy(TPFileDescriptorSetChild)) {
        new (mozilla::KnownNotNull, ptr_PFileDescriptorSetChild()) PFileDescriptorSetChild*;
    }
    (*(ptr_PFileDescriptorSetChild())) = const_cast<PFileDescriptorSetChild*>(aRhs);
    mType = TPFileDescriptorSetChild;
    return (*(this));
}

auto OptionalFileDescriptorSet::operator=(const nsTArray<FileDescriptor>& aRhs) -> OptionalFileDescriptorSet&
{
    if (MaybeDestroy(TArrayOfFileDescriptor)) {
        new (mozilla::KnownNotNull, ptr_ArrayOfFileDescriptor()) nsTArray<FileDescriptor>;
    }
    (*(ptr_ArrayOfFileDescriptor())) = (aRhs).Clone();
    mType = TArrayOfFileDescriptor;
    return (*(this));
}

auto OptionalFileDescriptorSet::operator=(nsTArray<FileDescriptor>&& aRhs) -> OptionalFileDescriptorSet&
{
    if (MaybeDestroy(TArrayOfFileDescriptor)) {
        new (mozilla::KnownNotNull, ptr_ArrayOfFileDescriptor()) nsTArray<FileDescriptor>;
    }
    (*(ptr_ArrayOfFileDescriptor())) = std::move(aRhs);
    mType = TArrayOfFileDescriptor;
    return (*(this));
}

auto OptionalFileDescriptorSet::operator=(const void_t& aRhs) -> OptionalFileDescriptorSet&
{
    if (MaybeDestroy(Tvoid_t)) {
        new (mozilla::KnownNotNull, ptr_void_t()) void_t;
    }
    (*(ptr_void_t())) = aRhs;
    mType = Tvoid_t;
    return (*(this));
}

auto OptionalFileDescriptorSet::operator=(void_t&& aRhs) -> OptionalFileDescriptorSet&
{
    if (MaybeDestroy(Tvoid_t)) {
        new (mozilla::KnownNotNull, ptr_void_t()) void_t;
    }
    (*(ptr_void_t())) = std::move(aRhs);
    mType = Tvoid_t;
    return (*(this));
}

auto OptionalFileDescriptorSet::operator=(const OptionalFileDescriptorSet& aRhs) -> OptionalFileDescriptorSet&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TPFileDescriptorSetParent:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_PFileDescriptorSetParent()) PFileDescriptorSetParent*;
            }
            (*(ptr_PFileDescriptorSetParent())) = const_cast<PFileDescriptorSetParent*>((aRhs).get_PFileDescriptorSetParent());
            break;
        }
    case TPFileDescriptorSetChild:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_PFileDescriptorSetChild()) PFileDescriptorSetChild*;
            }
            (*(ptr_PFileDescriptorSetChild())) = const_cast<PFileDescriptorSetChild*>((aRhs).get_PFileDescriptorSetChild());
            break;
        }
    case TArrayOfFileDescriptor:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ArrayOfFileDescriptor()) nsTArray<FileDescriptor>;
            }
            (*(ptr_ArrayOfFileDescriptor())) = ((aRhs).get_ArrayOfFileDescriptor()).Clone();
            break;
        }
    case Tvoid_t:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_void_t()) void_t;
            }
            (*(ptr_void_t())) = (aRhs).get_void_t();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto OptionalFileDescriptorSet::operator=(OptionalFileDescriptorSet&& aRhs) -> OptionalFileDescriptorSet&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TPFileDescriptorSetParent:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_PFileDescriptorSetParent()) PFileDescriptorSetParent*;
            }
            (*(ptr_PFileDescriptorSetParent())) = const_cast<PFileDescriptorSetParent*>(std::move((aRhs).get_PFileDescriptorSetParent()));
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TPFileDescriptorSetChild:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_PFileDescriptorSetChild()) PFileDescriptorSetChild*;
            }
            (*(ptr_PFileDescriptorSetChild())) = const_cast<PFileDescriptorSetChild*>(std::move((aRhs).get_PFileDescriptorSetChild()));
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TArrayOfFileDescriptor:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ArrayOfFileDescriptor()) nsTArray<FileDescriptor>;
            }
            (*(ptr_ArrayOfFileDescriptor())) = std::move((aRhs).get_ArrayOfFileDescriptor());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case Tvoid_t:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_void_t()) void_t;
            }
            (*(ptr_void_t())) = std::move((aRhs).get_void_t());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::OptionalFileDescriptorSet>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::dom::OptionalFileDescriptorSet union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'OptionalFileDescriptorSet'
    (aMsg)->WriteSentinel(2173372946);

    switch (type) {
    case union__::TPFileDescriptorSetParent:
        {
            if ((mozilla::ipc::ParentSide) == ((aActor)->GetSide())) {
                MOZ_RELEASE_ASSERT((aVar).get_PFileDescriptorSetParent(), "NULL actor value passed to non-nullable param");
                WriteIPDLParam(aMsg, aActor, (aVar).get_PFileDescriptorSetParent());
                // Sentinel = 'TPFileDescriptorSetParent'
                (aMsg)->WriteSentinel(2078673370);
            }
            else {
                aActor->FatalError("wrong side!");
            }
            return;
        }
    case union__::TPFileDescriptorSetChild:
        {
            if ((mozilla::ipc::ChildSide) == ((aActor)->GetSide())) {
                MOZ_RELEASE_ASSERT((aVar).get_PFileDescriptorSetChild(), "NULL actor value passed to non-nullable param");
                WriteIPDLParam(aMsg, aActor, (aVar).get_PFileDescriptorSetChild());
                // Sentinel = 'TPFileDescriptorSetChild'
                (aMsg)->WriteSentinel(1909459284);
            }
            else {
                aActor->FatalError("wrong side!");
            }
            return;
        }
    case union__::TArrayOfFileDescriptor:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_ArrayOfFileDescriptor());
            // Sentinel = 'TArrayOfFileDescriptor'
            (aMsg)->WriteSentinel(1610418344);
            return;
        }
    case union__::Tvoid_t:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_void_t());
            // Sentinel = 'Tvoid_t'
            (aMsg)->WriteSentinel(189006554);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::dom::OptionalFileDescriptorSet>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::dom::OptionalFileDescriptorSet union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union OptionalFileDescriptorSet");
        return false;
    }
    // Sentinel = 'OptionalFileDescriptorSet'
    if ((!((aMsg)->ReadSentinel(aIter, 2173372946)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union OptionalFileDescriptorSet");
        return false;
    }

    switch (type) {
    case union__::TPFileDescriptorSetParent:
        {
            if ((mozilla::ipc::ParentSide) == ((aActor)->GetSide())) {
                {
                    aActor->FatalError("wrong side!");
                    return false;
                }
            }
            mozilla::ipc::PFileDescriptorSetChild* tmp = nullptr;
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_PFileDescriptorSetChild())))))) {
                aActor->FatalError("Error deserializing variant TPFileDescriptorSetParent of union OptionalFileDescriptorSet");
                return false;
            }
            if ((!((*((&((aVar)->get_PFileDescriptorSetChild()))))))) {
                aActor->FatalError("Error deserializing variant TPFileDescriptorSetParent of union OptionalFileDescriptorSet");
                return false;
            }
            // Sentinel = 'TPFileDescriptorSetParent'
            if ((!((aMsg)->ReadSentinel(aIter, 2078673370)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TPFileDescriptorSetParent of union OptionalFileDescriptorSet");
                return false;
            }
            return true;
        }
    case union__::TPFileDescriptorSetChild:
        {
            if ((mozilla::ipc::ChildSide) == ((aActor)->GetSide())) {
                {
                    aActor->FatalError("wrong side!");
                    return false;
                }
            }
            mozilla::ipc::PFileDescriptorSetParent* tmp = nullptr;
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_PFileDescriptorSetParent())))))) {
                aActor->FatalError("Error deserializing variant TPFileDescriptorSetChild of union OptionalFileDescriptorSet");
                return false;
            }
            if ((!((*((&((aVar)->get_PFileDescriptorSetParent()))))))) {
                aActor->FatalError("Error deserializing variant TPFileDescriptorSetChild of union OptionalFileDescriptorSet");
                return false;
            }
            // Sentinel = 'TPFileDescriptorSetChild'
            if ((!((aMsg)->ReadSentinel(aIter, 1909459284)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TPFileDescriptorSetChild of union OptionalFileDescriptorSet");
                return false;
            }
            return true;
        }
    case union__::TArrayOfFileDescriptor:
        {
            nsTArray<mozilla::ipc::FileDescriptor> tmp;
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_ArrayOfFileDescriptor())))))) {
                aActor->FatalError("Error deserializing variant TArrayOfFileDescriptor of union OptionalFileDescriptorSet");
                return false;
            }
            // Sentinel = 'TArrayOfFileDescriptor'
            if ((!((aMsg)->ReadSentinel(aIter, 1610418344)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TArrayOfFileDescriptor of union OptionalFileDescriptorSet");
                return false;
            }
            return true;
        }
    case union__::Tvoid_t:
        {
            mozilla::void_t tmp = mozilla::void_t();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_void_t())))))) {
                aActor->FatalError("Error deserializing variant Tvoid_t of union OptionalFileDescriptorSet");
                return false;
            }
            // Sentinel = 'Tvoid_t'
            if ((!((aMsg)->ReadSentinel(aIter, 189006554)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant Tvoid_t of union OptionalFileDescriptorSet");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla
