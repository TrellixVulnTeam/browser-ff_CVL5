//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/net/PSocketProcessParent.h"
#include "mozilla/ProfilerLabels.h"
#include "mozilla/ipc/URIUtils.h"
#include "mozilla/net/SocketProcessParent.h"
#include "nsID.h"

#include "mozilla/net/PDNSRequestParent.h"
#include "mozilla/net/PSocketProcessBridgeParent.h"
#include "mozilla/PProfilerParent.h"
#include "mozilla/net/PWebrtcTCPSocketParent.h"
#include "mozilla/net/PHttpTransactionParent.h"
#include "mozilla/net/PHttpConnectionMgrParent.h"
#include "mozilla/ipc/PFileDescriptorSetParent.h"
#include "mozilla/ipc/PChildToParentStreamParent.h"
#include "mozilla/ipc/PParentToChildStreamParent.h"
#include "mozilla/net/PInputChannelThrottleQueueParent.h"
#include "mozilla/ipc/PBackgroundParent.h"
#include "mozilla/net/PAltServiceParent.h"
#include "mozilla/net/PAltSvcTransactionParent.h"
#include "mozilla/net/PTRRServiceParent.h"
#include "mozilla/net/PProxyConfigLookupParent.h"
#include "mozilla/net/PNativeDNSResolverOverrideParent.h"
#include "mozilla/PRemoteLazyInputStreamParent.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace net {


auto PSocketProcessParent::RecvPWebrtcTCPSocketConstructor(
        PWebrtcTCPSocketParent* actor,
        const mozilla::Maybe<TabId>& tabId) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PSocketProcessParent::RecvPChildToParentStreamConstructor(PChildToParentStreamParent* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PSocketProcessParent::RecvPAltServiceConstructor(PAltServiceParent* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PSocketProcessParent::RecvPProxyConfigLookupConstructor(
        PProxyConfigLookupParent* actor,
        nsIURI* aUri,
        const uint32_t& aFlags) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PSocketProcessParent::RecvPFileDescriptorSetConstructor(
        PFileDescriptorSetParent* actor,
        const FileDescriptor& fd) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PSocketProcessParent::RecvPDNSRequestConstructor(
        PDNSRequestParent* actor,
        const nsCString& hostName,
        const nsCString& trrServer,
        const uint16_t& type,
        const OriginAttributes& originAttributes,
        const uint32_t& flags) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PSocketProcessParent::ProcessingError(
        Result aCode,
        const char* aReason) -> void
{
}

auto PSocketProcessParent::ShouldContinueFromReplyTimeout() -> bool
{
    return true;
}

auto PSocketProcessParent::EnteredCxxStack() -> void
{
}

auto PSocketProcessParent::ExitedCxxStack() -> void
{
}

auto PSocketProcessParent::EnteredCall() -> void
{
}

auto PSocketProcessParent::ExitedCall() -> void
{
}

MOZ_IMPLICIT PSocketProcessParent::PSocketProcessParent() :
    mozilla::ipc::IToplevelProtocol("PSocketProcessParent", PSocketProcessMsgStart, mozilla::ipc::ParentSide)
{
    MOZ_COUNT_CTOR(PSocketProcessParent);
}

PSocketProcessParent::~PSocketProcessParent()
{
    MOZ_COUNT_DTOR(PSocketProcessParent);
}

auto PSocketProcessParent::ManagedPDNSRequestParent(nsTArray<PDNSRequestParent*>& aArr) const -> void
{
    mManagedPDNSRequestParent.ToArray(aArr);
}

auto PSocketProcessParent::ManagedPDNSRequestParent() const -> const ManagedContainer<PDNSRequestParent>&
{
    return mManagedPDNSRequestParent;
}

auto PSocketProcessParent::ManagedPWebrtcTCPSocketParent(nsTArray<PWebrtcTCPSocketParent*>& aArr) const -> void
{
    mManagedPWebrtcTCPSocketParent.ToArray(aArr);
}

auto PSocketProcessParent::ManagedPWebrtcTCPSocketParent() const -> const ManagedContainer<PWebrtcTCPSocketParent>&
{
    return mManagedPWebrtcTCPSocketParent;
}

auto PSocketProcessParent::ManagedPFileDescriptorSetParent(nsTArray<PFileDescriptorSetParent*>& aArr) const -> void
{
    mManagedPFileDescriptorSetParent.ToArray(aArr);
}

auto PSocketProcessParent::ManagedPFileDescriptorSetParent() const -> const ManagedContainer<PFileDescriptorSetParent>&
{
    return mManagedPFileDescriptorSetParent;
}

auto PSocketProcessParent::ManagedPHttpTransactionParent(nsTArray<PHttpTransactionParent*>& aArr) const -> void
{
    mManagedPHttpTransactionParent.ToArray(aArr);
}

auto PSocketProcessParent::ManagedPHttpTransactionParent() const -> const ManagedContainer<PHttpTransactionParent>&
{
    return mManagedPHttpTransactionParent;
}

auto PSocketProcessParent::ManagedPHttpConnectionMgrParent(nsTArray<PHttpConnectionMgrParent*>& aArr) const -> void
{
    mManagedPHttpConnectionMgrParent.ToArray(aArr);
}

auto PSocketProcessParent::ManagedPHttpConnectionMgrParent() const -> const ManagedContainer<PHttpConnectionMgrParent>&
{
    return mManagedPHttpConnectionMgrParent;
}

auto PSocketProcessParent::ManagedPChildToParentStreamParent(nsTArray<PChildToParentStreamParent*>& aArr) const -> void
{
    mManagedPChildToParentStreamParent.ToArray(aArr);
}

auto PSocketProcessParent::ManagedPChildToParentStreamParent() const -> const ManagedContainer<PChildToParentStreamParent>&
{
    return mManagedPChildToParentStreamParent;
}

auto PSocketProcessParent::ManagedPParentToChildStreamParent(nsTArray<PParentToChildStreamParent*>& aArr) const -> void
{
    mManagedPParentToChildStreamParent.ToArray(aArr);
}

auto PSocketProcessParent::ManagedPParentToChildStreamParent() const -> const ManagedContainer<PParentToChildStreamParent>&
{
    return mManagedPParentToChildStreamParent;
}

auto PSocketProcessParent::ManagedPInputChannelThrottleQueueParent(nsTArray<PInputChannelThrottleQueueParent*>& aArr) const -> void
{
    mManagedPInputChannelThrottleQueueParent.ToArray(aArr);
}

auto PSocketProcessParent::ManagedPInputChannelThrottleQueueParent() const -> const ManagedContainer<PInputChannelThrottleQueueParent>&
{
    return mManagedPInputChannelThrottleQueueParent;
}

auto PSocketProcessParent::ManagedPAltServiceParent(nsTArray<PAltServiceParent*>& aArr) const -> void
{
    mManagedPAltServiceParent.ToArray(aArr);
}

auto PSocketProcessParent::ManagedPAltServiceParent() const -> const ManagedContainer<PAltServiceParent>&
{
    return mManagedPAltServiceParent;
}

auto PSocketProcessParent::ManagedPAltSvcTransactionParent(nsTArray<PAltSvcTransactionParent*>& aArr) const -> void
{
    mManagedPAltSvcTransactionParent.ToArray(aArr);
}

auto PSocketProcessParent::ManagedPAltSvcTransactionParent() const -> const ManagedContainer<PAltSvcTransactionParent>&
{
    return mManagedPAltSvcTransactionParent;
}

auto PSocketProcessParent::ManagedPTRRServiceParent(nsTArray<PTRRServiceParent*>& aArr) const -> void
{
    mManagedPTRRServiceParent.ToArray(aArr);
}

auto PSocketProcessParent::ManagedPTRRServiceParent() const -> const ManagedContainer<PTRRServiceParent>&
{
    return mManagedPTRRServiceParent;
}

auto PSocketProcessParent::ManagedPProxyConfigLookupParent(nsTArray<PProxyConfigLookupParent*>& aArr) const -> void
{
    mManagedPProxyConfigLookupParent.ToArray(aArr);
}

auto PSocketProcessParent::ManagedPProxyConfigLookupParent() const -> const ManagedContainer<PProxyConfigLookupParent>&
{
    return mManagedPProxyConfigLookupParent;
}

auto PSocketProcessParent::ManagedPNativeDNSResolverOverrideParent(nsTArray<PNativeDNSResolverOverrideParent*>& aArr) const -> void
{
    mManagedPNativeDNSResolverOverrideParent.ToArray(aArr);
}

auto PSocketProcessParent::ManagedPNativeDNSResolverOverrideParent() const -> const ManagedContainer<PNativeDNSResolverOverrideParent>&
{
    return mManagedPNativeDNSResolverOverrideParent;
}

auto PSocketProcessParent::ManagedPRemoteLazyInputStreamParent(nsTArray<PRemoteLazyInputStreamParent*>& aArr) const -> void
{
    mManagedPRemoteLazyInputStreamParent.ToArray(aArr);
}

auto PSocketProcessParent::ManagedPRemoteLazyInputStreamParent() const -> const ManagedContainer<PRemoteLazyInputStreamParent>&
{
    return mManagedPRemoteLazyInputStreamParent;
}

auto PSocketProcessParent::AllManagedActors(nsTArray<RefPtr<mozilla::ipc::ActorLifecycleProxy>>& arr__) const -> void
{
    uint32_t total = 0;
    total += mManagedPDNSRequestParent.Count();
    total += mManagedPWebrtcTCPSocketParent.Count();
    total += mManagedPFileDescriptorSetParent.Count();
    total += mManagedPHttpTransactionParent.Count();
    total += mManagedPHttpConnectionMgrParent.Count();
    total += mManagedPChildToParentStreamParent.Count();
    total += mManagedPParentToChildStreamParent.Count();
    total += mManagedPInputChannelThrottleQueueParent.Count();
    total += mManagedPAltServiceParent.Count();
    total += mManagedPAltSvcTransactionParent.Count();
    total += mManagedPTRRServiceParent.Count();
    total += mManagedPProxyConfigLookupParent.Count();
    total += mManagedPNativeDNSResolverOverrideParent.Count();
    total += mManagedPRemoteLazyInputStreamParent.Count();
    arr__.SetCapacity(total);

    for (auto it = mManagedPDNSRequestParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPWebrtcTCPSocketParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPFileDescriptorSetParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPHttpTransactionParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPHttpConnectionMgrParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPChildToParentStreamParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPParentToChildStreamParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPInputChannelThrottleQueueParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPAltServiceParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPAltSvcTransactionParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPTRRServiceParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPProxyConfigLookupParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPNativeDNSResolverOverrideParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPRemoteLazyInputStreamParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

}

auto PSocketProcessParent::OpenPDNSRequestEndpoint(PDNSRequestParent* aActor) -> ManagedEndpoint<PDNSRequestChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PDNSRequestParent actor");
        return ManagedEndpoint<PDNSRequestChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPDNSRequestParent.PutEntry(aActor);

    return ManagedEndpoint<PDNSRequestChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessParent::BindPDNSRequestEndpoint(
        ManagedEndpoint<PDNSRequestParent> aEndpoint,
        PDNSRequestParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PDNSRequestParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPDNSRequestParent.PutEntry(aActor);

    return true;
}

auto PSocketProcessParent::OpenPWebrtcTCPSocketEndpoint(PWebrtcTCPSocketParent* aActor) -> ManagedEndpoint<PWebrtcTCPSocketChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebrtcTCPSocketParent actor");
        return ManagedEndpoint<PWebrtcTCPSocketChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPWebrtcTCPSocketParent.PutEntry(aActor);

    return ManagedEndpoint<PWebrtcTCPSocketChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessParent::BindPWebrtcTCPSocketEndpoint(
        ManagedEndpoint<PWebrtcTCPSocketParent> aEndpoint,
        PWebrtcTCPSocketParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebrtcTCPSocketParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPWebrtcTCPSocketParent.PutEntry(aActor);

    return true;
}

auto PSocketProcessParent::OpenPFileDescriptorSetEndpoint(PFileDescriptorSetParent* aActor) -> ManagedEndpoint<PFileDescriptorSetChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PFileDescriptorSetParent actor");
        return ManagedEndpoint<PFileDescriptorSetChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPFileDescriptorSetParent.PutEntry(aActor);

    return ManagedEndpoint<PFileDescriptorSetChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessParent::BindPFileDescriptorSetEndpoint(
        ManagedEndpoint<PFileDescriptorSetParent> aEndpoint,
        PFileDescriptorSetParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PFileDescriptorSetParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPFileDescriptorSetParent.PutEntry(aActor);

    return true;
}

auto PSocketProcessParent::OpenPHttpTransactionEndpoint(PHttpTransactionParent* aActor) -> ManagedEndpoint<PHttpTransactionChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PHttpTransactionParent actor");
        return ManagedEndpoint<PHttpTransactionChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPHttpTransactionParent.PutEntry(aActor);

    return ManagedEndpoint<PHttpTransactionChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessParent::BindPHttpTransactionEndpoint(
        ManagedEndpoint<PHttpTransactionParent> aEndpoint,
        PHttpTransactionParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PHttpTransactionParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPHttpTransactionParent.PutEntry(aActor);

    return true;
}

auto PSocketProcessParent::OpenPHttpConnectionMgrEndpoint(PHttpConnectionMgrParent* aActor) -> ManagedEndpoint<PHttpConnectionMgrChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PHttpConnectionMgrParent actor");
        return ManagedEndpoint<PHttpConnectionMgrChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPHttpConnectionMgrParent.PutEntry(aActor);

    return ManagedEndpoint<PHttpConnectionMgrChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessParent::BindPHttpConnectionMgrEndpoint(
        ManagedEndpoint<PHttpConnectionMgrParent> aEndpoint,
        PHttpConnectionMgrParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PHttpConnectionMgrParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPHttpConnectionMgrParent.PutEntry(aActor);

    return true;
}

auto PSocketProcessParent::OpenPChildToParentStreamEndpoint(PChildToParentStreamParent* aActor) -> ManagedEndpoint<PChildToParentStreamChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PChildToParentStreamParent actor");
        return ManagedEndpoint<PChildToParentStreamChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPChildToParentStreamParent.PutEntry(aActor);

    return ManagedEndpoint<PChildToParentStreamChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessParent::BindPChildToParentStreamEndpoint(
        ManagedEndpoint<PChildToParentStreamParent> aEndpoint,
        PChildToParentStreamParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PChildToParentStreamParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPChildToParentStreamParent.PutEntry(aActor);

    return true;
}

auto PSocketProcessParent::OpenPParentToChildStreamEndpoint(PParentToChildStreamParent* aActor) -> ManagedEndpoint<PParentToChildStreamChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PParentToChildStreamParent actor");
        return ManagedEndpoint<PParentToChildStreamChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPParentToChildStreamParent.PutEntry(aActor);

    return ManagedEndpoint<PParentToChildStreamChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessParent::BindPParentToChildStreamEndpoint(
        ManagedEndpoint<PParentToChildStreamParent> aEndpoint,
        PParentToChildStreamParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PParentToChildStreamParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPParentToChildStreamParent.PutEntry(aActor);

    return true;
}

auto PSocketProcessParent::OpenPInputChannelThrottleQueueEndpoint(PInputChannelThrottleQueueParent* aActor) -> ManagedEndpoint<PInputChannelThrottleQueueChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PInputChannelThrottleQueueParent actor");
        return ManagedEndpoint<PInputChannelThrottleQueueChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPInputChannelThrottleQueueParent.PutEntry(aActor);

    return ManagedEndpoint<PInputChannelThrottleQueueChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessParent::BindPInputChannelThrottleQueueEndpoint(
        ManagedEndpoint<PInputChannelThrottleQueueParent> aEndpoint,
        PInputChannelThrottleQueueParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PInputChannelThrottleQueueParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPInputChannelThrottleQueueParent.PutEntry(aActor);

    return true;
}

auto PSocketProcessParent::OpenPAltServiceEndpoint(PAltServiceParent* aActor) -> ManagedEndpoint<PAltServiceChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PAltServiceParent actor");
        return ManagedEndpoint<PAltServiceChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPAltServiceParent.PutEntry(aActor);

    return ManagedEndpoint<PAltServiceChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessParent::BindPAltServiceEndpoint(
        ManagedEndpoint<PAltServiceParent> aEndpoint,
        PAltServiceParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PAltServiceParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPAltServiceParent.PutEntry(aActor);

    return true;
}

auto PSocketProcessParent::OpenPAltSvcTransactionEndpoint(PAltSvcTransactionParent* aActor) -> ManagedEndpoint<PAltSvcTransactionChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PAltSvcTransactionParent actor");
        return ManagedEndpoint<PAltSvcTransactionChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPAltSvcTransactionParent.PutEntry(aActor);

    return ManagedEndpoint<PAltSvcTransactionChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessParent::BindPAltSvcTransactionEndpoint(
        ManagedEndpoint<PAltSvcTransactionParent> aEndpoint,
        PAltSvcTransactionParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PAltSvcTransactionParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPAltSvcTransactionParent.PutEntry(aActor);

    return true;
}

auto PSocketProcessParent::OpenPTRRServiceEndpoint(PTRRServiceParent* aActor) -> ManagedEndpoint<PTRRServiceChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PTRRServiceParent actor");
        return ManagedEndpoint<PTRRServiceChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPTRRServiceParent.PutEntry(aActor);

    return ManagedEndpoint<PTRRServiceChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessParent::BindPTRRServiceEndpoint(
        ManagedEndpoint<PTRRServiceParent> aEndpoint,
        PTRRServiceParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PTRRServiceParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPTRRServiceParent.PutEntry(aActor);

    return true;
}

auto PSocketProcessParent::OpenPProxyConfigLookupEndpoint(PProxyConfigLookupParent* aActor) -> ManagedEndpoint<PProxyConfigLookupChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PProxyConfigLookupParent actor");
        return ManagedEndpoint<PProxyConfigLookupChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPProxyConfigLookupParent.PutEntry(aActor);

    return ManagedEndpoint<PProxyConfigLookupChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessParent::BindPProxyConfigLookupEndpoint(
        ManagedEndpoint<PProxyConfigLookupParent> aEndpoint,
        PProxyConfigLookupParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PProxyConfigLookupParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPProxyConfigLookupParent.PutEntry(aActor);

    return true;
}

auto PSocketProcessParent::OpenPNativeDNSResolverOverrideEndpoint(PNativeDNSResolverOverrideParent* aActor) -> ManagedEndpoint<PNativeDNSResolverOverrideChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PNativeDNSResolverOverrideParent actor");
        return ManagedEndpoint<PNativeDNSResolverOverrideChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPNativeDNSResolverOverrideParent.PutEntry(aActor);

    return ManagedEndpoint<PNativeDNSResolverOverrideChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessParent::BindPNativeDNSResolverOverrideEndpoint(
        ManagedEndpoint<PNativeDNSResolverOverrideParent> aEndpoint,
        PNativeDNSResolverOverrideParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PNativeDNSResolverOverrideParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPNativeDNSResolverOverrideParent.PutEntry(aActor);

    return true;
}

auto PSocketProcessParent::OpenPRemoteLazyInputStreamEndpoint(PRemoteLazyInputStreamParent* aActor) -> ManagedEndpoint<PRemoteLazyInputStreamChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PRemoteLazyInputStreamParent actor");
        return ManagedEndpoint<PRemoteLazyInputStreamChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPRemoteLazyInputStreamParent.PutEntry(aActor);

    return ManagedEndpoint<PRemoteLazyInputStreamChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PSocketProcessParent::BindPRemoteLazyInputStreamEndpoint(
        ManagedEndpoint<PRemoteLazyInputStreamParent> aEndpoint,
        PRemoteLazyInputStreamParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PRemoteLazyInputStreamParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPRemoteLazyInputStreamParent.PutEntry(aActor);

    return true;
}

auto PSocketProcessParent::SendInit(const SocketPorcessInitAttributes& aAttributes) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_Init(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, aAttributes);
    // Sentinel = 'aAttributes'
    (msg__)->WriteSentinel(442434697);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_Init", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessParent::SendPreferenceUpdate(const Pref& pref) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_PreferenceUpdate(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, pref);
    // Sentinel = 'pref'
    (msg__)->WriteSentinel(71958958);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_PreferenceUpdate", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessParent::SendRequestMemoryReport(
        const uint32_t& generation,
        const bool& anonymize,
        const bool& minimizeMemoryUsage,
        const mozilla::Maybe<FileDescriptor>& DMDFile,
        mozilla::ipc::ResolveCallback<uint32_t>&& aResolve,
        mozilla::ipc::RejectCallback&& aReject) -> void
{
    IPC::Message* msg__ = PSocketProcess::Msg_RequestMemoryReport(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, generation);
    // Sentinel = 'generation'
    (msg__)->WriteSentinel(381158445);
    WriteIPDLParam(msg__, this, anonymize);
    // Sentinel = 'anonymize'
    (msg__)->WriteSentinel(321127387);
    WriteIPDLParam(msg__, this, minimizeMemoryUsage);
    // Sentinel = 'minimizeMemoryUsage'
    (msg__)->WriteSentinel(1321600977);
    WriteIPDLParam(msg__, this, DMDFile);
    // Sentinel = 'DMDFile'
    (msg__)->WriteSentinel(143983190);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_RequestMemoryReport", OTHER);

    ChannelSend(msg__, std::move(aResolve), std::move(aReject));
    return;
}

auto PSocketProcessParent::SendRequestMemoryReport(
        const uint32_t& generation,
        const bool& anonymize,
        const bool& minimizeMemoryUsage,
        const mozilla::Maybe<FileDescriptor>& DMDFile) -> RefPtr<RequestMemoryReportPromise>
{
    RefPtr<MozPromise<uint32_t, ResponseRejectReason, true>::Private> promise__ = new MozPromise<uint32_t, ResponseRejectReason, true>::Private(__func__);
    promise__->UseDirectTaskDispatch(__func__);
    SendRequestMemoryReport(std::move(generation), std::move(anonymize), std::move(minimizeMemoryUsage), std::move(DMDFile), [promise__](uint32_t&& aValue) {
        promise__->Resolve(std::move(aValue), __func__);
    }, [promise__](ResponseRejectReason&& aReason) {
        promise__->Reject(std::move(aReason), __func__);
    });
    return promise__;
}

auto PSocketProcessParent::SendSetOffline(const bool& offline) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_SetOffline(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, offline);
    // Sentinel = 'offline'
    (msg__)->WriteSentinel(194904804);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_SetOffline", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessParent::SendSetConnectivity(const bool& connectivity) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_SetConnectivity(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, connectivity);
    // Sentinel = 'connectivity'
    (msg__)->WriteSentinel(548734240);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_SetConnectivity", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessParent::SendInitLinuxSandbox(const mozilla::Maybe<FileDescriptor>& sandboxBroker) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_InitLinuxSandbox(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, sandboxBroker);
    // Sentinel = 'sandboxBroker'
    (msg__)->WriteSentinel(625149269);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_InitLinuxSandbox", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessParent::SendInitSocketProcessBridgeParent(
        const ProcessId& processId,
        Endpoint<mozilla::net::PSocketProcessBridgeParent>&& endpoint) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_InitSocketProcessBridgeParent(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, processId);
    // Sentinel = 'processId'
    (msg__)->WriteSentinel(318243757);
    WriteIPDLParam(msg__, this, std::move(endpoint));
    // Sentinel = 'endpoint'
    (msg__)->WriteSentinel(251724642);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_InitSocketProcessBridgeParent", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessParent::SendInitProfiler(Endpoint<mozilla::PProfilerChild>&& aEndpoint) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_InitProfiler(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, std::move(aEndpoint));
    // Sentinel = 'aEndpoint'
    (msg__)->WriteSentinel(292225955);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_InitProfiler", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessParent::SendSocketProcessTelemetryPing() -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_SocketProcessTelemetryPing(MSG_ROUTING_CONTROL);





    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_SocketProcessTelemetryPing", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessParent::SendPHttpTransactionConstructor(PHttpTransactionParent* actor) -> PHttpTransactionParent*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PHttpTransactionParent actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPHttpTransactionParent.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PSocketProcess::Msg_PHttpTransactionConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_PHttpTransactionConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PHttpTransactionParent constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PHttpTransactionMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PSocketProcessParent::SendPParentToChildStreamConstructor() -> PParentToChildStreamParent*
{
    PParentToChildStreamParent* actor = (static_cast<SocketProcessParent*>(this))->AllocPParentToChildStreamParent();
    return SendPParentToChildStreamConstructor(actor);
}

auto PSocketProcessParent::SendPParentToChildStreamConstructor(PParentToChildStreamParent* actor) -> PParentToChildStreamParent*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PParentToChildStreamParent actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPParentToChildStreamParent.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PSocketProcess::Msg_PParentToChildStreamConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_PParentToChildStreamConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PParentToChildStreamParent constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PParentToChildStreamMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PSocketProcessParent::SendPHttpConnectionMgrConstructor(
        PHttpConnectionMgrParent* actor,
        const HttpHandlerInitArgs& aArgs) -> PHttpConnectionMgrParent*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PHttpConnectionMgrParent actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPHttpConnectionMgrParent.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PSocketProcess::Msg_PHttpConnectionMgrConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, aArgs);
    // Sentinel = 'aArgs'
    (msg__)->WriteSentinel(92602863);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_PHttpConnectionMgrConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PHttpConnectionMgrParent constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PHttpConnectionMgrMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PSocketProcessParent::SendUpdateDeviceModelId(const nsCString& aModelId) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_UpdateDeviceModelId(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, aModelId);
    // Sentinel = 'aModelId'
    (msg__)->WriteSentinel(226951936);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_UpdateDeviceModelId", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessParent::SendOnHttpActivityDistributorActivated(const bool& aIsActivated) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_OnHttpActivityDistributorActivated(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, aIsActivated);
    // Sentinel = 'aIsActivated'
    (msg__)->WriteSentinel(496501939);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_OnHttpActivityDistributorActivated", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessParent::SendPInputChannelThrottleQueueConstructor(
        PInputChannelThrottleQueueParent* actor,
        const uint32_t& meanBytesPerSecond,
        const uint32_t& maxBytesPerSecond) -> PInputChannelThrottleQueueParent*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PInputChannelThrottleQueueParent actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPInputChannelThrottleQueueParent.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PSocketProcess::Msg_PInputChannelThrottleQueueConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, meanBytesPerSecond);
    // Sentinel = 'meanBytesPerSecond'
    (msg__)->WriteSentinel(1142097708);
    WriteIPDLParam(msg__, this, maxBytesPerSecond);
    // Sentinel = 'maxBytesPerSecond'
    (msg__)->WriteSentinel(1032193745);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_PInputChannelThrottleQueueConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PInputChannelThrottleQueueParent constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PInputChannelThrottleQueueMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PSocketProcessParent::SendPAltSvcTransactionConstructor(
        PAltSvcTransactionParent* actor,
        const HttpConnectionInfoCloneArgs& aConnInfo,
        const uint32_t& aCaps) -> PAltSvcTransactionParent*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PAltSvcTransactionParent actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPAltSvcTransactionParent.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PSocketProcess::Msg_PAltSvcTransactionConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, aConnInfo);
    // Sentinel = 'aConnInfo'
    (msg__)->WriteSentinel(284558204);
    WriteIPDLParam(msg__, this, aCaps);
    // Sentinel = 'aCaps'
    (msg__)->WriteSentinel(90964457);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_PAltSvcTransactionConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PAltSvcTransactionParent constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PAltSvcTransactionMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PSocketProcessParent::SendClearSessionCache() -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_ClearSessionCache(MSG_ROUTING_CONTROL);





    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_ClearSessionCache", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessParent::SendPTRRServiceConstructor(
        PTRRServiceParent* actor,
        const bool& aCaptiveIsPassed,
        const bool& aParentalControlEnabled,
        const nsTArray<nsCString>& aDNSSuffixList) -> PTRRServiceParent*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PTRRServiceParent actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPTRRServiceParent.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PSocketProcess::Msg_PTRRServiceConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, aCaptiveIsPassed);
    // Sentinel = 'aCaptiveIsPassed'
    (msg__)->WriteSentinel(883689034);
    WriteIPDLParam(msg__, this, aParentalControlEnabled);
    // Sentinel = 'aParentalControlEnabled'
    (msg__)->WriteSentinel(1835010341);
    WriteIPDLParam(msg__, this, aDNSSuffixList);
    // Sentinel = 'aDNSSuffixList'
    (msg__)->WriteSentinel(636552536);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_PTRRServiceConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PTRRServiceParent constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PTRRServiceMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PSocketProcessParent::SendPNativeDNSResolverOverrideConstructor(PNativeDNSResolverOverrideParent* actor) -> PNativeDNSResolverOverrideParent*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PNativeDNSResolverOverrideParent actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPNativeDNSResolverOverrideParent.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PSocketProcess::Msg_PNativeDNSResolverOverrideConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_PNativeDNSResolverOverrideConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PNativeDNSResolverOverrideParent constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PNativeDNSResolverOverrideMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PSocketProcessParent::SendNotifyObserver(
        const nsCString& aTopic,
        const nsString& aData) -> bool
{
    IPC::Message* msg__ = PSocketProcess::Msg_NotifyObserver(MSG_ROUTING_CONTROL);

    WriteIPDLParam(msg__, this, aTopic);
    // Sentinel = 'aTopic'
    (msg__)->WriteSentinel(137429601);
    WriteIPDLParam(msg__, this, aData);
    // Sentinel = 'aData'
    (msg__)->WriteSentinel(90571228);




    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_NotifyObserver", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PSocketProcessParent::SendPRemoteLazyInputStreamConstructor(
        PRemoteLazyInputStreamParent* actor,
        const nsID& aID,
        const uint64_t& aSize) -> PRemoteLazyInputStreamParent*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PRemoteLazyInputStreamParent actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPRemoteLazyInputStreamParent.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PSocketProcess::Msg_PRemoteLazyInputStreamConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, aID);
    // Sentinel = 'aID'
    (msg__)->WriteSentinel(33292527);
    WriteIPDLParam(msg__, this, aSize);
    // Sentinel = 'aSize'
    (msg__)->WriteSentinel(97124861);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_PRemoteLazyInputStreamConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PRemoteLazyInputStreamParent constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PRemoteLazyInputStreamMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PSocketProcessParent::SendGetSocketData(
        mozilla::ipc::ResolveCallback<SocketDataArgs>&& aResolve,
        mozilla::ipc::RejectCallback&& aReject) -> void
{
    IPC::Message* msg__ = PSocketProcess::Msg_GetSocketData(MSG_ROUTING_CONTROL);





    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_GetSocketData", OTHER);

    ChannelSend(msg__, std::move(aResolve), std::move(aReject));
    return;
}

auto PSocketProcessParent::SendGetSocketData() -> RefPtr<GetSocketDataPromise>
{
    RefPtr<MozPromise<SocketDataArgs, ResponseRejectReason, true>::Private> promise__ = new MozPromise<SocketDataArgs, ResponseRejectReason, true>::Private(__func__);
    promise__->UseDirectTaskDispatch(__func__);
    SendGetSocketData([promise__](SocketDataArgs&& aValue) {
        promise__->Resolve(std::move(aValue), __func__);
    }, [promise__](ResponseRejectReason&& aReason) {
        promise__->Reject(std::move(aReason), __func__);
    });
    return promise__;
}

auto PSocketProcessParent::SendGetDNSCacheEntries(
        mozilla::ipc::ResolveCallback<nsTArray<DNSCacheEntries>>&& aResolve,
        mozilla::ipc::RejectCallback&& aReject) -> void
{
    IPC::Message* msg__ = PSocketProcess::Msg_GetDNSCacheEntries(MSG_ROUTING_CONTROL);





    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_GetDNSCacheEntries", OTHER);

    ChannelSend(msg__, std::move(aResolve), std::move(aReject));
    return;
}

auto PSocketProcessParent::SendGetDNSCacheEntries() -> RefPtr<GetDNSCacheEntriesPromise>
{
    RefPtr<MozPromise<nsTArray<DNSCacheEntries>, ResponseRejectReason, true>::Private> promise__ = new MozPromise<nsTArray<DNSCacheEntries>, ResponseRejectReason, true>::Private(__func__);
    promise__->UseDirectTaskDispatch(__func__);
    SendGetDNSCacheEntries([promise__](nsTArray<DNSCacheEntries>&& aValue) {
        promise__->Resolve(std::move(aValue), __func__);
    }, [promise__](ResponseRejectReason&& aReason) {
        promise__->Reject(std::move(aReason), __func__);
    });
    return promise__;
}

auto PSocketProcessParent::SendGetHttpConnectionData(
        mozilla::ipc::ResolveCallback<nsTArray<HttpRetParams>>&& aResolve,
        mozilla::ipc::RejectCallback&& aReject) -> void
{
    IPC::Message* msg__ = PSocketProcess::Msg_GetHttpConnectionData(MSG_ROUTING_CONTROL);





    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_GetHttpConnectionData", OTHER);

    ChannelSend(msg__, std::move(aResolve), std::move(aReject));
    return;
}

auto PSocketProcessParent::SendGetHttpConnectionData() -> RefPtr<GetHttpConnectionDataPromise>
{
    RefPtr<MozPromise<nsTArray<HttpRetParams>, ResponseRejectReason, true>::Private> promise__ = new MozPromise<nsTArray<HttpRetParams>, ResponseRejectReason, true>::Private(__func__);
    promise__->UseDirectTaskDispatch(__func__);
    SendGetHttpConnectionData([promise__](nsTArray<HttpRetParams>&& aValue) {
        promise__->Resolve(std::move(aValue), __func__);
    }, [promise__](ResponseRejectReason&& aReason) {
        promise__->Reject(std::move(aReason), __func__);
    });
    return promise__;
}

auto PSocketProcessParent::SendPFileDescriptorSetConstructor(const FileDescriptor& fd) -> PFileDescriptorSetParent*
{
    PFileDescriptorSetParent* actor = (static_cast<SocketProcessParent*>(this))->AllocPFileDescriptorSetParent(fd);
    return SendPFileDescriptorSetConstructor(actor, fd);
}

auto PSocketProcessParent::SendPFileDescriptorSetConstructor(
        PFileDescriptorSetParent* actor,
        const FileDescriptor& fd) -> PFileDescriptorSetParent*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PFileDescriptorSetParent actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPFileDescriptorSetParent.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PSocketProcess::Msg_PFileDescriptorSetConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, fd);
    // Sentinel = 'fd'
    (msg__)->WriteSentinel(20054219);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_PFileDescriptorSetConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PFileDescriptorSetParent constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PFileDescriptorSetMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PSocketProcessParent::SendPDNSRequestConstructor(
        PDNSRequestParent* actor,
        const nsCString& hostName,
        const nsCString& trrServer,
        const uint16_t& type,
        const OriginAttributes& originAttributes,
        const uint32_t& flags) -> PDNSRequestParent*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PDNSRequestParent actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPDNSRequestParent.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PSocketProcess::Msg_PDNSRequestConstructor(MSG_ROUTING_CONTROL);

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, hostName);
    // Sentinel = 'hostName'
    (msg__)->WriteSentinel(249627456);
    WriteIPDLParam(msg__, this, trrServer);
    // Sentinel = 'trrServer'
    (msg__)->WriteSentinel(320603088);
    WriteIPDLParam(msg__, this, type);
    // Sentinel = 'type'
    (msg__)->WriteSentinel(75760067);
    WriteIPDLParam(msg__, this, originAttributes);
    // Sentinel = 'originAttributes'
    (msg__)->WriteSentinel(947259056);
    WriteIPDLParam(msg__, this, flags);
    // Sentinel = 'flags'
    (msg__)->WriteSentinel(102171150);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PSocketProcessParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PSocketProcess::Msg_PDNSRequestConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PDNSRequestParent constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PDNSRequestMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PSocketProcessParent::RemoveManagee(
        int32_t aProtocolId,
        IProtocol* aListener) -> void
{
    switch (aProtocolId) {
    case PDNSRequestMsgStart:
{
            PDNSRequestParent* actor = static_cast<PDNSRequestParent*>(aListener);
            auto& container = mManagedPDNSRequestParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PWebrtcTCPSocketMsgStart:
{
            PWebrtcTCPSocketParent* actor = static_cast<PWebrtcTCPSocketParent*>(aListener);
            auto& container = mManagedPWebrtcTCPSocketParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PFileDescriptorSetMsgStart:
{
            PFileDescriptorSetParent* actor = static_cast<PFileDescriptorSetParent*>(aListener);
            auto& container = mManagedPFileDescriptorSetParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PHttpTransactionMsgStart:
{
            PHttpTransactionParent* actor = static_cast<PHttpTransactionParent*>(aListener);
            auto& container = mManagedPHttpTransactionParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PHttpConnectionMgrMsgStart:
{
            PHttpConnectionMgrParent* actor = static_cast<PHttpConnectionMgrParent*>(aListener);
            auto& container = mManagedPHttpConnectionMgrParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PChildToParentStreamMsgStart:
{
            PChildToParentStreamParent* actor = static_cast<PChildToParentStreamParent*>(aListener);
            auto& container = mManagedPChildToParentStreamParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PParentToChildStreamMsgStart:
{
            PParentToChildStreamParent* actor = static_cast<PParentToChildStreamParent*>(aListener);
            auto& container = mManagedPParentToChildStreamParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PInputChannelThrottleQueueMsgStart:
{
            PInputChannelThrottleQueueParent* actor = static_cast<PInputChannelThrottleQueueParent*>(aListener);
            auto& container = mManagedPInputChannelThrottleQueueParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PAltServiceMsgStart:
{
            PAltServiceParent* actor = static_cast<PAltServiceParent*>(aListener);
            auto& container = mManagedPAltServiceParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PAltSvcTransactionMsgStart:
{
            PAltSvcTransactionParent* actor = static_cast<PAltSvcTransactionParent*>(aListener);
            auto& container = mManagedPAltSvcTransactionParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PTRRServiceMsgStart:
{
            PTRRServiceParent* actor = static_cast<PTRRServiceParent*>(aListener);
            auto& container = mManagedPTRRServiceParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PProxyConfigLookupMsgStart:
{
            PProxyConfigLookupParent* actor = static_cast<PProxyConfigLookupParent*>(aListener);
            auto& container = mManagedPProxyConfigLookupParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PNativeDNSResolverOverrideMsgStart:
{
            PNativeDNSResolverOverrideParent* actor = static_cast<PNativeDNSResolverOverrideParent*>(aListener);
            auto& container = mManagedPNativeDNSResolverOverrideParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PRemoteLazyInputStreamMsgStart:
{
            PRemoteLazyInputStreamParent* actor = static_cast<PRemoteLazyInputStreamParent*>(aListener);
            auto& container = mManagedPRemoteLazyInputStreamParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    default:
FatalError("unreached");
        return;    }
}

auto PSocketProcessParent::DeallocManagee(
        int32_t aProtocolId,
        IProtocol* aListener) -> void
{
    switch (aProtocolId) {
    case PWebrtcTCPSocketMsgStart:
        static_cast<SocketProcessParent*>(this)->DeallocPWebrtcTCPSocketParent(static_cast<PWebrtcTCPSocketParent*>(aListener));
        return;
    case PFileDescriptorSetMsgStart:
        static_cast<SocketProcessParent*>(this)->DeallocPFileDescriptorSetParent(static_cast<PFileDescriptorSetParent*>(aListener));
        return;
    case PChildToParentStreamMsgStart:
        static_cast<SocketProcessParent*>(this)->DeallocPChildToParentStreamParent(static_cast<PChildToParentStreamParent*>(aListener));
        return;
    case PParentToChildStreamMsgStart:
        static_cast<SocketProcessParent*>(this)->DeallocPParentToChildStreamParent(static_cast<PParentToChildStreamParent*>(aListener));
        return;
    default:
        FatalError("unreached");
        return;
    }
}

auto PSocketProcessParent::OnMessageReceived(const Message& msg__) -> PSocketProcessParent::Result
{
    int32_t route__ = msg__.routing_id();
    if (MSG_ROUTING_CONTROL != route__) {
        IProtocol* routed__ = Lookup(route__);
        if (!routed__ || !routed__->GetLifecycleProxy()) {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Ignored message for dead actor",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eSending);
            }

            return MsgProcessed;
        }

        RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
            routed__->GetLifecycleProxy();
        return proxy__->Get()->OnMessageReceived(msg__);
    }

    switch (msg__.type()) {
    case PSocketProcess::Msg_InitCrashReporter__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_InitCrashReporter", OTHER);

            PickleIterator iter__{msg__};
            NativeThreadId threadId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(threadId)))))) {
                FatalError("Error deserializing 'NativeThreadId'");
                return MsgValueError;
            }
            // Sentinel = 'threadId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 248185638)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'NativeThreadId'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessParent*>(this))->RecvInitCrashReporter(std::move(threadId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_AddMemoryReport__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_AddMemoryReport", OTHER);

            PickleIterator iter__{msg__};
            MemoryReport aReport{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aReport)))))) {
                FatalError("Error deserializing 'MemoryReport'");
                return MsgValueError;
            }
            // Sentinel = 'aReport'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 184025822)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'MemoryReport'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessParent*>(this))->RecvAddMemoryReport(std::move(aReport))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_AccumulateChildHistograms__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_AccumulateChildHistograms", OTHER);

            PickleIterator iter__{msg__};
            nsTArray<HistogramAccumulation> accumulations{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(accumulations)))))) {
                FatalError("Error deserializing 'HistogramAccumulation[]'");
                return MsgValueError;
            }
            // Sentinel = 'accumulations'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 632030585)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'HistogramAccumulation[]'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessParent*>(this))->RecvAccumulateChildHistograms(std::move(accumulations))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_AccumulateChildKeyedHistograms__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_AccumulateChildKeyedHistograms", OTHER);

            PickleIterator iter__{msg__};
            nsTArray<KeyedHistogramAccumulation> accumulations{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(accumulations)))))) {
                FatalError("Error deserializing 'KeyedHistogramAccumulation[]'");
                return MsgValueError;
            }
            // Sentinel = 'accumulations'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 632030585)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'KeyedHistogramAccumulation[]'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessParent*>(this))->RecvAccumulateChildKeyedHistograms(std::move(accumulations))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_UpdateChildScalars__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_UpdateChildScalars", OTHER);

            PickleIterator iter__{msg__};
            nsTArray<ScalarAction> actions{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(actions)))))) {
                FatalError("Error deserializing 'ScalarAction[]'");
                return MsgValueError;
            }
            // Sentinel = 'actions'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 193200882)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ScalarAction[]'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessParent*>(this))->RecvUpdateChildScalars(std::move(actions))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_UpdateChildKeyedScalars__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_UpdateChildKeyedScalars", OTHER);

            PickleIterator iter__{msg__};
            nsTArray<KeyedScalarAction> actions{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(actions)))))) {
                FatalError("Error deserializing 'KeyedScalarAction[]'");
                return MsgValueError;
            }
            // Sentinel = 'actions'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 193200882)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'KeyedScalarAction[]'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessParent*>(this))->RecvUpdateChildKeyedScalars(std::move(actions))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_RecordChildEvents__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_RecordChildEvents", OTHER);

            PickleIterator iter__{msg__};
            nsTArray<ChildEventData> events{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(events)))))) {
                FatalError("Error deserializing 'ChildEventData[]'");
                return MsgValueError;
            }
            // Sentinel = 'events'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 149619350)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ChildEventData[]'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessParent*>(this))->RecvRecordChildEvents(std::move(events))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_RecordDiscardedData__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_RecordDiscardedData", OTHER);

            PickleIterator iter__{msg__};
            DiscardedData data{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(data)))))) {
                FatalError("Error deserializing 'DiscardedData'");
                return MsgValueError;
            }
            // Sentinel = 'data'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 67109275)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'DiscardedData'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessParent*>(this))->RecvRecordDiscardedData(std::move(data))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_PWebrtcTCPSocketConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_PWebrtcTCPSocketConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            mozilla::Maybe<TabId> tabId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(tabId)))))) {
                FatalError("Error deserializing 'TabId?'");
                return MsgValueError;
            }
            // Sentinel = 'tabId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 99156453)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'TabId?'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PWebrtcTCPSocketParent* actor = (static_cast<SocketProcessParent*>(this))->AllocPWebrtcTCPSocketParent(tabId);
            if (!actor) {
                NS_WARNING("Cannot bind null PWebrtcTCPSocketParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPWebrtcTCPSocketParent.PutEntry(actor);

            if ((!((static_cast<SocketProcessParent*>(this))->RecvPWebrtcTCPSocketConstructor(std::move(actor), std::move(tabId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_PChildToParentStreamConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_PChildToParentStreamConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PChildToParentStreamParent* actor = (static_cast<SocketProcessParent*>(this))->AllocPChildToParentStreamParent();
            if (!actor) {
                NS_WARNING("Cannot bind null PChildToParentStreamParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPChildToParentStreamParent.PutEntry(actor);

            if ((!((static_cast<SocketProcessParent*>(this))->RecvPChildToParentStreamConstructor(std::move(actor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_ObserveHttpActivity__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_ObserveHttpActivity", OTHER);

            PickleIterator iter__{msg__};
            HttpActivityArgs aActivityArgs{};
            uint32_t aActivityType{};
            uint32_t aActivitySubtype{};
            PRTime aTimestamp{};
            uint64_t aExtraSizeData{};
            nsCString aExtraStringData{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aActivityArgs)))))) {
                FatalError("Error deserializing 'HttpActivityArgs'");
                return MsgValueError;
            }
            // Sentinel = 'aActivityArgs'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 599721276)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'HttpActivityArgs'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aActivityType)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'aActivityType'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 606340433)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aActivitySubtype)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'aActivitySubtype'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 916326043)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aTimestamp)))))) {
                FatalError("Error deserializing 'PRTime'");
                return MsgValueError;
            }
            // Sentinel = 'aTimestamp'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 367330326)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'PRTime'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aExtraSizeData)))))) {
                FatalError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            // Sentinel = 'aExtraSizeData'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 689833339)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aExtraStringData)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'aExtraStringData'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 905315927)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessParent*>(this))->RecvObserveHttpActivity(std::move(aActivityArgs), std::move(aActivityType), std::move(aActivitySubtype), std::move(aTimestamp), std::move(aExtraSizeData), std::move(aExtraStringData))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_InitBackground__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_InitBackground", OTHER);

            PickleIterator iter__{msg__};
            Endpoint<mozilla::ipc::PBackgroundParent> aEndpoint{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aEndpoint)))))) {
                FatalError("Error deserializing 'Endpoint<mozilla::ipc::PBackgroundParent>'");
                return MsgValueError;
            }
            // Sentinel = 'aEndpoint'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 292225955)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'Endpoint<mozilla::ipc::PBackgroundParent>'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessParent*>(this))->RecvInitBackground(std::move(aEndpoint))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_PAltServiceConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_PAltServiceConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PAltServiceParent> actor = (static_cast<SocketProcessParent*>(this))->AllocPAltServiceParent();
            if (!actor) {
                NS_WARNING("Cannot bind null PAltServiceParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPAltServiceParent.PutEntry(actor);

            if ((!((static_cast<SocketProcessParent*>(this))->RecvPAltServiceConstructor(actor)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_PProxyConfigLookupConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_PProxyConfigLookupConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            RefPtr<nsIURI> aUri{};
            uint32_t aFlags{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aUri)))))) {
                FatalError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            // Sentinel = 'aUri'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 64225682)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aFlags)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'aFlags'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 129892943)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PProxyConfigLookupParent> actor = (static_cast<SocketProcessParent*>(this))->AllocPProxyConfigLookupParent(aUri, aFlags);
            if (!actor) {
                NS_WARNING("Cannot bind null PProxyConfigLookupParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPProxyConfigLookupParent.PutEntry(actor);

            if ((!((static_cast<SocketProcessParent*>(this))->RecvPProxyConfigLookupConstructor(actor, aUri, std::move(aFlags))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_CachePushCheck__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_CachePushCheck", OTHER);

            PickleIterator iter__{msg__};
            RefPtr<nsIURI> aPushedURL{};
            OriginAttributes aOriginAttributes{};
            nsCString aRequestString{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aPushedURL)))))) {
                FatalError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            // Sentinel = 'aPushedURL'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 358155198)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aOriginAttributes)))))) {
                FatalError("Error deserializing 'OriginAttributes'");
                return MsgValueError;
            }
            // Sentinel = 'aOriginAttributes'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 1021839089)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'OriginAttributes'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aRequestString)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'aRequestString'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 712771010)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            int32_t id__ = MSG_ROUTING_CONTROL;
            int32_t seqno__ = msg__.seqno();
            RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
                GetLifecycleProxy();

            CachePushCheckResolver resolver = [proxy__, seqno__, id__](const bool& aParam) {
                if (!proxy__->Get()) {
                    NS_WARNING("Not resolving response because actor is dead.");
                    return;
                }
                PSocketProcessParent* self__ = static_cast<PSocketProcessParent*>(proxy__->Get());

                IPC::Message* reply__ = PSocketProcess::Reply_CachePushCheck(id__);
                reply__->set_seqno(seqno__);

                bool resolve__ = true;
                WriteIPDLParam(reply__, self__, resolve__);
                // Sentinel = 'resolve__'
                (reply__)->WriteSentinel(322044863);
                WriteIPDLParam(reply__, self__, aParam);
                // Sentinel = 'aAccepted'
                (reply__)->WriteSentinel(281281403);

                if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                    mozilla::ipc::LogMessageForProtocol(
                        "PSocketProcessParent",
                        (self__)->OtherPid(),
                        "Sending reply ",
                        reply__->type(),
                        mozilla::ipc::MessageDirection::eSending);
                }

                bool sendok__ = self__->ChannelSend(reply__);
                if (!sendok__) {
                    NS_WARNING("Error sending reply");
                }
            };
            if ((!((static_cast<SocketProcessParent*>(this))->RecvCachePushCheck(aPushedURL, std::move(aOriginAttributes), std::move(aRequestString), std::move(resolver))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Msg_ODoHServiceActivated__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_ODoHServiceActivated", OTHER);

            PickleIterator iter__{msg__};
            bool aActivated{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aActivated)))))) {
                FatalError("Error deserializing 'bool'");
                return MsgValueError;
            }
            // Sentinel = 'aActivated'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 355664887)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<SocketProcessParent*>(this))->RecvODoHServiceActivated(std::move(aActivated))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Reply_RequestMemoryReport__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_RequestMemoryReport", OTHER);

            PickleIterator iter__{msg__};
            bool resolve__ = false;
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(resolve__)))))) {
                FatalError("Error deserializing 'resolve__'");
                return MsgValueError;
            }
            // Sentinel = 'resolve__'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 322044863)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'resolve__'");
                return MsgValueError;
            }


            UniquePtr<MessageChannel::UntypedCallbackHolder> untypedCallback =
                GetIPCChannel()->PopCallback(msg__);

            typedef MessageChannel::CallbackHolder<uint32_t> CallbackHolder;
            auto* callback = static_cast<CallbackHolder*>(untypedCallback.get());
            if (!callback) {
                FatalError("Error unknown callback");
                return MsgProcessingError;
            }

            if (resolve__) {
                uint32_t aGeneration{};

                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aGeneration)))))) {
                    FatalError("Error deserializing 'uint32_t'");
                    return MsgValueError;
                }
                // Sentinel = 'aGeneration'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 430179438)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Resolve(std::move(aGeneration));
            } else {
                ResponseRejectReason reason__{};
                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(reason__)))))) {
                    FatalError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                // Sentinel = 'reason__'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 251855687)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Reject(std::move(reason__));
            }
            return MsgProcessed;
        }
    case PSocketProcess::Reply_PHttpTransactionConstructor__ID:
        {
            return MsgProcessed;
        }
    case PSocketProcess::Reply_PParentToChildStreamConstructor__ID:
        {
            return MsgProcessed;
        }
    case PSocketProcess::Reply_PHttpConnectionMgrConstructor__ID:
        {
            return MsgProcessed;
        }
    case PSocketProcess::Reply_PInputChannelThrottleQueueConstructor__ID:
        {
            return MsgProcessed;
        }
    case PSocketProcess::Reply_PAltSvcTransactionConstructor__ID:
        {
            return MsgProcessed;
        }
    case PSocketProcess::Reply_PTRRServiceConstructor__ID:
        {
            return MsgProcessed;
        }
    case PSocketProcess::Reply_PNativeDNSResolverOverrideConstructor__ID:
        {
            return MsgProcessed;
        }
    case PSocketProcess::Reply_PRemoteLazyInputStreamConstructor__ID:
        {
            return MsgProcessed;
        }
    case PSocketProcess::Reply_GetSocketData__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_GetSocketData", OTHER);

            PickleIterator iter__{msg__};
            bool resolve__ = false;
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(resolve__)))))) {
                FatalError("Error deserializing 'resolve__'");
                return MsgValueError;
            }
            // Sentinel = 'resolve__'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 322044863)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'resolve__'");
                return MsgValueError;
            }


            UniquePtr<MessageChannel::UntypedCallbackHolder> untypedCallback =
                GetIPCChannel()->PopCallback(msg__);

            typedef MessageChannel::CallbackHolder<SocketDataArgs> CallbackHolder;
            auto* callback = static_cast<CallbackHolder*>(untypedCallback.get());
            if (!callback) {
                FatalError("Error unknown callback");
                return MsgProcessingError;
            }

            if (resolve__) {
                SocketDataArgs data{};

                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(data)))))) {
                    FatalError("Error deserializing 'SocketDataArgs'");
                    return MsgValueError;
                }
                // Sentinel = 'data'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 67109275)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'SocketDataArgs'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Resolve(std::move(data));
            } else {
                ResponseRejectReason reason__{};
                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(reason__)))))) {
                    FatalError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                // Sentinel = 'reason__'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 251855687)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Reject(std::move(reason__));
            }
            return MsgProcessed;
        }
    case PSocketProcess::Reply_GetDNSCacheEntries__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_GetDNSCacheEntries", OTHER);

            PickleIterator iter__{msg__};
            bool resolve__ = false;
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(resolve__)))))) {
                FatalError("Error deserializing 'resolve__'");
                return MsgValueError;
            }
            // Sentinel = 'resolve__'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 322044863)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'resolve__'");
                return MsgValueError;
            }


            UniquePtr<MessageChannel::UntypedCallbackHolder> untypedCallback =
                GetIPCChannel()->PopCallback(msg__);

            typedef MessageChannel::CallbackHolder<nsTArray<DNSCacheEntries>> CallbackHolder;
            auto* callback = static_cast<CallbackHolder*>(untypedCallback.get());
            if (!callback) {
                FatalError("Error unknown callback");
                return MsgProcessingError;
            }

            if (resolve__) {
                nsTArray<DNSCacheEntries> entries{};

                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(entries)))))) {
                    FatalError("Error deserializing 'DNSCacheEntries[]'");
                    return MsgValueError;
                }
                // Sentinel = 'entries'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 199361275)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'DNSCacheEntries[]'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Resolve(std::move(entries));
            } else {
                ResponseRejectReason reason__{};
                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(reason__)))))) {
                    FatalError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                // Sentinel = 'reason__'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 251855687)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Reject(std::move(reason__));
            }
            return MsgProcessed;
        }
    case PSocketProcess::Reply_GetHttpConnectionData__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_GetHttpConnectionData", OTHER);

            PickleIterator iter__{msg__};
            bool resolve__ = false;
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(resolve__)))))) {
                FatalError("Error deserializing 'resolve__'");
                return MsgValueError;
            }
            // Sentinel = 'resolve__'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 322044863)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'resolve__'");
                return MsgValueError;
            }


            UniquePtr<MessageChannel::UntypedCallbackHolder> untypedCallback =
                GetIPCChannel()->PopCallback(msg__);

            typedef MessageChannel::CallbackHolder<nsTArray<HttpRetParams>> CallbackHolder;
            auto* callback = static_cast<CallbackHolder*>(untypedCallback.get());
            if (!callback) {
                FatalError("Error unknown callback");
                return MsgProcessingError;
            }

            if (resolve__) {
                nsTArray<HttpRetParams> params{};

                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(params)))))) {
                    FatalError("Error deserializing 'HttpRetParams[]'");
                    return MsgValueError;
                }
                // Sentinel = 'params'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 146997893)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'HttpRetParams[]'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Resolve(std::move(params));
            } else {
                ResponseRejectReason reason__{};
                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(reason__)))))) {
                    FatalError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                // Sentinel = 'reason__'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 251855687)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Reject(std::move(reason__));
            }
            return MsgProcessed;
        }
    case PSocketProcess::Reply_PFileDescriptorSetConstructor__ID:
        {
            return MsgProcessed;
        }
    case PSocketProcess::Msg_PFileDescriptorSetConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_PFileDescriptorSetConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            FileDescriptor fd{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(fd)))))) {
                FatalError("Error deserializing 'FileDescriptor'");
                return MsgValueError;
            }
            // Sentinel = 'fd'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 20054219)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'FileDescriptor'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PFileDescriptorSetParent* actor = (static_cast<SocketProcessParent*>(this))->AllocPFileDescriptorSetParent(fd);
            if (!actor) {
                NS_WARNING("Cannot bind null PFileDescriptorSetParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPFileDescriptorSetParent.PutEntry(actor);

            if ((!((static_cast<SocketProcessParent*>(this))->RecvPFileDescriptorSetConstructor(std::move(actor), std::move(fd))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PSocketProcess::Reply_PDNSRequestConstructor__ID:
        {
            return MsgProcessed;
        }
    case PSocketProcess::Msg_PDNSRequestConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_PDNSRequestConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            nsCString hostName{};
            nsCString trrServer{};
            uint16_t type{};
            OriginAttributes originAttributes{};
            uint32_t flags{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(hostName)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'hostName'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 249627456)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(trrServer)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'trrServer'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 320603088)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(type)))))) {
                FatalError("Error deserializing 'uint16_t'");
                return MsgValueError;
            }
            // Sentinel = 'type'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 75760067)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint16_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(originAttributes)))))) {
                FatalError("Error deserializing 'OriginAttributes'");
                return MsgValueError;
            }
            // Sentinel = 'originAttributes'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 947259056)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'OriginAttributes'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(flags)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'flags'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102171150)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PDNSRequestParent> actor = (static_cast<SocketProcessParent*>(this))->AllocPDNSRequestParent(hostName, trrServer, type, originAttributes, flags);
            if (!actor) {
                NS_WARNING("Cannot bind null PDNSRequestParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPDNSRequestParent.PutEntry(actor);

            if ((!((static_cast<SocketProcessParent*>(this))->RecvPDNSRequestConstructor(actor, std::move(hostName), std::move(trrServer), std::move(type), std::move(originAttributes), std::move(flags))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    default:
        return MsgNotKnown;
    case SHMEM_CREATED_MESSAGE_TYPE:
        {
            FatalError("this protocol tree does not use shmem");
            return MsgNotKnown;
        }
    case SHMEM_DESTROYED_MESSAGE_TYPE:
        {
            FatalError("this protocol tree does not use shmem");
            return MsgNotKnown;
        }
    }
}

auto PSocketProcessParent::OnMessageReceived(
        const Message& msg__,
        Message*& reply__) -> PSocketProcessParent::Result
{
    int32_t route__ = msg__.routing_id();
    if (MSG_ROUTING_CONTROL != route__) {
        IProtocol* routed__ = Lookup(route__);
        if (!routed__ || !routed__->GetLifecycleProxy()) {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Ignored message for dead actor",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eSending);
            }

            return MsgProcessed;
        }

        RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
            routed__->GetLifecycleProxy();
        return proxy__->Get()->OnMessageReceived(msg__, reply__);
    }

    switch (msg__.type()) {
    case PSocketProcess::Msg_GetTLSClientCert__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PSocketProcess::Msg_GetTLSClientCert", OTHER);

            PickleIterator iter__{msg__};
            nsCString aHostName{};
            OriginAttributes aOriginAttributes{};
            int32_t aPort{};
            uint32_t aProviderFlags{};
            uint32_t aProviderTlsFlags{};
            ByteArray aServerCert{};
            mozilla::Maybe<ByteArray> aClientCert{};
            nsTArray<ByteArray> aCollectedCANames{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aHostName)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'aHostName'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 290128769)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aOriginAttributes)))))) {
                FatalError("Error deserializing 'OriginAttributes'");
                return MsgValueError;
            }
            // Sentinel = 'aOriginAttributes'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 1021839089)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'OriginAttributes'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aPort)))))) {
                FatalError("Error deserializing 'int32_t'");
                return MsgValueError;
            }
            // Sentinel = 'aPort'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 97452551)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'int32_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aProviderFlags)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'aProviderFlags'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 701957530)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aProviderTlsFlags)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'aProviderTlsFlags'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 1025771213)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aServerCert)))))) {
                FatalError("Error deserializing 'ByteArray'");
                return MsgValueError;
            }
            // Sentinel = 'aServerCert'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 435553383)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ByteArray'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aClientCert)))))) {
                FatalError("Error deserializing 'ByteArray?'");
                return MsgValueError;
            }
            // Sentinel = 'aClientCert'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 420873295)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ByteArray?'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aCollectedCANames)))))) {
                FatalError("Error deserializing 'ByteArray[]'");
                return MsgValueError;
            }
            // Sentinel = 'aCollectedCANames'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 967968361)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ByteArray[]'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            int32_t id__ = MSG_ROUTING_CONTROL;
            bool aSucceeded{};
            ByteArray aOutCert{};
            ByteArray aOutKey{};
            nsTArray<ByteArray> aBuiltChain{};
            if ((!((static_cast<SocketProcessParent*>(this))->RecvGetTLSClientCert(std::move(aHostName), std::move(aOriginAttributes), std::move(aPort), std::move(aProviderFlags), std::move(aProviderTlsFlags), std::move(aServerCert), std::move(aClientCert), std::move(aCollectedCANames), (&(aSucceeded)), (&(aOutCert)), (&(aOutKey)), (&(aBuiltChain)))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            reply__ = PSocketProcess::Reply_GetTLSClientCert(id__);

            WriteIPDLParam(reply__, this, aSucceeded);
            // Sentinel = 'aSucceeded'
            (reply__)->WriteSentinel(357893095);
            WriteIPDLParam(reply__, this, aOutCert);
            // Sentinel = 'aOutCert'
            (reply__)->WriteSentinel(231605032);
            WriteIPDLParam(reply__, this, aOutKey);
            // Sentinel = 'aOutKey'
            (reply__)->WriteSentinel(180683459);
            WriteIPDLParam(reply__, this, aBuiltChain);
            // Sentinel = 'aBuiltChain'
            (reply__)->WriteSentinel(422380613);

            if (mozilla::ipc::LoggingEnabledFor("PSocketProcessParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PSocketProcessParent",
                    OtherPid(),
                    "Sending reply ",
                    reply__->type(),
                    mozilla::ipc::MessageDirection::eSending);
            }
            return MsgProcessed;
        }
    default:
        return MsgNotKnown;
    }
}

auto PSocketProcessParent::OnCallReceived(
        const Message& msg__,
        Message*& reply__) -> PSocketProcessParent::Result
{
    MOZ_ASSERT_UNREACHABLE("message protocol not supported");
    return MsgNotKnown;
}

auto PSocketProcessParent::OnChannelClose() -> void
{
    DestroySubtree(NormalShutdown);
    ClearSubtree();
    DeallocShmems();
    if (GetLifecycleProxy()) {
        GetLifecycleProxy()->Release();
    }
}

auto PSocketProcessParent::OnChannelError() -> void
{
    DestroySubtree(AbnormalShutdown);
    ClearSubtree();
    DeallocShmems();
    if (GetLifecycleProxy()) {
        GetLifecycleProxy()->Release();
    }
}

auto PSocketProcessParent::ClearSubtree() -> void
{
    for (auto it = mManagedPDNSRequestParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPDNSRequestParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPDNSRequestParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPDNSRequestParent.Clear();

    for (auto it = mManagedPWebrtcTCPSocketParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPWebrtcTCPSocketParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPWebrtcTCPSocketParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPWebrtcTCPSocketParent.Clear();

    for (auto it = mManagedPFileDescriptorSetParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPFileDescriptorSetParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPFileDescriptorSetParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPFileDescriptorSetParent.Clear();

    for (auto it = mManagedPHttpTransactionParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPHttpTransactionParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPHttpTransactionParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPHttpTransactionParent.Clear();

    for (auto it = mManagedPHttpConnectionMgrParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPHttpConnectionMgrParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPHttpConnectionMgrParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPHttpConnectionMgrParent.Clear();

    for (auto it = mManagedPChildToParentStreamParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPChildToParentStreamParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPChildToParentStreamParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPChildToParentStreamParent.Clear();

    for (auto it = mManagedPParentToChildStreamParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPParentToChildStreamParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPParentToChildStreamParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPParentToChildStreamParent.Clear();

    for (auto it = mManagedPInputChannelThrottleQueueParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPInputChannelThrottleQueueParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPInputChannelThrottleQueueParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPInputChannelThrottleQueueParent.Clear();

    for (auto it = mManagedPAltServiceParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPAltServiceParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPAltServiceParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPAltServiceParent.Clear();

    for (auto it = mManagedPAltSvcTransactionParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPAltSvcTransactionParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPAltSvcTransactionParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPAltSvcTransactionParent.Clear();

    for (auto it = mManagedPTRRServiceParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPTRRServiceParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPTRRServiceParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPTRRServiceParent.Clear();

    for (auto it = mManagedPProxyConfigLookupParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPProxyConfigLookupParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPProxyConfigLookupParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPProxyConfigLookupParent.Clear();

    for (auto it = mManagedPNativeDNSResolverOverrideParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPNativeDNSResolverOverrideParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPNativeDNSResolverOverrideParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPNativeDNSResolverOverrideParent.Clear();

    for (auto it = mManagedPRemoteLazyInputStreamParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPRemoteLazyInputStreamParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPRemoteLazyInputStreamParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPRemoteLazyInputStreamParent.Clear();

}



} // namespace net
} // namespace mozilla
namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::net::PSocketProcessParent*>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    int32_t id;
    if (!aVar) {
        id = 0;  // kNullActorId
    } else {
        id = aVar->Id();
        if (id == 1) {  // kFreedActorId
            aVar->FatalError("Actor has been |delete|d");
        }
        MOZ_RELEASE_ASSERT(
            aActor->GetIPCChannel() == aVar->GetIPCChannel(),
            "Actor must be from the same channel as the"
            " actor it's being sent over");
        MOZ_RELEASE_ASSERT(
            aVar->CanSend(),
            "Actor must still be open when sending");
    }

    WriteIPDLParam(aMsg, aActor, id);
}

auto IPDLParamTraits<mozilla::net::PSocketProcessParent*>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    mozilla::Maybe<mozilla::ipc::IProtocol*> actor =
        aActor->ReadActor(aMsg, aIter, true, "PSocketProcess", PSocketProcessMsgStart);
    if (actor.isNothing()) {
        return false;
    }

    *aVar = static_cast<mozilla::net::PSocketProcessParent*>(actor.value());
    return true;
}

} // namespace ipc
} // namespace mozilla
