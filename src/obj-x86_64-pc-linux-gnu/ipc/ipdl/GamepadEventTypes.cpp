//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/GamepadMessageUtils.h"
#include "mozilla/dom/GamepadEventTypes.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"


//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct GamepadAdded|
//
namespace mozilla {
namespace dom {
auto GamepadAdded::StaticAssertions() const -> void
{
    static_assert(
        (offsetof(GamepadAdded, num_touches_) - offsetof(GamepadAdded, display_id_)) == 20,
        "Bad assumptions about field layout!");
}

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::GamepadAdded>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).id());
    // Sentinel = 'id'
    (aMsg)->WriteSentinel(20447438);
    WriteIPDLParam(aMsg, aActor, (aVar).mapping());
    // Sentinel = 'mapping'
    (aMsg)->WriteSentinel(196477677);
    WriteIPDLParam(aMsg, aActor, (aVar).hand());
    // Sentinel = 'hand'
    (aMsg)->WriteSentinel(67568028);
    (aMsg)->WriteBytes((&((aVar).display_id())), 24);
    // Sentinel = 'display_id | num_buttons | num_axes | num_haptics | num_lights | num_touches'
    (aMsg)->WriteSentinel(1783504236);
}

auto IPDLParamTraits<mozilla::dom::GamepadAdded>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->id())))))) {
        aActor->FatalError("Error deserializing 'id' (nsString) member of 'GamepadAdded'");
        return false;
    }
    // Sentinel = 'id'
    if ((!((aMsg)->ReadSentinel(aIter, 20447438)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'id' (nsString) member of 'GamepadAdded'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->mapping())))))) {
        aActor->FatalError("Error deserializing 'mapping' (GamepadMappingType) member of 'GamepadAdded'");
        return false;
    }
    // Sentinel = 'mapping'
    if ((!((aMsg)->ReadSentinel(aIter, 196477677)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'mapping' (GamepadMappingType) member of 'GamepadAdded'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->hand())))))) {
        aActor->FatalError("Error deserializing 'hand' (GamepadHand) member of 'GamepadAdded'");
        return false;
    }
    // Sentinel = 'hand'
    if ((!((aMsg)->ReadSentinel(aIter, 67568028)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'hand' (GamepadHand) member of 'GamepadAdded'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->display_id())), 24)))) {
        aActor->FatalError("Error bulk reading fields from uint32_t");
        return false;
    }
    // Sentinel = 'display_id | num_buttons | num_axes | num_haptics | num_lights | num_touches'
    if ((!((aMsg)->ReadSentinel(aIter, 1783504236)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint32_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct GamepadRemoved|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::GamepadRemoved>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
}

auto IPDLParamTraits<mozilla::dom::GamepadRemoved>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct GamepadAxisInformation|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::GamepadAxisInformation>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    (aMsg)->WriteBytes((&((aVar).value())), 8);
    // Sentinel = 'value'
    (aMsg)->WriteSentinel(107610654);
    (aMsg)->WriteBytes((&((aVar).axis())), 4);
    // Sentinel = 'axis'
    (aMsg)->WriteSentinel(70582710);
}

auto IPDLParamTraits<mozilla::dom::GamepadAxisInformation>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->value())), 8)))) {
        aActor->FatalError("Error bulk reading fields from double");
        return false;
    }
    // Sentinel = 'value'
    if ((!((aMsg)->ReadSentinel(aIter, 107610654)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from double");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->axis())), 4)))) {
        aActor->FatalError("Error bulk reading fields from uint32_t");
        return false;
    }
    // Sentinel = 'axis'
    if ((!((aMsg)->ReadSentinel(aIter, 70582710)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint32_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct GamepadButtonInformation|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::GamepadButtonInformation>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).pressed());
    // Sentinel = 'pressed'
    (aMsg)->WriteSentinel(202310391);
    WriteIPDLParam(aMsg, aActor, (aVar).touched());
    // Sentinel = 'touched'
    (aMsg)->WriteSentinel(201851629);
    (aMsg)->WriteBytes((&((aVar).value())), 8);
    // Sentinel = 'value'
    (aMsg)->WriteSentinel(107610654);
    (aMsg)->WriteBytes((&((aVar).button())), 4);
    // Sentinel = 'button'
    (aMsg)->WriteSentinel(152240797);
}

auto IPDLParamTraits<mozilla::dom::GamepadButtonInformation>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->pressed())))))) {
        aActor->FatalError("Error deserializing 'pressed' (bool) member of 'GamepadButtonInformation'");
        return false;
    }
    // Sentinel = 'pressed'
    if ((!((aMsg)->ReadSentinel(aIter, 202310391)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'pressed' (bool) member of 'GamepadButtonInformation'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->touched())))))) {
        aActor->FatalError("Error deserializing 'touched' (bool) member of 'GamepadButtonInformation'");
        return false;
    }
    // Sentinel = 'touched'
    if ((!((aMsg)->ReadSentinel(aIter, 201851629)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'touched' (bool) member of 'GamepadButtonInformation'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->value())), 8)))) {
        aActor->FatalError("Error bulk reading fields from double");
        return false;
    }
    // Sentinel = 'value'
    if ((!((aMsg)->ReadSentinel(aIter, 107610654)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from double");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->button())), 4)))) {
        aActor->FatalError("Error bulk reading fields from uint32_t");
        return false;
    }
    // Sentinel = 'button'
    if ((!((aMsg)->ReadSentinel(aIter, 152240797)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint32_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct GamepadPoseInformation|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::GamepadPoseInformation>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).pose_state());
    // Sentinel = 'pose_state'
    (aMsg)->WriteSentinel(392496184);
}

auto IPDLParamTraits<mozilla::dom::GamepadPoseInformation>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->pose_state())))))) {
        aActor->FatalError("Error deserializing 'pose_state' (GamepadPoseState) member of 'GamepadPoseInformation'");
        return false;
    }
    // Sentinel = 'pose_state'
    if ((!((aMsg)->ReadSentinel(aIter, 392496184)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'pose_state' (GamepadPoseState) member of 'GamepadPoseInformation'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct GamepadLightIndicatorTypeInformation|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::GamepadLightIndicatorTypeInformation>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).type());
    // Sentinel = 'type'
    (aMsg)->WriteSentinel(75760067);
    (aMsg)->WriteBytes((&((aVar).light())), 4);
    // Sentinel = 'light'
    (aMsg)->WriteSentinel(104727065);
}

auto IPDLParamTraits<mozilla::dom::GamepadLightIndicatorTypeInformation>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->type())))))) {
        aActor->FatalError("Error deserializing 'type' (GamepadLightIndicatorType) member of 'GamepadLightIndicatorTypeInformation'");
        return false;
    }
    // Sentinel = 'type'
    if ((!((aMsg)->ReadSentinel(aIter, 75760067)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'type' (GamepadLightIndicatorType) member of 'GamepadLightIndicatorTypeInformation'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->light())), 4)))) {
        aActor->FatalError("Error bulk reading fields from uint32_t");
        return false;
    }
    // Sentinel = 'light'
    if ((!((aMsg)->ReadSentinel(aIter, 104727065)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint32_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct GamepadHandInformation|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::GamepadHandInformation>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).hand());
    // Sentinel = 'hand'
    (aMsg)->WriteSentinel(67568028);
}

auto IPDLParamTraits<mozilla::dom::GamepadHandInformation>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->hand())))))) {
        aActor->FatalError("Error deserializing 'hand' (GamepadHand) member of 'GamepadHandInformation'");
        return false;
    }
    // Sentinel = 'hand'
    if ((!((aMsg)->ReadSentinel(aIter, 67568028)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'hand' (GamepadHand) member of 'GamepadHandInformation'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct GamepadTouchInformation|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::GamepadTouchInformation>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).touch_state());
    // Sentinel = 'touch_state'
    (aMsg)->WriteSentinel(472056996);
    (aMsg)->WriteBytes((&((aVar).index())), 4);
    // Sentinel = 'index'
    (aMsg)->WriteSentinel(104333849);
}

auto IPDLParamTraits<mozilla::dom::GamepadTouchInformation>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->touch_state())))))) {
        aActor->FatalError("Error deserializing 'touch_state' (GamepadTouchState) member of 'GamepadTouchInformation'");
        return false;
    }
    // Sentinel = 'touch_state'
    if ((!((aMsg)->ReadSentinel(aIter, 472056996)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'touch_state' (GamepadTouchState) member of 'GamepadTouchInformation'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->index())), 4)))) {
        aActor->FatalError("Error bulk reading fields from uint32_t");
        return false;
    }
    // Sentinel = 'index'
    if ((!((aMsg)->ReadSentinel(aIter, 104333849)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint32_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union GamepadChangeEventBody|
//
namespace mozilla {
namespace dom {
auto GamepadChangeEventBody::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TGamepadAdded:
        {
            (ptr_GamepadAdded())->~GamepadAdded__tdef();
            break;
        }
    case TGamepadRemoved:
        {
            (ptr_GamepadRemoved())->~GamepadRemoved__tdef();
            break;
        }
    case TGamepadAxisInformation:
        {
            (ptr_GamepadAxisInformation())->~GamepadAxisInformation__tdef();
            break;
        }
    case TGamepadButtonInformation:
        {
            (ptr_GamepadButtonInformation())->~GamepadButtonInformation__tdef();
            break;
        }
    case TGamepadHandInformation:
        {
            (ptr_GamepadHandInformation())->~GamepadHandInformation__tdef();
            break;
        }
    case TGamepadLightIndicatorTypeInformation:
        {
            (ptr_GamepadLightIndicatorTypeInformation())->~GamepadLightIndicatorTypeInformation__tdef();
            break;
        }
    case TGamepadPoseInformation:
        {
            (ptr_GamepadPoseInformation())->~GamepadPoseInformation__tdef();
            break;
        }
    case TGamepadTouchInformation:
        {
            (ptr_GamepadTouchInformation())->~GamepadTouchInformation__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT GamepadChangeEventBody::GamepadChangeEventBody(const GamepadAdded& aOther)
{
    new (mozilla::KnownNotNull, ptr_GamepadAdded()) GamepadAdded(aOther);
    mType = TGamepadAdded;
}

MOZ_IMPLICIT GamepadChangeEventBody::GamepadChangeEventBody(GamepadAdded&& aOther)
{
    new (mozilla::KnownNotNull, ptr_GamepadAdded()) GamepadAdded(std::move(aOther));
    mType = TGamepadAdded;
}

MOZ_IMPLICIT GamepadChangeEventBody::GamepadChangeEventBody(const GamepadRemoved& aOther)
{
    new (mozilla::KnownNotNull, ptr_GamepadRemoved()) GamepadRemoved(aOther);
    mType = TGamepadRemoved;
}

MOZ_IMPLICIT GamepadChangeEventBody::GamepadChangeEventBody(GamepadRemoved&& aOther)
{
    new (mozilla::KnownNotNull, ptr_GamepadRemoved()) GamepadRemoved(std::move(aOther));
    mType = TGamepadRemoved;
}

MOZ_IMPLICIT GamepadChangeEventBody::GamepadChangeEventBody(const GamepadAxisInformation& aOther)
{
    new (mozilla::KnownNotNull, ptr_GamepadAxisInformation()) GamepadAxisInformation(aOther);
    mType = TGamepadAxisInformation;
}

MOZ_IMPLICIT GamepadChangeEventBody::GamepadChangeEventBody(GamepadAxisInformation&& aOther)
{
    new (mozilla::KnownNotNull, ptr_GamepadAxisInformation()) GamepadAxisInformation(std::move(aOther));
    mType = TGamepadAxisInformation;
}

MOZ_IMPLICIT GamepadChangeEventBody::GamepadChangeEventBody(const GamepadButtonInformation& aOther)
{
    new (mozilla::KnownNotNull, ptr_GamepadButtonInformation()) GamepadButtonInformation(aOther);
    mType = TGamepadButtonInformation;
}

MOZ_IMPLICIT GamepadChangeEventBody::GamepadChangeEventBody(GamepadButtonInformation&& aOther)
{
    new (mozilla::KnownNotNull, ptr_GamepadButtonInformation()) GamepadButtonInformation(std::move(aOther));
    mType = TGamepadButtonInformation;
}

MOZ_IMPLICIT GamepadChangeEventBody::GamepadChangeEventBody(const GamepadHandInformation& aOther)
{
    new (mozilla::KnownNotNull, ptr_GamepadHandInformation()) GamepadHandInformation(aOther);
    mType = TGamepadHandInformation;
}

MOZ_IMPLICIT GamepadChangeEventBody::GamepadChangeEventBody(GamepadHandInformation&& aOther)
{
    new (mozilla::KnownNotNull, ptr_GamepadHandInformation()) GamepadHandInformation(std::move(aOther));
    mType = TGamepadHandInformation;
}

MOZ_IMPLICIT GamepadChangeEventBody::GamepadChangeEventBody(const GamepadLightIndicatorTypeInformation& aOther)
{
    new (mozilla::KnownNotNull, ptr_GamepadLightIndicatorTypeInformation()) GamepadLightIndicatorTypeInformation(aOther);
    mType = TGamepadLightIndicatorTypeInformation;
}

MOZ_IMPLICIT GamepadChangeEventBody::GamepadChangeEventBody(GamepadLightIndicatorTypeInformation&& aOther)
{
    new (mozilla::KnownNotNull, ptr_GamepadLightIndicatorTypeInformation()) GamepadLightIndicatorTypeInformation(std::move(aOther));
    mType = TGamepadLightIndicatorTypeInformation;
}

MOZ_IMPLICIT GamepadChangeEventBody::GamepadChangeEventBody(const GamepadPoseInformation& aOther)
{
    new (mozilla::KnownNotNull, ptr_GamepadPoseInformation()) GamepadPoseInformation(aOther);
    mType = TGamepadPoseInformation;
}

MOZ_IMPLICIT GamepadChangeEventBody::GamepadChangeEventBody(GamepadPoseInformation&& aOther)
{
    new (mozilla::KnownNotNull, ptr_GamepadPoseInformation()) GamepadPoseInformation(std::move(aOther));
    mType = TGamepadPoseInformation;
}

MOZ_IMPLICIT GamepadChangeEventBody::GamepadChangeEventBody(const GamepadTouchInformation& aOther)
{
    new (mozilla::KnownNotNull, ptr_GamepadTouchInformation()) GamepadTouchInformation(aOther);
    mType = TGamepadTouchInformation;
}

MOZ_IMPLICIT GamepadChangeEventBody::GamepadChangeEventBody(GamepadTouchInformation&& aOther)
{
    new (mozilla::KnownNotNull, ptr_GamepadTouchInformation()) GamepadTouchInformation(std::move(aOther));
    mType = TGamepadTouchInformation;
}

MOZ_IMPLICIT GamepadChangeEventBody::GamepadChangeEventBody(const GamepadChangeEventBody& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TGamepadAdded:
        {
            new (mozilla::KnownNotNull, ptr_GamepadAdded()) GamepadAdded((aOther).get_GamepadAdded());
            break;
        }
    case TGamepadRemoved:
        {
            new (mozilla::KnownNotNull, ptr_GamepadRemoved()) GamepadRemoved((aOther).get_GamepadRemoved());
            break;
        }
    case TGamepadAxisInformation:
        {
            new (mozilla::KnownNotNull, ptr_GamepadAxisInformation()) GamepadAxisInformation((aOther).get_GamepadAxisInformation());
            break;
        }
    case TGamepadButtonInformation:
        {
            new (mozilla::KnownNotNull, ptr_GamepadButtonInformation()) GamepadButtonInformation((aOther).get_GamepadButtonInformation());
            break;
        }
    case TGamepadHandInformation:
        {
            new (mozilla::KnownNotNull, ptr_GamepadHandInformation()) GamepadHandInformation((aOther).get_GamepadHandInformation());
            break;
        }
    case TGamepadLightIndicatorTypeInformation:
        {
            new (mozilla::KnownNotNull, ptr_GamepadLightIndicatorTypeInformation()) GamepadLightIndicatorTypeInformation((aOther).get_GamepadLightIndicatorTypeInformation());
            break;
        }
    case TGamepadPoseInformation:
        {
            new (mozilla::KnownNotNull, ptr_GamepadPoseInformation()) GamepadPoseInformation((aOther).get_GamepadPoseInformation());
            break;
        }
    case TGamepadTouchInformation:
        {
            new (mozilla::KnownNotNull, ptr_GamepadTouchInformation()) GamepadTouchInformation((aOther).get_GamepadTouchInformation());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT GamepadChangeEventBody::GamepadChangeEventBody(GamepadChangeEventBody&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TGamepadAdded:
        {
            new (mozilla::KnownNotNull, ptr_GamepadAdded()) GamepadAdded(std::move((aOther).get_GamepadAdded()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TGamepadRemoved:
        {
            new (mozilla::KnownNotNull, ptr_GamepadRemoved()) GamepadRemoved(std::move((aOther).get_GamepadRemoved()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TGamepadAxisInformation:
        {
            new (mozilla::KnownNotNull, ptr_GamepadAxisInformation()) GamepadAxisInformation(std::move((aOther).get_GamepadAxisInformation()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TGamepadButtonInformation:
        {
            new (mozilla::KnownNotNull, ptr_GamepadButtonInformation()) GamepadButtonInformation(std::move((aOther).get_GamepadButtonInformation()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TGamepadHandInformation:
        {
            new (mozilla::KnownNotNull, ptr_GamepadHandInformation()) GamepadHandInformation(std::move((aOther).get_GamepadHandInformation()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TGamepadLightIndicatorTypeInformation:
        {
            new (mozilla::KnownNotNull, ptr_GamepadLightIndicatorTypeInformation()) GamepadLightIndicatorTypeInformation(std::move((aOther).get_GamepadLightIndicatorTypeInformation()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TGamepadPoseInformation:
        {
            new (mozilla::KnownNotNull, ptr_GamepadPoseInformation()) GamepadPoseInformation(std::move((aOther).get_GamepadPoseInformation()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TGamepadTouchInformation:
        {
            new (mozilla::KnownNotNull, ptr_GamepadTouchInformation()) GamepadTouchInformation(std::move((aOther).get_GamepadTouchInformation()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

GamepadChangeEventBody::~GamepadChangeEventBody()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto GamepadChangeEventBody::operator=(const GamepadAdded& aRhs) -> GamepadChangeEventBody&
{
    if (MaybeDestroy(TGamepadAdded)) {
        new (mozilla::KnownNotNull, ptr_GamepadAdded()) GamepadAdded;
    }
    (*(ptr_GamepadAdded())) = aRhs;
    mType = TGamepadAdded;
    return (*(this));
}

auto GamepadChangeEventBody::operator=(GamepadAdded&& aRhs) -> GamepadChangeEventBody&
{
    if (MaybeDestroy(TGamepadAdded)) {
        new (mozilla::KnownNotNull, ptr_GamepadAdded()) GamepadAdded;
    }
    (*(ptr_GamepadAdded())) = std::move(aRhs);
    mType = TGamepadAdded;
    return (*(this));
}

auto GamepadChangeEventBody::operator=(const GamepadRemoved& aRhs) -> GamepadChangeEventBody&
{
    if (MaybeDestroy(TGamepadRemoved)) {
        new (mozilla::KnownNotNull, ptr_GamepadRemoved()) GamepadRemoved;
    }
    (*(ptr_GamepadRemoved())) = aRhs;
    mType = TGamepadRemoved;
    return (*(this));
}

auto GamepadChangeEventBody::operator=(GamepadRemoved&& aRhs) -> GamepadChangeEventBody&
{
    if (MaybeDestroy(TGamepadRemoved)) {
        new (mozilla::KnownNotNull, ptr_GamepadRemoved()) GamepadRemoved;
    }
    (*(ptr_GamepadRemoved())) = std::move(aRhs);
    mType = TGamepadRemoved;
    return (*(this));
}

auto GamepadChangeEventBody::operator=(const GamepadAxisInformation& aRhs) -> GamepadChangeEventBody&
{
    if (MaybeDestroy(TGamepadAxisInformation)) {
        new (mozilla::KnownNotNull, ptr_GamepadAxisInformation()) GamepadAxisInformation;
    }
    (*(ptr_GamepadAxisInformation())) = aRhs;
    mType = TGamepadAxisInformation;
    return (*(this));
}

auto GamepadChangeEventBody::operator=(GamepadAxisInformation&& aRhs) -> GamepadChangeEventBody&
{
    if (MaybeDestroy(TGamepadAxisInformation)) {
        new (mozilla::KnownNotNull, ptr_GamepadAxisInformation()) GamepadAxisInformation;
    }
    (*(ptr_GamepadAxisInformation())) = std::move(aRhs);
    mType = TGamepadAxisInformation;
    return (*(this));
}

auto GamepadChangeEventBody::operator=(const GamepadButtonInformation& aRhs) -> GamepadChangeEventBody&
{
    if (MaybeDestroy(TGamepadButtonInformation)) {
        new (mozilla::KnownNotNull, ptr_GamepadButtonInformation()) GamepadButtonInformation;
    }
    (*(ptr_GamepadButtonInformation())) = aRhs;
    mType = TGamepadButtonInformation;
    return (*(this));
}

auto GamepadChangeEventBody::operator=(GamepadButtonInformation&& aRhs) -> GamepadChangeEventBody&
{
    if (MaybeDestroy(TGamepadButtonInformation)) {
        new (mozilla::KnownNotNull, ptr_GamepadButtonInformation()) GamepadButtonInformation;
    }
    (*(ptr_GamepadButtonInformation())) = std::move(aRhs);
    mType = TGamepadButtonInformation;
    return (*(this));
}

auto GamepadChangeEventBody::operator=(const GamepadHandInformation& aRhs) -> GamepadChangeEventBody&
{
    if (MaybeDestroy(TGamepadHandInformation)) {
        new (mozilla::KnownNotNull, ptr_GamepadHandInformation()) GamepadHandInformation;
    }
    (*(ptr_GamepadHandInformation())) = aRhs;
    mType = TGamepadHandInformation;
    return (*(this));
}

auto GamepadChangeEventBody::operator=(GamepadHandInformation&& aRhs) -> GamepadChangeEventBody&
{
    if (MaybeDestroy(TGamepadHandInformation)) {
        new (mozilla::KnownNotNull, ptr_GamepadHandInformation()) GamepadHandInformation;
    }
    (*(ptr_GamepadHandInformation())) = std::move(aRhs);
    mType = TGamepadHandInformation;
    return (*(this));
}

auto GamepadChangeEventBody::operator=(const GamepadLightIndicatorTypeInformation& aRhs) -> GamepadChangeEventBody&
{
    if (MaybeDestroy(TGamepadLightIndicatorTypeInformation)) {
        new (mozilla::KnownNotNull, ptr_GamepadLightIndicatorTypeInformation()) GamepadLightIndicatorTypeInformation;
    }
    (*(ptr_GamepadLightIndicatorTypeInformation())) = aRhs;
    mType = TGamepadLightIndicatorTypeInformation;
    return (*(this));
}

auto GamepadChangeEventBody::operator=(GamepadLightIndicatorTypeInformation&& aRhs) -> GamepadChangeEventBody&
{
    if (MaybeDestroy(TGamepadLightIndicatorTypeInformation)) {
        new (mozilla::KnownNotNull, ptr_GamepadLightIndicatorTypeInformation()) GamepadLightIndicatorTypeInformation;
    }
    (*(ptr_GamepadLightIndicatorTypeInformation())) = std::move(aRhs);
    mType = TGamepadLightIndicatorTypeInformation;
    return (*(this));
}

auto GamepadChangeEventBody::operator=(const GamepadPoseInformation& aRhs) -> GamepadChangeEventBody&
{
    if (MaybeDestroy(TGamepadPoseInformation)) {
        new (mozilla::KnownNotNull, ptr_GamepadPoseInformation()) GamepadPoseInformation;
    }
    (*(ptr_GamepadPoseInformation())) = aRhs;
    mType = TGamepadPoseInformation;
    return (*(this));
}

auto GamepadChangeEventBody::operator=(GamepadPoseInformation&& aRhs) -> GamepadChangeEventBody&
{
    if (MaybeDestroy(TGamepadPoseInformation)) {
        new (mozilla::KnownNotNull, ptr_GamepadPoseInformation()) GamepadPoseInformation;
    }
    (*(ptr_GamepadPoseInformation())) = std::move(aRhs);
    mType = TGamepadPoseInformation;
    return (*(this));
}

auto GamepadChangeEventBody::operator=(const GamepadTouchInformation& aRhs) -> GamepadChangeEventBody&
{
    if (MaybeDestroy(TGamepadTouchInformation)) {
        new (mozilla::KnownNotNull, ptr_GamepadTouchInformation()) GamepadTouchInformation;
    }
    (*(ptr_GamepadTouchInformation())) = aRhs;
    mType = TGamepadTouchInformation;
    return (*(this));
}

auto GamepadChangeEventBody::operator=(GamepadTouchInformation&& aRhs) -> GamepadChangeEventBody&
{
    if (MaybeDestroy(TGamepadTouchInformation)) {
        new (mozilla::KnownNotNull, ptr_GamepadTouchInformation()) GamepadTouchInformation;
    }
    (*(ptr_GamepadTouchInformation())) = std::move(aRhs);
    mType = TGamepadTouchInformation;
    return (*(this));
}

auto GamepadChangeEventBody::operator=(const GamepadChangeEventBody& aRhs) -> GamepadChangeEventBody&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TGamepadAdded:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_GamepadAdded()) GamepadAdded;
            }
            (*(ptr_GamepadAdded())) = (aRhs).get_GamepadAdded();
            break;
        }
    case TGamepadRemoved:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_GamepadRemoved()) GamepadRemoved;
            }
            (*(ptr_GamepadRemoved())) = (aRhs).get_GamepadRemoved();
            break;
        }
    case TGamepadAxisInformation:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_GamepadAxisInformation()) GamepadAxisInformation;
            }
            (*(ptr_GamepadAxisInformation())) = (aRhs).get_GamepadAxisInformation();
            break;
        }
    case TGamepadButtonInformation:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_GamepadButtonInformation()) GamepadButtonInformation;
            }
            (*(ptr_GamepadButtonInformation())) = (aRhs).get_GamepadButtonInformation();
            break;
        }
    case TGamepadHandInformation:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_GamepadHandInformation()) GamepadHandInformation;
            }
            (*(ptr_GamepadHandInformation())) = (aRhs).get_GamepadHandInformation();
            break;
        }
    case TGamepadLightIndicatorTypeInformation:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_GamepadLightIndicatorTypeInformation()) GamepadLightIndicatorTypeInformation;
            }
            (*(ptr_GamepadLightIndicatorTypeInformation())) = (aRhs).get_GamepadLightIndicatorTypeInformation();
            break;
        }
    case TGamepadPoseInformation:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_GamepadPoseInformation()) GamepadPoseInformation;
            }
            (*(ptr_GamepadPoseInformation())) = (aRhs).get_GamepadPoseInformation();
            break;
        }
    case TGamepadTouchInformation:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_GamepadTouchInformation()) GamepadTouchInformation;
            }
            (*(ptr_GamepadTouchInformation())) = (aRhs).get_GamepadTouchInformation();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto GamepadChangeEventBody::operator=(GamepadChangeEventBody&& aRhs) -> GamepadChangeEventBody&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TGamepadAdded:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_GamepadAdded()) GamepadAdded;
            }
            (*(ptr_GamepadAdded())) = std::move((aRhs).get_GamepadAdded());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TGamepadRemoved:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_GamepadRemoved()) GamepadRemoved;
            }
            (*(ptr_GamepadRemoved())) = std::move((aRhs).get_GamepadRemoved());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TGamepadAxisInformation:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_GamepadAxisInformation()) GamepadAxisInformation;
            }
            (*(ptr_GamepadAxisInformation())) = std::move((aRhs).get_GamepadAxisInformation());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TGamepadButtonInformation:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_GamepadButtonInformation()) GamepadButtonInformation;
            }
            (*(ptr_GamepadButtonInformation())) = std::move((aRhs).get_GamepadButtonInformation());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TGamepadHandInformation:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_GamepadHandInformation()) GamepadHandInformation;
            }
            (*(ptr_GamepadHandInformation())) = std::move((aRhs).get_GamepadHandInformation());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TGamepadLightIndicatorTypeInformation:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_GamepadLightIndicatorTypeInformation()) GamepadLightIndicatorTypeInformation;
            }
            (*(ptr_GamepadLightIndicatorTypeInformation())) = std::move((aRhs).get_GamepadLightIndicatorTypeInformation());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TGamepadPoseInformation:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_GamepadPoseInformation()) GamepadPoseInformation;
            }
            (*(ptr_GamepadPoseInformation())) = std::move((aRhs).get_GamepadPoseInformation());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TGamepadTouchInformation:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_GamepadTouchInformation()) GamepadTouchInformation;
            }
            (*(ptr_GamepadTouchInformation())) = std::move((aRhs).get_GamepadTouchInformation());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::GamepadChangeEventBody>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::dom::GamepadChangeEventBody union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'GamepadChangeEventBody'
    (aMsg)->WriteSentinel(1612187782);

    switch (type) {
    case union__::TGamepadAdded:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_GamepadAdded());
            // Sentinel = 'TGamepadAdded'
            (aMsg)->WriteSentinel(558695638);
            return;
        }
    case union__::TGamepadRemoved:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_GamepadRemoved());
            // Sentinel = 'TGamepadRemoved'
            (aMsg)->WriteSentinel(758056406);
            return;
        }
    case union__::TGamepadAxisInformation:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_GamepadAxisInformation());
            // Sentinel = 'TGamepadAxisInformation'
            (aMsg)->WriteSentinel(1774389535);
            return;
        }
    case union__::TGamepadButtonInformation:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_GamepadButtonInformation());
            // Sentinel = 'TGamepadButtonInformation'
            (aMsg)->WriteSentinel(2119436806);
            return;
        }
    case union__::TGamepadHandInformation:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_GamepadHandInformation());
            // Sentinel = 'TGamepadHandInformation'
            (aMsg)->WriteSentinel(1752631557);
            return;
        }
    case union__::TGamepadLightIndicatorTypeInformation:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_GamepadLightIndicatorTypeInformation());
            // Sentinel = 'TGamepadLightIndicatorTypeInformation'
            (aMsg)->WriteSentinel(289803969);
            return;
        }
    case union__::TGamepadPoseInformation:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_GamepadPoseInformation());
            // Sentinel = 'TGamepadPoseInformation'
            (aMsg)->WriteSentinel(1778387233);
            return;
        }
    case union__::TGamepadTouchInformation:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_GamepadTouchInformation());
            // Sentinel = 'TGamepadTouchInformation'
            (aMsg)->WriteSentinel(1941768589);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::dom::GamepadChangeEventBody>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::dom::GamepadChangeEventBody union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union GamepadChangeEventBody");
        return false;
    }
    // Sentinel = 'GamepadChangeEventBody'
    if ((!((aMsg)->ReadSentinel(aIter, 1612187782)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union GamepadChangeEventBody");
        return false;
    }

    switch (type) {
    case union__::TGamepadAdded:
        {
            mozilla::dom::GamepadAdded tmp = mozilla::dom::GamepadAdded();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_GamepadAdded())))))) {
                aActor->FatalError("Error deserializing variant TGamepadAdded of union GamepadChangeEventBody");
                return false;
            }
            // Sentinel = 'TGamepadAdded'
            if ((!((aMsg)->ReadSentinel(aIter, 558695638)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TGamepadAdded of union GamepadChangeEventBody");
                return false;
            }
            return true;
        }
    case union__::TGamepadRemoved:
        {
            mozilla::dom::GamepadRemoved tmp = mozilla::dom::GamepadRemoved();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_GamepadRemoved())))))) {
                aActor->FatalError("Error deserializing variant TGamepadRemoved of union GamepadChangeEventBody");
                return false;
            }
            // Sentinel = 'TGamepadRemoved'
            if ((!((aMsg)->ReadSentinel(aIter, 758056406)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TGamepadRemoved of union GamepadChangeEventBody");
                return false;
            }
            return true;
        }
    case union__::TGamepadAxisInformation:
        {
            mozilla::dom::GamepadAxisInformation tmp = mozilla::dom::GamepadAxisInformation();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_GamepadAxisInformation())))))) {
                aActor->FatalError("Error deserializing variant TGamepadAxisInformation of union GamepadChangeEventBody");
                return false;
            }
            // Sentinel = 'TGamepadAxisInformation'
            if ((!((aMsg)->ReadSentinel(aIter, 1774389535)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TGamepadAxisInformation of union GamepadChangeEventBody");
                return false;
            }
            return true;
        }
    case union__::TGamepadButtonInformation:
        {
            mozilla::dom::GamepadButtonInformation tmp = mozilla::dom::GamepadButtonInformation();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_GamepadButtonInformation())))))) {
                aActor->FatalError("Error deserializing variant TGamepadButtonInformation of union GamepadChangeEventBody");
                return false;
            }
            // Sentinel = 'TGamepadButtonInformation'
            if ((!((aMsg)->ReadSentinel(aIter, 2119436806)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TGamepadButtonInformation of union GamepadChangeEventBody");
                return false;
            }
            return true;
        }
    case union__::TGamepadHandInformation:
        {
            mozilla::dom::GamepadHandInformation tmp = mozilla::dom::GamepadHandInformation();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_GamepadHandInformation())))))) {
                aActor->FatalError("Error deserializing variant TGamepadHandInformation of union GamepadChangeEventBody");
                return false;
            }
            // Sentinel = 'TGamepadHandInformation'
            if ((!((aMsg)->ReadSentinel(aIter, 1752631557)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TGamepadHandInformation of union GamepadChangeEventBody");
                return false;
            }
            return true;
        }
    case union__::TGamepadLightIndicatorTypeInformation:
        {
            mozilla::dom::GamepadLightIndicatorTypeInformation tmp = mozilla::dom::GamepadLightIndicatorTypeInformation();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_GamepadLightIndicatorTypeInformation())))))) {
                aActor->FatalError("Error deserializing variant TGamepadLightIndicatorTypeInformation of union GamepadChangeEventBody");
                return false;
            }
            // Sentinel = 'TGamepadLightIndicatorTypeInformation'
            if ((!((aMsg)->ReadSentinel(aIter, 289803969)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TGamepadLightIndicatorTypeInformation of union GamepadChangeEventBody");
                return false;
            }
            return true;
        }
    case union__::TGamepadPoseInformation:
        {
            mozilla::dom::GamepadPoseInformation tmp = mozilla::dom::GamepadPoseInformation();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_GamepadPoseInformation())))))) {
                aActor->FatalError("Error deserializing variant TGamepadPoseInformation of union GamepadChangeEventBody");
                return false;
            }
            // Sentinel = 'TGamepadPoseInformation'
            if ((!((aMsg)->ReadSentinel(aIter, 1778387233)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TGamepadPoseInformation of union GamepadChangeEventBody");
                return false;
            }
            return true;
        }
    case union__::TGamepadTouchInformation:
        {
            mozilla::dom::GamepadTouchInformation tmp = mozilla::dom::GamepadTouchInformation();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_GamepadTouchInformation())))))) {
                aActor->FatalError("Error deserializing variant TGamepadTouchInformation of union GamepadChangeEventBody");
                return false;
            }
            // Sentinel = 'TGamepadTouchInformation'
            if ((!((aMsg)->ReadSentinel(aIter, 1941768589)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TGamepadTouchInformation of union GamepadChangeEventBody");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct GamepadChangeEvent|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::GamepadChangeEvent>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).handle());
    // Sentinel = 'handle'
    (aMsg)->WriteSentinel(142344813);
    WriteIPDLParam(aMsg, aActor, (aVar).body());
    // Sentinel = 'body'
    (aMsg)->WriteSentinel(68813231);
}

auto IPDLParamTraits<mozilla::dom::GamepadChangeEvent>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->handle())))))) {
        aActor->FatalError("Error deserializing 'handle' (GamepadHandle) member of 'GamepadChangeEvent'");
        return false;
    }
    // Sentinel = 'handle'
    if ((!((aMsg)->ReadSentinel(aIter, 142344813)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'handle' (GamepadHandle) member of 'GamepadChangeEvent'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->body())))))) {
        aActor->FatalError("Error deserializing 'body' (GamepadChangeEventBody) member of 'GamepadChangeEvent'");
        return false;
    }
    // Sentinel = 'body'
    if ((!((aMsg)->ReadSentinel(aIter, 68813231)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'body' (GamepadChangeEventBody) member of 'GamepadChangeEvent'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla
