//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/net/PNeckoParent.h"
#include "SerializedLoadContext.h"
#include "mozilla/ProfilerLabels.h"
#include "mozilla/dom/PermissionMessageUtils.h"
#include "mozilla/ipc/IPCStreamUtils.h"
#include "mozilla/ipc/URIUtils.h"
#include "mozilla/net/NeckoParent.h"
#include "nsIPrincipal.h"

#include "mozilla/dom/PContentParent.h"
#include "mozilla/net/PHttpChannelParent.h"
#include "mozilla/net/PCookieServiceParent.h"
#include "mozilla/dom/PBrowserParent.h"
#include "mozilla/net/PFTPChannelParent.h"
#include "mozilla/net/PGIOChannelParent.h"
#include "mozilla/net/PWebSocketParent.h"
#include "mozilla/net/PWebSocketEventListenerParent.h"
#include "mozilla/net/PTCPSocketParent.h"
#include "mozilla/net/PTCPServerSocketParent.h"
#include "mozilla/net/PUDPSocketParent.h"
#include "mozilla/net/PDNSRequestParent.h"
#include "mozilla/ipc/PFileDescriptorSetParent.h"
#include "mozilla/net/PDataChannelParent.h"
#include "mozilla/net/PSimpleChannelParent.h"
#include "mozilla/net/PTransportProviderParent.h"
#include "mozilla/ipc/PChildToParentStreamParent.h"
#include "mozilla/ipc/PParentToChildStreamParent.h"
#include "mozilla/net/PStunAddrsRequestParent.h"
#include "mozilla/net/PFileChannelParent.h"
#include "mozilla/net/PClassifierDummyChannelParent.h"
#include "mozilla/net/PWebrtcTCPSocketParent.h"
#include "mozilla/net/PSocketProcessBridgeParent.h"
#include "mozilla/net/PDocumentChannelParent.h"
#include "mozilla/net/PAltDataOutputStreamParent.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace net {


auto PNeckoParent::Recv__delete__() -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PNeckoParent::RecvPCookieServiceConstructor(PCookieServiceParent* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PNeckoParent::RecvPHttpChannelConstructor(
        PHttpChannelParent* actor,
        PBrowserParent* browser,
        const SerializedLoadContext& loadContext,
        const HttpChannelCreationArgs& args) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PNeckoParent::RecvPFTPChannelConstructor(
        PFTPChannelParent* actor,
        PBrowserParent* browser,
        const SerializedLoadContext& loadContext,
        const FTPChannelCreationArgs& args) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PNeckoParent::RecvPWebSocketConstructor(
        PWebSocketParent* actor,
        PBrowserParent* browser,
        const SerializedLoadContext& loadContext,
        const uint32_t& aSerialID) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PNeckoParent::RecvPTCPServerSocketConstructor(
        PTCPServerSocketParent* actor,
        const uint16_t& localPort,
        const uint16_t& backlog,
        const bool& useArrayBuffers) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PNeckoParent::RecvPUDPSocketConstructor(
        PUDPSocketParent* actor,
        nsIPrincipal* principal,
        const nsCString& filter) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PNeckoParent::RecvPDNSRequestConstructor(
        PDNSRequestParent* actor,
        const nsCString& hostName,
        const nsCString& trrServer,
        const uint16_t& type,
        const OriginAttributes& originAttributes,
        const uint32_t& flags) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PNeckoParent::RecvPDocumentChannelConstructor(
        PDocumentChannelParent* actor,
        const MaybeDiscardedBrowsingContext& browsingContext,
        const DocumentChannelCreationArgs& args) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PNeckoParent::RecvPWebSocketEventListenerConstructor(
        PWebSocketEventListenerParent* actor,
        const uint64_t& aInnerWindowID) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PNeckoParent::RecvPDataChannelConstructor(
        PDataChannelParent* actor,
        const uint32_t& channelId) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PNeckoParent::RecvPGIOChannelConstructor(
        PGIOChannelParent* actor,
        PBrowserParent* browser,
        const SerializedLoadContext& loadContext,
        const GIOChannelCreationArgs& args) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PNeckoParent::RecvPSimpleChannelConstructor(
        PSimpleChannelParent* actor,
        const uint32_t& channelId) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PNeckoParent::RecvPFileChannelConstructor(
        PFileChannelParent* actor,
        const uint32_t& channelId) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PNeckoParent::RecvPClassifierDummyChannelConstructor(
        PClassifierDummyChannelParent* actor,
        nsIURI* uri,
        nsIURI* aTopWindowURI,
        const nsresult& aTopWindowURIResult,
        const mozilla::Maybe<LoadInfoArgs>& loadInfo) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PNeckoParent::RecvPAltDataOutputStreamConstructor(
        PAltDataOutputStreamParent* actor,
        const nsCString& type,
        const int64_t& predictedSize,
        PHttpChannelParent* channel) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PNeckoParent::RecvPStunAddrsRequestConstructor(PStunAddrsRequestParent* actor) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PNeckoParent::RecvPWebrtcTCPSocketConstructor(
        PWebrtcTCPSocketParent* actor,
        const mozilla::Maybe<TabId>& tabId) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

auto PNeckoParent::RecvPTCPSocketConstructor(
        PTCPSocketParent* actor,
        const nsString& host,
        const uint16_t& port) -> mozilla::ipc::IPCResult
{
    return IPC_OK();
}

MOZ_IMPLICIT PNeckoParent::PNeckoParent() :
    mozilla::ipc::IProtocol(PNeckoMsgStart, mozilla::ipc::ParentSide)
{
    MOZ_COUNT_CTOR(PNeckoParent);
}

PNeckoParent::~PNeckoParent()
{
    MOZ_COUNT_DTOR(PNeckoParent);
}

auto PNeckoParent::Manager() const -> PContentParent*
{
    return static_cast<PContentParent*>(IProtocol::Manager());
}

auto PNeckoParent::ManagedPHttpChannelParent(nsTArray<PHttpChannelParent*>& aArr) const -> void
{
    mManagedPHttpChannelParent.ToArray(aArr);
}

auto PNeckoParent::ManagedPHttpChannelParent() const -> const ManagedContainer<PHttpChannelParent>&
{
    return mManagedPHttpChannelParent;
}

auto PNeckoParent::ManagedPCookieServiceParent(nsTArray<PCookieServiceParent*>& aArr) const -> void
{
    mManagedPCookieServiceParent.ToArray(aArr);
}

auto PNeckoParent::ManagedPCookieServiceParent() const -> const ManagedContainer<PCookieServiceParent>&
{
    return mManagedPCookieServiceParent;
}

auto PNeckoParent::ManagedPFTPChannelParent(nsTArray<PFTPChannelParent*>& aArr) const -> void
{
    mManagedPFTPChannelParent.ToArray(aArr);
}

auto PNeckoParent::ManagedPFTPChannelParent() const -> const ManagedContainer<PFTPChannelParent>&
{
    return mManagedPFTPChannelParent;
}

auto PNeckoParent::ManagedPWebSocketParent(nsTArray<PWebSocketParent*>& aArr) const -> void
{
    mManagedPWebSocketParent.ToArray(aArr);
}

auto PNeckoParent::ManagedPWebSocketParent() const -> const ManagedContainer<PWebSocketParent>&
{
    return mManagedPWebSocketParent;
}

auto PNeckoParent::ManagedPWebSocketEventListenerParent(nsTArray<PWebSocketEventListenerParent*>& aArr) const -> void
{
    mManagedPWebSocketEventListenerParent.ToArray(aArr);
}

auto PNeckoParent::ManagedPWebSocketEventListenerParent() const -> const ManagedContainer<PWebSocketEventListenerParent>&
{
    return mManagedPWebSocketEventListenerParent;
}

auto PNeckoParent::ManagedPTCPSocketParent(nsTArray<PTCPSocketParent*>& aArr) const -> void
{
    mManagedPTCPSocketParent.ToArray(aArr);
}

auto PNeckoParent::ManagedPTCPSocketParent() const -> const ManagedContainer<PTCPSocketParent>&
{
    return mManagedPTCPSocketParent;
}

auto PNeckoParent::ManagedPTCPServerSocketParent(nsTArray<PTCPServerSocketParent*>& aArr) const -> void
{
    mManagedPTCPServerSocketParent.ToArray(aArr);
}

auto PNeckoParent::ManagedPTCPServerSocketParent() const -> const ManagedContainer<PTCPServerSocketParent>&
{
    return mManagedPTCPServerSocketParent;
}

auto PNeckoParent::ManagedPUDPSocketParent(nsTArray<PUDPSocketParent*>& aArr) const -> void
{
    mManagedPUDPSocketParent.ToArray(aArr);
}

auto PNeckoParent::ManagedPUDPSocketParent() const -> const ManagedContainer<PUDPSocketParent>&
{
    return mManagedPUDPSocketParent;
}

auto PNeckoParent::ManagedPDNSRequestParent(nsTArray<PDNSRequestParent*>& aArr) const -> void
{
    mManagedPDNSRequestParent.ToArray(aArr);
}

auto PNeckoParent::ManagedPDNSRequestParent() const -> const ManagedContainer<PDNSRequestParent>&
{
    return mManagedPDNSRequestParent;
}

auto PNeckoParent::ManagedPDataChannelParent(nsTArray<PDataChannelParent*>& aArr) const -> void
{
    mManagedPDataChannelParent.ToArray(aArr);
}

auto PNeckoParent::ManagedPDataChannelParent() const -> const ManagedContainer<PDataChannelParent>&
{
    return mManagedPDataChannelParent;
}

auto PNeckoParent::ManagedPGIOChannelParent(nsTArray<PGIOChannelParent*>& aArr) const -> void
{
    mManagedPGIOChannelParent.ToArray(aArr);
}

auto PNeckoParent::ManagedPGIOChannelParent() const -> const ManagedContainer<PGIOChannelParent>&
{
    return mManagedPGIOChannelParent;
}

auto PNeckoParent::ManagedPSimpleChannelParent(nsTArray<PSimpleChannelParent*>& aArr) const -> void
{
    mManagedPSimpleChannelParent.ToArray(aArr);
}

auto PNeckoParent::ManagedPSimpleChannelParent() const -> const ManagedContainer<PSimpleChannelParent>&
{
    return mManagedPSimpleChannelParent;
}

auto PNeckoParent::ManagedPFileChannelParent(nsTArray<PFileChannelParent*>& aArr) const -> void
{
    mManagedPFileChannelParent.ToArray(aArr);
}

auto PNeckoParent::ManagedPFileChannelParent() const -> const ManagedContainer<PFileChannelParent>&
{
    return mManagedPFileChannelParent;
}

auto PNeckoParent::ManagedPTransportProviderParent(nsTArray<PTransportProviderParent*>& aArr) const -> void
{
    mManagedPTransportProviderParent.ToArray(aArr);
}

auto PNeckoParent::ManagedPTransportProviderParent() const -> const ManagedContainer<PTransportProviderParent>&
{
    return mManagedPTransportProviderParent;
}

auto PNeckoParent::ManagedPAltDataOutputStreamParent(nsTArray<PAltDataOutputStreamParent*>& aArr) const -> void
{
    mManagedPAltDataOutputStreamParent.ToArray(aArr);
}

auto PNeckoParent::ManagedPAltDataOutputStreamParent() const -> const ManagedContainer<PAltDataOutputStreamParent>&
{
    return mManagedPAltDataOutputStreamParent;
}

auto PNeckoParent::ManagedPStunAddrsRequestParent(nsTArray<PStunAddrsRequestParent*>& aArr) const -> void
{
    mManagedPStunAddrsRequestParent.ToArray(aArr);
}

auto PNeckoParent::ManagedPStunAddrsRequestParent() const -> const ManagedContainer<PStunAddrsRequestParent>&
{
    return mManagedPStunAddrsRequestParent;
}

auto PNeckoParent::ManagedPClassifierDummyChannelParent(nsTArray<PClassifierDummyChannelParent*>& aArr) const -> void
{
    mManagedPClassifierDummyChannelParent.ToArray(aArr);
}

auto PNeckoParent::ManagedPClassifierDummyChannelParent() const -> const ManagedContainer<PClassifierDummyChannelParent>&
{
    return mManagedPClassifierDummyChannelParent;
}

auto PNeckoParent::ManagedPWebrtcTCPSocketParent(nsTArray<PWebrtcTCPSocketParent*>& aArr) const -> void
{
    mManagedPWebrtcTCPSocketParent.ToArray(aArr);
}

auto PNeckoParent::ManagedPWebrtcTCPSocketParent() const -> const ManagedContainer<PWebrtcTCPSocketParent>&
{
    return mManagedPWebrtcTCPSocketParent;
}

auto PNeckoParent::ManagedPDocumentChannelParent(nsTArray<PDocumentChannelParent*>& aArr) const -> void
{
    mManagedPDocumentChannelParent.ToArray(aArr);
}

auto PNeckoParent::ManagedPDocumentChannelParent() const -> const ManagedContainer<PDocumentChannelParent>&
{
    return mManagedPDocumentChannelParent;
}

auto PNeckoParent::AllManagedActors(nsTArray<RefPtr<mozilla::ipc::ActorLifecycleProxy>>& arr__) const -> void
{
    uint32_t total = 0;
    total += mManagedPHttpChannelParent.Count();
    total += mManagedPCookieServiceParent.Count();
    total += mManagedPFTPChannelParent.Count();
    total += mManagedPWebSocketParent.Count();
    total += mManagedPWebSocketEventListenerParent.Count();
    total += mManagedPTCPSocketParent.Count();
    total += mManagedPTCPServerSocketParent.Count();
    total += mManagedPUDPSocketParent.Count();
    total += mManagedPDNSRequestParent.Count();
    total += mManagedPDataChannelParent.Count();
    total += mManagedPGIOChannelParent.Count();
    total += mManagedPSimpleChannelParent.Count();
    total += mManagedPFileChannelParent.Count();
    total += mManagedPTransportProviderParent.Count();
    total += mManagedPAltDataOutputStreamParent.Count();
    total += mManagedPStunAddrsRequestParent.Count();
    total += mManagedPClassifierDummyChannelParent.Count();
    total += mManagedPWebrtcTCPSocketParent.Count();
    total += mManagedPDocumentChannelParent.Count();
    arr__.SetCapacity(total);

    for (auto it = mManagedPHttpChannelParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPCookieServiceParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPFTPChannelParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPWebSocketParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPWebSocketEventListenerParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPTCPSocketParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPTCPServerSocketParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPUDPSocketParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPDNSRequestParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPDataChannelParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPGIOChannelParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPSimpleChannelParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPFileChannelParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPTransportProviderParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPAltDataOutputStreamParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPStunAddrsRequestParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPClassifierDummyChannelParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPWebrtcTCPSocketParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPDocumentChannelParent.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

}

auto PNeckoParent::OpenPHttpChannelEndpoint(PHttpChannelParent* aActor) -> ManagedEndpoint<PHttpChannelChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PHttpChannelParent actor");
        return ManagedEndpoint<PHttpChannelChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPHttpChannelParent.PutEntry(aActor);

    return ManagedEndpoint<PHttpChannelChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoParent::BindPHttpChannelEndpoint(
        ManagedEndpoint<PHttpChannelParent> aEndpoint,
        PHttpChannelParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PHttpChannelParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPHttpChannelParent.PutEntry(aActor);

    return true;
}

auto PNeckoParent::OpenPCookieServiceEndpoint(PCookieServiceParent* aActor) -> ManagedEndpoint<PCookieServiceChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PCookieServiceParent actor");
        return ManagedEndpoint<PCookieServiceChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPCookieServiceParent.PutEntry(aActor);

    return ManagedEndpoint<PCookieServiceChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoParent::BindPCookieServiceEndpoint(
        ManagedEndpoint<PCookieServiceParent> aEndpoint,
        PCookieServiceParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PCookieServiceParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPCookieServiceParent.PutEntry(aActor);

    return true;
}

auto PNeckoParent::OpenPFTPChannelEndpoint(PFTPChannelParent* aActor) -> ManagedEndpoint<PFTPChannelChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PFTPChannelParent actor");
        return ManagedEndpoint<PFTPChannelChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPFTPChannelParent.PutEntry(aActor);

    return ManagedEndpoint<PFTPChannelChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoParent::BindPFTPChannelEndpoint(
        ManagedEndpoint<PFTPChannelParent> aEndpoint,
        PFTPChannelParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PFTPChannelParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPFTPChannelParent.PutEntry(aActor);

    return true;
}

auto PNeckoParent::OpenPWebSocketEndpoint(PWebSocketParent* aActor) -> ManagedEndpoint<PWebSocketChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebSocketParent actor");
        return ManagedEndpoint<PWebSocketChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPWebSocketParent.PutEntry(aActor);

    return ManagedEndpoint<PWebSocketChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoParent::BindPWebSocketEndpoint(
        ManagedEndpoint<PWebSocketParent> aEndpoint,
        PWebSocketParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebSocketParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPWebSocketParent.PutEntry(aActor);

    return true;
}

auto PNeckoParent::OpenPWebSocketEventListenerEndpoint(PWebSocketEventListenerParent* aActor) -> ManagedEndpoint<PWebSocketEventListenerChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebSocketEventListenerParent actor");
        return ManagedEndpoint<PWebSocketEventListenerChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPWebSocketEventListenerParent.PutEntry(aActor);

    return ManagedEndpoint<PWebSocketEventListenerChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoParent::BindPWebSocketEventListenerEndpoint(
        ManagedEndpoint<PWebSocketEventListenerParent> aEndpoint,
        PWebSocketEventListenerParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebSocketEventListenerParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPWebSocketEventListenerParent.PutEntry(aActor);

    return true;
}

auto PNeckoParent::OpenPTCPSocketEndpoint(PTCPSocketParent* aActor) -> ManagedEndpoint<PTCPSocketChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PTCPSocketParent actor");
        return ManagedEndpoint<PTCPSocketChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPTCPSocketParent.PutEntry(aActor);

    return ManagedEndpoint<PTCPSocketChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoParent::BindPTCPSocketEndpoint(
        ManagedEndpoint<PTCPSocketParent> aEndpoint,
        PTCPSocketParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PTCPSocketParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPTCPSocketParent.PutEntry(aActor);

    return true;
}

auto PNeckoParent::OpenPTCPServerSocketEndpoint(PTCPServerSocketParent* aActor) -> ManagedEndpoint<PTCPServerSocketChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PTCPServerSocketParent actor");
        return ManagedEndpoint<PTCPServerSocketChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPTCPServerSocketParent.PutEntry(aActor);

    return ManagedEndpoint<PTCPServerSocketChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoParent::BindPTCPServerSocketEndpoint(
        ManagedEndpoint<PTCPServerSocketParent> aEndpoint,
        PTCPServerSocketParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PTCPServerSocketParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPTCPServerSocketParent.PutEntry(aActor);

    return true;
}

auto PNeckoParent::OpenPUDPSocketEndpoint(PUDPSocketParent* aActor) -> ManagedEndpoint<PUDPSocketChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PUDPSocketParent actor");
        return ManagedEndpoint<PUDPSocketChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPUDPSocketParent.PutEntry(aActor);

    return ManagedEndpoint<PUDPSocketChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoParent::BindPUDPSocketEndpoint(
        ManagedEndpoint<PUDPSocketParent> aEndpoint,
        PUDPSocketParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PUDPSocketParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPUDPSocketParent.PutEntry(aActor);

    return true;
}

auto PNeckoParent::OpenPDNSRequestEndpoint(PDNSRequestParent* aActor) -> ManagedEndpoint<PDNSRequestChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PDNSRequestParent actor");
        return ManagedEndpoint<PDNSRequestChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPDNSRequestParent.PutEntry(aActor);

    return ManagedEndpoint<PDNSRequestChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoParent::BindPDNSRequestEndpoint(
        ManagedEndpoint<PDNSRequestParent> aEndpoint,
        PDNSRequestParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PDNSRequestParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPDNSRequestParent.PutEntry(aActor);

    return true;
}

auto PNeckoParent::OpenPDataChannelEndpoint(PDataChannelParent* aActor) -> ManagedEndpoint<PDataChannelChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PDataChannelParent actor");
        return ManagedEndpoint<PDataChannelChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPDataChannelParent.PutEntry(aActor);

    return ManagedEndpoint<PDataChannelChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoParent::BindPDataChannelEndpoint(
        ManagedEndpoint<PDataChannelParent> aEndpoint,
        PDataChannelParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PDataChannelParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPDataChannelParent.PutEntry(aActor);

    return true;
}

auto PNeckoParent::OpenPGIOChannelEndpoint(PGIOChannelParent* aActor) -> ManagedEndpoint<PGIOChannelChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PGIOChannelParent actor");
        return ManagedEndpoint<PGIOChannelChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPGIOChannelParent.PutEntry(aActor);

    return ManagedEndpoint<PGIOChannelChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoParent::BindPGIOChannelEndpoint(
        ManagedEndpoint<PGIOChannelParent> aEndpoint,
        PGIOChannelParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PGIOChannelParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPGIOChannelParent.PutEntry(aActor);

    return true;
}

auto PNeckoParent::OpenPSimpleChannelEndpoint(PSimpleChannelParent* aActor) -> ManagedEndpoint<PSimpleChannelChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PSimpleChannelParent actor");
        return ManagedEndpoint<PSimpleChannelChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPSimpleChannelParent.PutEntry(aActor);

    return ManagedEndpoint<PSimpleChannelChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoParent::BindPSimpleChannelEndpoint(
        ManagedEndpoint<PSimpleChannelParent> aEndpoint,
        PSimpleChannelParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PSimpleChannelParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPSimpleChannelParent.PutEntry(aActor);

    return true;
}

auto PNeckoParent::OpenPFileChannelEndpoint(PFileChannelParent* aActor) -> ManagedEndpoint<PFileChannelChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PFileChannelParent actor");
        return ManagedEndpoint<PFileChannelChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPFileChannelParent.PutEntry(aActor);

    return ManagedEndpoint<PFileChannelChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoParent::BindPFileChannelEndpoint(
        ManagedEndpoint<PFileChannelParent> aEndpoint,
        PFileChannelParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PFileChannelParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPFileChannelParent.PutEntry(aActor);

    return true;
}

auto PNeckoParent::OpenPTransportProviderEndpoint(PTransportProviderParent* aActor) -> ManagedEndpoint<PTransportProviderChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PTransportProviderParent actor");
        return ManagedEndpoint<PTransportProviderChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPTransportProviderParent.PutEntry(aActor);

    return ManagedEndpoint<PTransportProviderChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoParent::BindPTransportProviderEndpoint(
        ManagedEndpoint<PTransportProviderParent> aEndpoint,
        PTransportProviderParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PTransportProviderParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPTransportProviderParent.PutEntry(aActor);

    return true;
}

auto PNeckoParent::OpenPAltDataOutputStreamEndpoint(PAltDataOutputStreamParent* aActor) -> ManagedEndpoint<PAltDataOutputStreamChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PAltDataOutputStreamParent actor");
        return ManagedEndpoint<PAltDataOutputStreamChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPAltDataOutputStreamParent.PutEntry(aActor);

    return ManagedEndpoint<PAltDataOutputStreamChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoParent::BindPAltDataOutputStreamEndpoint(
        ManagedEndpoint<PAltDataOutputStreamParent> aEndpoint,
        PAltDataOutputStreamParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PAltDataOutputStreamParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPAltDataOutputStreamParent.PutEntry(aActor);

    return true;
}

auto PNeckoParent::OpenPStunAddrsRequestEndpoint(PStunAddrsRequestParent* aActor) -> ManagedEndpoint<PStunAddrsRequestChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PStunAddrsRequestParent actor");
        return ManagedEndpoint<PStunAddrsRequestChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPStunAddrsRequestParent.PutEntry(aActor);

    return ManagedEndpoint<PStunAddrsRequestChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoParent::BindPStunAddrsRequestEndpoint(
        ManagedEndpoint<PStunAddrsRequestParent> aEndpoint,
        PStunAddrsRequestParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PStunAddrsRequestParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPStunAddrsRequestParent.PutEntry(aActor);

    return true;
}

auto PNeckoParent::OpenPClassifierDummyChannelEndpoint(PClassifierDummyChannelParent* aActor) -> ManagedEndpoint<PClassifierDummyChannelChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PClassifierDummyChannelParent actor");
        return ManagedEndpoint<PClassifierDummyChannelChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPClassifierDummyChannelParent.PutEntry(aActor);

    return ManagedEndpoint<PClassifierDummyChannelChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoParent::BindPClassifierDummyChannelEndpoint(
        ManagedEndpoint<PClassifierDummyChannelParent> aEndpoint,
        PClassifierDummyChannelParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PClassifierDummyChannelParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPClassifierDummyChannelParent.PutEntry(aActor);

    return true;
}

auto PNeckoParent::OpenPWebrtcTCPSocketEndpoint(PWebrtcTCPSocketParent* aActor) -> ManagedEndpoint<PWebrtcTCPSocketChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebrtcTCPSocketParent actor");
        return ManagedEndpoint<PWebrtcTCPSocketChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPWebrtcTCPSocketParent.PutEntry(aActor);

    return ManagedEndpoint<PWebrtcTCPSocketChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoParent::BindPWebrtcTCPSocketEndpoint(
        ManagedEndpoint<PWebrtcTCPSocketParent> aEndpoint,
        PWebrtcTCPSocketParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebrtcTCPSocketParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPWebrtcTCPSocketParent.PutEntry(aActor);

    return true;
}

auto PNeckoParent::OpenPDocumentChannelEndpoint(PDocumentChannelParent* aActor) -> ManagedEndpoint<PDocumentChannelChild>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PDocumentChannelParent actor");
        return ManagedEndpoint<PDocumentChannelChild>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPDocumentChannelParent.PutEntry(aActor);

    return ManagedEndpoint<PDocumentChannelChild>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PNeckoParent::BindPDocumentChannelEndpoint(
        ManagedEndpoint<PDocumentChannelParent> aEndpoint,
        PDocumentChannelParent* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PDocumentChannelParent actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPDocumentChannelParent.PutEntry(aActor);

    return true;
}

auto PNeckoParent::SendAsyncAuthPromptForNestedFrame(
        const TabId& nestedFrameId,
        const nsCString& uri,
        const nsString& realm,
        const uint64_t& callbackId) -> bool
{
    IPC::Message* msg__ = PNecko::Msg_AsyncAuthPromptForNestedFrame(Id());

    WriteIPDLParam(msg__, this, nestedFrameId);
    // Sentinel = 'nestedFrameId'
    (msg__)->WriteSentinel(618202396);
    WriteIPDLParam(msg__, this, uri);
    // Sentinel = 'uri'
    (msg__)->WriteSentinel(45023569);
    WriteIPDLParam(msg__, this, realm);
    // Sentinel = 'realm'
    (msg__)->WriteSentinel(104530450);
    WriteIPDLParam(msg__, this, callbackId);
    // Sentinel = 'callbackId'
    (msg__)->WriteSentinel(362349531);




    if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_AsyncAuthPromptForNestedFrame", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PNeckoParent::SendPredOnPredictPrefetch(
        nsIURI* uri,
        const uint32_t& httpStatus) -> bool
{
    IPC::Message* msg__ = PNecko::Msg_PredOnPredictPrefetch(Id());

    WriteIPDLParam(msg__, this, uri);
    // Sentinel = 'uri'
    (msg__)->WriteSentinel(45023569);
    WriteIPDLParam(msg__, this, httpStatus);
    // Sentinel = 'httpStatus'
    (msg__)->WriteSentinel(391185477);




    if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PredOnPredictPrefetch", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PNeckoParent::SendPredOnPredictPreconnect(nsIURI* uri) -> bool
{
    IPC::Message* msg__ = PNecko::Msg_PredOnPredictPreconnect(Id());

    WriteIPDLParam(msg__, this, uri);
    // Sentinel = 'uri'
    (msg__)->WriteSentinel(45023569);




    if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PredOnPredictPreconnect", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PNeckoParent::SendPredOnPredictDNS(nsIURI* uri) -> bool
{
    IPC::Message* msg__ = PNecko::Msg_PredOnPredictDNS(Id());

    WriteIPDLParam(msg__, this, uri);
    // Sentinel = 'uri'
    (msg__)->WriteSentinel(45023569);




    if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PredOnPredictDNS", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PNeckoParent::SendSpeculativeConnectRequest() -> bool
{
    IPC::Message* msg__ = PNecko::Msg_SpeculativeConnectRequest(Id());





    if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_SpeculativeConnectRequest", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PNeckoParent::SendNetworkChangeNotification(const nsCString& type) -> bool
{
    IPC::Message* msg__ = PNecko::Msg_NetworkChangeNotification(Id());

    WriteIPDLParam(msg__, this, type);
    // Sentinel = 'type'
    (msg__)->WriteSentinel(75760067);




    if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_NetworkChangeNotification", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PNeckoParent::SendPTransportProviderConstructor() -> PTransportProviderParent*
{
    PTransportProviderParent* actor = (static_cast<NeckoParent*>(this))->AllocPTransportProviderParent();
    return SendPTransportProviderConstructor(actor);
}

auto PNeckoParent::SendPTransportProviderConstructor(PTransportProviderParent* actor) -> PTransportProviderParent*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PTransportProviderParent actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPTransportProviderParent.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PNecko::Msg_PTransportProviderConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PTransportProviderConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PTransportProviderParent constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PTransportProviderMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PNeckoParent::SendPTCPSocketConstructor(
        const nsString& host,
        const uint16_t& port) -> PTCPSocketParent*
{
    PTCPSocketParent* actor = (static_cast<NeckoParent*>(this))->AllocPTCPSocketParent(host, port);
    return SendPTCPSocketConstructor(actor, host, port);
}

auto PNeckoParent::SendPTCPSocketConstructor(
        PTCPSocketParent* actor,
        const nsString& host,
        const uint16_t& port) -> PTCPSocketParent*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PTCPSocketParent actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPTCPSocketParent.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PNecko::Msg_PTCPSocketConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, host);
    // Sentinel = 'host'
    (msg__)->WriteSentinel(72024511);
    WriteIPDLParam(msg__, this, port);
    // Sentinel = 'port'
    (msg__)->WriteSentinel(73990598);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
        mozilla::ipc::LogMessageForProtocol(
            "PNeckoParent",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PNecko::Msg_PTCPSocketConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PTCPSocketParent constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PTCPSocketMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PNeckoParent::RemoveManagee(
        int32_t aProtocolId,
        IProtocol* aListener) -> void
{
    switch (aProtocolId) {
    case PHttpChannelMsgStart:
{
            PHttpChannelParent* actor = static_cast<PHttpChannelParent*>(aListener);
            auto& container = mManagedPHttpChannelParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PCookieServiceMsgStart:
{
            PCookieServiceParent* actor = static_cast<PCookieServiceParent*>(aListener);
            auto& container = mManagedPCookieServiceParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PFTPChannelMsgStart:
{
            PFTPChannelParent* actor = static_cast<PFTPChannelParent*>(aListener);
            auto& container = mManagedPFTPChannelParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PWebSocketMsgStart:
{
            PWebSocketParent* actor = static_cast<PWebSocketParent*>(aListener);
            auto& container = mManagedPWebSocketParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PWebSocketEventListenerMsgStart:
{
            PWebSocketEventListenerParent* actor = static_cast<PWebSocketEventListenerParent*>(aListener);
            auto& container = mManagedPWebSocketEventListenerParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PTCPSocketMsgStart:
{
            PTCPSocketParent* actor = static_cast<PTCPSocketParent*>(aListener);
            auto& container = mManagedPTCPSocketParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PTCPServerSocketMsgStart:
{
            PTCPServerSocketParent* actor = static_cast<PTCPServerSocketParent*>(aListener);
            auto& container = mManagedPTCPServerSocketParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PUDPSocketMsgStart:
{
            PUDPSocketParent* actor = static_cast<PUDPSocketParent*>(aListener);
            auto& container = mManagedPUDPSocketParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PDNSRequestMsgStart:
{
            PDNSRequestParent* actor = static_cast<PDNSRequestParent*>(aListener);
            auto& container = mManagedPDNSRequestParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PDataChannelMsgStart:
{
            PDataChannelParent* actor = static_cast<PDataChannelParent*>(aListener);
            auto& container = mManagedPDataChannelParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PGIOChannelMsgStart:
{
            PGIOChannelParent* actor = static_cast<PGIOChannelParent*>(aListener);
            auto& container = mManagedPGIOChannelParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PSimpleChannelMsgStart:
{
            PSimpleChannelParent* actor = static_cast<PSimpleChannelParent*>(aListener);
            auto& container = mManagedPSimpleChannelParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PFileChannelMsgStart:
{
            PFileChannelParent* actor = static_cast<PFileChannelParent*>(aListener);
            auto& container = mManagedPFileChannelParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PTransportProviderMsgStart:
{
            PTransportProviderParent* actor = static_cast<PTransportProviderParent*>(aListener);
            auto& container = mManagedPTransportProviderParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PAltDataOutputStreamMsgStart:
{
            PAltDataOutputStreamParent* actor = static_cast<PAltDataOutputStreamParent*>(aListener);
            auto& container = mManagedPAltDataOutputStreamParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PStunAddrsRequestMsgStart:
{
            PStunAddrsRequestParent* actor = static_cast<PStunAddrsRequestParent*>(aListener);
            auto& container = mManagedPStunAddrsRequestParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PClassifierDummyChannelMsgStart:
{
            PClassifierDummyChannelParent* actor = static_cast<PClassifierDummyChannelParent*>(aListener);
            auto& container = mManagedPClassifierDummyChannelParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PWebrtcTCPSocketMsgStart:
{
            PWebrtcTCPSocketParent* actor = static_cast<PWebrtcTCPSocketParent*>(aListener);
            auto& container = mManagedPWebrtcTCPSocketParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PDocumentChannelMsgStart:
{
            PDocumentChannelParent* actor = static_cast<PDocumentChannelParent*>(aListener);
            auto& container = mManagedPDocumentChannelParent;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    default:
FatalError("unreached");
        return;    }
}

auto PNeckoParent::DeallocManagee(
        int32_t aProtocolId,
        IProtocol* aListener) -> void
{
    switch (aProtocolId) {
    case PCookieServiceMsgStart:
        static_cast<NeckoParent*>(this)->DeallocPCookieServiceParent(static_cast<PCookieServiceParent*>(aListener));
        return;
    case PFTPChannelMsgStart:
        static_cast<NeckoParent*>(this)->DeallocPFTPChannelParent(static_cast<PFTPChannelParent*>(aListener));
        return;
    case PWebSocketMsgStart:
        static_cast<NeckoParent*>(this)->DeallocPWebSocketParent(static_cast<PWebSocketParent*>(aListener));
        return;
    case PWebSocketEventListenerMsgStart:
        static_cast<NeckoParent*>(this)->DeallocPWebSocketEventListenerParent(static_cast<PWebSocketEventListenerParent*>(aListener));
        return;
    case PTCPSocketMsgStart:
        static_cast<NeckoParent*>(this)->DeallocPTCPSocketParent(static_cast<PTCPSocketParent*>(aListener));
        return;
    case PTCPServerSocketMsgStart:
        static_cast<NeckoParent*>(this)->DeallocPTCPServerSocketParent(static_cast<PTCPServerSocketParent*>(aListener));
        return;
    case PUDPSocketMsgStart:
        static_cast<NeckoParent*>(this)->DeallocPUDPSocketParent(static_cast<PUDPSocketParent*>(aListener));
        return;
    case PGIOChannelMsgStart:
        static_cast<NeckoParent*>(this)->DeallocPGIOChannelParent(static_cast<PGIOChannelParent*>(aListener));
        return;
    case PSimpleChannelMsgStart:
        static_cast<NeckoParent*>(this)->DeallocPSimpleChannelParent(static_cast<PSimpleChannelParent*>(aListener));
        return;
    case PTransportProviderMsgStart:
        static_cast<NeckoParent*>(this)->DeallocPTransportProviderParent(static_cast<PTransportProviderParent*>(aListener));
        return;
    case PAltDataOutputStreamMsgStart:
        static_cast<NeckoParent*>(this)->DeallocPAltDataOutputStreamParent(static_cast<PAltDataOutputStreamParent*>(aListener));
        return;
    case PStunAddrsRequestMsgStart:
        static_cast<NeckoParent*>(this)->DeallocPStunAddrsRequestParent(static_cast<PStunAddrsRequestParent*>(aListener));
        return;
    case PClassifierDummyChannelMsgStart:
        static_cast<NeckoParent*>(this)->DeallocPClassifierDummyChannelParent(static_cast<PClassifierDummyChannelParent*>(aListener));
        return;
    case PWebrtcTCPSocketMsgStart:
        static_cast<NeckoParent*>(this)->DeallocPWebrtcTCPSocketParent(static_cast<PWebrtcTCPSocketParent*>(aListener));
        return;
    default:
        FatalError("unreached");
        return;
    }
}

auto PNeckoParent::OnMessageReceived(const Message& msg__) -> PNeckoParent::Result
{
    switch (msg__.type()) {
    case PNecko::Msg___delete____ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg___delete__", OTHER);

            PickleIterator iter__{msg__};
            PNeckoParent* actor{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(actor)))))) {
                FatalError("Error deserializing 'PNecko'");
                return MsgValueError;
            }
            if ((!((*((&(actor))))))) {
                FatalError("Error deserializing 'PNecko'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'PNecko'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<NeckoParent*>(this))->Recv__delete__()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }


            IProtocol* mgr = actor->Manager();
            actor->DestroySubtree(Deletion);
            actor->ClearSubtree();
            mgr->RemoveManagee(PNeckoMsgStart, actor);

            return MsgProcessed;
        }
    case PNecko::Msg_PCookieServiceConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PCookieServiceConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PCookieServiceParent* actor = (static_cast<NeckoParent*>(this))->AllocPCookieServiceParent();
            if (!actor) {
                NS_WARNING("Cannot bind null PCookieServiceParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPCookieServiceParent.PutEntry(actor);

            if ((!((static_cast<NeckoParent*>(this))->RecvPCookieServiceConstructor(std::move(actor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PHttpChannelConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PHttpChannelConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            PBrowserParent* browser{};
            SerializedLoadContext loadContext{};
            HttpChannelCreationArgs args{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(browser)))))) {
                FatalError("Error deserializing 'PBrowser'");
                return MsgValueError;
            }
            // Sentinel = 'browser'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 201130757)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'PBrowser'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(loadContext)))))) {
                FatalError("Error deserializing 'SerializedLoadContext'");
                return MsgValueError;
            }
            // Sentinel = 'loadContext'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 444990598)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'SerializedLoadContext'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(args)))))) {
                FatalError("Error deserializing 'HttpChannelCreationArgs'");
                return MsgValueError;
            }
            // Sentinel = 'args'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 69140910)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'HttpChannelCreationArgs'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PHttpChannelParent> actor = (static_cast<NeckoParent*>(this))->AllocPHttpChannelParent(browser, loadContext, args);
            if (!actor) {
                NS_WARNING("Cannot bind null PHttpChannelParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPHttpChannelParent.PutEntry(actor);

            if ((!((static_cast<NeckoParent*>(this))->RecvPHttpChannelConstructor(actor, browser, std::move(loadContext), std::move(args))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PFTPChannelConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PFTPChannelConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            PBrowserParent* browser{};
            SerializedLoadContext loadContext{};
            FTPChannelCreationArgs args{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(browser)))))) {
                FatalError("Error deserializing 'PBrowser'");
                return MsgValueError;
            }
            // Sentinel = 'browser'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 201130757)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'PBrowser'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(loadContext)))))) {
                FatalError("Error deserializing 'SerializedLoadContext'");
                return MsgValueError;
            }
            // Sentinel = 'loadContext'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 444990598)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'SerializedLoadContext'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(args)))))) {
                FatalError("Error deserializing 'FTPChannelCreationArgs'");
                return MsgValueError;
            }
            // Sentinel = 'args'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 69140910)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'FTPChannelCreationArgs'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PFTPChannelParent* actor = (static_cast<NeckoParent*>(this))->AllocPFTPChannelParent(browser, loadContext, args);
            if (!actor) {
                NS_WARNING("Cannot bind null PFTPChannelParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPFTPChannelParent.PutEntry(actor);

            if ((!((static_cast<NeckoParent*>(this))->RecvPFTPChannelConstructor(std::move(actor), browser, std::move(loadContext), std::move(args))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PWebSocketConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PWebSocketConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            PBrowserParent* browser{};
            SerializedLoadContext loadContext{};
            uint32_t aSerialID{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(browser)))))) {
                FatalError("Error deserializing 'PBrowser'");
                return MsgValueError;
            }
            // Sentinel = 'browser'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 201130757)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'PBrowser'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(loadContext)))))) {
                FatalError("Error deserializing 'SerializedLoadContext'");
                return MsgValueError;
            }
            // Sentinel = 'loadContext'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 444990598)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'SerializedLoadContext'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aSerialID)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'aSerialID'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 287572815)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PWebSocketParent* actor = (static_cast<NeckoParent*>(this))->AllocPWebSocketParent(browser, loadContext, aSerialID);
            if (!actor) {
                NS_WARNING("Cannot bind null PWebSocketParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPWebSocketParent.PutEntry(actor);

            if ((!((static_cast<NeckoParent*>(this))->RecvPWebSocketConstructor(std::move(actor), browser, std::move(loadContext), std::move(aSerialID))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PTCPServerSocketConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PTCPServerSocketConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            uint16_t localPort{};
            uint16_t backlog{};
            bool useArrayBuffers{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(localPort)))))) {
                FatalError("Error deserializing 'uint16_t'");
                return MsgValueError;
            }
            // Sentinel = 'localPort'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 306774961)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint16_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(backlog)))))) {
                FatalError("Error deserializing 'uint16_t'");
                return MsgValueError;
            }
            // Sentinel = 'backlog'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 186581716)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint16_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(useArrayBuffers)))))) {
                FatalError("Error deserializing 'bool'");
                return MsgValueError;
            }
            // Sentinel = 'useArrayBuffers'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 815007258)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PTCPServerSocketParent* actor = (static_cast<NeckoParent*>(this))->AllocPTCPServerSocketParent(localPort, backlog, useArrayBuffers);
            if (!actor) {
                NS_WARNING("Cannot bind null PTCPServerSocketParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPTCPServerSocketParent.PutEntry(actor);

            if ((!((static_cast<NeckoParent*>(this))->RecvPTCPServerSocketConstructor(std::move(actor), std::move(localPort), std::move(backlog), std::move(useArrayBuffers))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PUDPSocketConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PUDPSocketConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            RefPtr<nsIPrincipal> principal{};
            nsCString filter{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(principal)))))) {
                FatalError("Error deserializing 'nsIPrincipal'");
                return MsgValueError;
            }
            // Sentinel = 'principal'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 319620035)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsIPrincipal'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(filter)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'filter'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 146735751)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PUDPSocketParent* actor = (static_cast<NeckoParent*>(this))->AllocPUDPSocketParent(principal, filter);
            if (!actor) {
                NS_WARNING("Cannot bind null PUDPSocketParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPUDPSocketParent.PutEntry(actor);

            if ((!((static_cast<NeckoParent*>(this))->RecvPUDPSocketConstructor(std::move(actor), principal, std::move(filter))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PDNSRequestConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PDNSRequestConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            nsCString hostName{};
            nsCString trrServer{};
            uint16_t type{};
            OriginAttributes originAttributes{};
            uint32_t flags{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(hostName)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'hostName'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 249627456)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(trrServer)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'trrServer'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 320603088)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(type)))))) {
                FatalError("Error deserializing 'uint16_t'");
                return MsgValueError;
            }
            // Sentinel = 'type'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 75760067)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint16_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(originAttributes)))))) {
                FatalError("Error deserializing 'OriginAttributes'");
                return MsgValueError;
            }
            // Sentinel = 'originAttributes'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 947259056)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'OriginAttributes'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(flags)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'flags'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102171150)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PDNSRequestParent> actor = (static_cast<NeckoParent*>(this))->AllocPDNSRequestParent(hostName, trrServer, type, originAttributes, flags);
            if (!actor) {
                NS_WARNING("Cannot bind null PDNSRequestParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPDNSRequestParent.PutEntry(actor);

            if ((!((static_cast<NeckoParent*>(this))->RecvPDNSRequestConstructor(actor, std::move(hostName), std::move(trrServer), std::move(type), std::move(originAttributes), std::move(flags))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PDocumentChannelConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PDocumentChannelConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            MaybeDiscardedBrowsingContext browsingContext{};
            DocumentChannelCreationArgs args{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(browsingContext)))))) {
                FatalError("Error deserializing 'MaybeDiscardedBrowsingContext'");
                return MsgValueError;
            }
            // Sentinel = 'browsingContext'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 844695121)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'MaybeDiscardedBrowsingContext'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(args)))))) {
                FatalError("Error deserializing 'DocumentChannelCreationArgs'");
                return MsgValueError;
            }
            // Sentinel = 'args'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 69140910)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'DocumentChannelCreationArgs'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PDocumentChannelParent> actor = (static_cast<NeckoParent*>(this))->AllocPDocumentChannelParent(browsingContext, args);
            if (!actor) {
                NS_WARNING("Cannot bind null PDocumentChannelParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPDocumentChannelParent.PutEntry(actor);

            if ((!((static_cast<NeckoParent*>(this))->RecvPDocumentChannelConstructor(actor, std::move(browsingContext), std::move(args))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PWebSocketEventListenerConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PWebSocketEventListenerConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            uint64_t aInnerWindowID{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aInnerWindowID)))))) {
                FatalError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            // Sentinel = 'aInnerWindowID'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 687670627)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PWebSocketEventListenerParent* actor = (static_cast<NeckoParent*>(this))->AllocPWebSocketEventListenerParent(aInnerWindowID);
            if (!actor) {
                NS_WARNING("Cannot bind null PWebSocketEventListenerParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPWebSocketEventListenerParent.PutEntry(actor);

            if ((!((static_cast<NeckoParent*>(this))->RecvPWebSocketEventListenerConstructor(std::move(actor), std::move(aInnerWindowID))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PredPredict__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PredPredict", OTHER);

            PickleIterator iter__{msg__};
            RefPtr<nsIURI> targetURI{};
            RefPtr<nsIURI> sourceURI{};
            uint32_t reason{};
            OriginAttributes originAttributes{};
            bool hasVerifier{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(targetURI)))))) {
                FatalError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            // Sentinel = 'targetURI'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 308413304)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(sourceURI)))))) {
                FatalError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            // Sentinel = 'sourceURI'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 316277634)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(reason)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'reason'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 148112009)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(originAttributes)))))) {
                FatalError("Error deserializing 'OriginAttributes'");
                return MsgValueError;
            }
            // Sentinel = 'originAttributes'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 947259056)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'OriginAttributes'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(hasVerifier)))))) {
                FatalError("Error deserializing 'bool'");
                return MsgValueError;
            }
            // Sentinel = 'hasVerifier'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 445842553)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<NeckoParent*>(this))->RecvPredPredict(targetURI, sourceURI, std::move(reason), std::move(originAttributes), std::move(hasVerifier))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PredLearn__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PredLearn", OTHER);

            PickleIterator iter__{msg__};
            RefPtr<nsIURI> targetURI{};
            RefPtr<nsIURI> sourceURI{};
            uint32_t reason{};
            OriginAttributes originAttributes{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(targetURI)))))) {
                FatalError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            // Sentinel = 'targetURI'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 308413304)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(sourceURI)))))) {
                FatalError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            // Sentinel = 'sourceURI'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 316277634)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(reason)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'reason'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 148112009)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(originAttributes)))))) {
                FatalError("Error deserializing 'OriginAttributes'");
                return MsgValueError;
            }
            // Sentinel = 'originAttributes'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 947259056)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'OriginAttributes'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<NeckoParent*>(this))->RecvPredLearn(targetURI, sourceURI, std::move(reason), std::move(originAttributes))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PredReset__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PredReset", OTHER);

            if ((!((static_cast<NeckoParent*>(this))->RecvPredReset()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_SpeculativeConnect__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_SpeculativeConnect", OTHER);

            PickleIterator iter__{msg__};
            RefPtr<nsIURI> uri{};
            RefPtr<nsIPrincipal> principal{};
            bool anonymous{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(uri)))))) {
                FatalError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            // Sentinel = 'uri'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 45023569)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(principal)))))) {
                FatalError("Error deserializing 'nsIPrincipal'");
                return MsgValueError;
            }
            // Sentinel = 'principal'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 319620035)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsIPrincipal'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(anonymous)))))) {
                FatalError("Error deserializing 'bool'");
                return MsgValueError;
            }
            // Sentinel = 'anonymous'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 322569194)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<NeckoParent*>(this))->RecvSpeculativeConnect(uri, principal, std::move(anonymous))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_HTMLDNSPrefetch__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_HTMLDNSPrefetch", OTHER);

            PickleIterator iter__{msg__};
            nsString hostname{};
            bool isHttps{};
            OriginAttributes originAttributes{};
            uint32_t flags{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(hostname)))))) {
                FatalError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            // Sentinel = 'hostname'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 258016096)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(isHttps)))))) {
                FatalError("Error deserializing 'bool'");
                return MsgValueError;
            }
            // Sentinel = 'isHttps'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 192873200)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(originAttributes)))))) {
                FatalError("Error deserializing 'OriginAttributes'");
                return MsgValueError;
            }
            // Sentinel = 'originAttributes'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 947259056)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'OriginAttributes'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(flags)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'flags'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102171150)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<NeckoParent*>(this))->RecvHTMLDNSPrefetch(std::move(hostname), std::move(isHttps), std::move(originAttributes), std::move(flags))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_CancelHTMLDNSPrefetch__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_CancelHTMLDNSPrefetch", OTHER);

            PickleIterator iter__{msg__};
            nsString hostname{};
            bool isHttps{};
            OriginAttributes originAttributes{};
            uint32_t flags{};
            nsresult reason{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(hostname)))))) {
                FatalError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            // Sentinel = 'hostname'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 258016096)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(isHttps)))))) {
                FatalError("Error deserializing 'bool'");
                return MsgValueError;
            }
            // Sentinel = 'isHttps'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 192873200)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(originAttributes)))))) {
                FatalError("Error deserializing 'OriginAttributes'");
                return MsgValueError;
            }
            // Sentinel = 'originAttributes'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 947259056)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'OriginAttributes'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(flags)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'flags'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102171150)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(reason)))))) {
                FatalError("Error deserializing 'nsresult'");
                return MsgValueError;
            }
            // Sentinel = 'reason'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 148112009)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsresult'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<NeckoParent*>(this))->RecvCancelHTMLDNSPrefetch(std::move(hostname), std::move(isHttps), std::move(originAttributes), std::move(flags), std::move(reason))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PDataChannelConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PDataChannelConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            uint32_t channelId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(channelId)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'channelId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 301138823)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PDataChannelParent> actor = (static_cast<NeckoParent*>(this))->AllocPDataChannelParent(channelId);
            if (!actor) {
                NS_WARNING("Cannot bind null PDataChannelParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPDataChannelParent.PutEntry(actor);

            if ((!((static_cast<NeckoParent*>(this))->RecvPDataChannelConstructor(actor, std::move(channelId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PGIOChannelConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PGIOChannelConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            PBrowserParent* browser{};
            SerializedLoadContext loadContext{};
            GIOChannelCreationArgs args{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(browser)))))) {
                FatalError("Error deserializing 'PBrowser'");
                return MsgValueError;
            }
            // Sentinel = 'browser'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 201130757)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'PBrowser'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(loadContext)))))) {
                FatalError("Error deserializing 'SerializedLoadContext'");
                return MsgValueError;
            }
            // Sentinel = 'loadContext'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 444990598)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'SerializedLoadContext'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(args)))))) {
                FatalError("Error deserializing 'GIOChannelCreationArgs'");
                return MsgValueError;
            }
            // Sentinel = 'args'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 69140910)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'GIOChannelCreationArgs'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PGIOChannelParent* actor = (static_cast<NeckoParent*>(this))->AllocPGIOChannelParent(browser, loadContext, args);
            if (!actor) {
                NS_WARNING("Cannot bind null PGIOChannelParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPGIOChannelParent.PutEntry(actor);

            if ((!((static_cast<NeckoParent*>(this))->RecvPGIOChannelConstructor(std::move(actor), browser, std::move(loadContext), std::move(args))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PSimpleChannelConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PSimpleChannelConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            uint32_t channelId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(channelId)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'channelId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 301138823)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PSimpleChannelParent* actor = (static_cast<NeckoParent*>(this))->AllocPSimpleChannelParent(channelId);
            if (!actor) {
                NS_WARNING("Cannot bind null PSimpleChannelParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPSimpleChannelParent.PutEntry(actor);

            if ((!((static_cast<NeckoParent*>(this))->RecvPSimpleChannelConstructor(std::move(actor), std::move(channelId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PFileChannelConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PFileChannelConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            uint32_t channelId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(channelId)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'channelId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 301138823)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            RefPtr<PFileChannelParent> actor = (static_cast<NeckoParent*>(this))->AllocPFileChannelParent(channelId);
            if (!actor) {
                NS_WARNING("Cannot bind null PFileChannelParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPFileChannelParent.PutEntry(actor);

            if ((!((static_cast<NeckoParent*>(this))->RecvPFileChannelConstructor(actor, std::move(channelId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PClassifierDummyChannelConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PClassifierDummyChannelConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            RefPtr<nsIURI> uri{};
            RefPtr<nsIURI> aTopWindowURI{};
            nsresult aTopWindowURIResult{};
            mozilla::Maybe<LoadInfoArgs> loadInfo{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(uri)))))) {
                FatalError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            // Sentinel = 'uri'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 45023569)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aTopWindowURI)))))) {
                FatalError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            // Sentinel = 'aTopWindowURI'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 598934781)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aTopWindowURIResult)))))) {
                FatalError("Error deserializing 'nsresult'");
                return MsgValueError;
            }
            // Sentinel = 'aTopWindowURIResult'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 1241319292)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsresult'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(loadInfo)))))) {
                FatalError("Error deserializing 'LoadInfoArgs?'");
                return MsgValueError;
            }
            // Sentinel = 'loadInfo'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 240386861)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'LoadInfoArgs?'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PClassifierDummyChannelParent* actor = (static_cast<NeckoParent*>(this))->AllocPClassifierDummyChannelParent(uri, aTopWindowURI, aTopWindowURIResult, loadInfo);
            if (!actor) {
                NS_WARNING("Cannot bind null PClassifierDummyChannelParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPClassifierDummyChannelParent.PutEntry(actor);

            if ((!((static_cast<NeckoParent*>(this))->RecvPClassifierDummyChannelConstructor(std::move(actor), uri, aTopWindowURI, std::move(aTopWindowURIResult), std::move(loadInfo))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_OnAuthAvailable__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_OnAuthAvailable", OTHER);

            PickleIterator iter__{msg__};
            uint64_t callbackId{};
            nsString user{};
            nsString password{};
            nsString domain{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(callbackId)))))) {
                FatalError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            // Sentinel = 'callbackId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 362349531)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(user)))))) {
                FatalError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            // Sentinel = 'user'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 74252736)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(password)))))) {
                FatalError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            // Sentinel = 'password'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 261161844)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(domain)))))) {
                FatalError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            // Sentinel = 'domain'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 144704121)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<NeckoParent*>(this))->RecvOnAuthAvailable(std::move(callbackId), std::move(user), std::move(password), std::move(domain))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_OnAuthCancelled__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_OnAuthCancelled", OTHER);

            PickleIterator iter__{msg__};
            uint64_t callbackId{};
            bool userCancel{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(callbackId)))))) {
                FatalError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            // Sentinel = 'callbackId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 362349531)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(userCancel)))))) {
                FatalError("Error deserializing 'bool'");
                return MsgValueError;
            }
            // Sentinel = 'userCancel'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 377160710)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<NeckoParent*>(this))->RecvOnAuthCancelled(std::move(callbackId), std::move(userCancel))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_RequestContextLoadBegin__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_RequestContextLoadBegin", OTHER);

            PickleIterator iter__{msg__};
            uint64_t rcid{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(rcid)))))) {
                FatalError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            // Sentinel = 'rcid'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 69927331)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<NeckoParent*>(this))->RecvRequestContextLoadBegin(std::move(rcid))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_RequestContextAfterDOMContentLoaded__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_RequestContextAfterDOMContentLoaded", OTHER);

            PickleIterator iter__{msg__};
            uint64_t rcid{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(rcid)))))) {
                FatalError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            // Sentinel = 'rcid'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 69927331)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<NeckoParent*>(this))->RecvRequestContextAfterDOMContentLoaded(std::move(rcid))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_RemoveRequestContext__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_RemoveRequestContext", OTHER);

            PickleIterator iter__{msg__};
            uint64_t rcid{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(rcid)))))) {
                FatalError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            // Sentinel = 'rcid'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 69927331)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<NeckoParent*>(this))->RecvRemoveRequestContext(std::move(rcid))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PAltDataOutputStreamConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PAltDataOutputStreamConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            nsCString type{};
            int64_t predictedSize{};
            PHttpChannelParent* channel{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(type)))))) {
                FatalError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            // Sentinel = 'type'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 75760067)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsCString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(predictedSize)))))) {
                FatalError("Error deserializing 'int64_t'");
                return MsgValueError;
            }
            // Sentinel = 'predictedSize'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 628819280)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'int64_t'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(channel)))))) {
                FatalError("Error deserializing 'PHttpChannel'");
                return MsgValueError;
            }
            if ((!((*((&(channel))))))) {
                FatalError("Error deserializing 'PHttpChannel'");
                return MsgValueError;
            }
            // Sentinel = 'channel'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 189334234)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'PHttpChannel'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PAltDataOutputStreamParent* actor = (static_cast<NeckoParent*>(this))->AllocPAltDataOutputStreamParent(type, predictedSize, channel);
            if (!actor) {
                NS_WARNING("Cannot bind null PAltDataOutputStreamParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPAltDataOutputStreamParent.PutEntry(actor);

            if ((!((static_cast<NeckoParent*>(this))->RecvPAltDataOutputStreamConstructor(std::move(actor), std::move(type), std::move(predictedSize), channel)))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PStunAddrsRequestConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PStunAddrsRequestConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PStunAddrsRequestParent* actor = (static_cast<NeckoParent*>(this))->AllocPStunAddrsRequestParent();
            if (!actor) {
                NS_WARNING("Cannot bind null PStunAddrsRequestParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPStunAddrsRequestParent.PutEntry(actor);

            if ((!((static_cast<NeckoParent*>(this))->RecvPStunAddrsRequestConstructor(std::move(actor))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_PWebrtcTCPSocketConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PWebrtcTCPSocketConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            mozilla::Maybe<TabId> tabId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(tabId)))))) {
                FatalError("Error deserializing 'TabId?'");
                return MsgValueError;
            }
            // Sentinel = 'tabId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 99156453)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'TabId?'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PWebrtcTCPSocketParent* actor = (static_cast<NeckoParent*>(this))->AllocPWebrtcTCPSocketParent(tabId);
            if (!actor) {
                NS_WARNING("Cannot bind null PWebrtcTCPSocketParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPWebrtcTCPSocketParent.PutEntry(actor);

            if ((!((static_cast<NeckoParent*>(this))->RecvPWebrtcTCPSocketConstructor(std::move(actor), std::move(tabId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_GetExtensionStream__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_GetExtensionStream", OTHER);

            PickleIterator iter__{msg__};
            RefPtr<nsIURI> uri{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(uri)))))) {
                FatalError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            // Sentinel = 'uri'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 45023569)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            int32_t id__ = Id();
            int32_t seqno__ = msg__.seqno();
            RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
                GetLifecycleProxy();

            GetExtensionStreamResolver resolver = [proxy__, seqno__, id__](nsIInputStream* aParam) {
                if (!proxy__->Get()) {
                    NS_WARNING("Not resolving response because actor is dead.");
                    return;
                }
                PNeckoParent* self__ = static_cast<PNeckoParent*>(proxy__->Get());

                IPC::Message* reply__ = PNecko::Reply_GetExtensionStream(id__);
                reply__->set_seqno(seqno__);

                bool resolve__ = true;
                WriteIPDLParam(reply__, self__, resolve__);
                // Sentinel = 'resolve__'
                (reply__)->WriteSentinel(322044863);
                WriteIPDLParam(reply__, self__, aParam);
                // Sentinel = 'stream'
                (reply__)->WriteSentinel(153223821);

                if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                    mozilla::ipc::LogMessageForProtocol(
                        "PNeckoParent",
                        (self__)->OtherPid(),
                        "Sending reply ",
                        reply__->type(),
                        mozilla::ipc::MessageDirection::eSending);
                }

                bool sendok__ = self__->ChannelSend(reply__);
                if (!sendok__) {
                    NS_WARNING("Error sending reply");
                }
            };
            if ((!((static_cast<NeckoParent*>(this))->RecvGetExtensionStream(uri, std::move(resolver))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_GetExtensionFD__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_GetExtensionFD", OTHER);

            PickleIterator iter__{msg__};
            RefPtr<nsIURI> uri{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(uri)))))) {
                FatalError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            // Sentinel = 'uri'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 45023569)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            int32_t id__ = Id();
            int32_t seqno__ = msg__.seqno();
            RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
                GetLifecycleProxy();

            GetExtensionFDResolver resolver = [proxy__, seqno__, id__](const FileDescriptor& aParam) {
                if (!proxy__->Get()) {
                    NS_WARNING("Not resolving response because actor is dead.");
                    return;
                }
                PNeckoParent* self__ = static_cast<PNeckoParent*>(proxy__->Get());

                IPC::Message* reply__ = PNecko::Reply_GetExtensionFD(id__);
                reply__->set_seqno(seqno__);

                bool resolve__ = true;
                WriteIPDLParam(reply__, self__, resolve__);
                // Sentinel = 'resolve__'
                (reply__)->WriteSentinel(322044863);
                WriteIPDLParam(reply__, self__, aParam);
                // Sentinel = 'fd'
                (reply__)->WriteSentinel(20054219);

                if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                    mozilla::ipc::LogMessageForProtocol(
                        "PNeckoParent",
                        (self__)->OtherPid(),
                        "Sending reply ",
                        reply__->type(),
                        mozilla::ipc::MessageDirection::eSending);
                }

                bool sendok__ = self__->ChannelSend(reply__);
                if (!sendok__) {
                    NS_WARNING("Error sending reply");
                }
            };
            if ((!((static_cast<NeckoParent*>(this))->RecvGetExtensionFD(uri, std::move(resolver))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_InitSocketProcessBridge__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_InitSocketProcessBridge", OTHER);

            int32_t id__ = Id();
            int32_t seqno__ = msg__.seqno();
            RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
                GetLifecycleProxy();

            InitSocketProcessBridgeResolver resolver = [proxy__, seqno__, id__](Endpoint<mozilla::net::PSocketProcessBridgeChild>&& aParam) {
                if (!proxy__->Get()) {
                    NS_WARNING("Not resolving response because actor is dead.");
                    return;
                }
                PNeckoParent* self__ = static_cast<PNeckoParent*>(proxy__->Get());

                IPC::Message* reply__ = PNecko::Reply_InitSocketProcessBridge(id__);
                reply__->set_seqno(seqno__);

                bool resolve__ = true;
                WriteIPDLParam(reply__, self__, resolve__);
                // Sentinel = 'resolve__'
                (reply__)->WriteSentinel(322044863);
                WriteIPDLParam(reply__, self__, std::move(aParam));
                // Sentinel = 'endpoint'
                (reply__)->WriteSentinel(251724642);

                if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                    mozilla::ipc::LogMessageForProtocol(
                        "PNeckoParent",
                        (self__)->OtherPid(),
                        "Sending reply ",
                        reply__->type(),
                        mozilla::ipc::MessageDirection::eSending);
                }

                bool sendok__ = self__->ChannelSend(reply__);
                if (!sendok__) {
                    NS_WARNING("Error sending reply");
                }
            };
            if ((!((static_cast<NeckoParent*>(this))->RecvInitSocketProcessBridge(std::move(resolver))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_ResetSocketProcessBridge__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_ResetSocketProcessBridge", OTHER);

            if ((!((static_cast<NeckoParent*>(this))->RecvResetSocketProcessBridge()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_EnsureHSTSData__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_EnsureHSTSData", OTHER);

            int32_t id__ = Id();
            int32_t seqno__ = msg__.seqno();
            RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
                GetLifecycleProxy();

            EnsureHSTSDataResolver resolver = [proxy__, seqno__, id__](const bool& aParam) {
                if (!proxy__->Get()) {
                    NS_WARNING("Not resolving response because actor is dead.");
                    return;
                }
                PNeckoParent* self__ = static_cast<PNeckoParent*>(proxy__->Get());

                IPC::Message* reply__ = PNecko::Reply_EnsureHSTSData(id__);
                reply__->set_seqno(seqno__);

                bool resolve__ = true;
                WriteIPDLParam(reply__, self__, resolve__);
                // Sentinel = 'resolve__'
                (reply__)->WriteSentinel(322044863);
                WriteIPDLParam(reply__, self__, aParam);
                // Sentinel = 'result'
                (reply__)->WriteSentinel(153223840);

                if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                    mozilla::ipc::LogMessageForProtocol(
                        "PNeckoParent",
                        (self__)->OtherPid(),
                        "Sending reply ",
                        reply__->type(),
                        mozilla::ipc::MessageDirection::eSending);
                }

                bool sendok__ = self__->ChannelSend(reply__);
                if (!sendok__) {
                    NS_WARNING("Error sending reply");
                }
            };
            if ((!((static_cast<NeckoParent*>(this))->RecvEnsureHSTSData(std::move(resolver))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Msg_GetPageThumbStream__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_GetPageThumbStream", OTHER);

            PickleIterator iter__{msg__};
            RefPtr<nsIURI> uri{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(uri)))))) {
                FatalError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            // Sentinel = 'uri'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 45023569)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsIURI'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            int32_t id__ = Id();
            int32_t seqno__ = msg__.seqno();
            RefPtr<mozilla::ipc::ActorLifecycleProxy> proxy__ =
                GetLifecycleProxy();

            GetPageThumbStreamResolver resolver = [proxy__, seqno__, id__](nsIInputStream* aParam) {
                if (!proxy__->Get()) {
                    NS_WARNING("Not resolving response because actor is dead.");
                    return;
                }
                PNeckoParent* self__ = static_cast<PNeckoParent*>(proxy__->Get());

                IPC::Message* reply__ = PNecko::Reply_GetPageThumbStream(id__);
                reply__->set_seqno(seqno__);

                bool resolve__ = true;
                WriteIPDLParam(reply__, self__, resolve__);
                // Sentinel = 'resolve__'
                (reply__)->WriteSentinel(322044863);
                WriteIPDLParam(reply__, self__, aParam);
                // Sentinel = 'stream'
                (reply__)->WriteSentinel(153223821);

                if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                    mozilla::ipc::LogMessageForProtocol(
                        "PNeckoParent",
                        (self__)->OtherPid(),
                        "Sending reply ",
                        reply__->type(),
                        mozilla::ipc::MessageDirection::eSending);
                }

                bool sendok__ = self__->ChannelSend(reply__);
                if (!sendok__) {
                    NS_WARNING("Error sending reply");
                }
            };
            if ((!((static_cast<NeckoParent*>(this))->RecvGetPageThumbStream(uri, std::move(resolver))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PNecko::Reply_PTransportProviderConstructor__ID:
        {
            return MsgProcessed;
        }
    case PNecko::Reply_PTCPSocketConstructor__ID:
        {
            return MsgProcessed;
        }
    case PNecko::Msg_PTCPSocketConstructor__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PNeckoParent")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PNeckoParent",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PNecko::Msg_PTCPSocketConstructor", OTHER);

            PickleIterator iter__{msg__};
            ActorHandle handle__{};
            nsString host{};
            uint16_t port{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(handle__)))))) {
                FatalError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            // Sentinel = 'actor'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 102892058)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ActorHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(host)))))) {
                FatalError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            // Sentinel = 'host'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 72024511)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'nsString'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(port)))))) {
                FatalError("Error deserializing 'uint16_t'");
                return MsgValueError;
            }
            // Sentinel = 'port'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 73990598)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint16_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            PTCPSocketParent* actor = (static_cast<NeckoParent*>(this))->AllocPTCPSocketParent(host, port);
            if (!actor) {
                NS_WARNING("Cannot bind null PTCPSocketParent actor");
                return MsgValueError;
            }

            actor->SetManagerAndRegister(this, (handle__).mId);
            mManagedPTCPSocketParent.PutEntry(actor);

            if ((!((static_cast<NeckoParent*>(this))->RecvPTCPSocketConstructor(std::move(actor), std::move(host), std::move(port))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    default:
        return MsgNotKnown;
    }
}

auto PNeckoParent::OnMessageReceived(
        const Message& msg__,
        Message*& reply__) -> PNeckoParent::Result
{
    return MsgNotKnown;
}

auto PNeckoParent::OnCallReceived(
        const Message& msg__,
        Message*& reply__) -> PNeckoParent::Result
{
    MOZ_ASSERT_UNREACHABLE("message protocol not supported");
    return MsgNotKnown;
}

auto PNeckoParent::ClearSubtree() -> void
{
    for (auto it = mManagedPHttpChannelParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPHttpChannelParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPHttpChannelParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPHttpChannelParent.Clear();

    for (auto it = mManagedPCookieServiceParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPCookieServiceParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPCookieServiceParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPCookieServiceParent.Clear();

    for (auto it = mManagedPFTPChannelParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPFTPChannelParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPFTPChannelParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPFTPChannelParent.Clear();

    for (auto it = mManagedPWebSocketParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPWebSocketParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPWebSocketParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPWebSocketParent.Clear();

    for (auto it = mManagedPWebSocketEventListenerParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPWebSocketEventListenerParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPWebSocketEventListenerParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPWebSocketEventListenerParent.Clear();

    for (auto it = mManagedPTCPSocketParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPTCPSocketParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPTCPSocketParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPTCPSocketParent.Clear();

    for (auto it = mManagedPTCPServerSocketParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPTCPServerSocketParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPTCPServerSocketParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPTCPServerSocketParent.Clear();

    for (auto it = mManagedPUDPSocketParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPUDPSocketParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPUDPSocketParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPUDPSocketParent.Clear();

    for (auto it = mManagedPDNSRequestParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPDNSRequestParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPDNSRequestParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPDNSRequestParent.Clear();

    for (auto it = mManagedPDataChannelParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPDataChannelParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPDataChannelParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPDataChannelParent.Clear();

    for (auto it = mManagedPGIOChannelParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPGIOChannelParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPGIOChannelParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPGIOChannelParent.Clear();

    for (auto it = mManagedPSimpleChannelParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPSimpleChannelParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPSimpleChannelParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPSimpleChannelParent.Clear();

    for (auto it = mManagedPFileChannelParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPFileChannelParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPFileChannelParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPFileChannelParent.Clear();

    for (auto it = mManagedPTransportProviderParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPTransportProviderParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPTransportProviderParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPTransportProviderParent.Clear();

    for (auto it = mManagedPAltDataOutputStreamParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPAltDataOutputStreamParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPAltDataOutputStreamParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPAltDataOutputStreamParent.Clear();

    for (auto it = mManagedPStunAddrsRequestParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPStunAddrsRequestParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPStunAddrsRequestParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPStunAddrsRequestParent.Clear();

    for (auto it = mManagedPClassifierDummyChannelParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPClassifierDummyChannelParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPClassifierDummyChannelParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPClassifierDummyChannelParent.Clear();

    for (auto it = mManagedPWebrtcTCPSocketParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPWebrtcTCPSocketParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPWebrtcTCPSocketParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPWebrtcTCPSocketParent.Clear();

    for (auto it = mManagedPDocumentChannelParent.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPDocumentChannelParent.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPDocumentChannelParent kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPDocumentChannelParent.Clear();

}



} // namespace net
} // namespace mozilla
namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::net::PNeckoParent*>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    int32_t id;
    if (!aVar) {
        id = 0;  // kNullActorId
    } else {
        id = aVar->Id();
        if (id == 1) {  // kFreedActorId
            aVar->FatalError("Actor has been |delete|d");
        }
        MOZ_RELEASE_ASSERT(
            aActor->GetIPCChannel() == aVar->GetIPCChannel(),
            "Actor must be from the same channel as the"
            " actor it's being sent over");
        MOZ_RELEASE_ASSERT(
            aVar->CanSend(),
            "Actor must still be open when sending");
    }

    WriteIPDLParam(aMsg, aActor, id);
}

auto IPDLParamTraits<mozilla::net::PNeckoParent*>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    mozilla::Maybe<mozilla::ipc::IProtocol*> actor =
        aActor->ReadActor(aMsg, aIter, true, "PNecko", PNeckoMsgStart);
    if (actor.isNothing()) {
        return false;
    }

    *aVar = static_cast<mozilla::net::PNeckoParent*>(actor.value());
    return true;
}

} // namespace ipc
} // namespace mozilla
