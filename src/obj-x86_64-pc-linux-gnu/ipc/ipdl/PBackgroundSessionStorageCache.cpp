//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/ipc/PBackgroundParent.h"
#include "mozilla/ipc/PBackgroundChild.h"
#include "mozilla/dom/PBackgroundSessionStorageManagerParent.h"
#include "mozilla/dom/PBackgroundSessionStorageManagerChild.h"
#include "mozilla/dom/PBackgroundSessionStorageCache.h"
#include "mozilla/dom/PBackgroundSessionStorageCacheParent.h"
#include "mozilla/dom/PBackgroundSessionStorageCacheChild.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace dom {
namespace PBackgroundSessionStorageCache {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::dom::PBackgroundSessionStorageCacheParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::dom::PBackgroundSessionStorageCacheChild>* aChild)
{
    return mozilla::ipc::CreateEndpoints(
        mozilla::ipc::PrivateIPDLInterface(),
        aParentDestPid, aChildDestPid,
        aParent, aChild);
}
IPC::Message*
Msg_DeleteMe(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_DeleteMe__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_Load(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Load__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply_Load(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply_Load__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::SYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}
IPC::Message*
Msg_Checkpoint(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Checkpoint__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg___delete__(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg___delete____ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply___delete__(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply___delete____ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}

} // namespace PBackgroundSessionStorageCache
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct SSSetItemInfo|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::SSSetItemInfo>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).key());
    // Sentinel = 'key'
    (aMsg)->WriteSentinel(42402122);
    WriteIPDLParam(aMsg, aActor, (aVar).value());
    // Sentinel = 'value'
    (aMsg)->WriteSentinel(107610654);
}

auto IPDLParamTraits<mozilla::dom::SSSetItemInfo>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->key())))))) {
        aActor->FatalError("Error deserializing 'key' (nsString) member of 'SSSetItemInfo'");
        return false;
    }
    // Sentinel = 'key'
    if ((!((aMsg)->ReadSentinel(aIter, 42402122)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'key' (nsString) member of 'SSSetItemInfo'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->value())))))) {
        aActor->FatalError("Error deserializing 'value' (nsString) member of 'SSSetItemInfo'");
        return false;
    }
    // Sentinel = 'value'
    if ((!((aMsg)->ReadSentinel(aIter, 107610654)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'value' (nsString) member of 'SSSetItemInfo'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct SSRemoveItemInfo|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::SSRemoveItemInfo>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).key());
    // Sentinel = 'key'
    (aMsg)->WriteSentinel(42402122);
}

auto IPDLParamTraits<mozilla::dom::SSRemoveItemInfo>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->key())))))) {
        aActor->FatalError("Error deserializing 'key' (nsString) member of 'SSRemoveItemInfo'");
        return false;
    }
    // Sentinel = 'key'
    if ((!((aMsg)->ReadSentinel(aIter, 42402122)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'key' (nsString) member of 'SSRemoveItemInfo'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct SSClearInfo|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::SSClearInfo>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
}

auto IPDLParamTraits<mozilla::dom::SSClearInfo>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union SSWriteInfo|
//
namespace mozilla {
namespace dom {
auto SSWriteInfo::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TSSSetItemInfo:
        {
            (ptr_SSSetItemInfo())->~SSSetItemInfo__tdef();
            break;
        }
    case TSSRemoveItemInfo:
        {
            (ptr_SSRemoveItemInfo())->~SSRemoveItemInfo__tdef();
            break;
        }
    case TSSClearInfo:
        {
            (ptr_SSClearInfo())->~SSClearInfo__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT SSWriteInfo::SSWriteInfo(const SSSetItemInfo& aOther)
{
    new (mozilla::KnownNotNull, ptr_SSSetItemInfo()) SSSetItemInfo(aOther);
    mType = TSSSetItemInfo;
}

MOZ_IMPLICIT SSWriteInfo::SSWriteInfo(SSSetItemInfo&& aOther)
{
    new (mozilla::KnownNotNull, ptr_SSSetItemInfo()) SSSetItemInfo(std::move(aOther));
    mType = TSSSetItemInfo;
}

MOZ_IMPLICIT SSWriteInfo::SSWriteInfo(const SSRemoveItemInfo& aOther)
{
    new (mozilla::KnownNotNull, ptr_SSRemoveItemInfo()) SSRemoveItemInfo(aOther);
    mType = TSSRemoveItemInfo;
}

MOZ_IMPLICIT SSWriteInfo::SSWriteInfo(SSRemoveItemInfo&& aOther)
{
    new (mozilla::KnownNotNull, ptr_SSRemoveItemInfo()) SSRemoveItemInfo(std::move(aOther));
    mType = TSSRemoveItemInfo;
}

MOZ_IMPLICIT SSWriteInfo::SSWriteInfo(const SSClearInfo& aOther)
{
    new (mozilla::KnownNotNull, ptr_SSClearInfo()) SSClearInfo(aOther);
    mType = TSSClearInfo;
}

MOZ_IMPLICIT SSWriteInfo::SSWriteInfo(SSClearInfo&& aOther)
{
    new (mozilla::KnownNotNull, ptr_SSClearInfo()) SSClearInfo(std::move(aOther));
    mType = TSSClearInfo;
}

MOZ_IMPLICIT SSWriteInfo::SSWriteInfo(const SSWriteInfo& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TSSSetItemInfo:
        {
            new (mozilla::KnownNotNull, ptr_SSSetItemInfo()) SSSetItemInfo((aOther).get_SSSetItemInfo());
            break;
        }
    case TSSRemoveItemInfo:
        {
            new (mozilla::KnownNotNull, ptr_SSRemoveItemInfo()) SSRemoveItemInfo((aOther).get_SSRemoveItemInfo());
            break;
        }
    case TSSClearInfo:
        {
            new (mozilla::KnownNotNull, ptr_SSClearInfo()) SSClearInfo((aOther).get_SSClearInfo());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT SSWriteInfo::SSWriteInfo(SSWriteInfo&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TSSSetItemInfo:
        {
            new (mozilla::KnownNotNull, ptr_SSSetItemInfo()) SSSetItemInfo(std::move((aOther).get_SSSetItemInfo()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TSSRemoveItemInfo:
        {
            new (mozilla::KnownNotNull, ptr_SSRemoveItemInfo()) SSRemoveItemInfo(std::move((aOther).get_SSRemoveItemInfo()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TSSClearInfo:
        {
            new (mozilla::KnownNotNull, ptr_SSClearInfo()) SSClearInfo(std::move((aOther).get_SSClearInfo()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

SSWriteInfo::~SSWriteInfo()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto SSWriteInfo::operator=(const SSSetItemInfo& aRhs) -> SSWriteInfo&
{
    if (MaybeDestroy(TSSSetItemInfo)) {
        new (mozilla::KnownNotNull, ptr_SSSetItemInfo()) SSSetItemInfo;
    }
    (*(ptr_SSSetItemInfo())) = aRhs;
    mType = TSSSetItemInfo;
    return (*(this));
}

auto SSWriteInfo::operator=(SSSetItemInfo&& aRhs) -> SSWriteInfo&
{
    if (MaybeDestroy(TSSSetItemInfo)) {
        new (mozilla::KnownNotNull, ptr_SSSetItemInfo()) SSSetItemInfo;
    }
    (*(ptr_SSSetItemInfo())) = std::move(aRhs);
    mType = TSSSetItemInfo;
    return (*(this));
}

auto SSWriteInfo::operator=(const SSRemoveItemInfo& aRhs) -> SSWriteInfo&
{
    if (MaybeDestroy(TSSRemoveItemInfo)) {
        new (mozilla::KnownNotNull, ptr_SSRemoveItemInfo()) SSRemoveItemInfo;
    }
    (*(ptr_SSRemoveItemInfo())) = aRhs;
    mType = TSSRemoveItemInfo;
    return (*(this));
}

auto SSWriteInfo::operator=(SSRemoveItemInfo&& aRhs) -> SSWriteInfo&
{
    if (MaybeDestroy(TSSRemoveItemInfo)) {
        new (mozilla::KnownNotNull, ptr_SSRemoveItemInfo()) SSRemoveItemInfo;
    }
    (*(ptr_SSRemoveItemInfo())) = std::move(aRhs);
    mType = TSSRemoveItemInfo;
    return (*(this));
}

auto SSWriteInfo::operator=(const SSClearInfo& aRhs) -> SSWriteInfo&
{
    if (MaybeDestroy(TSSClearInfo)) {
        new (mozilla::KnownNotNull, ptr_SSClearInfo()) SSClearInfo;
    }
    (*(ptr_SSClearInfo())) = aRhs;
    mType = TSSClearInfo;
    return (*(this));
}

auto SSWriteInfo::operator=(SSClearInfo&& aRhs) -> SSWriteInfo&
{
    if (MaybeDestroy(TSSClearInfo)) {
        new (mozilla::KnownNotNull, ptr_SSClearInfo()) SSClearInfo;
    }
    (*(ptr_SSClearInfo())) = std::move(aRhs);
    mType = TSSClearInfo;
    return (*(this));
}

auto SSWriteInfo::operator=(const SSWriteInfo& aRhs) -> SSWriteInfo&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TSSSetItemInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_SSSetItemInfo()) SSSetItemInfo;
            }
            (*(ptr_SSSetItemInfo())) = (aRhs).get_SSSetItemInfo();
            break;
        }
    case TSSRemoveItemInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_SSRemoveItemInfo()) SSRemoveItemInfo;
            }
            (*(ptr_SSRemoveItemInfo())) = (aRhs).get_SSRemoveItemInfo();
            break;
        }
    case TSSClearInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_SSClearInfo()) SSClearInfo;
            }
            (*(ptr_SSClearInfo())) = (aRhs).get_SSClearInfo();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto SSWriteInfo::operator=(SSWriteInfo&& aRhs) -> SSWriteInfo&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TSSSetItemInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_SSSetItemInfo()) SSSetItemInfo;
            }
            (*(ptr_SSSetItemInfo())) = std::move((aRhs).get_SSSetItemInfo());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TSSRemoveItemInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_SSRemoveItemInfo()) SSRemoveItemInfo;
            }
            (*(ptr_SSRemoveItemInfo())) = std::move((aRhs).get_SSRemoveItemInfo());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TSSClearInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_SSClearInfo()) SSClearInfo;
            }
            (*(ptr_SSClearInfo())) = std::move((aRhs).get_SSClearInfo());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::SSWriteInfo>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::dom::SSWriteInfo union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'SSWriteInfo'
    (aMsg)->WriteSentinel(414319678);

    switch (type) {
    case union__::TSSSetItemInfo:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_SSSetItemInfo());
            // Sentinel = 'TSSSetItemInfo'
            (aMsg)->WriteSentinel(636749122);
            return;
        }
    case union__::TSSRemoveItemInfo:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_SSRemoveItemInfo());
            // Sentinel = 'TSSRemoveItemInfo'
            (aMsg)->WriteSentinel(955582084);
            return;
        }
    case union__::TSSClearInfo:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_SSClearInfo());
            // Sentinel = 'TSSClearInfo'
            (aMsg)->WriteSentinel(460457070);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::dom::SSWriteInfo>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::dom::SSWriteInfo union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union SSWriteInfo");
        return false;
    }
    // Sentinel = 'SSWriteInfo'
    if ((!((aMsg)->ReadSentinel(aIter, 414319678)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union SSWriteInfo");
        return false;
    }

    switch (type) {
    case union__::TSSSetItemInfo:
        {
            mozilla::dom::SSSetItemInfo tmp = mozilla::dom::SSSetItemInfo();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_SSSetItemInfo())))))) {
                aActor->FatalError("Error deserializing variant TSSSetItemInfo of union SSWriteInfo");
                return false;
            }
            // Sentinel = 'TSSSetItemInfo'
            if ((!((aMsg)->ReadSentinel(aIter, 636749122)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TSSSetItemInfo of union SSWriteInfo");
                return false;
            }
            return true;
        }
    case union__::TSSRemoveItemInfo:
        {
            mozilla::dom::SSRemoveItemInfo tmp = mozilla::dom::SSRemoveItemInfo();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_SSRemoveItemInfo())))))) {
                aActor->FatalError("Error deserializing variant TSSRemoveItemInfo of union SSWriteInfo");
                return false;
            }
            // Sentinel = 'TSSRemoveItemInfo'
            if ((!((aMsg)->ReadSentinel(aIter, 955582084)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TSSRemoveItemInfo of union SSWriteInfo");
                return false;
            }
            return true;
        }
    case union__::TSSClearInfo:
        {
            mozilla::dom::SSClearInfo tmp = mozilla::dom::SSClearInfo();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_SSClearInfo())))))) {
                aActor->FatalError("Error deserializing variant TSSClearInfo of union SSWriteInfo");
                return false;
            }
            // Sentinel = 'TSSClearInfo'
            if ((!((aMsg)->ReadSentinel(aIter, 460457070)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TSSClearInfo of union SSWriteInfo");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla
