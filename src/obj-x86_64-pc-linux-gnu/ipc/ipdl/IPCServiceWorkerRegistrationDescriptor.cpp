//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "ipc/ErrorIPCUtils.h"
#include "mozilla/dom/ServiceWorkerIPCUtils.h"
#include "mozilla/dom/IPCServiceWorkerRegistrationDescriptor.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"


//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct IPCServiceWorkerRegistrationDescriptor|
//
namespace mozilla {
namespace dom {
auto IPCServiceWorkerRegistrationDescriptor::operator==(const IPCServiceWorkerRegistrationDescriptor& _o) const -> bool
{
    if ((!((id()) == ((_o).id())))) {
        return false;
    }
    if ((!((version()) == ((_o).version())))) {
        return false;
    }
    if ((!((principalInfo()) == ((_o).principalInfo())))) {
        return false;
    }
    if ((!((scope()) == ((_o).scope())))) {
        return false;
    }
    if ((!((updateViaCache()) == ((_o).updateViaCache())))) {
        return false;
    }
    if ((!((installing()) == ((_o).installing())))) {
        return false;
    }
    if ((!((waiting()) == ((_o).waiting())))) {
        return false;
    }
    if ((!((active()) == ((_o).active())))) {
        return false;
    }
    return true;
}

auto IPCServiceWorkerRegistrationDescriptor::operator!=(const IPCServiceWorkerRegistrationDescriptor& _o) const -> bool
{
    return (!(operator==(_o)));
}

auto IPCServiceWorkerRegistrationDescriptor::StaticAssertions() const -> void
{
    static_assert(
        (offsetof(IPCServiceWorkerRegistrationDescriptor, version_) - offsetof(IPCServiceWorkerRegistrationDescriptor, id_)) == 8,
        "Bad assumptions about field layout!");
}

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::IPCServiceWorkerRegistrationDescriptor>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).principalInfo());
    // Sentinel = 'principalInfo'
    (aMsg)->WriteSentinel(633472335);
    WriteIPDLParam(aMsg, aActor, (aVar).scope());
    // Sentinel = 'scope'
    (aMsg)->WriteSentinel(107086363);
    WriteIPDLParam(aMsg, aActor, (aVar).updateViaCache());
    // Sentinel = 'updateViaCache'
    (aMsg)->WriteSentinel(706348408);
    WriteIPDLParam(aMsg, aActor, (aVar).installing());
    // Sentinel = 'installing'
    (aMsg)->WriteSentinel(391513142);
    WriteIPDLParam(aMsg, aActor, (aVar).waiting());
    // Sentinel = 'waiting'
    (aMsg)->WriteSentinel(199820020);
    WriteIPDLParam(aMsg, aActor, (aVar).active());
    // Sentinel = 'active'
    (aMsg)->WriteSentinel(144114301);
    (aMsg)->WriteBytes((&((aVar).id())), 16);
    // Sentinel = 'id | version'
    (aMsg)->WriteSentinel(470090896);
}

auto IPDLParamTraits<mozilla::dom::IPCServiceWorkerRegistrationDescriptor>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->principalInfo())))))) {
        aActor->FatalError("Error deserializing 'principalInfo' (PrincipalInfo) member of 'IPCServiceWorkerRegistrationDescriptor'");
        return false;
    }
    // Sentinel = 'principalInfo'
    if ((!((aMsg)->ReadSentinel(aIter, 633472335)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'principalInfo' (PrincipalInfo) member of 'IPCServiceWorkerRegistrationDescriptor'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->scope())))))) {
        aActor->FatalError("Error deserializing 'scope' (nsCString) member of 'IPCServiceWorkerRegistrationDescriptor'");
        return false;
    }
    // Sentinel = 'scope'
    if ((!((aMsg)->ReadSentinel(aIter, 107086363)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'scope' (nsCString) member of 'IPCServiceWorkerRegistrationDescriptor'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->updateViaCache())))))) {
        aActor->FatalError("Error deserializing 'updateViaCache' (ServiceWorkerUpdateViaCache) member of 'IPCServiceWorkerRegistrationDescriptor'");
        return false;
    }
    // Sentinel = 'updateViaCache'
    if ((!((aMsg)->ReadSentinel(aIter, 706348408)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'updateViaCache' (ServiceWorkerUpdateViaCache) member of 'IPCServiceWorkerRegistrationDescriptor'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->installing())))))) {
        aActor->FatalError("Error deserializing 'installing' (IPCServiceWorkerDescriptor?) member of 'IPCServiceWorkerRegistrationDescriptor'");
        return false;
    }
    // Sentinel = 'installing'
    if ((!((aMsg)->ReadSentinel(aIter, 391513142)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'installing' (IPCServiceWorkerDescriptor?) member of 'IPCServiceWorkerRegistrationDescriptor'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->waiting())))))) {
        aActor->FatalError("Error deserializing 'waiting' (IPCServiceWorkerDescriptor?) member of 'IPCServiceWorkerRegistrationDescriptor'");
        return false;
    }
    // Sentinel = 'waiting'
    if ((!((aMsg)->ReadSentinel(aIter, 199820020)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'waiting' (IPCServiceWorkerDescriptor?) member of 'IPCServiceWorkerRegistrationDescriptor'");
        return false;
    }
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->active())))))) {
        aActor->FatalError("Error deserializing 'active' (IPCServiceWorkerDescriptor?) member of 'IPCServiceWorkerRegistrationDescriptor'");
        return false;
    }
    // Sentinel = 'active'
    if ((!((aMsg)->ReadSentinel(aIter, 144114301)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'active' (IPCServiceWorkerDescriptor?) member of 'IPCServiceWorkerRegistrationDescriptor'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->id())), 16)))) {
        aActor->FatalError("Error bulk reading fields from uint64_t");
        return false;
    }
    // Sentinel = 'id | version'
    if ((!((aMsg)->ReadSentinel(aIter, 470090896)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint64_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult|
//
namespace mozilla {
namespace dom {
auto IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TIPCServiceWorkerRegistrationDescriptor:
        {
            (ptr_IPCServiceWorkerRegistrationDescriptor())->~IPCServiceWorkerRegistrationDescriptor__tdef();
            break;
        }
    case TCopyableErrorResult:
        {
            (ptr_CopyableErrorResult())->~CopyableErrorResult__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult::IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult(const IPCServiceWorkerRegistrationDescriptor& aOther)
{
    new (mozilla::KnownNotNull, ptr_IPCServiceWorkerRegistrationDescriptor()) IPCServiceWorkerRegistrationDescriptor(aOther);
    mType = TIPCServiceWorkerRegistrationDescriptor;
}

MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult::IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult(IPCServiceWorkerRegistrationDescriptor&& aOther)
{
    new (mozilla::KnownNotNull, ptr_IPCServiceWorkerRegistrationDescriptor()) IPCServiceWorkerRegistrationDescriptor(std::move(aOther));
    mType = TIPCServiceWorkerRegistrationDescriptor;
}

MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult::IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult(const CopyableErrorResult& aOther)
{
    new (mozilla::KnownNotNull, ptr_CopyableErrorResult()) CopyableErrorResult(aOther);
    mType = TCopyableErrorResult;
}

MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult::IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult(CopyableErrorResult&& aOther)
{
    new (mozilla::KnownNotNull, ptr_CopyableErrorResult()) CopyableErrorResult(std::move(aOther));
    mType = TCopyableErrorResult;
}

MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult::IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult(const IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TIPCServiceWorkerRegistrationDescriptor:
        {
            new (mozilla::KnownNotNull, ptr_IPCServiceWorkerRegistrationDescriptor()) IPCServiceWorkerRegistrationDescriptor((aOther).get_IPCServiceWorkerRegistrationDescriptor());
            break;
        }
    case TCopyableErrorResult:
        {
            new (mozilla::KnownNotNull, ptr_CopyableErrorResult()) CopyableErrorResult((aOther).get_CopyableErrorResult());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult::IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult(IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TIPCServiceWorkerRegistrationDescriptor:
        {
            new (mozilla::KnownNotNull, ptr_IPCServiceWorkerRegistrationDescriptor()) IPCServiceWorkerRegistrationDescriptor(std::move((aOther).get_IPCServiceWorkerRegistrationDescriptor()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TCopyableErrorResult:
        {
            new (mozilla::KnownNotNull, ptr_CopyableErrorResult()) CopyableErrorResult(std::move((aOther).get_CopyableErrorResult()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult::~IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult::operator=(const IPCServiceWorkerRegistrationDescriptor& aRhs) -> IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult&
{
    if (MaybeDestroy(TIPCServiceWorkerRegistrationDescriptor)) {
        new (mozilla::KnownNotNull, ptr_IPCServiceWorkerRegistrationDescriptor()) IPCServiceWorkerRegistrationDescriptor;
    }
    (*(ptr_IPCServiceWorkerRegistrationDescriptor())) = aRhs;
    mType = TIPCServiceWorkerRegistrationDescriptor;
    return (*(this));
}

auto IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult::operator=(IPCServiceWorkerRegistrationDescriptor&& aRhs) -> IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult&
{
    if (MaybeDestroy(TIPCServiceWorkerRegistrationDescriptor)) {
        new (mozilla::KnownNotNull, ptr_IPCServiceWorkerRegistrationDescriptor()) IPCServiceWorkerRegistrationDescriptor;
    }
    (*(ptr_IPCServiceWorkerRegistrationDescriptor())) = std::move(aRhs);
    mType = TIPCServiceWorkerRegistrationDescriptor;
    return (*(this));
}

auto IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult::operator=(const CopyableErrorResult& aRhs) -> IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult&
{
    if (MaybeDestroy(TCopyableErrorResult)) {
        new (mozilla::KnownNotNull, ptr_CopyableErrorResult()) CopyableErrorResult;
    }
    (*(ptr_CopyableErrorResult())) = aRhs;
    mType = TCopyableErrorResult;
    return (*(this));
}

auto IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult::operator=(CopyableErrorResult&& aRhs) -> IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult&
{
    if (MaybeDestroy(TCopyableErrorResult)) {
        new (mozilla::KnownNotNull, ptr_CopyableErrorResult()) CopyableErrorResult;
    }
    (*(ptr_CopyableErrorResult())) = std::move(aRhs);
    mType = TCopyableErrorResult;
    return (*(this));
}

auto IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult::operator=(const IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult& aRhs) -> IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TIPCServiceWorkerRegistrationDescriptor:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_IPCServiceWorkerRegistrationDescriptor()) IPCServiceWorkerRegistrationDescriptor;
            }
            (*(ptr_IPCServiceWorkerRegistrationDescriptor())) = (aRhs).get_IPCServiceWorkerRegistrationDescriptor();
            break;
        }
    case TCopyableErrorResult:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_CopyableErrorResult()) CopyableErrorResult;
            }
            (*(ptr_CopyableErrorResult())) = (aRhs).get_CopyableErrorResult();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult::operator=(IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult&& aRhs) -> IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TIPCServiceWorkerRegistrationDescriptor:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_IPCServiceWorkerRegistrationDescriptor()) IPCServiceWorkerRegistrationDescriptor;
            }
            (*(ptr_IPCServiceWorkerRegistrationDescriptor())) = std::move((aRhs).get_IPCServiceWorkerRegistrationDescriptor());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TCopyableErrorResult:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_CopyableErrorResult()) CopyableErrorResult;
            }
            (*(ptr_CopyableErrorResult())) = std::move((aRhs).get_CopyableErrorResult());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::dom::IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult'
    (aMsg)->WriteSentinel(3141539771);

    switch (type) {
    case union__::TIPCServiceWorkerRegistrationDescriptor:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_IPCServiceWorkerRegistrationDescriptor());
            // Sentinel = 'TIPCServiceWorkerRegistrationDescriptor'
            (aMsg)->WriteSentinel(751308694);
            return;
        }
    case union__::TCopyableErrorResult:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_CopyableErrorResult());
            // Sentinel = 'TCopyableErrorResult'
            (aMsg)->WriteSentinel(1376585741);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::dom::IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::dom::IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult");
        return false;
    }
    // Sentinel = 'IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult'
    if ((!((aMsg)->ReadSentinel(aIter, 3141539771)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult");
        return false;
    }

    switch (type) {
    case union__::TIPCServiceWorkerRegistrationDescriptor:
        {
            mozilla::dom::IPCServiceWorkerRegistrationDescriptor tmp = mozilla::dom::IPCServiceWorkerRegistrationDescriptor();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_IPCServiceWorkerRegistrationDescriptor())))))) {
                aActor->FatalError("Error deserializing variant TIPCServiceWorkerRegistrationDescriptor of union IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult");
                return false;
            }
            // Sentinel = 'TIPCServiceWorkerRegistrationDescriptor'
            if ((!((aMsg)->ReadSentinel(aIter, 751308694)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TIPCServiceWorkerRegistrationDescriptor of union IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult");
                return false;
            }
            return true;
        }
    case union__::TCopyableErrorResult:
        {
            mozilla::CopyableErrorResult tmp = mozilla::CopyableErrorResult();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_CopyableErrorResult())))))) {
                aActor->FatalError("Error deserializing variant TCopyableErrorResult of union IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult");
                return false;
            }
            // Sentinel = 'TCopyableErrorResult'
            if ((!((aMsg)->ReadSentinel(aIter, 1376585741)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TCopyableErrorResult of union IPCServiceWorkerRegistrationDescriptorOrCopyableErrorResult");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct IPCServiceWorkerRegistrationDescriptorList|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::IPCServiceWorkerRegistrationDescriptorList>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).values());
    // Sentinel = 'values'
    (aMsg)->WriteSentinel(150667921);
}

auto IPDLParamTraits<mozilla::dom::IPCServiceWorkerRegistrationDescriptorList>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->values())))))) {
        aActor->FatalError("Error deserializing 'values' (IPCServiceWorkerRegistrationDescriptor[]) member of 'IPCServiceWorkerRegistrationDescriptorList'");
        return false;
    }
    // Sentinel = 'values'
    if ((!((aMsg)->ReadSentinel(aIter, 150667921)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'values' (IPCServiceWorkerRegistrationDescriptor[]) member of 'IPCServiceWorkerRegistrationDescriptorList'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult|
//
namespace mozilla {
namespace dom {
auto IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TIPCServiceWorkerRegistrationDescriptorList:
        {
            (ptr_IPCServiceWorkerRegistrationDescriptorList())->~IPCServiceWorkerRegistrationDescriptorList__tdef();
            break;
        }
    case TCopyableErrorResult:
        {
            (ptr_CopyableErrorResult())->~CopyableErrorResult__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult::IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult(const IPCServiceWorkerRegistrationDescriptorList& aOther)
{
    new (mozilla::KnownNotNull, ptr_IPCServiceWorkerRegistrationDescriptorList()) IPCServiceWorkerRegistrationDescriptorList(aOther);
    mType = TIPCServiceWorkerRegistrationDescriptorList;
}

MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult::IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult(IPCServiceWorkerRegistrationDescriptorList&& aOther)
{
    new (mozilla::KnownNotNull, ptr_IPCServiceWorkerRegistrationDescriptorList()) IPCServiceWorkerRegistrationDescriptorList(std::move(aOther));
    mType = TIPCServiceWorkerRegistrationDescriptorList;
}

MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult::IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult(const CopyableErrorResult& aOther)
{
    new (mozilla::KnownNotNull, ptr_CopyableErrorResult()) CopyableErrorResult(aOther);
    mType = TCopyableErrorResult;
}

MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult::IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult(CopyableErrorResult&& aOther)
{
    new (mozilla::KnownNotNull, ptr_CopyableErrorResult()) CopyableErrorResult(std::move(aOther));
    mType = TCopyableErrorResult;
}

MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult::IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult(const IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TIPCServiceWorkerRegistrationDescriptorList:
        {
            new (mozilla::KnownNotNull, ptr_IPCServiceWorkerRegistrationDescriptorList()) IPCServiceWorkerRegistrationDescriptorList((aOther).get_IPCServiceWorkerRegistrationDescriptorList());
            break;
        }
    case TCopyableErrorResult:
        {
            new (mozilla::KnownNotNull, ptr_CopyableErrorResult()) CopyableErrorResult((aOther).get_CopyableErrorResult());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult::IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult(IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TIPCServiceWorkerRegistrationDescriptorList:
        {
            new (mozilla::KnownNotNull, ptr_IPCServiceWorkerRegistrationDescriptorList()) IPCServiceWorkerRegistrationDescriptorList(std::move((aOther).get_IPCServiceWorkerRegistrationDescriptorList()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TCopyableErrorResult:
        {
            new (mozilla::KnownNotNull, ptr_CopyableErrorResult()) CopyableErrorResult(std::move((aOther).get_CopyableErrorResult()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult::~IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult::operator=(const IPCServiceWorkerRegistrationDescriptorList& aRhs) -> IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult&
{
    if (MaybeDestroy(TIPCServiceWorkerRegistrationDescriptorList)) {
        new (mozilla::KnownNotNull, ptr_IPCServiceWorkerRegistrationDescriptorList()) IPCServiceWorkerRegistrationDescriptorList;
    }
    (*(ptr_IPCServiceWorkerRegistrationDescriptorList())) = aRhs;
    mType = TIPCServiceWorkerRegistrationDescriptorList;
    return (*(this));
}

auto IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult::operator=(IPCServiceWorkerRegistrationDescriptorList&& aRhs) -> IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult&
{
    if (MaybeDestroy(TIPCServiceWorkerRegistrationDescriptorList)) {
        new (mozilla::KnownNotNull, ptr_IPCServiceWorkerRegistrationDescriptorList()) IPCServiceWorkerRegistrationDescriptorList;
    }
    (*(ptr_IPCServiceWorkerRegistrationDescriptorList())) = std::move(aRhs);
    mType = TIPCServiceWorkerRegistrationDescriptorList;
    return (*(this));
}

auto IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult::operator=(const CopyableErrorResult& aRhs) -> IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult&
{
    if (MaybeDestroy(TCopyableErrorResult)) {
        new (mozilla::KnownNotNull, ptr_CopyableErrorResult()) CopyableErrorResult;
    }
    (*(ptr_CopyableErrorResult())) = aRhs;
    mType = TCopyableErrorResult;
    return (*(this));
}

auto IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult::operator=(CopyableErrorResult&& aRhs) -> IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult&
{
    if (MaybeDestroy(TCopyableErrorResult)) {
        new (mozilla::KnownNotNull, ptr_CopyableErrorResult()) CopyableErrorResult;
    }
    (*(ptr_CopyableErrorResult())) = std::move(aRhs);
    mType = TCopyableErrorResult;
    return (*(this));
}

auto IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult::operator=(const IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult& aRhs) -> IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TIPCServiceWorkerRegistrationDescriptorList:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_IPCServiceWorkerRegistrationDescriptorList()) IPCServiceWorkerRegistrationDescriptorList;
            }
            (*(ptr_IPCServiceWorkerRegistrationDescriptorList())) = (aRhs).get_IPCServiceWorkerRegistrationDescriptorList();
            break;
        }
    case TCopyableErrorResult:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_CopyableErrorResult()) CopyableErrorResult;
            }
            (*(ptr_CopyableErrorResult())) = (aRhs).get_CopyableErrorResult();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult::operator=(IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult&& aRhs) -> IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TIPCServiceWorkerRegistrationDescriptorList:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_IPCServiceWorkerRegistrationDescriptorList()) IPCServiceWorkerRegistrationDescriptorList;
            }
            (*(ptr_IPCServiceWorkerRegistrationDescriptorList())) = std::move((aRhs).get_IPCServiceWorkerRegistrationDescriptorList());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TCopyableErrorResult:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_CopyableErrorResult()) CopyableErrorResult;
            }
            (*(ptr_CopyableErrorResult())) = std::move((aRhs).get_CopyableErrorResult());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::dom::IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult'
    (aMsg)->WriteSentinel(501750103);

    switch (type) {
    case union__::TIPCServiceWorkerRegistrationDescriptorList:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_IPCServiceWorkerRegistrationDescriptorList());
            // Sentinel = 'TIPCServiceWorkerRegistrationDescriptorList'
            (aMsg)->WriteSentinel(1860505906);
            return;
        }
    case union__::TCopyableErrorResult:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_CopyableErrorResult());
            // Sentinel = 'TCopyableErrorResult'
            (aMsg)->WriteSentinel(1376585741);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::dom::IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::dom::IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult");
        return false;
    }
    // Sentinel = 'IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult'
    if ((!((aMsg)->ReadSentinel(aIter, 501750103)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult");
        return false;
    }

    switch (type) {
    case union__::TIPCServiceWorkerRegistrationDescriptorList:
        {
            mozilla::dom::IPCServiceWorkerRegistrationDescriptorList tmp = mozilla::dom::IPCServiceWorkerRegistrationDescriptorList();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_IPCServiceWorkerRegistrationDescriptorList())))))) {
                aActor->FatalError("Error deserializing variant TIPCServiceWorkerRegistrationDescriptorList of union IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult");
                return false;
            }
            // Sentinel = 'TIPCServiceWorkerRegistrationDescriptorList'
            if ((!((aMsg)->ReadSentinel(aIter, 1860505906)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TIPCServiceWorkerRegistrationDescriptorList of union IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult");
                return false;
            }
            return true;
        }
    case union__::TCopyableErrorResult:
        {
            mozilla::CopyableErrorResult tmp = mozilla::CopyableErrorResult();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_CopyableErrorResult())))))) {
                aActor->FatalError("Error deserializing variant TCopyableErrorResult of union IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult");
                return false;
            }
            // Sentinel = 'TCopyableErrorResult'
            if ((!((aMsg)->ReadSentinel(aIter, 1376585741)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TCopyableErrorResult of union IPCServiceWorkerRegistrationDescriptorListOrCopyableErrorResult");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla
