//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/layers/PCompositorBridgeChild.h"
#include "mozilla/D3DMessageUtils.h"
#include "mozilla/GfxMessageUtils.h"
#include "mozilla/ProfilerLabels.h"
#include "mozilla/ProfilerMarkers.h"
#include "mozilla/TimeStamp.h"
#include "mozilla/ipc/IPCCore.h"
#include "mozilla/layers/CompositorBridgeChild.h"
#include "mozilla/layers/CompositorTypes.h"
#include "mozilla/layers/LayersMessageUtils.h"
#include "mozilla/layers/LayersTypes.h"
#include "mozilla/layers/ScrollableLayerGuid.h"
#include "mozilla/layers/WebRenderMessageUtils.h"

#include "mozilla/layers/PAPZChild.h"
#include "mozilla/layers/PAPZCTreeManagerChild.h"
#include "mozilla/dom/PBrowserChild.h"
#include "mozilla/layers/PCanvasChild.h"
#include "mozilla/layers/PCompositorManagerChild.h"
#include "mozilla/widget/PCompositorWidgetChild.h"
#include "mozilla/layers/PLayerTransactionChild.h"
#include "mozilla/layers/PTextureChild.h"
#include "mozilla/dom/PWebGLChild.h"
#include "mozilla/layers/PWebRenderBridgeChild.h"
#include "mozilla/webgpu/PWebGPUChild.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace layers {


MOZ_IMPLICIT PCompositorBridgeChild::PCompositorBridgeChild() :
    mozilla::ipc::IProtocol(PCompositorBridgeMsgStart, mozilla::ipc::ChildSide)
{
    MOZ_COUNT_CTOR(PCompositorBridgeChild);
}

PCompositorBridgeChild::~PCompositorBridgeChild()
{
    MOZ_COUNT_DTOR(PCompositorBridgeChild);
}

auto PCompositorBridgeChild::Manager() const -> PCompositorManagerChild*
{
    return static_cast<PCompositorManagerChild*>(IProtocol::Manager());
}

auto PCompositorBridgeChild::ManagedPAPZChild(nsTArray<PAPZChild*>& aArr) const -> void
{
    mManagedPAPZChild.ToArray(aArr);
}

auto PCompositorBridgeChild::ManagedPAPZChild() const -> const ManagedContainer<PAPZChild>&
{
    return mManagedPAPZChild;
}

auto PCompositorBridgeChild::ManagedPAPZCTreeManagerChild(nsTArray<PAPZCTreeManagerChild*>& aArr) const -> void
{
    mManagedPAPZCTreeManagerChild.ToArray(aArr);
}

auto PCompositorBridgeChild::ManagedPAPZCTreeManagerChild() const -> const ManagedContainer<PAPZCTreeManagerChild>&
{
    return mManagedPAPZCTreeManagerChild;
}

auto PCompositorBridgeChild::ManagedPLayerTransactionChild(nsTArray<PLayerTransactionChild*>& aArr) const -> void
{
    mManagedPLayerTransactionChild.ToArray(aArr);
}

auto PCompositorBridgeChild::ManagedPLayerTransactionChild() const -> const ManagedContainer<PLayerTransactionChild>&
{
    return mManagedPLayerTransactionChild;
}

auto PCompositorBridgeChild::ManagedPTextureChild(nsTArray<PTextureChild*>& aArr) const -> void
{
    mManagedPTextureChild.ToArray(aArr);
}

auto PCompositorBridgeChild::ManagedPTextureChild() const -> const ManagedContainer<PTextureChild>&
{
    return mManagedPTextureChild;
}

auto PCompositorBridgeChild::ManagedPCompositorWidgetChild(nsTArray<PCompositorWidgetChild*>& aArr) const -> void
{
    mManagedPCompositorWidgetChild.ToArray(aArr);
}

auto PCompositorBridgeChild::ManagedPCompositorWidgetChild() const -> const ManagedContainer<PCompositorWidgetChild>&
{
    return mManagedPCompositorWidgetChild;
}

auto PCompositorBridgeChild::ManagedPWebRenderBridgeChild(nsTArray<PWebRenderBridgeChild*>& aArr) const -> void
{
    mManagedPWebRenderBridgeChild.ToArray(aArr);
}

auto PCompositorBridgeChild::ManagedPWebRenderBridgeChild() const -> const ManagedContainer<PWebRenderBridgeChild>&
{
    return mManagedPWebRenderBridgeChild;
}

auto PCompositorBridgeChild::ManagedPWebGLChild(nsTArray<PWebGLChild*>& aArr) const -> void
{
    mManagedPWebGLChild.ToArray(aArr);
}

auto PCompositorBridgeChild::ManagedPWebGLChild() const -> const ManagedContainer<PWebGLChild>&
{
    return mManagedPWebGLChild;
}

auto PCompositorBridgeChild::ManagedPWebGPUChild(nsTArray<PWebGPUChild*>& aArr) const -> void
{
    mManagedPWebGPUChild.ToArray(aArr);
}

auto PCompositorBridgeChild::ManagedPWebGPUChild() const -> const ManagedContainer<PWebGPUChild>&
{
    return mManagedPWebGPUChild;
}

auto PCompositorBridgeChild::AllManagedActors(nsTArray<RefPtr<mozilla::ipc::ActorLifecycleProxy>>& arr__) const -> void
{
    uint32_t total = 0;
    total += mManagedPAPZChild.Count();
    total += mManagedPAPZCTreeManagerChild.Count();
    total += mManagedPLayerTransactionChild.Count();
    total += mManagedPTextureChild.Count();
    total += mManagedPCompositorWidgetChild.Count();
    total += mManagedPWebRenderBridgeChild.Count();
    total += mManagedPWebGLChild.Count();
    total += mManagedPWebGPUChild.Count();
    arr__.SetCapacity(total);

    for (auto it = mManagedPAPZChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPAPZCTreeManagerChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPLayerTransactionChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPTextureChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPCompositorWidgetChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPWebRenderBridgeChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPWebGLChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

    for (auto it = mManagedPWebGPUChild.ConstIter(); !it.Done(); it.Next()) {
        arr__.AppendElement(it.Get()->GetKey()->GetLifecycleProxy());
    }

}

auto PCompositorBridgeChild::OpenPAPZEndpoint(PAPZChild* aActor) -> ManagedEndpoint<PAPZParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PAPZChild actor");
        return ManagedEndpoint<PAPZParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPAPZChild.PutEntry(aActor);

    return ManagedEndpoint<PAPZParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PCompositorBridgeChild::BindPAPZEndpoint(
        ManagedEndpoint<PAPZChild> aEndpoint,
        PAPZChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PAPZChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPAPZChild.PutEntry(aActor);

    return true;
}

auto PCompositorBridgeChild::OpenPAPZCTreeManagerEndpoint(PAPZCTreeManagerChild* aActor) -> ManagedEndpoint<PAPZCTreeManagerParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PAPZCTreeManagerChild actor");
        return ManagedEndpoint<PAPZCTreeManagerParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPAPZCTreeManagerChild.PutEntry(aActor);

    return ManagedEndpoint<PAPZCTreeManagerParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PCompositorBridgeChild::BindPAPZCTreeManagerEndpoint(
        ManagedEndpoint<PAPZCTreeManagerChild> aEndpoint,
        PAPZCTreeManagerChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PAPZCTreeManagerChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPAPZCTreeManagerChild.PutEntry(aActor);

    return true;
}

auto PCompositorBridgeChild::OpenPLayerTransactionEndpoint(PLayerTransactionChild* aActor) -> ManagedEndpoint<PLayerTransactionParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PLayerTransactionChild actor");
        return ManagedEndpoint<PLayerTransactionParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPLayerTransactionChild.PutEntry(aActor);

    return ManagedEndpoint<PLayerTransactionParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PCompositorBridgeChild::BindPLayerTransactionEndpoint(
        ManagedEndpoint<PLayerTransactionChild> aEndpoint,
        PLayerTransactionChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PLayerTransactionChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPLayerTransactionChild.PutEntry(aActor);

    return true;
}

auto PCompositorBridgeChild::OpenPTextureEndpoint(PTextureChild* aActor) -> ManagedEndpoint<PTextureParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PTextureChild actor");
        return ManagedEndpoint<PTextureParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPTextureChild.PutEntry(aActor);

    return ManagedEndpoint<PTextureParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PCompositorBridgeChild::BindPTextureEndpoint(
        ManagedEndpoint<PTextureChild> aEndpoint,
        PTextureChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PTextureChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPTextureChild.PutEntry(aActor);

    return true;
}

auto PCompositorBridgeChild::OpenPCompositorWidgetEndpoint(PCompositorWidgetChild* aActor) -> ManagedEndpoint<PCompositorWidgetParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PCompositorWidgetChild actor");
        return ManagedEndpoint<PCompositorWidgetParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPCompositorWidgetChild.PutEntry(aActor);

    return ManagedEndpoint<PCompositorWidgetParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PCompositorBridgeChild::BindPCompositorWidgetEndpoint(
        ManagedEndpoint<PCompositorWidgetChild> aEndpoint,
        PCompositorWidgetChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PCompositorWidgetChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPCompositorWidgetChild.PutEntry(aActor);

    return true;
}

auto PCompositorBridgeChild::OpenPWebRenderBridgeEndpoint(PWebRenderBridgeChild* aActor) -> ManagedEndpoint<PWebRenderBridgeParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebRenderBridgeChild actor");
        return ManagedEndpoint<PWebRenderBridgeParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPWebRenderBridgeChild.PutEntry(aActor);

    return ManagedEndpoint<PWebRenderBridgeParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PCompositorBridgeChild::BindPWebRenderBridgeEndpoint(
        ManagedEndpoint<PWebRenderBridgeChild> aEndpoint,
        PWebRenderBridgeChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebRenderBridgeChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPWebRenderBridgeChild.PutEntry(aActor);

    return true;
}

auto PCompositorBridgeChild::OpenPWebGLEndpoint(PWebGLChild* aActor) -> ManagedEndpoint<PWebGLParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebGLChild actor");
        return ManagedEndpoint<PWebGLParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPWebGLChild.PutEntry(aActor);

    return ManagedEndpoint<PWebGLParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PCompositorBridgeChild::BindPWebGLEndpoint(
        ManagedEndpoint<PWebGLChild> aEndpoint,
        PWebGLChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebGLChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPWebGLChild.PutEntry(aActor);

    return true;
}

auto PCompositorBridgeChild::OpenPWebGPUEndpoint(PWebGPUChild* aActor) -> ManagedEndpoint<PWebGPUParent>
{
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebGPUChild actor");
        return ManagedEndpoint<PWebGPUParent>();
    }

    aActor->SetManagerAndRegister(this);
    mManagedPWebGPUChild.PutEntry(aActor);

    return ManagedEndpoint<PWebGPUParent>(mozilla::ipc::PrivateIPDLInterface(), aActor->Id());
}

auto PCompositorBridgeChild::BindPWebGPUEndpoint(
        ManagedEndpoint<PWebGPUChild> aEndpoint,
        PWebGPUChild* aActor) -> bool
{
    MOZ_RELEASE_ASSERT(aEndpoint.ActorId(), "Invalid Endpoint!");
    if (!aActor) {
        NS_WARNING("Cannot bind null PWebGPUChild actor");
        return false;
    }

    aActor->SetManagerAndRegister(this, *aEndpoint.ActorId());
    mManagedPWebGPUChild.PutEntry(aActor);

    return true;
}

auto PCompositorBridgeChild::Send__delete__(PCompositorBridgeChild* actor) -> bool
{
    if (!actor || !actor->CanSend()) {
        NS_WARNING("Attempt to __delete__ missing or closed actor");
        return false;
    }
    IPC::Message* msg__ = PCompositorBridge::Msg___delete__((actor)->Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, actor, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);



    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            (actor)->OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg___delete__", OTHER);

    bool sendok__ = (actor)->ChannelSend(msg__);

    IProtocol* mgr = actor->Manager();
    actor->DestroySubtree(Deletion);
    actor->ClearSubtree();
    mgr->RemoveManagee(PCompositorBridgeMsgStart, actor);
    return sendok__;
}

auto PCompositorBridgeChild::SendPCompositorWidgetConstructor(const CompositorWidgetInitData& aInitData) -> PCompositorWidgetChild*
{
    PCompositorWidgetChild* actor = (static_cast<CompositorBridgeChild*>(this))->AllocPCompositorWidgetChild(aInitData);
    return SendPCompositorWidgetConstructor(actor, aInitData);
}

auto PCompositorBridgeChild::SendPCompositorWidgetConstructor(
        PCompositorWidgetChild* actor,
        const CompositorWidgetInitData& aInitData) -> PCompositorWidgetChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PCompositorWidgetChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPCompositorWidgetChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PCompositorBridge::Msg_PCompositorWidgetConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, aInitData);
    // Sentinel = 'aInitData'
    (msg__)->WriteSentinel(284296048);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_PCompositorWidgetConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PCompositorWidgetChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PCompositorWidgetMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PCompositorBridgeChild::SendInitialize(const LayersId& rootLayerTreeId) -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_Initialize(Id());

    WriteIPDLParam(msg__, this, rootLayerTreeId);
    // Sentinel = 'rootLayerTreeId'
    (msg__)->WriteSentinel(828507647);



    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_Initialize", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PCompositorBridge::Msg_Initialize", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    return true;
}

auto PCompositorBridgeChild::SendPAPZConstructor(const LayersId& layersId) -> PAPZChild*
{
    PAPZChild* actor = (static_cast<CompositorBridgeChild*>(this))->AllocPAPZChild(layersId);
    return SendPAPZConstructor(actor, layersId);
}

auto PCompositorBridgeChild::SendPAPZConstructor(
        PAPZChild* actor,
        const LayersId& layersId) -> PAPZChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PAPZChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPAPZChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PCompositorBridge::Msg_PAPZConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, layersId);
    // Sentinel = 'layersId'
    (msg__)->WriteSentinel(250938174);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_PAPZConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PAPZChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PAPZMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PCompositorBridgeChild::SendPAPZCTreeManagerConstructor(const LayersId& layersId) -> PAPZCTreeManagerChild*
{
    PAPZCTreeManagerChild* actor = (static_cast<CompositorBridgeChild*>(this))->AllocPAPZCTreeManagerChild(layersId);
    return SendPAPZCTreeManagerConstructor(actor, layersId);
}

auto PCompositorBridgeChild::SendPAPZCTreeManagerConstructor(
        PAPZCTreeManagerChild* actor,
        const LayersId& layersId) -> PAPZCTreeManagerChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PAPZCTreeManagerChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPAPZCTreeManagerChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PCompositorBridge::Msg_PAPZCTreeManagerConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, layersId);
    // Sentinel = 'layersId'
    (msg__)->WriteSentinel(250938174);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_PAPZCTreeManagerConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PAPZCTreeManagerChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PAPZCTreeManagerMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PCompositorBridgeChild::SendPWebGPUConstructor() -> PWebGPUChild*
{
    PWebGPUChild* actor = (static_cast<CompositorBridgeChild*>(this))->AllocPWebGPUChild();
    return SendPWebGPUConstructor(actor);
}

auto PCompositorBridgeChild::SendPWebGPUConstructor(PWebGPUChild* actor) -> PWebGPUChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PWebGPUChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPWebGPUChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PCompositorBridge::Msg_PWebGPUConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_PWebGPUConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PWebGPUChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PWebGPUMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PCompositorBridgeChild::SendWillClose() -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_WillClose(Id());




    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_WillClose", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PCompositorBridge::Msg_WillClose", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    return true;
}

auto PCompositorBridgeChild::SendPause() -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_Pause(Id());




    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_Pause", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PCompositorBridge::Msg_Pause", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    return true;
}

auto PCompositorBridgeChild::SendResume() -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_Resume(Id());




    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_Resume", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PCompositorBridge::Msg_Resume", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    return true;
}

auto PCompositorBridgeChild::SendResumeAsync() -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_ResumeAsync(Id());





    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_ResumeAsync", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PCompositorBridgeChild::SendNotifyChildCreated(
        const LayersId& id,
        CompositorOptions* compositorOptions) -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_NotifyChildCreated(Id());

    WriteIPDLParam(msg__, this, id);
    // Sentinel = 'id'
    (msg__)->WriteSentinel(20447438);



    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_NotifyChildCreated", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PCompositorBridge::Msg_NotifyChildCreated", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    PickleIterator iter__{reply__};

    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, compositorOptions)))) {
        FatalError("Error deserializing 'CompositorOptions'");
        return false;
    }
    // Sentinel = 'compositorOptions'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 1089275708)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'CompositorOptions'");
        return false;
    }
    reply__.EndRead(iter__, reply__.type());

    return true;
}

auto PCompositorBridgeChild::SendMapAndNotifyChildCreated(
        const LayersId& id,
        const ProcessId& owner,
        CompositorOptions* compositorOptions) -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_MapAndNotifyChildCreated(Id());

    WriteIPDLParam(msg__, this, id);
    // Sentinel = 'id'
    (msg__)->WriteSentinel(20447438);
    WriteIPDLParam(msg__, this, owner);
    // Sentinel = 'owner'
    (msg__)->WriteSentinel(110232108);



    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_MapAndNotifyChildCreated", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PCompositorBridge::Msg_MapAndNotifyChildCreated", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    PickleIterator iter__{reply__};

    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, compositorOptions)))) {
        FatalError("Error deserializing 'CompositorOptions'");
        return false;
    }
    // Sentinel = 'compositorOptions'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 1089275708)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'CompositorOptions'");
        return false;
    }
    reply__.EndRead(iter__, reply__.type());

    return true;
}

auto PCompositorBridgeChild::SendAdoptChild(const LayersId& id) -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_AdoptChild(Id());

    WriteIPDLParam(msg__, this, id);
    // Sentinel = 'id'
    (msg__)->WriteSentinel(20447438);




    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_AdoptChild", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PCompositorBridgeChild::SendNotifyChildRecreated(
        const LayersId& id,
        CompositorOptions* compositorOptions) -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_NotifyChildRecreated(Id());

    WriteIPDLParam(msg__, this, id);
    // Sentinel = 'id'
    (msg__)->WriteSentinel(20447438);



    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_NotifyChildRecreated", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PCompositorBridge::Msg_NotifyChildRecreated", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    PickleIterator iter__{reply__};

    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, compositorOptions)))) {
        FatalError("Error deserializing 'CompositorOptions'");
        return false;
    }
    // Sentinel = 'compositorOptions'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 1089275708)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'CompositorOptions'");
        return false;
    }
    reply__.EndRead(iter__, reply__.type());

    return true;
}

auto PCompositorBridgeChild::SendMakeSnapshot(
        const SurfaceDescriptor& inSnapshot,
        const IntRect& dirtyRect) -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_MakeSnapshot(Id());

    WriteIPDLParam(msg__, this, inSnapshot);
    // Sentinel = 'inSnapshot'
    (msg__)->WriteSentinel(375915560);
    WriteIPDLParam(msg__, this, dirtyRect);
    // Sentinel = 'dirtyRect'
    (msg__)->WriteSentinel(314115003);



    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_MakeSnapshot", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PCompositorBridge::Msg_MakeSnapshot", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    return true;
}

auto PCompositorBridgeChild::SendFlushRendering() -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_FlushRendering(Id());




    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_FlushRendering", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PCompositorBridge::Msg_FlushRendering", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    return true;
}

auto PCompositorBridgeChild::SendFlushRenderingAsync() -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_FlushRenderingAsync(Id());





    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_FlushRenderingAsync", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PCompositorBridgeChild::SendWaitOnTransactionProcessed() -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_WaitOnTransactionProcessed(Id());




    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_WaitOnTransactionProcessed", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PCompositorBridge::Msg_WaitOnTransactionProcessed", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    return true;
}

auto PCompositorBridgeChild::SendForcePresent() -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_ForcePresent(Id());





    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_ForcePresent", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PCompositorBridgeChild::SendStartFrameTimeRecording(
        const int32_t& bufferSize,
        uint32_t* startIndex) -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_StartFrameTimeRecording(Id());

    WriteIPDLParam(msg__, this, bufferSize);
    // Sentinel = 'bufferSize'
    (msg__)->WriteSentinel(376243222);



    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_StartFrameTimeRecording", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PCompositorBridge::Msg_StartFrameTimeRecording", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    PickleIterator iter__{reply__};

    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, startIndex)))) {
        FatalError("Error deserializing 'uint32_t'");
        return false;
    }
    // Sentinel = 'startIndex'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 386728999)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
        return false;
    }
    reply__.EndRead(iter__, reply__.type());

    return true;
}

auto PCompositorBridgeChild::SendStopFrameTimeRecording(
        const uint32_t& startIndex,
        nsTArray<float>* intervals) -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_StopFrameTimeRecording(Id());

    WriteIPDLParam(msg__, this, startIndex);
    // Sentinel = 'startIndex'
    (msg__)->WriteSentinel(386728999);



    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_StopFrameTimeRecording", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PCompositorBridge::Msg_StopFrameTimeRecording", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    PickleIterator iter__{reply__};

    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, intervals)))) {
        FatalError("Error deserializing 'float[]'");
        return false;
    }
    // Sentinel = 'intervals'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 322175961)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'float[]'");
        return false;
    }
    reply__.EndRead(iter__, reply__.type());

    return true;
}

auto PCompositorBridgeChild::SendPLayerTransactionConstructor(
        const nsTArray<LayersBackend>& layersBackendHints,
        const LayersId& id) -> PLayerTransactionChild*
{
    PLayerTransactionChild* actor = (static_cast<CompositorBridgeChild*>(this))->AllocPLayerTransactionChild(layersBackendHints, id);
    return SendPLayerTransactionConstructor(actor, layersBackendHints, id);
}

auto PCompositorBridgeChild::SendPLayerTransactionConstructor(
        PLayerTransactionChild* actor,
        const nsTArray<LayersBackend>& layersBackendHints,
        const LayersId& id) -> PLayerTransactionChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PLayerTransactionChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPLayerTransactionChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PCompositorBridge::Msg_PLayerTransactionConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, layersBackendHints);
    // Sentinel = 'layersBackendHints'
    (msg__)->WriteSentinel(1153435455);
    WriteIPDLParam(msg__, this, id);
    // Sentinel = 'id'
    (msg__)->WriteSentinel(20447438);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_PLayerTransactionConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PLayerTransactionChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PLayerTransactionMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PCompositorBridgeChild::SendNotifyRegionInvalidated(const nsIntRegion& region) -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_NotifyRegionInvalidated(Id());

    WriteIPDLParam(msg__, this, region);
    // Sentinel = 'region'
    (msg__)->WriteSentinel(147718789);




    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_NotifyRegionInvalidated", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PCompositorBridgeChild::SendRequestNotifyAfterRemotePaint() -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_RequestNotifyAfterRemotePaint(Id());





    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_RequestNotifyAfterRemotePaint", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PCompositorBridgeChild::SendPTextureConstructor(
        const SurfaceDescriptor& aSharedData,
        const ReadLockDescriptor& aReadLock,
        const LayersBackend& aBackend,
        const TextureFlags& aTextureFlags,
        const LayersId& id,
        const uint64_t& aSerial,
        const MaybeExternalImageId& aExternalImageId) -> PTextureChild*
{
    PTextureChild* actor = (static_cast<CompositorBridgeChild*>(this))->AllocPTextureChild(aSharedData, aReadLock, aBackend, aTextureFlags, id, aSerial, aExternalImageId);
    return SendPTextureConstructor(actor, aSharedData, aReadLock, aBackend, aTextureFlags, id, aSerial, aExternalImageId);
}

auto PCompositorBridgeChild::SendPTextureConstructor(
        PTextureChild* actor,
        const SurfaceDescriptor& aSharedData,
        const ReadLockDescriptor& aReadLock,
        const LayersBackend& aBackend,
        const TextureFlags& aTextureFlags,
        const LayersId& id,
        const uint64_t& aSerial,
        const MaybeExternalImageId& aExternalImageId) -> PTextureChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PTextureChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPTextureChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PCompositorBridge::Msg_PTextureConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, aSharedData);
    // Sentinel = 'aSharedData'
    (msg__)->WriteSentinel(420480051);
    WriteIPDLParam(msg__, this, aReadLock);
    // Sentinel = 'aReadLock'
    (msg__)->WriteSentinel(279774055);
    WriteIPDLParam(msg__, this, aBackend);
    // Sentinel = 'aBackend'
    (msg__)->WriteSentinel(221119242);
    WriteIPDLParam(msg__, this, aTextureFlags);
    // Sentinel = 'aTextureFlags'
    (msg__)->WriteSentinel(614139200);
    WriteIPDLParam(msg__, this, id);
    // Sentinel = 'id'
    (msg__)->WriteSentinel(20447438);
    WriteIPDLParam(msg__, this, aSerial);
    // Sentinel = 'aSerial'
    (msg__)->WriteSentinel(181011138);
    WriteIPDLParam(msg__, this, aExternalImageId);
    // Sentinel = 'aExternalImageId'
    (msg__)->WriteSentinel(898172469);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_PTextureConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PTextureChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PTextureMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PCompositorBridgeChild::SendInitPCanvasParent(Endpoint<mozilla::layers::PCanvasParent>&& aEndpoint) -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_InitPCanvasParent(Id());

    WriteIPDLParam(msg__, this, std::move(aEndpoint));
    // Sentinel = 'aEndpoint'
    (msg__)->WriteSentinel(292225955);




    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_InitPCanvasParent", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PCompositorBridgeChild::SendReleasePCanvasParent() -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_ReleasePCanvasParent(Id());





    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_ReleasePCanvasParent", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PCompositorBridgeChild::SendSyncWithCompositor() -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_SyncWithCompositor(Id());




    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_SyncWithCompositor", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PCompositorBridge::Msg_SyncWithCompositor", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    return true;
}

auto PCompositorBridgeChild::SendPWebRenderBridgeConstructor(
        const PipelineId& pipelineId,
        const LayoutDeviceIntSize& aSize,
        const WindowKind& aKind) -> PWebRenderBridgeChild*
{
    PWebRenderBridgeChild* actor = (static_cast<CompositorBridgeChild*>(this))->AllocPWebRenderBridgeChild(pipelineId, aSize, aKind);
    return SendPWebRenderBridgeConstructor(actor, pipelineId, aSize, aKind);
}

auto PCompositorBridgeChild::SendPWebRenderBridgeConstructor(
        PWebRenderBridgeChild* actor,
        const PipelineId& pipelineId,
        const LayoutDeviceIntSize& aSize,
        const WindowKind& aKind) -> PWebRenderBridgeChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PWebRenderBridgeChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPWebRenderBridgeChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PCompositorBridge::Msg_PWebRenderBridgeConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);
    WriteIPDLParam(msg__, this, pipelineId);
    // Sentinel = 'pipelineId'
    (msg__)->WriteSentinel(382731268);
    WriteIPDLParam(msg__, this, aSize);
    // Sentinel = 'aSize'
    (msg__)->WriteSentinel(97124861);
    WriteIPDLParam(msg__, this, aKind);
    // Sentinel = 'aKind'
    (msg__)->WriteSentinel(93389288);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_PWebRenderBridgeConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PWebRenderBridgeChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PWebRenderBridgeMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PCompositorBridgeChild::SendCheckContentOnlyTDR(
        const uint32_t& sequenceNum,
        bool* isContentOnlyTDR) -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_CheckContentOnlyTDR(Id());

    WriteIPDLParam(msg__, this, sequenceNum);
    // Sentinel = 'sequenceNum'
    (msg__)->WriteSentinel(464127114);



    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_CheckContentOnlyTDR", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PCompositorBridge::Msg_CheckContentOnlyTDR", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    PickleIterator iter__{reply__};

    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, isContentOnlyTDR)))) {
        FatalError("Error deserializing 'bool'");
        return false;
    }
    // Sentinel = 'isContentOnlyTDR'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 919668292)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
        return false;
    }
    reply__.EndRead(iter__, reply__.type());

    return true;
}

auto PCompositorBridgeChild::SendBeginRecording(
        const TimeStamp& aRecordingStart,
        mozilla::ipc::ResolveCallback<bool>&& aResolve,
        mozilla::ipc::RejectCallback&& aReject) -> void
{
    IPC::Message* msg__ = PCompositorBridge::Msg_BeginRecording(Id());

    WriteIPDLParam(msg__, this, aRecordingStart);
    // Sentinel = 'aRecordingStart'
    (msg__)->WriteSentinel(794428941);




    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_BeginRecording", OTHER);

    ChannelSend(msg__, std::move(aResolve), std::move(aReject));
    return;
}

auto PCompositorBridgeChild::SendBeginRecording(const TimeStamp& aRecordingStart) -> RefPtr<BeginRecordingPromise>
{
    RefPtr<MozPromise<bool, ResponseRejectReason, true>::Private> promise__ = new MozPromise<bool, ResponseRejectReason, true>::Private(__func__);
    promise__->UseDirectTaskDispatch(__func__);
    SendBeginRecording(std::move(aRecordingStart), [promise__](bool&& aValue) {
        promise__->Resolve(std::move(aValue), __func__);
    }, [promise__](ResponseRejectReason&& aReason) {
        promise__->Reject(std::move(aReason), __func__);
    });
    return promise__;
}

auto PCompositorBridgeChild::SendEndRecordingToDisk(
        mozilla::ipc::ResolveCallback<bool>&& aResolve,
        mozilla::ipc::RejectCallback&& aReject) -> void
{
    IPC::Message* msg__ = PCompositorBridge::Msg_EndRecordingToDisk(Id());





    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_EndRecordingToDisk", OTHER);

    ChannelSend(msg__, std::move(aResolve), std::move(aReject));
    return;
}

auto PCompositorBridgeChild::SendEndRecordingToDisk() -> RefPtr<EndRecordingToDiskPromise>
{
    RefPtr<MozPromise<bool, ResponseRejectReason, true>::Private> promise__ = new MozPromise<bool, ResponseRejectReason, true>::Private(__func__);
    promise__->UseDirectTaskDispatch(__func__);
    SendEndRecordingToDisk([promise__](bool&& aValue) {
        promise__->Resolve(std::move(aValue), __func__);
    }, [promise__](ResponseRejectReason&& aReason) {
        promise__->Reject(std::move(aReason), __func__);
    });
    return promise__;
}

auto PCompositorBridgeChild::SendEndRecordingToMemory(
        mozilla::ipc::ResolveCallback<mozilla::Maybe<CollectedFramesParams>>&& aResolve,
        mozilla::ipc::RejectCallback&& aReject) -> void
{
    IPC::Message* msg__ = PCompositorBridge::Msg_EndRecordingToMemory(Id());





    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_EndRecordingToMemory", OTHER);

    ChannelSend(msg__, std::move(aResolve), std::move(aReject));
    return;
}

auto PCompositorBridgeChild::SendEndRecordingToMemory() -> RefPtr<EndRecordingToMemoryPromise>
{
    RefPtr<MozPromise<mozilla::Maybe<CollectedFramesParams>, ResponseRejectReason, true>::Private> promise__ = new MozPromise<mozilla::Maybe<CollectedFramesParams>, ResponseRejectReason, true>::Private(__func__);
    promise__->UseDirectTaskDispatch(__func__);
    SendEndRecordingToMemory([promise__](mozilla::Maybe<CollectedFramesParams>&& aValue) {
        promise__->Resolve(std::move(aValue), __func__);
    }, [promise__](ResponseRejectReason&& aReason) {
        promise__->Reject(std::move(aReason), __func__);
    });
    return promise__;
}

auto PCompositorBridgeChild::SendSupportsAsyncDXGISurface(bool* value) -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_SupportsAsyncDXGISurface(Id());




    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_SupportsAsyncDXGISurface", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PCompositorBridge::Msg_SupportsAsyncDXGISurface", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    PickleIterator iter__{reply__};

    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, value)))) {
        FatalError("Error deserializing 'bool'");
        return false;
    }
    // Sentinel = 'value'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 107610654)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
        return false;
    }
    reply__.EndRead(iter__, reply__.type());

    return true;
}

auto PCompositorBridgeChild::SendPreferredDXGIAdapter(DxgiAdapterDesc* desc) -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_PreferredDXGIAdapter(Id());




    Message reply__;

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_PreferredDXGIAdapter", OTHER);

    bool sendok__ = false;
    {
        AUTO_PROFILER_TRACING_MARKER("Sync IPC", "PCompositorBridge::Msg_PreferredDXGIAdapter", IPC);
        sendok__ = ChannelSend(msg__, (&(reply__)));
    }
    if ((!(sendok__))) {
        return false;
    }

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Received reply ",
            (&(reply__))->type(),
            mozilla::ipc::MessageDirection::eReceiving);
    }

    PickleIterator iter__{reply__};

    if ((!(ReadIPDLParam((&(reply__)), (&(iter__)), this, desc)))) {
        FatalError("Error deserializing 'DxgiAdapterDesc'");
        return false;
    }
    // Sentinel = 'desc'
    if ((!(((&(reply__)))->ReadSentinel((&(iter__)), 67895712)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'DxgiAdapterDesc'");
        return false;
    }
    reply__.EndRead(iter__, reply__.type());

    return true;
}

auto PCompositorBridgeChild::SendRequestFxrOutput() -> bool
{
    IPC::Message* msg__ = PCompositorBridge::Msg_RequestFxrOutput(Id());





    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_RequestFxrOutput", OTHER);

    bool sendok__ = ChannelSend(msg__);
    return sendok__;
}

auto PCompositorBridgeChild::SendPWebGLConstructor(PWebGLChild* actor) -> PWebGLChild*
{
    if (!actor) {
        NS_WARNING("Cannot bind null PWebGLChild actor");
        return nullptr;
    }

    actor->SetManagerAndRegister(this);
    mManagedPWebGLChild.PutEntry(actor);


    // Build our constructor message.
    IPC::Message* msg__ = PCompositorBridge::Msg_PWebGLConstructor(Id());

    MOZ_RELEASE_ASSERT(actor, "NULL actor value passed to non-nullable param");
    WriteIPDLParam(msg__, this, actor);
    // Sentinel = 'actor'
    (msg__)->WriteSentinel(102892058);




    // Notify the other side about the newly created actor. This can
    // fail if our manager has already been destroyed.
    //
    // NOTE: If the send call fails due to toplevel channel teardown,
    // the `IProtocol::ChannelSend` wrapper absorbs the error for us,
    // so we don't tear down actors unexpectedly.

    if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
        mozilla::ipc::LogMessageForProtocol(
            "PCompositorBridgeChild",
            OtherPid(),
            "Sending ",
            msg__->type(),
            mozilla::ipc::MessageDirection::eSending);
    }
    AUTO_PROFILER_LABEL("PCompositorBridge::Msg_PWebGLConstructor", OTHER);

    bool sendok__ = ChannelSend(msg__);


    // Warn, destroy the actor, and return null if the message failed to
    // send. Otherwise, return the successfully created actor reference.
    if (!sendok__) {
        NS_WARNING("Error sending PWebGLChild constructor");
        IProtocol* mgr = actor->Manager();
        actor->DestroySubtree(FailedConstructor);
        actor->ClearSubtree();
        mgr->RemoveManagee(PWebGLMsgStart, actor);

        return nullptr;
    }
    return actor;
}

auto PCompositorBridgeChild::RemoveManagee(
        int32_t aProtocolId,
        IProtocol* aListener) -> void
{
    switch (aProtocolId) {
    case PAPZMsgStart:
{
            PAPZChild* actor = static_cast<PAPZChild*>(aListener);
            auto& container = mManagedPAPZChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PAPZCTreeManagerMsgStart:
{
            PAPZCTreeManagerChild* actor = static_cast<PAPZCTreeManagerChild*>(aListener);
            auto& container = mManagedPAPZCTreeManagerChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PLayerTransactionMsgStart:
{
            PLayerTransactionChild* actor = static_cast<PLayerTransactionChild*>(aListener);
            auto& container = mManagedPLayerTransactionChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PTextureMsgStart:
{
            PTextureChild* actor = static_cast<PTextureChild*>(aListener);
            auto& container = mManagedPTextureChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PCompositorWidgetMsgStart:
{
            PCompositorWidgetChild* actor = static_cast<PCompositorWidgetChild*>(aListener);
            auto& container = mManagedPCompositorWidgetChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PWebRenderBridgeMsgStart:
{
            PWebRenderBridgeChild* actor = static_cast<PWebRenderBridgeChild*>(aListener);
            auto& container = mManagedPWebRenderBridgeChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PWebGLMsgStart:
{
            PWebGLChild* actor = static_cast<PWebGLChild*>(aListener);
            auto& container = mManagedPWebGLChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    case PWebGPUMsgStart:
{
            PWebGPUChild* actor = static_cast<PWebGPUChild*>(aListener);
            auto& container = mManagedPWebGPUChild;

            // Use a temporary variable here so all the assertion expressions
            // in the MOZ_RELEASE_ASSERT call below are textually identical;
            // the linker can then merge the strings from the assertion macro(s).
            MOZ_RELEASE_ASSERT(container.Contains(actor),
                "actor not managed by this!");
            container.RemoveEntry(actor);

            auto* proxy = actor->GetLifecycleProxy();
            NS_IF_RELEASE(proxy);
            return;
        }    default:
FatalError("unreached");
        return;    }
}

auto PCompositorBridgeChild::DeallocManagee(
        int32_t aProtocolId,
        IProtocol* aListener) -> void
{
    switch (aProtocolId) {
    case PAPZMsgStart:
        static_cast<CompositorBridgeChild*>(this)->DeallocPAPZChild(static_cast<PAPZChild*>(aListener));
        return;
    case PAPZCTreeManagerMsgStart:
        static_cast<CompositorBridgeChild*>(this)->DeallocPAPZCTreeManagerChild(static_cast<PAPZCTreeManagerChild*>(aListener));
        return;
    case PLayerTransactionMsgStart:
        static_cast<CompositorBridgeChild*>(this)->DeallocPLayerTransactionChild(static_cast<PLayerTransactionChild*>(aListener));
        return;
    case PTextureMsgStart:
        static_cast<CompositorBridgeChild*>(this)->DeallocPTextureChild(static_cast<PTextureChild*>(aListener));
        return;
    case PCompositorWidgetMsgStart:
        static_cast<CompositorBridgeChild*>(this)->DeallocPCompositorWidgetChild(static_cast<PCompositorWidgetChild*>(aListener));
        return;
    case PWebRenderBridgeMsgStart:
        static_cast<CompositorBridgeChild*>(this)->DeallocPWebRenderBridgeChild(static_cast<PWebRenderBridgeChild*>(aListener));
        return;
    case PWebGPUMsgStart:
        static_cast<CompositorBridgeChild*>(this)->DeallocPWebGPUChild(static_cast<PWebGPUChild*>(aListener));
        return;
    default:
        FatalError("unreached");
        return;
    }
}

auto PCompositorBridgeChild::OnMessageReceived(const Message& msg__) -> PCompositorBridgeChild::Result
{
    switch (msg__.type()) {
    case PCompositorBridge::Msg_InvalidateLayers__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PCompositorBridgeChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PCompositorBridge::Msg_InvalidateLayers", OTHER);

            PickleIterator iter__{msg__};
            LayersId layersId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(layersId)))))) {
                FatalError("Error deserializing 'LayersId'");
                return MsgValueError;
            }
            // Sentinel = 'layersId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 250938174)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'LayersId'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<CompositorBridgeChild*>(this))->RecvInvalidateLayers(std::move(layersId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PCompositorBridge::Msg_DidComposite__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PCompositorBridgeChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PCompositorBridge::Msg_DidComposite", OTHER);

            PickleIterator iter__{msg__};
            LayersId id{};
            TransactionId transactionId{};
            TimeStamp compositeStart{};
            TimeStamp compositeEnd{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(id)))))) {
                FatalError("Error deserializing 'LayersId'");
                return MsgValueError;
            }
            // Sentinel = 'id'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 20447438)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'LayersId'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(transactionId)))))) {
                FatalError("Error deserializing 'TransactionId'");
                return MsgValueError;
            }
            // Sentinel = 'transactionId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 642319700)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'TransactionId'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(compositeStart)))))) {
                FatalError("Error deserializing 'TimeStamp'");
                return MsgValueError;
            }
            // Sentinel = 'compositeStart'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 740558306)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'TimeStamp'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(compositeEnd)))))) {
                FatalError("Error deserializing 'TimeStamp'");
                return MsgValueError;
            }
            // Sentinel = 'compositeEnd'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 547423467)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'TimeStamp'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<CompositorBridgeChild*>(this))->RecvDidComposite(std::move(id), std::move(transactionId), std::move(compositeStart), std::move(compositeEnd))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PCompositorBridge::Msg_NotifyFrameStats__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PCompositorBridgeChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PCompositorBridge::Msg_NotifyFrameStats", OTHER);

            PickleIterator iter__{msg__};
            nsTArray<FrameStats> aFrameStats{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aFrameStats)))))) {
                FatalError("Error deserializing 'FrameStats[]'");
                return MsgValueError;
            }
            // Sentinel = 'aFrameStats'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 423756892)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'FrameStats[]'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<CompositorBridgeChild*>(this))->RecvNotifyFrameStats(std::move(aFrameStats))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PCompositorBridge::Msg_RemotePaintIsReady__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PCompositorBridgeChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PCompositorBridge::Msg_RemotePaintIsReady", OTHER);

            if ((!((static_cast<CompositorBridgeChild*>(this))->RecvRemotePaintIsReady()))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PCompositorBridge::Msg_ParentAsyncMessages__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PCompositorBridgeChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PCompositorBridge::Msg_ParentAsyncMessages", OTHER);

            PickleIterator iter__{msg__};
            nsTArray<AsyncParentMessageData> aMessages{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aMessages)))))) {
                FatalError("Error deserializing 'AsyncParentMessageData[]'");
                return MsgValueError;
            }
            // Sentinel = 'aMessages'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 293864346)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'AsyncParentMessageData[]'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<CompositorBridgeChild*>(this))->RecvParentAsyncMessages(std::move(aMessages))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PCompositorBridge::Msg_ObserveLayersUpdate__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PCompositorBridgeChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PCompositorBridge::Msg_ObserveLayersUpdate", OTHER);

            PickleIterator iter__{msg__};
            LayersId aLayersId{};
            LayersObserverEpoch aEpoch{};
            bool aActive{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aLayersId)))))) {
                FatalError("Error deserializing 'LayersId'");
                return MsgValueError;
            }
            // Sentinel = 'aLayersId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 291439487)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'LayersId'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aEpoch)))))) {
                FatalError("Error deserializing 'LayersObserverEpoch'");
                return MsgValueError;
            }
            // Sentinel = 'aEpoch'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 132121169)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'LayersObserverEpoch'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aActive)))))) {
                FatalError("Error deserializing 'bool'");
                return MsgValueError;
            }
            // Sentinel = 'aActive'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 176095934)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<CompositorBridgeChild*>(this))->RecvObserveLayersUpdate(std::move(aLayersId), std::move(aEpoch), std::move(aActive))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PCompositorBridge::Msg_CompositorOptionsChanged__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PCompositorBridgeChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PCompositorBridge::Msg_CompositorOptionsChanged", OTHER);

            PickleIterator iter__{msg__};
            LayersId id{};
            CompositorOptions newOptions{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(id)))))) {
                FatalError("Error deserializing 'LayersId'");
                return MsgValueError;
            }
            // Sentinel = 'id'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 20447438)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'LayersId'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(newOptions)))))) {
                FatalError("Error deserializing 'CompositorOptions'");
                return MsgValueError;
            }
            // Sentinel = 'newOptions'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 384304183)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'CompositorOptions'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<CompositorBridgeChild*>(this))->RecvCompositorOptionsChanged(std::move(id), std::move(newOptions))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PCompositorBridge::Msg_NotifyJankedAnimations__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PCompositorBridgeChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PCompositorBridge::Msg_NotifyJankedAnimations", OTHER);

            PickleIterator iter__{msg__};
            LayersId id{};
            nsTArray<uint64_t> aJankedAnimations{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(id)))))) {
                FatalError("Error deserializing 'LayersId'");
                return MsgValueError;
            }
            // Sentinel = 'id'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 20447438)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'LayersId'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aJankedAnimations)))))) {
                FatalError("Error deserializing 'uint64_t[]'");
                return MsgValueError;
            }
            // Sentinel = 'aJankedAnimations'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 985728706)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint64_t[]'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<CompositorBridgeChild*>(this))->RecvNotifyJankedAnimations(std::move(id), std::move(aJankedAnimations))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PCompositorBridge::Reply___delete____ID:
        {
            return MsgProcessed;
        }
    case PCompositorBridge::Reply_PCompositorWidgetConstructor__ID:
        {
            return MsgProcessed;
        }
    case PCompositorBridge::Reply_PAPZConstructor__ID:
        {
            return MsgProcessed;
        }
    case PCompositorBridge::Reply_PAPZCTreeManagerConstructor__ID:
        {
            return MsgProcessed;
        }
    case PCompositorBridge::Reply_PWebGPUConstructor__ID:
        {
            return MsgProcessed;
        }
    case PCompositorBridge::Reply_PLayerTransactionConstructor__ID:
        {
            return MsgProcessed;
        }
    case PCompositorBridge::Reply_PTextureConstructor__ID:
        {
            return MsgProcessed;
        }
    case PCompositorBridge::Reply_PWebRenderBridgeConstructor__ID:
        {
            return MsgProcessed;
        }
    case PCompositorBridge::Reply_BeginRecording__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PCompositorBridgeChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PCompositorBridge::Msg_BeginRecording", OTHER);

            PickleIterator iter__{msg__};
            bool resolve__ = false;
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(resolve__)))))) {
                FatalError("Error deserializing 'resolve__'");
                return MsgValueError;
            }
            // Sentinel = 'resolve__'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 322044863)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'resolve__'");
                return MsgValueError;
            }


            UniquePtr<MessageChannel::UntypedCallbackHolder> untypedCallback =
                GetIPCChannel()->PopCallback(msg__);

            typedef MessageChannel::CallbackHolder<bool> CallbackHolder;
            auto* callback = static_cast<CallbackHolder*>(untypedCallback.get());
            if (!callback) {
                FatalError("Error unknown callback");
                return MsgProcessingError;
            }

            if (resolve__) {
                bool success{};

                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(success)))))) {
                    FatalError("Error deserializing 'bool'");
                    return MsgValueError;
                }
                // Sentinel = 'success'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 200082170)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Resolve(std::move(success));
            } else {
                ResponseRejectReason reason__{};
                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(reason__)))))) {
                    FatalError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                // Sentinel = 'reason__'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 251855687)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Reject(std::move(reason__));
            }
            return MsgProcessed;
        }
    case PCompositorBridge::Reply_EndRecordingToDisk__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PCompositorBridgeChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PCompositorBridge::Msg_EndRecordingToDisk", OTHER);

            PickleIterator iter__{msg__};
            bool resolve__ = false;
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(resolve__)))))) {
                FatalError("Error deserializing 'resolve__'");
                return MsgValueError;
            }
            // Sentinel = 'resolve__'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 322044863)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'resolve__'");
                return MsgValueError;
            }


            UniquePtr<MessageChannel::UntypedCallbackHolder> untypedCallback =
                GetIPCChannel()->PopCallback(msg__);

            typedef MessageChannel::CallbackHolder<bool> CallbackHolder;
            auto* callback = static_cast<CallbackHolder*>(untypedCallback.get());
            if (!callback) {
                FatalError("Error unknown callback");
                return MsgProcessingError;
            }

            if (resolve__) {
                bool success{};

                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(success)))))) {
                    FatalError("Error deserializing 'bool'");
                    return MsgValueError;
                }
                // Sentinel = 'success'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 200082170)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'bool'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Resolve(std::move(success));
            } else {
                ResponseRejectReason reason__{};
                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(reason__)))))) {
                    FatalError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                // Sentinel = 'reason__'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 251855687)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Reject(std::move(reason__));
            }
            return MsgProcessed;
        }
    case PCompositorBridge::Reply_EndRecordingToMemory__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PCompositorBridgeChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PCompositorBridge::Msg_EndRecordingToMemory", OTHER);

            PickleIterator iter__{msg__};
            bool resolve__ = false;
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(resolve__)))))) {
                FatalError("Error deserializing 'resolve__'");
                return MsgValueError;
            }
            // Sentinel = 'resolve__'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 322044863)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'resolve__'");
                return MsgValueError;
            }


            UniquePtr<MessageChannel::UntypedCallbackHolder> untypedCallback =
                GetIPCChannel()->PopCallback(msg__);

            typedef MessageChannel::CallbackHolder<mozilla::Maybe<CollectedFramesParams>> CallbackHolder;
            auto* callback = static_cast<CallbackHolder*>(untypedCallback.get());
            if (!callback) {
                FatalError("Error unknown callback");
                return MsgProcessingError;
            }

            if (resolve__) {
                mozilla::Maybe<CollectedFramesParams> frames{};

                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(frames)))))) {
                    FatalError("Error deserializing 'CollectedFramesParams?'");
                    return MsgValueError;
                }
                // Sentinel = 'frames'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 145490559)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'CollectedFramesParams?'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Resolve(std::move(frames));
            } else {
                ResponseRejectReason reason__{};
                if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(reason__)))))) {
                    FatalError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                // Sentinel = 'reason__'
                if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 251855687)))) {
                    mozilla::ipc::SentinelReadError("Error deserializing 'reason__'");
                    return MsgValueError;
                }
                msg__.EndRead(iter__, msg__.type());

                callback->Reject(std::move(reason__));
            }
            return MsgProcessed;
        }
    case PCompositorBridge::Reply_PWebGLConstructor__ID:
        {
            return MsgProcessed;
        }
    case PCompositorBridge::Msg_SharedCompositorFrameMetrics__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PCompositorBridgeChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PCompositorBridge::Msg_SharedCompositorFrameMetrics", OTHER);

            PickleIterator iter__{msg__};
            Handle metrics{};
            CrossProcessMutexHandle mutex{};
            LayersId aLayersId{};
            uint32_t aAPZCId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(metrics)))))) {
                FatalError("Error deserializing 'Handle'");
                return MsgValueError;
            }
            // Sentinel = 'metrics'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 199230200)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'Handle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(mutex)))))) {
                FatalError("Error deserializing 'CrossProcessMutexHandle'");
                return MsgValueError;
            }
            // Sentinel = 'mutex'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 110625332)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'CrossProcessMutexHandle'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aLayersId)))))) {
                FatalError("Error deserializing 'LayersId'");
                return MsgValueError;
            }
            // Sentinel = 'aLayersId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 291439487)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'LayersId'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aAPZCId)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'aAPZCId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 149619261)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<CompositorBridgeChild*>(this))->RecvSharedCompositorFrameMetrics(std::move(metrics), std::move(mutex), std::move(aLayersId), std::move(aAPZCId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    case PCompositorBridge::Msg_ReleaseSharedCompositorFrameMetrics__ID:
        {
            if (mozilla::ipc::LoggingEnabledFor("PCompositorBridgeChild")) {
                mozilla::ipc::LogMessageForProtocol(
                    "PCompositorBridgeChild",
                    OtherPid(),
                    "Received ",
                    (&(msg__))->type(),
                    mozilla::ipc::MessageDirection::eReceiving);
            }
            AUTO_PROFILER_LABEL("PCompositorBridge::Msg_ReleaseSharedCompositorFrameMetrics", OTHER);

            PickleIterator iter__{msg__};
            ViewID aId{};
            uint32_t aAPZCId{};

            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aId)))))) {
                FatalError("Error deserializing 'ViewID'");
                return MsgValueError;
            }
            // Sentinel = 'aId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 35389711)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'ViewID'");
                return MsgValueError;
            }
            if ((!(ReadIPDLParam((&(msg__)), (&(iter__)), this, (&(aAPZCId)))))) {
                FatalError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            // Sentinel = 'aAPZCId'
            if ((!(((&(msg__)))->ReadSentinel((&(iter__)), 149619261)))) {
                mozilla::ipc::SentinelReadError("Error deserializing 'uint32_t'");
                return MsgValueError;
            }
            msg__.EndRead(iter__, msg__.type());
            if ((!((static_cast<CompositorBridgeChild*>(this))->RecvReleaseSharedCompositorFrameMetrics(std::move(aId), std::move(aAPZCId))))) {
                mozilla::ipc::ProtocolErrorBreakpoint("Handler returned error code!");
                // Error handled in mozilla::ipc::IPCResult
                return MsgProcessingError;
            }

            return MsgProcessed;
        }
    default:
        return MsgNotKnown;
    }
}

auto PCompositorBridgeChild::OnMessageReceived(
        const Message& msg__,
        Message*& reply__) -> PCompositorBridgeChild::Result
{
    return MsgNotKnown;
}

auto PCompositorBridgeChild::OnCallReceived(
        const Message& msg__,
        Message*& reply__) -> PCompositorBridgeChild::Result
{
    MOZ_ASSERT_UNREACHABLE("message protocol not supported");
    return MsgNotKnown;
}

auto PCompositorBridgeChild::ClearSubtree() -> void
{
    for (auto it = mManagedPAPZChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPAPZChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPAPZChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPAPZChild.Clear();

    for (auto it = mManagedPAPZCTreeManagerChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPAPZCTreeManagerChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPAPZCTreeManagerChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPAPZCTreeManagerChild.Clear();

    for (auto it = mManagedPLayerTransactionChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPLayerTransactionChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPLayerTransactionChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPLayerTransactionChild.Clear();

    for (auto it = mManagedPTextureChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPTextureChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPTextureChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPTextureChild.Clear();

    for (auto it = mManagedPCompositorWidgetChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPCompositorWidgetChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPCompositorWidgetChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPCompositorWidgetChild.Clear();

    for (auto it = mManagedPWebRenderBridgeChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPWebRenderBridgeChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPWebRenderBridgeChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPWebRenderBridgeChild.Clear();

    for (auto it = mManagedPWebGLChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPWebGLChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPWebGLChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPWebGLChild.Clear();

    for (auto it = mManagedPWebGPUChild.Iter(); !it.Done(); it.Next()) {
        it.Get()->GetKey()->ClearSubtree();
    }
    for (auto it = mManagedPWebGPUChild.Iter(); !it.Done(); it.Next()) {
        // Recursively releasing mManagedPWebGPUChild kids.
        auto* proxy = it.Get()->GetKey()->GetLifecycleProxy();
        NS_IF_RELEASE(proxy);
    }
    mManagedPWebGPUChild.Clear();

}



} // namespace layers
} // namespace mozilla
namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::layers::PCompositorBridgeChild*>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    int32_t id;
    if (!aVar) {
        id = 0;  // kNullActorId
    } else {
        id = aVar->Id();
        if (id == 1) {  // kFreedActorId
            aVar->FatalError("Actor has been |delete|d");
        }
        MOZ_RELEASE_ASSERT(
            aActor->GetIPCChannel() == aVar->GetIPCChannel(),
            "Actor must be from the same channel as the"
            " actor it's being sent over");
        MOZ_RELEASE_ASSERT(
            aVar->CanSend(),
            "Actor must still be open when sending");
    }

    WriteIPDLParam(aMsg, aActor, id);
}

auto IPDLParamTraits<mozilla::layers::PCompositorBridgeChild*>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    mozilla::Maybe<mozilla::ipc::IProtocol*> actor =
        aActor->ReadActor(aMsg, aIter, true, "PCompositorBridge", PCompositorBridgeMsgStart);
    if (actor.isNothing()) {
        return false;
    }

    *aVar = static_cast<mozilla::layers::PCompositorBridgeChild*>(actor.value());
    return true;
}

} // namespace ipc
} // namespace mozilla
