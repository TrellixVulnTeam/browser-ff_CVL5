//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/net/NeckoMessageUtils.h"
#include "mozilla/net/DNS.h"
#include "prio.h"
#include "mozilla/net/PNeckoParent.h"
#include "mozilla/net/PNeckoChild.h"
#include "mozilla/ipc/PBackgroundParent.h"
#include "mozilla/ipc/PBackgroundChild.h"
#include "mozilla/ipc/PFileDescriptorSetParent.h"
#include "mozilla/ipc/PFileDescriptorSetChild.h"
#include "mozilla/ipc/PChildToParentStreamParent.h"
#include "mozilla/ipc/PChildToParentStreamChild.h"
#include "mozilla/ipc/PParentToChildStreamParent.h"
#include "mozilla/ipc/PParentToChildStreamChild.h"
#include "mozilla/net/PUDPSocket.h"
#include "mozilla/net/PUDPSocketParent.h"
#include "mozilla/net/PUDPSocketChild.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace net {
namespace PUDPSocket {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::net::PUDPSocketParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::net::PUDPSocketChild>* aChild)
{
    return mozilla::ipc::CreateEndpoints(
        mozilla::ipc::PrivateIPDLInterface(),
        aParentDestPid, aChildDestPid,
        aParent, aChild);
}
IPC::Message*
Msg_Bind(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Bind__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_Connect(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Connect__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_OutgoingData(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_OutgoingData__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_JoinMulticast(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_JoinMulticast__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_LeaveMulticast(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_LeaveMulticast__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_Close(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Close__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_RequestDelete(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_RequestDelete__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_CallbackOpened(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_CallbackOpened__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_CallbackConnected(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_CallbackConnected__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_CallbackClosed(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_CallbackClosed__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_CallbackReceivedData(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_CallbackReceivedData__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg_CallbackError(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_CallbackError__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg___delete__(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg___delete____ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply___delete__(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply___delete____ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}

} // namespace PUDPSocket
} // namespace net
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct UDPAddressInfo|
//

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<UDPAddressInfo>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).addr());
    // Sentinel = 'addr'
    (aMsg)->WriteSentinel(65929628);
    (aMsg)->WriteBytes((&((aVar).port())), 2);
    // Sentinel = 'port'
    (aMsg)->WriteSentinel(73990598);
}

auto IPDLParamTraits<UDPAddressInfo>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->addr())))))) {
        aActor->FatalError("Error deserializing 'addr' (nsCString) member of 'UDPAddressInfo'");
        return false;
    }
    // Sentinel = 'addr'
    if ((!((aMsg)->ReadSentinel(aIter, 65929628)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'addr' (nsCString) member of 'UDPAddressInfo'");
        return false;
    }
    if ((!((aMsg)->ReadBytesInto(aIter, (&((aVar)->port())), 2)))) {
        aActor->FatalError("Error bulk reading fields from uint16_t");
        return false;
    }
    // Sentinel = 'port'
    if ((!((aMsg)->ReadSentinel(aIter, 73990598)))) {
        mozilla::ipc::SentinelReadError("Error bulk reading fields from uint16_t");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union UDPSocketAddr|
//
auto UDPSocketAddr::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TUDPAddressInfo:
        {
            (ptr_UDPAddressInfo())->~UDPAddressInfo__tdef();
            break;
        }
    case TNetAddr:
        {
            (ptr_NetAddr())->~NetAddr__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT UDPSocketAddr::UDPSocketAddr(const UDPAddressInfo& aOther)
{
    new (mozilla::KnownNotNull, ptr_UDPAddressInfo()) UDPAddressInfo(aOther);
    mType = TUDPAddressInfo;
}

MOZ_IMPLICIT UDPSocketAddr::UDPSocketAddr(UDPAddressInfo&& aOther)
{
    new (mozilla::KnownNotNull, ptr_UDPAddressInfo()) UDPAddressInfo(std::move(aOther));
    mType = TUDPAddressInfo;
}

MOZ_IMPLICIT UDPSocketAddr::UDPSocketAddr(const NetAddr& aOther)
{
    new (mozilla::KnownNotNull, ptr_NetAddr()) NetAddr(aOther);
    mType = TNetAddr;
}

MOZ_IMPLICIT UDPSocketAddr::UDPSocketAddr(NetAddr&& aOther)
{
    new (mozilla::KnownNotNull, ptr_NetAddr()) NetAddr(std::move(aOther));
    mType = TNetAddr;
}

MOZ_IMPLICIT UDPSocketAddr::UDPSocketAddr(const UDPSocketAddr& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TUDPAddressInfo:
        {
            new (mozilla::KnownNotNull, ptr_UDPAddressInfo()) UDPAddressInfo((aOther).get_UDPAddressInfo());
            break;
        }
    case TNetAddr:
        {
            new (mozilla::KnownNotNull, ptr_NetAddr()) NetAddr((aOther).get_NetAddr());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT UDPSocketAddr::UDPSocketAddr(UDPSocketAddr&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TUDPAddressInfo:
        {
            new (mozilla::KnownNotNull, ptr_UDPAddressInfo()) UDPAddressInfo(std::move((aOther).get_UDPAddressInfo()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TNetAddr:
        {
            new (mozilla::KnownNotNull, ptr_NetAddr()) NetAddr(std::move((aOther).get_NetAddr()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

UDPSocketAddr::~UDPSocketAddr()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto UDPSocketAddr::operator=(const UDPAddressInfo& aRhs) -> UDPSocketAddr&
{
    if (MaybeDestroy(TUDPAddressInfo)) {
        new (mozilla::KnownNotNull, ptr_UDPAddressInfo()) UDPAddressInfo;
    }
    (*(ptr_UDPAddressInfo())) = aRhs;
    mType = TUDPAddressInfo;
    return (*(this));
}

auto UDPSocketAddr::operator=(UDPAddressInfo&& aRhs) -> UDPSocketAddr&
{
    if (MaybeDestroy(TUDPAddressInfo)) {
        new (mozilla::KnownNotNull, ptr_UDPAddressInfo()) UDPAddressInfo;
    }
    (*(ptr_UDPAddressInfo())) = std::move(aRhs);
    mType = TUDPAddressInfo;
    return (*(this));
}

auto UDPSocketAddr::operator=(const NetAddr& aRhs) -> UDPSocketAddr&
{
    if (MaybeDestroy(TNetAddr)) {
        new (mozilla::KnownNotNull, ptr_NetAddr()) NetAddr;
    }
    (*(ptr_NetAddr())) = aRhs;
    mType = TNetAddr;
    return (*(this));
}

auto UDPSocketAddr::operator=(NetAddr&& aRhs) -> UDPSocketAddr&
{
    if (MaybeDestroy(TNetAddr)) {
        new (mozilla::KnownNotNull, ptr_NetAddr()) NetAddr;
    }
    (*(ptr_NetAddr())) = std::move(aRhs);
    mType = TNetAddr;
    return (*(this));
}

auto UDPSocketAddr::operator=(const UDPSocketAddr& aRhs) -> UDPSocketAddr&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TUDPAddressInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_UDPAddressInfo()) UDPAddressInfo;
            }
            (*(ptr_UDPAddressInfo())) = (aRhs).get_UDPAddressInfo();
            break;
        }
    case TNetAddr:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_NetAddr()) NetAddr;
            }
            (*(ptr_NetAddr())) = (aRhs).get_NetAddr();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto UDPSocketAddr::operator=(UDPSocketAddr&& aRhs) -> UDPSocketAddr&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TUDPAddressInfo:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_UDPAddressInfo()) UDPAddressInfo;
            }
            (*(ptr_UDPAddressInfo())) = std::move((aRhs).get_UDPAddressInfo());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TNetAddr:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_NetAddr()) NetAddr;
            }
            (*(ptr_NetAddr())) = std::move((aRhs).get_NetAddr());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}


namespace mozilla {
namespace ipc {
auto IPDLParamTraits<UDPSocketAddr>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef UDPSocketAddr union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'UDPSocketAddr'
    (aMsg)->WriteSentinel(540280014);

    switch (type) {
    case union__::TUDPAddressInfo:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_UDPAddressInfo());
            // Sentinel = 'TUDPAddressInfo'
            (aMsg)->WriteSentinel(704185744);
            return;
        }
    case union__::TNetAddr:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_NetAddr());
            // Sentinel = 'TNetAddr'
            (aMsg)->WriteSentinel(215352055);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<UDPSocketAddr>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef UDPSocketAddr union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union UDPSocketAddr");
        return false;
    }
    // Sentinel = 'UDPSocketAddr'
    if ((!((aMsg)->ReadSentinel(aIter, 540280014)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union UDPSocketAddr");
        return false;
    }

    switch (type) {
    case union__::TUDPAddressInfo:
        {
            UDPAddressInfo tmp = UDPAddressInfo();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_UDPAddressInfo())))))) {
                aActor->FatalError("Error deserializing variant TUDPAddressInfo of union UDPSocketAddr");
                return false;
            }
            // Sentinel = 'TUDPAddressInfo'
            if ((!((aMsg)->ReadSentinel(aIter, 704185744)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TUDPAddressInfo of union UDPSocketAddr");
                return false;
            }
            return true;
        }
    case union__::TNetAddr:
        {
            mozilla::net::NetAddr tmp = mozilla::net::NetAddr();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_NetAddr())))))) {
                aActor->FatalError("Error deserializing variant TNetAddr of union UDPSocketAddr");
                return false;
            }
            // Sentinel = 'TNetAddr'
            if ((!((aMsg)->ReadSentinel(aIter, 215352055)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TNetAddr of union UDPSocketAddr");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union UDPData|
//
auto UDPData::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TArrayOfuint8_t:
        {
            (ptr_ArrayOfuint8_t())->~ArrayOfuint8_t__tdef();
            break;
        }
    case TIPCStream:
        {
            (ptr_IPCStream())->~IPCStream__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT UDPData::UDPData(const nsTArray<uint8_t>& aOther)
{
    new (mozilla::KnownNotNull, ptr_ArrayOfuint8_t()) nsTArray<uint8_t>((aOther).Clone());
    mType = TArrayOfuint8_t;
}

MOZ_IMPLICIT UDPData::UDPData(nsTArray<uint8_t>&& aOther)
{
    new (mozilla::KnownNotNull, ptr_ArrayOfuint8_t()) nsTArray<uint8_t>(std::move(aOther));
    mType = TArrayOfuint8_t;
}

MOZ_IMPLICIT UDPData::UDPData(const IPCStream& aOther)
{
    new (mozilla::KnownNotNull, ptr_IPCStream()) IPCStream(aOther);
    mType = TIPCStream;
}

MOZ_IMPLICIT UDPData::UDPData(IPCStream&& aOther)
{
    new (mozilla::KnownNotNull, ptr_IPCStream()) IPCStream(std::move(aOther));
    mType = TIPCStream;
}

MOZ_IMPLICIT UDPData::UDPData(const UDPData& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TArrayOfuint8_t:
        {
            new (mozilla::KnownNotNull, ptr_ArrayOfuint8_t()) nsTArray<uint8_t>(((aOther).get_ArrayOfuint8_t()).Clone());
            break;
        }
    case TIPCStream:
        {
            new (mozilla::KnownNotNull, ptr_IPCStream()) IPCStream((aOther).get_IPCStream());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT UDPData::UDPData(UDPData&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TArrayOfuint8_t:
        {
            new (mozilla::KnownNotNull, ptr_ArrayOfuint8_t()) nsTArray<uint8_t>(std::move((aOther).get_ArrayOfuint8_t()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TIPCStream:
        {
            new (mozilla::KnownNotNull, ptr_IPCStream()) IPCStream(std::move((aOther).get_IPCStream()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

UDPData::~UDPData()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto UDPData::operator=(const nsTArray<uint8_t>& aRhs) -> UDPData&
{
    if (MaybeDestroy(TArrayOfuint8_t)) {
        new (mozilla::KnownNotNull, ptr_ArrayOfuint8_t()) nsTArray<uint8_t>;
    }
    (*(ptr_ArrayOfuint8_t())) = (aRhs).Clone();
    mType = TArrayOfuint8_t;
    return (*(this));
}

auto UDPData::operator=(nsTArray<uint8_t>&& aRhs) -> UDPData&
{
    if (MaybeDestroy(TArrayOfuint8_t)) {
        new (mozilla::KnownNotNull, ptr_ArrayOfuint8_t()) nsTArray<uint8_t>;
    }
    (*(ptr_ArrayOfuint8_t())) = std::move(aRhs);
    mType = TArrayOfuint8_t;
    return (*(this));
}

auto UDPData::operator=(const IPCStream& aRhs) -> UDPData&
{
    if (MaybeDestroy(TIPCStream)) {
        new (mozilla::KnownNotNull, ptr_IPCStream()) IPCStream;
    }
    (*(ptr_IPCStream())) = aRhs;
    mType = TIPCStream;
    return (*(this));
}

auto UDPData::operator=(IPCStream&& aRhs) -> UDPData&
{
    if (MaybeDestroy(TIPCStream)) {
        new (mozilla::KnownNotNull, ptr_IPCStream()) IPCStream;
    }
    (*(ptr_IPCStream())) = std::move(aRhs);
    mType = TIPCStream;
    return (*(this));
}

auto UDPData::operator=(const UDPData& aRhs) -> UDPData&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TArrayOfuint8_t:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ArrayOfuint8_t()) nsTArray<uint8_t>;
            }
            (*(ptr_ArrayOfuint8_t())) = ((aRhs).get_ArrayOfuint8_t()).Clone();
            break;
        }
    case TIPCStream:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_IPCStream()) IPCStream;
            }
            (*(ptr_IPCStream())) = (aRhs).get_IPCStream();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto UDPData::operator=(UDPData&& aRhs) -> UDPData&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TArrayOfuint8_t:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ArrayOfuint8_t()) nsTArray<uint8_t>;
            }
            (*(ptr_ArrayOfuint8_t())) = std::move((aRhs).get_ArrayOfuint8_t());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TIPCStream:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_IPCStream()) IPCStream;
            }
            (*(ptr_IPCStream())) = std::move((aRhs).get_IPCStream());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}


namespace mozilla {
namespace ipc {
auto IPDLParamTraits<UDPData>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef UDPData union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'UDPData'
    (aMsg)->WriteSentinel(150864484);

    switch (type) {
    case union__::TArrayOfuint8_t:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_ArrayOfuint8_t());
            // Sentinel = 'TArrayOfuint8_t'
            (aMsg)->WriteSentinel(771753428);
            return;
        }
    case union__::TIPCStream:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_IPCStream());
            // Sentinel = 'TIPCStream'
            (aMsg)->WriteSentinel(311690141);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<UDPData>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef UDPData union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union UDPData");
        return false;
    }
    // Sentinel = 'UDPData'
    if ((!((aMsg)->ReadSentinel(aIter, 150864484)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union UDPData");
        return false;
    }

    switch (type) {
    case union__::TArrayOfuint8_t:
        {
            nsTArray<uint8_t> tmp;
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_ArrayOfuint8_t())))))) {
                aActor->FatalError("Error deserializing variant TArrayOfuint8_t of union UDPData");
                return false;
            }
            // Sentinel = 'TArrayOfuint8_t'
            if ((!((aMsg)->ReadSentinel(aIter, 771753428)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TArrayOfuint8_t of union UDPData");
                return false;
            }
            return true;
        }
    case union__::TIPCStream:
        {
            mozilla::ipc::IPCStream tmp = mozilla::ipc::IPCStream();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_IPCStream())))))) {
                aActor->FatalError("Error deserializing variant TIPCStream of union UDPData");
                return false;
            }
            // Sentinel = 'TIPCStream'
            if ((!((aMsg)->ReadSentinel(aIter, 311690141)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TIPCStream of union UDPData");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla
