//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/PBrowserParent.h"
#include "mozilla/dom/PBrowserChild.h"
#include "mozilla/ipc/PChildToParentStreamParent.h"
#include "mozilla/ipc/PChildToParentStreamChild.h"
#include "mozilla/ipc/PFileDescriptorSetParent.h"
#include "mozilla/ipc/PFileDescriptorSetChild.h"
#include "mozilla/ipc/PParentToChildStreamParent.h"
#include "mozilla/ipc/PParentToChildStreamChild.h"
#include "mozilla/PRemoteLazyInputStreamParent.h"
#include "mozilla/PRemoteLazyInputStreamChild.h"
#include "mozilla/dom/PFilePicker.h"
#include "mozilla/dom/PFilePickerParent.h"
#include "mozilla/dom/PFilePickerChild.h"

#include "ipc/IPCMessageUtils.h"
#include "nsIFile.h"
#include "mozilla/ipc/Endpoint.h"
#include "mozilla/ipc/ProtocolMessageUtils.h"
#include "mozilla/ipc/ProtocolUtils.h"
#include "mozilla/ipc/ShmemMessageUtils.h"
#include "mozilla/ipc/TaintingIPCUtils.h"

namespace mozilla {
namespace dom {
namespace PFilePicker {

nsresult
CreateEndpoints(
        base::ProcessId aParentDestPid,
        base::ProcessId aChildDestPid,
        mozilla::ipc::Endpoint<mozilla::dom::PFilePickerParent>* aParent,
        mozilla::ipc::Endpoint<mozilla::dom::PFilePickerChild>* aChild)
{
    return mozilla::ipc::CreateEndpoints(
        mozilla::ipc::PrivateIPDLInterface(),
        aParentDestPid, aChildDestPid,
        aParent, aChild);
}
IPC::Message*
Msg_Open(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg_Open__ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Msg___delete__(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Msg___delete____ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::NOT_REPLY));
}
IPC::Message*
Reply___delete__(int32_t routingId)
{
    return IPC::Message::IPDLMessage(routingId, Reply___delete____ID, IPC::Message::HeaderFlags(IPC::Message::NOT_NESTED, IPC::Message::NORMAL_PRIORITY, IPC::Message::COMPRESSION_NONE, IPC::Message::NOT_CONSTRUCTOR, IPC::Message::ASYNC, IPC::Message::NOT_INTERRUPT, IPC::Message::REPLY));
}

} // namespace PFilePicker
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct InputBlobs|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::InputBlobs>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).blobs());
    // Sentinel = 'blobs'
    (aMsg)->WriteSentinel(102957587);
}

auto IPDLParamTraits<mozilla::dom::InputBlobs>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->blobs())))))) {
        aActor->FatalError("Error deserializing 'blobs' (IPCBlob[]) member of 'InputBlobs'");
        return false;
    }
    // Sentinel = 'blobs'
    if ((!((aMsg)->ReadSentinel(aIter, 102957587)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'blobs' (IPCBlob[]) member of 'InputBlobs'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct InputDirectory|
//
namespace mozilla {
namespace dom {
} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::InputDirectory>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    WriteIPDLParam(aMsg, aActor, (aVar).directoryPath());
    // Sentinel = 'directoryPath'
    (aMsg)->WriteSentinel(633668963);
}

auto IPDLParamTraits<mozilla::dom::InputDirectory>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->directoryPath())))))) {
        aActor->FatalError("Error deserializing 'directoryPath' (nsString) member of 'InputDirectory'");
        return false;
    }
    // Sentinel = 'directoryPath'
    if ((!((aMsg)->ReadSentinel(aIter, 633668963)))) {
        mozilla::ipc::SentinelReadError("Error deserializing 'directoryPath' (nsString) member of 'InputDirectory'");
        return false;
    }
    return true;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union MaybeInputData|
//
namespace mozilla {
namespace dom {
auto MaybeInputData::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TInputBlobs:
        {
            (ptr_InputBlobs())->~InputBlobs__tdef();
            break;
        }
    case TInputDirectory:
        {
            (ptr_InputDirectory())->~InputDirectory__tdef();
            break;
        }
    case Tvoid_t:
        {
            (ptr_void_t())->~void_t__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT MaybeInputData::MaybeInputData(const InputBlobs& aOther)
{
    new (mozilla::KnownNotNull, ptr_InputBlobs()) InputBlobs(aOther);
    mType = TInputBlobs;
}

MOZ_IMPLICIT MaybeInputData::MaybeInputData(InputBlobs&& aOther)
{
    new (mozilla::KnownNotNull, ptr_InputBlobs()) InputBlobs(std::move(aOther));
    mType = TInputBlobs;
}

MOZ_IMPLICIT MaybeInputData::MaybeInputData(const InputDirectory& aOther)
{
    new (mozilla::KnownNotNull, ptr_InputDirectory()) InputDirectory(aOther);
    mType = TInputDirectory;
}

MOZ_IMPLICIT MaybeInputData::MaybeInputData(InputDirectory&& aOther)
{
    new (mozilla::KnownNotNull, ptr_InputDirectory()) InputDirectory(std::move(aOther));
    mType = TInputDirectory;
}

MOZ_IMPLICIT MaybeInputData::MaybeInputData(const void_t& aOther)
{
    new (mozilla::KnownNotNull, ptr_void_t()) void_t(aOther);
    mType = Tvoid_t;
}

MOZ_IMPLICIT MaybeInputData::MaybeInputData(void_t&& aOther)
{
    new (mozilla::KnownNotNull, ptr_void_t()) void_t(std::move(aOther));
    mType = Tvoid_t;
}

MOZ_IMPLICIT MaybeInputData::MaybeInputData(const MaybeInputData& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TInputBlobs:
        {
            new (mozilla::KnownNotNull, ptr_InputBlobs()) InputBlobs((aOther).get_InputBlobs());
            break;
        }
    case TInputDirectory:
        {
            new (mozilla::KnownNotNull, ptr_InputDirectory()) InputDirectory((aOther).get_InputDirectory());
            break;
        }
    case Tvoid_t:
        {
            new (mozilla::KnownNotNull, ptr_void_t()) void_t((aOther).get_void_t());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

MOZ_IMPLICIT MaybeInputData::MaybeInputData(MaybeInputData&& aOther)
{
    (aOther).AssertSanity();
    Type t = (aOther).type();
    switch (t) {
    case TInputBlobs:
        {
            new (mozilla::KnownNotNull, ptr_InputBlobs()) InputBlobs(std::move((aOther).get_InputBlobs()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case TInputDirectory:
        {
            new (mozilla::KnownNotNull, ptr_InputDirectory()) InputDirectory(std::move((aOther).get_InputDirectory()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case Tvoid_t:
        {
            new (mozilla::KnownNotNull, ptr_void_t()) void_t(std::move((aOther).get_void_t()));
            static_cast<void>((aOther).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    (aOther).mType = T__None;
    mType = t;
}

MaybeInputData::~MaybeInputData()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto MaybeInputData::operator=(const InputBlobs& aRhs) -> MaybeInputData&
{
    if (MaybeDestroy(TInputBlobs)) {
        new (mozilla::KnownNotNull, ptr_InputBlobs()) InputBlobs;
    }
    (*(ptr_InputBlobs())) = aRhs;
    mType = TInputBlobs;
    return (*(this));
}

auto MaybeInputData::operator=(InputBlobs&& aRhs) -> MaybeInputData&
{
    if (MaybeDestroy(TInputBlobs)) {
        new (mozilla::KnownNotNull, ptr_InputBlobs()) InputBlobs;
    }
    (*(ptr_InputBlobs())) = std::move(aRhs);
    mType = TInputBlobs;
    return (*(this));
}

auto MaybeInputData::operator=(const InputDirectory& aRhs) -> MaybeInputData&
{
    if (MaybeDestroy(TInputDirectory)) {
        new (mozilla::KnownNotNull, ptr_InputDirectory()) InputDirectory;
    }
    (*(ptr_InputDirectory())) = aRhs;
    mType = TInputDirectory;
    return (*(this));
}

auto MaybeInputData::operator=(InputDirectory&& aRhs) -> MaybeInputData&
{
    if (MaybeDestroy(TInputDirectory)) {
        new (mozilla::KnownNotNull, ptr_InputDirectory()) InputDirectory;
    }
    (*(ptr_InputDirectory())) = std::move(aRhs);
    mType = TInputDirectory;
    return (*(this));
}

auto MaybeInputData::operator=(const void_t& aRhs) -> MaybeInputData&
{
    if (MaybeDestroy(Tvoid_t)) {
        new (mozilla::KnownNotNull, ptr_void_t()) void_t;
    }
    (*(ptr_void_t())) = aRhs;
    mType = Tvoid_t;
    return (*(this));
}

auto MaybeInputData::operator=(void_t&& aRhs) -> MaybeInputData&
{
    if (MaybeDestroy(Tvoid_t)) {
        new (mozilla::KnownNotNull, ptr_void_t()) void_t;
    }
    (*(ptr_void_t())) = std::move(aRhs);
    mType = Tvoid_t;
    return (*(this));
}

auto MaybeInputData::operator=(const MaybeInputData& aRhs) -> MaybeInputData&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TInputBlobs:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_InputBlobs()) InputBlobs;
            }
            (*(ptr_InputBlobs())) = (aRhs).get_InputBlobs();
            break;
        }
    case TInputDirectory:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_InputDirectory()) InputDirectory;
            }
            (*(ptr_InputDirectory())) = (aRhs).get_InputDirectory();
            break;
        }
    case Tvoid_t:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_void_t()) void_t;
            }
            (*(ptr_void_t())) = (aRhs).get_void_t();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto MaybeInputData::operator=(MaybeInputData&& aRhs) -> MaybeInputData&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TInputBlobs:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_InputBlobs()) InputBlobs;
            }
            (*(ptr_InputBlobs())) = std::move((aRhs).get_InputBlobs());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case TInputDirectory:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_InputDirectory()) InputDirectory;
            }
            (*(ptr_InputDirectory())) = std::move((aRhs).get_InputDirectory());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case Tvoid_t:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_void_t()) void_t;
            }
            (*(ptr_void_t())) = std::move((aRhs).get_void_t());
            static_cast<void>((aRhs).MaybeDestroy(T__None));
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    (aRhs).mType = T__None;
    mType = t;
    return (*(this));
}

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace ipc {
auto IPDLParamTraits<mozilla::dom::MaybeInputData>::Write(
        IPC::Message* aMsg,
        mozilla::ipc::IProtocol* aActor,
        const paramType& aVar) -> void
{
    typedef mozilla::dom::MaybeInputData union__;
    int type = (aVar).type();
    WriteIPDLParam(aMsg, aActor, type);
    // Sentinel = 'MaybeInputData'
    (aMsg)->WriteSentinel(680789369);

    switch (type) {
    case union__::TInputBlobs:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_InputBlobs());
            // Sentinel = 'TInputBlobs'
            (aMsg)->WriteSentinel(424150103);
            return;
        }
    case union__::TInputDirectory:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_InputDirectory());
            // Sentinel = 'TInputDirectory'
            (aMsg)->WriteSentinel(787416602);
            return;
        }
    case union__::Tvoid_t:
        {
            WriteIPDLParam(aMsg, aActor, (aVar).get_void_t());
            // Sentinel = 'Tvoid_t'
            (aMsg)->WriteSentinel(189006554);
            return;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return;
        }
    }
}

auto IPDLParamTraits<mozilla::dom::MaybeInputData>::Read(
        const IPC::Message* aMsg,
        PickleIterator* aIter,
        mozilla::ipc::IProtocol* aActor,
        paramType* aVar) -> bool
{
    typedef mozilla::dom::MaybeInputData union__;
    int type = 0;
    if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&(type)))))) {
        aActor->FatalError("Error deserializing type of union MaybeInputData");
        return false;
    }
    // Sentinel = 'MaybeInputData'
    if ((!((aMsg)->ReadSentinel(aIter, 680789369)))) {
        mozilla::ipc::SentinelReadError("Error deserializing type of union MaybeInputData");
        return false;
    }

    switch (type) {
    case union__::TInputBlobs:
        {
            mozilla::dom::InputBlobs tmp = mozilla::dom::InputBlobs();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_InputBlobs())))))) {
                aActor->FatalError("Error deserializing variant TInputBlobs of union MaybeInputData");
                return false;
            }
            // Sentinel = 'TInputBlobs'
            if ((!((aMsg)->ReadSentinel(aIter, 424150103)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TInputBlobs of union MaybeInputData");
                return false;
            }
            return true;
        }
    case union__::TInputDirectory:
        {
            mozilla::dom::InputDirectory tmp = mozilla::dom::InputDirectory();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_InputDirectory())))))) {
                aActor->FatalError("Error deserializing variant TInputDirectory of union MaybeInputData");
                return false;
            }
            // Sentinel = 'TInputDirectory'
            if ((!((aMsg)->ReadSentinel(aIter, 787416602)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant TInputDirectory of union MaybeInputData");
                return false;
            }
            return true;
        }
    case union__::Tvoid_t:
        {
            mozilla::void_t tmp = mozilla::void_t();
            (*(aVar)) = std::move(tmp);
            if ((!(ReadIPDLParam(aMsg, aIter, aActor, (&((aVar)->get_void_t())))))) {
                aActor->FatalError("Error deserializing variant Tvoid_t of union MaybeInputData");
                return false;
            }
            // Sentinel = 'Tvoid_t'
            if ((!((aMsg)->ReadSentinel(aIter, 189006554)))) {
                mozilla::ipc::SentinelReadError("Error deserializing variant Tvoid_t of union MaybeInputData");
                return false;
            }
            return true;
        }
    default:
        {
            aActor->FatalError("unknown union type");
            return false;
        }
    }
}

} // namespace ipc
} // namespace mozilla
