/* THIS FILE IS AUTOGENERATED FROM TestCodeGen.webidl BY Codegen.py - DO NOT EDIT */

#ifndef mozilla_dom_TestCodeGenBinding_h
#define mozilla_dom_TestCodeGenBinding_h

#include "CustomEventBinding.h"
#include "TestBindingHeader.h"
#include "TestDictionaryBinding.h"
#include "js/RootingAPI.h"
#include "js/TypeDecls.h"
#include "mozilla/ArrayUtils.h"
#include "mozilla/ErrorResult.h"
#include "mozilla/Span.h"
#include "mozilla/dom/BindingDeclarations.h"
#include "mozilla/dom/CallbackFunction.h"
#include "mozilla/dom/CallbackInterface.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/Promise.h"
#include "mozilla/dom/PrototypeList.h"
#include "mozilla/dom/Record.h"
#include "mozilla/dom/RootedDictionary.h"
#include "mozilla/dom/ToJSValue.h"
#include "mozilla/dom/TypedArray.h"
#include "mozilla/dom/UnionTypes.h"

class nsRenamedInterface;
struct nsRenamedInterfaceAtoms;

namespace mozilla {
namespace dom {

struct CustomEventInit;
struct Dict;
struct DictAtoms;
struct DictContainingDict;
struct DictContainingDictAtoms;
struct DictContainingSequence;
struct DictContainingSequenceAtoms;
struct DictForConstructorAtoms;
struct DictWithAllowSharedMembersAtoms;
struct DictWithConditionalMembersAtoms;
class FloatOrString;
struct NativePropertyHooks;
class ObjectOrLong;
class OnlyForUseInConstructor;
struct OnlyForUseInConstructorAtoms;
class OwningFloatOrString;
class OwningObjectOrLong;
struct ParentDictAtoms;
class Promise;
class ProtoAndIfaceCache;
struct TestAttributesOnDictionaryMembersAtoms;
class TestAttributesOnTypes;
struct TestAttributesOnTypesAtoms;
class TestBooleanConstruction;
class TestBooleanReturn;
class TestCEReactionsInterface;
struct TestCEReactionsInterfaceAtoms;
class TestCallback;
class TestCallbackConstruction;
class TestCallbackInterface;
struct TestCallbackInterfaceAtoms;
class TestCallbackInterfaceConstruction;
class TestCallbackInterfaceReturn;
class TestCallbackReturn;
class TestChildInterface;
struct TestChildInterfaceAtoms;
class TestConstructorForFuncInterface;
struct TestConstructorForFuncInterfaceAtoms;
class TestConstructorForPrefInterface;
struct TestConstructorForPrefInterfaceAtoms;
class TestConstructorForSCInterface;
struct TestConstructorForSCInterfaceAtoms;
class TestCppKeywordNamedMethodsInterface;
struct TestCppKeywordNamedMethodsInterfaceAtoms;
class TestDeprecatedInterface;
struct TestDeprecatedInterfaceAtoms;
class TestEnumConstruction;
class TestEnumReturn;
class TestExternalInterface;
class TestExternalInterfaceConstruction;
class TestExternalInterfaceReturn;
class TestFloatConstruction;
class TestFloatReturn;
class TestFuncConstructorForDifferentFuncInterface;
struct TestFuncConstructorForDifferentFuncInterfaceAtoms;
class TestFuncConstructorForInterface;
struct TestFuncConstructorForInterfaceAtoms;
class TestHTMLConstructorInterface;
struct TestHTMLConstructorInterfaceAtoms;
class TestIndexedAndNamedGetterAndSetterInterface;
struct TestIndexedAndNamedGetterAndSetterInterfaceAtoms;
class TestIndexedAndNamedGetterInterface;
struct TestIndexedAndNamedGetterInterfaceAtoms;
class TestIndexedAndNamedSetterInterface;
struct TestIndexedAndNamedSetterInterfaceAtoms;
class TestIndexedGetterAndSetterAndNamedGetterInterface;
struct TestIndexedGetterAndSetterAndNamedGetterInterfaceAtoms;
class TestIndexedGetterInterface;
struct TestIndexedGetterInterfaceAtoms;
class TestIndexedSetterInterface;
struct TestIndexedSetterInterfaceAtoms;
class TestIntegerArguments;
class TestIntegerConstruction;
class TestIntegerReturn;
class TestInterface;
class TestInterfaceArguments;
struct TestInterfaceAtoms;
class TestInterfaceConstruction;
class TestInterfaceReturn;
class TestInterfaceWithPromiseConstructorArg;
struct TestInterfaceWithPromiseConstructorArgAtoms;
class TestNamedDeleterInterface;
struct TestNamedDeleterInterfaceAtoms;
class TestNamedDeleterWithRetvalInterface;
struct TestNamedDeleterWithRetvalInterfaceAtoms;
class TestNamedGetterInterface;
struct TestNamedGetterInterfaceAtoms;
class TestNamedSetterInterface;
struct TestNamedSetterInterfaceAtoms;
class TestNamespace;
struct TestNamespaceAtoms;
class TestNonWrapperCacheInterface;
struct TestNonWrapperCacheInterfaceAtoms;
class TestNullableCallbackInterfaceReturn;
class TestNullableCallbackReturn;
class TestNullableExternalInterfaceReturn;
class TestNullableIntegerReturn;
class TestNullableInterfaceReturn;
class TestNullableObjectReturn;
class TestNullableSequenceReturn;
class TestNullableTypedArrayReturn;
class TestObjectArguments;
class TestObjectConstruction;
class TestObjectReturn;
class TestOptionalArguments;
class TestParentInterface;
struct TestParentInterfaceAtoms;
class TestPrefChromeOnlySCFuncConstructorForInterface;
struct TestPrefChromeOnlySCFuncConstructorForInterfaceAtoms;
class TestPrefConstructorForDifferentPrefInterface;
struct TestPrefConstructorForDifferentPrefInterfaceAtoms;
class TestPrefConstructorForInterface;
struct TestPrefConstructorForInterfaceAtoms;
class TestProtoObjectHackedNamespace;
struct TestProtoObjectHackedNamespaceAtoms;
class TestRenamedNamespace;
struct TestRenamedNamespaceAtoms;
class TestSCConstructorForInterface;
struct TestSCConstructorForInterfaceAtoms;
class TestSecureContextInterface;
struct TestSecureContextInterfaceAtoms;
class TestSequenceConstruction;
class TestSequenceReturn;
class TestSingleOperationCallbackInterface;
struct TestSingleOperationCallbackInterfaceAtoms;
class TestStringConstruction;
class TestStringEnumArguments;
class TestStringReturn;
class TestThrowingConstructorInterface;
struct TestThrowingConstructorInterfaceAtoms;
class TestTreatAsNullCallback;
class TestTypedArrayConstruction;
class TestTypedArrayReturn;
class TestVoidConstruction;
class TestWorkerExposedInterface;
struct TestWorkerExposedInterfaceAtoms;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

enum class TestEnum : uint8_t {
  _1,
  A,
  B,
  _1_2,
  _2d_array,
  EndGuard_
};

namespace TestEnumValues {
extern const EnumEntry strings[6];

static constexpr size_t Count = 5;

// Our "strings" contains an extra entry with a null string.
static_assert(mozilla::ArrayLength(strings) - 1 == Count,
              "Mismatch between enum strings and enum count");

static_assert(static_cast<size_t>(TestEnum::EndGuard_) == Count,
              "Mismatch between enum value and enum count");

inline auto GetString(TestEnum stringId) {
  MOZ_ASSERT(static_cast<uint8_t>(stringId) < Count);
  const EnumEntry& entry = strings[static_cast<uint8_t>(stringId)];
  return Span<const char>{entry.value, entry.length};
}
} // namespace TestEnumValues

bool
ToJSValue(JSContext* aCx, TestEnum aArgument, JS::MutableHandle<JS::Value> aValue);


struct DictContainingSequence : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<int32_t>> mOurSequence;
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<OwningFloatOrString>> mOurSequence10;
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<OwningNonNull<mozilla::dom::TestInterface>>> mOurSequence2;
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<JS::Value>> mOurSequence3;
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<JSObject*>> mOurSequence4;
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<JSObject*>> mOurSequence5;
  MOZ_INIT_OUTSIDE_CTOR Optional<Nullable<Sequence<JSObject*>>> mOurSequence6;
  MOZ_INIT_OUTSIDE_CTOR Optional<Nullable<Sequence<JSObject*>>> mOurSequence7;
  MOZ_INIT_OUTSIDE_CTOR Nullable<Sequence<JSObject*>> mOurSequence8;
  MOZ_INIT_OUTSIDE_CTOR Nullable<Sequence<JSObject*>> mOurSequence9;

  DictContainingSequence();

  explicit inline DictContainingSequence(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  DictContainingSequence(const DictContainingSequence&) = delete;
  DictContainingSequence& operator=(const DictContainingSequence&) = delete;

  static bool
  InitIds(JSContext* cx, DictContainingSequenceAtoms* atomsCache);

public:
  bool
  Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  inline void
  TraverseForCC(nsCycleCollectionTraversalCallback& aCallback, uint32_t aFlags)
  {
    ImplCycleCollectionTraverse(aCallback, mOurSequence2, "mOurSequence2", aFlags);
  }

  inline void
  UnlinkForCC()
  {
    ImplCycleCollectionUnlink(mOurSequence2);
  }
};

namespace binding_detail {
struct FastDictContainingSequence : public DictContainingSequence
{
  inline FastDictContainingSequence()
    : DictContainingSequence(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct DictWithAllowSharedMembers : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR Optional<ArrayBufferView> mA;
  MOZ_INIT_OUTSIDE_CTOR Optional<Nullable<ArrayBufferView>> mB;
  MOZ_INIT_OUTSIDE_CTOR Optional<ArrayBuffer> mC;
  MOZ_INIT_OUTSIDE_CTOR Optional<Nullable<ArrayBuffer>> mD;
  MOZ_INIT_OUTSIDE_CTOR Optional<ArrayBufferView> mE;
  MOZ_INIT_OUTSIDE_CTOR Optional<ArrayBufferView> mF;

  DictWithAllowSharedMembers();

  explicit inline DictWithAllowSharedMembers(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  DictWithAllowSharedMembers(const DictWithAllowSharedMembers&) = delete;
  DictWithAllowSharedMembers& operator=(const DictWithAllowSharedMembers&) = delete;

  static bool
  InitIds(JSContext* cx, DictWithAllowSharedMembersAtoms* atomsCache);

public:
  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  void
  TraceDictionary(JSTracer* trc);
};

namespace binding_detail {
struct FastDictWithAllowSharedMembers : public DictWithAllowSharedMembers
{
  inline FastDictWithAllowSharedMembers()
    : DictWithAllowSharedMembers(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct DictWithConditionalMembers : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR Optional<int32_t> mChromeOnlyFuncAndPrefControlledMember;
  MOZ_INIT_OUTSIDE_CTOR Optional<int32_t> mChromeOnlyFuncControlledMember;
  MOZ_INIT_OUTSIDE_CTOR Optional<int32_t> mChromeOnlyMember;
  MOZ_INIT_OUTSIDE_CTOR Optional<int32_t> mFuncControlledMember;
  MOZ_INIT_OUTSIDE_CTOR Optional<int32_t> mPrefControlledMember;

  DictWithConditionalMembers();

  explicit inline DictWithConditionalMembers(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline DictWithConditionalMembers(const DictWithConditionalMembers& aOther)
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  void
  TraceDictionary(JSTracer* trc);

  DictWithConditionalMembers&
  operator=(const DictWithConditionalMembers& aOther);

  bool
  operator==(const DictWithConditionalMembers& aOther) const;

private:
  static bool
  InitIds(JSContext* cx, DictWithConditionalMembersAtoms* atomsCache);
};

namespace binding_detail {
struct FastDictWithConditionalMembers : public DictWithConditionalMembers
{
  inline FastDictWithConditionalMembers()
    : DictWithConditionalMembers(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct ParentDict : public GrandparentDict
{
  MOZ_INIT_OUTSIDE_CTOR int32_t mC;
  MOZ_INIT_OUTSIDE_CTOR JS::Value mParentAny;
  MOZ_INIT_OUTSIDE_CTOR Optional<RefPtr<mozilla::dom::TestExternalInterface>> mSomeExternalInterface;
  MOZ_INIT_OUTSIDE_CTOR Optional<OwningNonNull<mozilla::dom::TestInterface>> mSomeInterface;
  MOZ_INIT_OUTSIDE_CTOR RefPtr<mozilla::dom::TestInterface> mSomeNullableInterface;

  ParentDict();

  explicit inline ParentDict(const FastDictionaryInitializer& )
    : GrandparentDict(FastDictionaryInitializer())
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  ParentDict(const ParentDict&) = delete;
  ParentDict& operator=(const ParentDict&) = delete;

  static bool
  InitIds(JSContext* cx, ParentDictAtoms* atomsCache);

public:
  bool
  Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  inline void
  TraverseForCC(nsCycleCollectionTraversalCallback& aCallback, uint32_t aFlags)
  {
    ImplCycleCollectionTraverse(aCallback, mSomeExternalInterface, "mSomeExternalInterface", aFlags);
    ImplCycleCollectionTraverse(aCallback, mSomeInterface, "mSomeInterface", aFlags);
    ImplCycleCollectionTraverse(aCallback, mSomeNullableInterface, "mSomeNullableInterface", aFlags);
  }

  inline void
  UnlinkForCC()
  {
    ImplCycleCollectionUnlink(mSomeExternalInterface);
    ImplCycleCollectionUnlink(mSomeInterface);
    ImplCycleCollectionUnlink(mSomeNullableInterface);
  }
};

namespace binding_detail {
struct FastParentDict : public ParentDict
{
  inline FastParentDict()
    : ParentDict(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct TestAttributesOnDictionaryMembers : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR Optional<uint8_t> mA;
  MOZ_INIT_OUTSIDE_CTOR Optional<uint8_t> mB;
  MOZ_INIT_OUTSIDE_CTOR uint8_t mC;
  MOZ_INIT_OUTSIDE_CTOR Optional<uint8_t> mD;

  TestAttributesOnDictionaryMembers();

  explicit inline TestAttributesOnDictionaryMembers(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

  explicit inline TestAttributesOnDictionaryMembers(const TestAttributesOnDictionaryMembers& aOther)
  {
    *this = aOther;
  }

  bool
  Init(const char* sourceDescription = "Value", bool passedToJSImpl = false);

  void
  TraceDictionary(JSTracer* trc);

  TestAttributesOnDictionaryMembers&
  operator=(const TestAttributesOnDictionaryMembers& aOther);

  bool
  operator==(const TestAttributesOnDictionaryMembers& aOther) const;

private:
  static bool
  InitIds(JSContext* cx, TestAttributesOnDictionaryMembersAtoms* atomsCache);
};

namespace binding_detail {
struct FastTestAttributesOnDictionaryMembers : public TestAttributesOnDictionaryMembers
{
  inline FastTestAttributesOnDictionaryMembers()
    : TestAttributesOnDictionaryMembers(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct Dict : public ParentDict
{
  MOZ_INIT_OUTSIDE_CTOR Optional<int32_t> mA;
  MOZ_INIT_OUTSIDE_CTOR JS::Value mAnotherAny;
  MOZ_INIT_OUTSIDE_CTOR JSObject* mAnotherObj;
  MOZ_INIT_OUTSIDE_CTOR Optional<ArrayBuffer> mArrayBuffer;
  MOZ_INIT_OUTSIDE_CTOR int32_t mB;
  MOZ_INIT_OUTSIDE_CTOR Optional<nsCString> mByteStr;
  MOZ_INIT_OUTSIDE_CTOR Optional<Record<nsCString, int32_t>> mByteStringRecord;
  MOZ_INIT_OUTSIDE_CTOR Optional<uint32_t> mClampedUnsignedLong;
  MOZ_INIT_OUTSIDE_CTOR Optional<CustomEventInit> mCustomEventInit;
  MOZ_INIT_OUTSIDE_CTOR Optional<int32_t> mDashed_name;
  MOZ_INIT_OUTSIDE_CTOR Optional<CustomEventInit> mDictionaryTypedef;
  MOZ_INIT_OUTSIDE_CTOR nsString mEmpty;
  MOZ_INIT_OUTSIDE_CTOR nsCString mEmptyByteStr;
  MOZ_INIT_OUTSIDE_CTOR Optional<uint32_t> mEnforcedUnsignedLong;
  MOZ_INIT_OUTSIDE_CTOR Nullable<Float64Array> mFloat64Array;
  MOZ_INIT_OUTSIDE_CTOR OwningFloatOrString mFloatOrString;
  MOZ_INIT_OUTSIDE_CTOR double mInfUrDouble;
  MOZ_INIT_OUTSIDE_CTOR float mInfUrFloat;
  MOZ_INIT_OUTSIDE_CTOR double mNanUrDouble;
  MOZ_INIT_OUTSIDE_CTOR float mNanUrFloat;
  MOZ_INIT_OUTSIDE_CTOR double mNegativeInfUrDouble;
  MOZ_INIT_OUTSIDE_CTOR float mNegativeInfUrFloat;
  MOZ_INIT_OUTSIDE_CTOR Optional<Nullable<ArrayBuffer>> mNullableArrayBuffer;
  MOZ_INIT_OUTSIDE_CTOR Nullable<Record<nsCString, int32_t>> mNullableByteStringRecordWithDefault;
  MOZ_INIT_OUTSIDE_CTOR Nullable<OwningFloatOrString > mNullableFloatOrString;
  MOZ_INIT_OUTSIDE_CTOR Optional<Nullable<Record<nsString, int32_t>>> mNullableRecord;
  MOZ_INIT_OUTSIDE_CTOR Nullable<Record<nsString, nsString>> mNullableRecordWithDefault;
  MOZ_INIT_OUTSIDE_CTOR Nullable<Record<nsString, int32_t>> mNullableUSVStringRecordWithDefault;
  MOZ_INIT_OUTSIDE_CTOR Nullable<Record<nsCString, int32_t>> mNullableUTF8StringRecordWithDefault;
  MOZ_INIT_OUTSIDE_CTOR Optional<OwningObjectOrLong> mObjectOrLong;
  MOZ_INIT_OUTSIDE_CTOR nsCString mOtherByteStr;
  MOZ_INIT_OUTSIDE_CTOR TestEnum mOtherEnum;
  MOZ_INIT_OUTSIDE_CTOR nsString mOtherStr;
  MOZ_INIT_OUTSIDE_CTOR Optional<OwningNonNull<Promise>> mPromise;
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<OwningNonNull<Promise>>> mPromiseSequence;
  MOZ_INIT_OUTSIDE_CTOR Optional<bool> mPrototype;
  MOZ_INIT_OUTSIDE_CTOR Optional<Record<nsString, int32_t>> mRecordMember;
  MOZ_INIT_OUTSIDE_CTOR Record<nsCString, OwningNonNull<mozilla::dom::TestInterface>> mRequiredByteRecord;
  MOZ_INIT_OUTSIDE_CTOR int32_t mRequiredLong;
  MOZ_INIT_OUTSIDE_CTOR JSObject* mRequiredObject;
  MOZ_INIT_OUTSIDE_CTOR Record<nsString, OwningNonNull<mozilla::dom::TestInterface>> mRequiredRecord;
  MOZ_INIT_OUTSIDE_CTOR Record<nsString, OwningNonNull<mozilla::dom::TestInterface>> mRequiredUSVRecord;
  MOZ_INIT_OUTSIDE_CTOR Record<nsCString, OwningNonNull<mozilla::dom::TestInterface>> mRequiredUTF8Record;
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<int32_t>> mSeq1;
  MOZ_INIT_OUTSIDE_CTOR Sequence<int32_t> mSeq2;
  MOZ_INIT_OUTSIDE_CTOR Optional<Nullable<Sequence<int32_t>>> mSeq3;
  MOZ_INIT_OUTSIDE_CTOR Nullable<Sequence<int32_t>> mSeq4;
  MOZ_INIT_OUTSIDE_CTOR Nullable<Sequence<int32_t>> mSeq5;
  MOZ_INIT_OUTSIDE_CTOR JS::Value mSomeAny;
  MOZ_INIT_OUTSIDE_CTOR RefPtr<TestCallback> mSomeCallback;
  MOZ_INIT_OUTSIDE_CTOR Optional<TestEnum> mSomeEnum;
  MOZ_INIT_OUTSIDE_CTOR Optional<JSObject*> mSomeObj;
  MOZ_INIT_OUTSIDE_CTOR Optional<nsString> mStr;
  MOZ_INIT_OUTSIDE_CTOR Optional<nsString> mTemplate;
  MOZ_INIT_OUTSIDE_CTOR Optional<Uint8Array> mUint8Array;
  MOZ_INIT_OUTSIDE_CTOR double mUrDouble;
  MOZ_INIT_OUTSIDE_CTOR double mUrDouble2;
  MOZ_INIT_OUTSIDE_CTOR double mUrDouble3;
  MOZ_INIT_OUTSIDE_CTOR Nullable<double> mUrDouble4;
  MOZ_INIT_OUTSIDE_CTOR float mUrFloat;
  MOZ_INIT_OUTSIDE_CTOR float mUrFloat2;
  MOZ_INIT_OUTSIDE_CTOR float mUrFloat3;
  MOZ_INIT_OUTSIDE_CTOR Nullable<float> mUrFloat4;
  MOZ_INIT_OUTSIDE_CTOR Optional<Record<nsString, int32_t>> mUsvStringRecord;
  MOZ_INIT_OUTSIDE_CTOR Optional<Record<nsCString, int32_t>> mUtf8StringRecord;
  MOZ_INIT_OUTSIDE_CTOR Optional<int32_t> mX;
  MOZ_INIT_OUTSIDE_CTOR nsString mYetAnotherStr;
  MOZ_INIT_OUTSIDE_CTOR int32_t mZ;

  Dict();

  explicit inline Dict(const FastDictionaryInitializer& )
    : ParentDict(FastDictionaryInitializer()),
      mAnotherObj(nullptr),
      mRequiredObject(nullptr)
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  Dict(const Dict&) = delete;
  Dict& operator=(const Dict&) = delete;

  static bool
  InitIds(JSContext* cx, DictAtoms* atomsCache);

public:
  bool
  Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);
};

namespace binding_detail {
struct FastDict : public Dict
{
  inline FastDict()
    : Dict(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct DictContainingDict : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR Optional<Dict> mMemberDict;

  DictContainingDict();

  explicit inline DictContainingDict(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  DictContainingDict(const DictContainingDict&) = delete;
  DictContainingDict& operator=(const DictContainingDict&) = delete;

  static bool
  InitIds(JSContext* cx, DictContainingDictAtoms* atomsCache);

public:
  bool
  Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  inline void
  TraverseForCC(nsCycleCollectionTraversalCallback& aCallback, uint32_t aFlags)
  {
    ImplCycleCollectionTraverse(aCallback, mMemberDict, "mMemberDict", aFlags);
  }

  inline void
  UnlinkForCC()
  {
    ImplCycleCollectionUnlink(mMemberDict);
  }
};

namespace binding_detail {
struct FastDictContainingDict : public DictContainingDict
{
  inline FastDictContainingDict()
    : DictContainingDict(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


struct DictForConstructor : public DictionaryBase
{
  MOZ_INIT_OUTSIDE_CTOR JS::Value mAny1;
  MOZ_INIT_OUTSIDE_CTOR Optional<Dict> mDict;
  MOZ_INIT_OUTSIDE_CTOR Optional<DictContainingDict> mDict2;
  MOZ_INIT_OUTSIDE_CTOR Optional<JSObject*> mObj1;
  MOZ_INIT_OUTSIDE_CTOR Optional<JSObject*> mObj2;
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<Dict>> mSeq1;
  MOZ_INIT_OUTSIDE_CTOR Optional<Nullable<Sequence<Sequence<Dict>>>> mSeq2;
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<Nullable<Sequence<Dict>>>> mSeq3;
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<JS::Value>> mSeq4;
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<JS::Value>> mSeq5;
  MOZ_INIT_OUTSIDE_CTOR Optional<Sequence<DictContainingSequence>> mSeq6;

  DictForConstructor();

  explicit inline DictForConstructor(const FastDictionaryInitializer& )
  {
    // Do nothing here; this is used by our "Fast" subclass
  }

private:
  DictForConstructor(const DictForConstructor&) = delete;
  DictForConstructor& operator=(const DictForConstructor&) = delete;

  static bool
  InitIds(JSContext* cx, DictForConstructorAtoms* atomsCache);

public:
  bool
  Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription = "Value", bool passedToJSImpl = false);

  bool
  ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const;

  void
  TraceDictionary(JSTracer* trc);

  inline void
  TraverseForCC(nsCycleCollectionTraversalCallback& aCallback, uint32_t aFlags)
  {
    ImplCycleCollectionTraverse(aCallback, mDict, "mDict", aFlags);
    ImplCycleCollectionTraverse(aCallback, mDict2, "mDict2", aFlags);
    ImplCycleCollectionTraverse(aCallback, mSeq1, "mSeq1", aFlags);
    ImplCycleCollectionTraverse(aCallback, mSeq2, "mSeq2", aFlags);
    ImplCycleCollectionTraverse(aCallback, mSeq3, "mSeq3", aFlags);
    ImplCycleCollectionTraverse(aCallback, mSeq6, "mSeq6", aFlags);
  }

  inline void
  UnlinkForCC()
  {
    ImplCycleCollectionUnlink(mDict);
    ImplCycleCollectionUnlink(mDict2);
    ImplCycleCollectionUnlink(mSeq1);
    ImplCycleCollectionUnlink(mSeq2);
    ImplCycleCollectionUnlink(mSeq3);
    ImplCycleCollectionUnlink(mSeq6);
  }
};

namespace binding_detail {
struct FastDictForConstructor : public DictForConstructor
{
  inline FastDictForConstructor()
    : DictForConstructor(FastDictionaryInitializer())
  {
    // Doesn't matter what int we pass to the parent constructor
  }
};
} // namespace binding_detail


class TestCallback : public CallbackFunction
{
public:
  explicit inline TestCallback(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestCallback(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestCallback(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestCallback(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestCallback";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetCallContext(), thisValJS, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestCallback";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(const char* aExecutionReason = nullptr)
  {
    return Call(IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestCallback& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT void Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv);
};


class TestTreatAsNullCallback : public CallbackFunction
{
public:
  explicit inline TestTreatAsNullCallback(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestTreatAsNullCallback(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestTreatAsNullCallback(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestTreatAsNullCallback(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestTreatAsNullCallback";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetCallContext(), thisValJS, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestTreatAsNullCallback";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(const char* aExecutionReason = nullptr)
  {
    return Call(IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestTreatAsNullCallback& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT void Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv);
};


class TestIntegerReturn : public CallbackFunction
{
public:
  explicit inline TestIntegerReturn(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestIntegerReturn(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestIntegerReturn(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestIntegerReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline int32_t
  Call(const T& thisVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestIntegerReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return int32_t(0);
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return int32_t(0);
    }
    return Call(s.GetCallContext(), thisValJS, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline int32_t
  Call(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestIntegerReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return int32_t(0);
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline int32_t
  Call(const T& thisVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline int32_t
  Call(const char* aExecutionReason = nullptr)
  {
    return Call(IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestIntegerReturn& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT int32_t Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv);
};


class TestNullableIntegerReturn : public CallbackFunction
{
public:
  explicit inline TestNullableIntegerReturn(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableIntegerReturn(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableIntegerReturn(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableIntegerReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline Nullable<int32_t>
  Call(const T& thisVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestNullableIntegerReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return Nullable<int32_t>();
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return Nullable<int32_t>();
    }
    return Call(s.GetCallContext(), thisValJS, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline Nullable<int32_t>
  Call(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestNullableIntegerReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return Nullable<int32_t>();
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline Nullable<int32_t>
  Call(const T& thisVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline Nullable<int32_t>
  Call(const char* aExecutionReason = nullptr)
  {
    return Call(IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestNullableIntegerReturn& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT Nullable<int32_t> Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv);
};


class TestBooleanReturn : public CallbackFunction
{
public:
  explicit inline TestBooleanReturn(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestBooleanReturn(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestBooleanReturn(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestBooleanReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline bool
  Call(const T& thisVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestBooleanReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return bool(0);
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return bool(0);
    }
    return Call(s.GetCallContext(), thisValJS, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline bool
  Call(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestBooleanReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return bool(0);
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline bool
  Call(const T& thisVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline bool
  Call(const char* aExecutionReason = nullptr)
  {
    return Call(IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestBooleanReturn& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT bool Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv);
};


class TestFloatReturn : public CallbackFunction
{
public:
  explicit inline TestFloatReturn(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestFloatReturn(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestFloatReturn(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestFloatReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline float
  Call(const T& thisVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestFloatReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return float(0);
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return float(0);
    }
    return Call(s.GetCallContext(), thisValJS, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline float
  Call(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestFloatReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return float(0);
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline float
  Call(const T& thisVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline float
  Call(const char* aExecutionReason = nullptr)
  {
    return Call(IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestFloatReturn& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT float Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv);
};


class TestStringReturn : public CallbackFunction
{
public:
  explicit inline TestStringReturn(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestStringReturn(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestStringReturn(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestStringReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, int32_t arg, nsString& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestStringReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetCallContext(), thisValJS, arg, aRetVal, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(int32_t arg, nsString& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestStringReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, arg, aRetVal, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, int32_t arg, nsString& aRetVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, arg, aRetVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(int32_t arg, nsString& aRetVal, const char* aExecutionReason = nullptr)
  {
    return Call(arg, aRetVal, IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestStringReturn& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT void Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, int32_t arg, nsString& aRetVal, ErrorResult& aRv);
};


class TestEnumReturn : public CallbackFunction
{
public:
  explicit inline TestEnumReturn(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestEnumReturn(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestEnumReturn(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestEnumReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline TestEnum
  Call(const T& thisVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestEnumReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return TestEnum(0);
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return TestEnum(0);
    }
    return Call(s.GetCallContext(), thisValJS, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline TestEnum
  Call(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestEnumReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return TestEnum(0);
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline TestEnum
  Call(const T& thisVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline TestEnum
  Call(const char* aExecutionReason = nullptr)
  {
    return Call(IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestEnumReturn& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT TestEnum Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv);
};


class TestInterfaceReturn : public CallbackFunction
{
public:
  explicit inline TestInterfaceReturn(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestInterfaceReturn(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestInterfaceReturn(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestInterfaceReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestInterface>
  Call(const T& thisVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestInterfaceReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return nullptr;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return Call(s.GetCallContext(), thisValJS, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestInterface>
  Call(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestInterfaceReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return nullptr;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestInterface>
  Call(const T& thisVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestInterface>
  Call(const char* aExecutionReason = nullptr)
  {
    return Call(IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestInterfaceReturn& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT already_AddRefed<TestInterface> Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv);
};


class TestNullableInterfaceReturn : public CallbackFunction
{
public:
  explicit inline TestNullableInterfaceReturn(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableInterfaceReturn(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableInterfaceReturn(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableInterfaceReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestInterface>
  Call(const T& thisVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestNullableInterfaceReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return nullptr;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return Call(s.GetCallContext(), thisValJS, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestInterface>
  Call(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestNullableInterfaceReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return nullptr;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestInterface>
  Call(const T& thisVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestInterface>
  Call(const char* aExecutionReason = nullptr)
  {
    return Call(IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestNullableInterfaceReturn& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT already_AddRefed<TestInterface> Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv);
};


class TestExternalInterfaceReturn : public CallbackFunction
{
public:
  explicit inline TestExternalInterfaceReturn(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestExternalInterfaceReturn(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestExternalInterfaceReturn(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestExternalInterfaceReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestExternalInterface>
  Call(const T& thisVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestExternalInterfaceReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return nullptr;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return Call(s.GetCallContext(), thisValJS, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestExternalInterface>
  Call(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestExternalInterfaceReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return nullptr;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestExternalInterface>
  Call(const T& thisVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestExternalInterface>
  Call(const char* aExecutionReason = nullptr)
  {
    return Call(IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestExternalInterfaceReturn& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT already_AddRefed<TestExternalInterface> Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv);
};


class TestNullableExternalInterfaceReturn : public CallbackFunction
{
public:
  explicit inline TestNullableExternalInterfaceReturn(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableExternalInterfaceReturn(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableExternalInterfaceReturn(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableExternalInterfaceReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestExternalInterface>
  Call(const T& thisVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestNullableExternalInterfaceReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return nullptr;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return Call(s.GetCallContext(), thisValJS, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestExternalInterface>
  Call(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestNullableExternalInterfaceReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return nullptr;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestExternalInterface>
  Call(const T& thisVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestExternalInterface>
  Call(const char* aExecutionReason = nullptr)
  {
    return Call(IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestNullableExternalInterfaceReturn& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT already_AddRefed<TestExternalInterface> Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv);
};


class TestCallbackInterfaceReturn : public CallbackFunction
{
public:
  explicit inline TestCallbackInterfaceReturn(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestCallbackInterfaceReturn(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestCallbackInterfaceReturn(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestCallbackInterfaceReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestCallbackInterface>
  Call(const T& thisVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestCallbackInterfaceReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return nullptr;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return Call(s.GetCallContext(), thisValJS, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestCallbackInterface>
  Call(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestCallbackInterfaceReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return nullptr;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestCallbackInterface>
  Call(const T& thisVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestCallbackInterface>
  Call(const char* aExecutionReason = nullptr)
  {
    return Call(IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestCallbackInterfaceReturn& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT already_AddRefed<TestCallbackInterface> Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv);
};


class TestNullableCallbackInterfaceReturn : public CallbackFunction
{
public:
  explicit inline TestNullableCallbackInterfaceReturn(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableCallbackInterfaceReturn(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableCallbackInterfaceReturn(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableCallbackInterfaceReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestCallbackInterface>
  Call(const T& thisVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestNullableCallbackInterfaceReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return nullptr;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return Call(s.GetCallContext(), thisValJS, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestCallbackInterface>
  Call(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestNullableCallbackInterfaceReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return nullptr;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestCallbackInterface>
  Call(const T& thisVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestCallbackInterface>
  Call(const char* aExecutionReason = nullptr)
  {
    return Call(IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestNullableCallbackInterfaceReturn& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT already_AddRefed<TestCallbackInterface> Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv);
};


class TestCallbackReturn : public CallbackFunction
{
public:
  explicit inline TestCallbackReturn(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestCallbackReturn(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestCallbackReturn(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestCallbackReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestCallback>
  Call(const T& thisVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestCallbackReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return nullptr;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return Call(s.GetCallContext(), thisValJS, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestCallback>
  Call(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestCallbackReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return nullptr;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestCallback>
  Call(const T& thisVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestCallback>
  Call(const char* aExecutionReason = nullptr)
  {
    return Call(IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestCallbackReturn& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT already_AddRefed<TestCallback> Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv);
};


class TestNullableCallbackReturn : public CallbackFunction
{
public:
  explicit inline TestNullableCallbackReturn(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableCallbackReturn(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableCallbackReturn(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableCallbackReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestCallback>
  Call(const T& thisVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestNullableCallbackReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return nullptr;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return Call(s.GetCallContext(), thisValJS, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestCallback>
  Call(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestNullableCallbackReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return nullptr;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestCallback>
  Call(const T& thisVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline already_AddRefed<TestCallback>
  Call(const char* aExecutionReason = nullptr)
  {
    return Call(IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestNullableCallbackReturn& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT already_AddRefed<TestCallback> Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv);
};


class TestObjectReturn : public CallbackFunction
{
public:
  explicit inline TestObjectReturn(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestObjectReturn(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestObjectReturn(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestObjectReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestObjectReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetCallContext(), thisValJS, aRetVal, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestObjectReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRetVal, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, JS::MutableHandle<JSObject*> aRetVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, aRetVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(JS::MutableHandle<JSObject*> aRetVal, const char* aExecutionReason = nullptr)
  {
    return Call(aRetVal, IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestObjectReturn& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT void Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv);
};


class TestNullableObjectReturn : public CallbackFunction
{
public:
  explicit inline TestNullableObjectReturn(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableObjectReturn(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableObjectReturn(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableObjectReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestNullableObjectReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetCallContext(), thisValJS, aRetVal, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestNullableObjectReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRetVal, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, JS::MutableHandle<JSObject*> aRetVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, aRetVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(JS::MutableHandle<JSObject*> aRetVal, const char* aExecutionReason = nullptr)
  {
    return Call(aRetVal, IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestNullableObjectReturn& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT void Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv);
};


class TestTypedArrayReturn : public CallbackFunction
{
public:
  explicit inline TestTypedArrayReturn(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestTypedArrayReturn(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestTypedArrayReturn(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestTypedArrayReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestTypedArrayReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetCallContext(), thisValJS, aRetVal, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestTypedArrayReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRetVal, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, JS::MutableHandle<JSObject*> aRetVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, aRetVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(JS::MutableHandle<JSObject*> aRetVal, const char* aExecutionReason = nullptr)
  {
    return Call(aRetVal, IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestTypedArrayReturn& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT void Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv);
};


class TestNullableTypedArrayReturn : public CallbackFunction
{
public:
  explicit inline TestNullableTypedArrayReturn(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableTypedArrayReturn(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableTypedArrayReturn(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableTypedArrayReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestNullableTypedArrayReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetCallContext(), thisValJS, aRetVal, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestNullableTypedArrayReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRetVal, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, JS::MutableHandle<JSObject*> aRetVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, aRetVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(JS::MutableHandle<JSObject*> aRetVal, const char* aExecutionReason = nullptr)
  {
    return Call(aRetVal, IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestNullableTypedArrayReturn& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT void Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv);
};


class TestSequenceReturn : public CallbackFunction
{
public:
  explicit inline TestSequenceReturn(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestSequenceReturn(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestSequenceReturn(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestSequenceReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, nsTArray<bool>& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestSequenceReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetCallContext(), thisValJS, aRetVal, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(nsTArray<bool>& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestSequenceReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRetVal, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, nsTArray<bool>& aRetVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, aRetVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(nsTArray<bool>& aRetVal, const char* aExecutionReason = nullptr)
  {
    return Call(aRetVal, IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestSequenceReturn& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT void Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, nsTArray<bool>& aRetVal, ErrorResult& aRv);
};


class TestNullableSequenceReturn : public CallbackFunction
{
public:
  explicit inline TestNullableSequenceReturn(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableSequenceReturn(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableSequenceReturn(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestNullableSequenceReturn(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, Nullable<nsTArray<bool>>& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestNullableSequenceReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetCallContext(), thisValJS, aRetVal, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(Nullable<nsTArray<bool>>& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestNullableSequenceReturn";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRetVal, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, Nullable<nsTArray<bool>>& aRetVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, aRetVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(Nullable<nsTArray<bool>>& aRetVal, const char* aExecutionReason = nullptr)
  {
    return Call(aRetVal, IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestNullableSequenceReturn& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT void Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, Nullable<nsTArray<bool>>& aRetVal, ErrorResult& aRv);
};


class TestIntegerArguments : public CallbackFunction
{
public:
  explicit inline TestIntegerArguments(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestIntegerArguments(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestIntegerArguments(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestIntegerArguments(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, int32_t arg1, const Nullable<int32_t>& arg2, const Sequence<int32_t>& arg3, const Nullable<Sequence<Nullable<int32_t>>>& arg4, nsTArray<int32_t>& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestIntegerArguments";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetCallContext(), thisValJS, arg1, arg2, arg3, arg4, aRetVal, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(int32_t arg1, const Nullable<int32_t>& arg2, const Sequence<int32_t>& arg3, const Nullable<Sequence<Nullable<int32_t>>>& arg4, nsTArray<int32_t>& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestIntegerArguments";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, arg1, arg2, arg3, arg4, aRetVal, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, int32_t arg1, const Nullable<int32_t>& arg2, const Sequence<int32_t>& arg3, const Nullable<Sequence<Nullable<int32_t>>>& arg4, nsTArray<int32_t>& aRetVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, arg1, arg2, arg3, arg4, aRetVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(int32_t arg1, const Nullable<int32_t>& arg2, const Sequence<int32_t>& arg3, const Nullable<Sequence<Nullable<int32_t>>>& arg4, nsTArray<int32_t>& aRetVal, const char* aExecutionReason = nullptr)
  {
    return Call(arg1, arg2, arg3, arg4, aRetVal, IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestIntegerArguments& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT void Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, int32_t arg1, const Nullable<int32_t>& arg2, const Sequence<int32_t>& arg3, const Nullable<Sequence<Nullable<int32_t>>>& arg4, nsTArray<int32_t>& aRetVal, ErrorResult& aRv);
};


class TestInterfaceArguments : public CallbackFunction
{
public:
  explicit inline TestInterfaceArguments(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestInterfaceArguments(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestInterfaceArguments(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestInterfaceArguments(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, TestInterface& arg1, TestInterface* arg2, TestExternalInterface* arg3, TestExternalInterface* arg4, TestCallbackInterface& arg5, TestCallbackInterface* arg6, const Sequence<OwningNonNull<TestInterface>>& arg7, const Nullable<Sequence<RefPtr<TestInterface>>>& arg8, const Sequence<RefPtr<TestExternalInterface>>& arg9, const Nullable<Sequence<RefPtr<TestExternalInterface>>>& arg10, const Sequence<OwningNonNull<TestCallbackInterface>>& arg11, const Nullable<Sequence<RefPtr<TestCallbackInterface>>>& arg12, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestInterfaceArguments";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetCallContext(), thisValJS, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(TestInterface& arg1, TestInterface* arg2, TestExternalInterface* arg3, TestExternalInterface* arg4, TestCallbackInterface& arg5, TestCallbackInterface* arg6, const Sequence<OwningNonNull<TestInterface>>& arg7, const Nullable<Sequence<RefPtr<TestInterface>>>& arg8, const Sequence<RefPtr<TestExternalInterface>>& arg9, const Nullable<Sequence<RefPtr<TestExternalInterface>>>& arg10, const Sequence<OwningNonNull<TestCallbackInterface>>& arg11, const Nullable<Sequence<RefPtr<TestCallbackInterface>>>& arg12, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestInterfaceArguments";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, TestInterface& arg1, TestInterface* arg2, TestExternalInterface* arg3, TestExternalInterface* arg4, TestCallbackInterface& arg5, TestCallbackInterface* arg6, const Sequence<OwningNonNull<TestInterface>>& arg7, const Nullable<Sequence<RefPtr<TestInterface>>>& arg8, const Sequence<RefPtr<TestExternalInterface>>& arg9, const Nullable<Sequence<RefPtr<TestExternalInterface>>>& arg10, const Sequence<OwningNonNull<TestCallbackInterface>>& arg11, const Nullable<Sequence<RefPtr<TestCallbackInterface>>>& arg12, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(TestInterface& arg1, TestInterface* arg2, TestExternalInterface* arg3, TestExternalInterface* arg4, TestCallbackInterface& arg5, TestCallbackInterface* arg6, const Sequence<OwningNonNull<TestInterface>>& arg7, const Nullable<Sequence<RefPtr<TestInterface>>>& arg8, const Sequence<RefPtr<TestExternalInterface>>& arg9, const Nullable<Sequence<RefPtr<TestExternalInterface>>>& arg10, const Sequence<OwningNonNull<TestCallbackInterface>>& arg11, const Nullable<Sequence<RefPtr<TestCallbackInterface>>>& arg12, const char* aExecutionReason = nullptr)
  {
    return Call(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestInterfaceArguments& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT void Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, TestInterface& arg1, TestInterface* arg2, TestExternalInterface* arg3, TestExternalInterface* arg4, TestCallbackInterface& arg5, TestCallbackInterface* arg6, const Sequence<OwningNonNull<TestInterface>>& arg7, const Nullable<Sequence<RefPtr<TestInterface>>>& arg8, const Sequence<RefPtr<TestExternalInterface>>& arg9, const Nullable<Sequence<RefPtr<TestExternalInterface>>>& arg10, const Sequence<OwningNonNull<TestCallbackInterface>>& arg11, const Nullable<Sequence<RefPtr<TestCallbackInterface>>>& arg12, ErrorResult& aRv);
};


class TestStringEnumArguments : public CallbackFunction
{
public:
  explicit inline TestStringEnumArguments(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestStringEnumArguments(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestStringEnumArguments(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestStringEnumArguments(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, const nsAString& myString, const nsAString& nullString, TestEnum myEnum, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestStringEnumArguments";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetCallContext(), thisValJS, myString, nullString, myEnum, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(const nsAString& myString, const nsAString& nullString, TestEnum myEnum, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestStringEnumArguments";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, myString, nullString, myEnum, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, const nsAString& myString, const nsAString& nullString, TestEnum myEnum, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, myString, nullString, myEnum, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(const nsAString& myString, const nsAString& nullString, TestEnum myEnum, const char* aExecutionReason = nullptr)
  {
    return Call(myString, nullString, myEnum, IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestStringEnumArguments& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT void Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, const nsAString& myString, const nsAString& nullString, TestEnum myEnum, ErrorResult& aRv);
};


class TestObjectArguments : public CallbackFunction
{
public:
  explicit inline TestObjectArguments(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestObjectArguments(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestObjectArguments(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestObjectArguments(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, JS::Handle<JSObject*> anObj, JS::Handle<JSObject*> anotherObj, JS::Handle<JSObject*> buf, JS::Handle<JSObject*> buf2, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestObjectArguments";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetCallContext(), thisValJS, anObj, anotherObj, buf, buf2, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(JS::Handle<JSObject*> anObj, JS::Handle<JSObject*> anotherObj, JS::Handle<JSObject*> buf, JS::Handle<JSObject*> buf2, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestObjectArguments";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, anObj, anotherObj, buf, buf2, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, JS::Handle<JSObject*> anObj, JS::Handle<JSObject*> anotherObj, JS::Handle<JSObject*> buf, JS::Handle<JSObject*> buf2, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, anObj, anotherObj, buf, buf2, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(JS::Handle<JSObject*> anObj, JS::Handle<JSObject*> anotherObj, JS::Handle<JSObject*> buf, JS::Handle<JSObject*> buf2, const char* aExecutionReason = nullptr)
  {
    return Call(anObj, anotherObj, buf, buf2, IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestObjectArguments& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT void Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, JS::Handle<JSObject*> anObj, JS::Handle<JSObject*> anotherObj, JS::Handle<JSObject*> buf, JS::Handle<JSObject*> buf2, ErrorResult& aRv);
};


class TestOptionalArguments : public CallbackFunction
{
public:
  explicit inline TestOptionalArguments(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestOptionalArguments(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestOptionalArguments(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestOptionalArguments(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, const Optional<nsAString>& aString, const Optional<JS::Handle<JSObject*>>& something, const Optional<Sequence<OwningNonNull<TestInterface>>>& aSeq, const Optional<TestInterface*>& anInterface, const Optional<NonNull<TestInterface>>& anotherInterface, const Optional<int32_t>& aLong, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestOptionalArguments";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetCallContext(), thisValJS, aString, something, aSeq, anInterface, anotherInterface, aLong, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(const Optional<nsAString>& aString, const Optional<JS::Handle<JSObject*>>& something, const Optional<Sequence<OwningNonNull<TestInterface>>>& aSeq, const Optional<TestInterface*>& anInterface, const Optional<NonNull<TestInterface>>& anotherInterface, const Optional<int32_t>& aLong, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestOptionalArguments";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aString, something, aSeq, anInterface, anotherInterface, aLong, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, const Optional<nsAString>& aString, const Optional<JS::Handle<JSObject*>>& something, const Optional<Sequence<OwningNonNull<TestInterface>>>& aSeq, const Optional<TestInterface*>& anInterface, const Optional<NonNull<TestInterface>>& anotherInterface, const Optional<int32_t>& aLong, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, aString, something, aSeq, anInterface, anotherInterface, aLong, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(const Optional<nsAString>& aString, const Optional<JS::Handle<JSObject*>>& something, const Optional<Sequence<OwningNonNull<TestInterface>>>& aSeq, const Optional<TestInterface*>& anInterface, const Optional<NonNull<TestInterface>>& anotherInterface, const Optional<int32_t>& aLong, const char* aExecutionReason = nullptr)
  {
    return Call(aString, something, aSeq, anInterface, anotherInterface, aLong, IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestOptionalArguments& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT void Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, const Optional<nsAString>& aString, const Optional<JS::Handle<JSObject*>>& something, const Optional<Sequence<OwningNonNull<TestInterface>>>& aSeq, const Optional<TestInterface*>& anInterface, const Optional<NonNull<TestInterface>>& anotherInterface, const Optional<int32_t>& aLong, ErrorResult& aRv);
};


class TestVoidConstruction : public CallbackFunction
{
public:
  explicit inline TestVoidConstruction(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestVoidConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestVoidConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestVoidConstruction(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  MOZ_CAN_RUN_SCRIPT void Construct(const CustomEventInit& arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  inline bool
  operator==(const TestVoidConstruction& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }
};


class TestIntegerConstruction : public CallbackFunction
{
public:
  explicit inline TestIntegerConstruction(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestIntegerConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestIntegerConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestIntegerConstruction(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  MOZ_CAN_RUN_SCRIPT uint32_t Construct(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  inline bool
  operator==(const TestIntegerConstruction& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }
};


class TestBooleanConstruction : public CallbackFunction
{
public:
  explicit inline TestBooleanConstruction(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestBooleanConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestBooleanConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestBooleanConstruction(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  MOZ_CAN_RUN_SCRIPT bool Construct(JS::Handle<JS::Value> arg1, const Optional<JS::Handle<JS::Value>>& arg2, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  inline bool
  operator==(const TestBooleanConstruction& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }
};


class TestFloatConstruction : public CallbackFunction
{
public:
  explicit inline TestFloatConstruction(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestFloatConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestFloatConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestFloatConstruction(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  MOZ_CAN_RUN_SCRIPT float Construct(const Optional<JS::Handle<JSObject*>>& arg1, const Optional<CustomEventInit>& arg2, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  inline bool
  operator==(const TestFloatConstruction& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }
};


class TestStringConstruction : public CallbackFunction
{
public:
  explicit inline TestStringConstruction(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestStringConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestStringConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestStringConstruction(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  MOZ_CAN_RUN_SCRIPT void Construct(const Nullable<int32_t>& arg, nsString& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  inline bool
  operator==(const TestStringConstruction& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }
};


class TestEnumConstruction : public CallbackFunction
{
public:
  explicit inline TestEnumConstruction(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestEnumConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestEnumConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestEnumConstruction(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  MOZ_CAN_RUN_SCRIPT TestEnum Construct(const nsTArray<JS::Value>& arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  inline bool
  operator==(const TestEnumConstruction& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }
};


class TestInterfaceConstruction : public CallbackFunction
{
public:
  explicit inline TestInterfaceConstruction(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestInterfaceConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestInterfaceConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestInterfaceConstruction(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  MOZ_CAN_RUN_SCRIPT already_AddRefed<TestInterface> Construct(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  inline bool
  operator==(const TestInterfaceConstruction& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }
};


class TestExternalInterfaceConstruction : public CallbackFunction
{
public:
  explicit inline TestExternalInterfaceConstruction(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestExternalInterfaceConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestExternalInterfaceConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestExternalInterfaceConstruction(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  MOZ_CAN_RUN_SCRIPT already_AddRefed<TestExternalInterface> Construct(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  inline bool
  operator==(const TestExternalInterfaceConstruction& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }
};


class TestCallbackInterfaceConstruction : public CallbackFunction
{
public:
  explicit inline TestCallbackInterfaceConstruction(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestCallbackInterfaceConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestCallbackInterfaceConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestCallbackInterfaceConstruction(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  MOZ_CAN_RUN_SCRIPT already_AddRefed<TestCallbackInterface> Construct(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  inline bool
  operator==(const TestCallbackInterfaceConstruction& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }
};


class TestCallbackConstruction : public CallbackFunction
{
public:
  explicit inline TestCallbackConstruction(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestCallbackConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestCallbackConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestCallbackConstruction(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  MOZ_CAN_RUN_SCRIPT already_AddRefed<TestCallback> Construct(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  inline bool
  operator==(const TestCallbackConstruction& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }
};


class TestObjectConstruction : public CallbackFunction
{
public:
  explicit inline TestObjectConstruction(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestObjectConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestObjectConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestObjectConstruction(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  MOZ_CAN_RUN_SCRIPT void Construct(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  inline bool
  operator==(const TestObjectConstruction& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }
};


class TestTypedArrayConstruction : public CallbackFunction
{
public:
  explicit inline TestTypedArrayConstruction(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestTypedArrayConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestTypedArrayConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestTypedArrayConstruction(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  MOZ_CAN_RUN_SCRIPT void Construct(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  inline bool
  operator==(const TestTypedArrayConstruction& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }
};


class TestSequenceConstruction : public CallbackFunction
{
public:
  explicit inline TestSequenceConstruction(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestSequenceConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestSequenceConstruction(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline TestSequenceConstruction(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  MOZ_CAN_RUN_SCRIPT void Construct(nsTArray<bool>& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  inline bool
  operator==(const TestSequenceConstruction& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }
};


namespace binding_detail {
class FastTestCallback : public TestCallback
{
public:
  explicit inline FastTestCallback(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestCallback(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestCallback::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestCallback::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestTreatAsNullCallback : public TestTreatAsNullCallback
{
public:
  explicit inline FastTestTreatAsNullCallback(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestTreatAsNullCallback(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestTreatAsNullCallback::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestTreatAsNullCallback::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestIntegerReturn : public TestIntegerReturn
{
public:
  explicit inline FastTestIntegerReturn(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestIntegerReturn(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestIntegerReturn::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestIntegerReturn::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestNullableIntegerReturn : public TestNullableIntegerReturn
{
public:
  explicit inline FastTestNullableIntegerReturn(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestNullableIntegerReturn(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestNullableIntegerReturn::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestNullableIntegerReturn::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestBooleanReturn : public TestBooleanReturn
{
public:
  explicit inline FastTestBooleanReturn(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestBooleanReturn(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestBooleanReturn::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestBooleanReturn::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestFloatReturn : public TestFloatReturn
{
public:
  explicit inline FastTestFloatReturn(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestFloatReturn(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestFloatReturn::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestFloatReturn::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestStringReturn : public TestStringReturn
{
public:
  explicit inline FastTestStringReturn(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestStringReturn(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestStringReturn::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestStringReturn::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestEnumReturn : public TestEnumReturn
{
public:
  explicit inline FastTestEnumReturn(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestEnumReturn(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestEnumReturn::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestEnumReturn::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestInterfaceReturn : public TestInterfaceReturn
{
public:
  explicit inline FastTestInterfaceReturn(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestInterfaceReturn(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestInterfaceReturn::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestInterfaceReturn::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestNullableInterfaceReturn : public TestNullableInterfaceReturn
{
public:
  explicit inline FastTestNullableInterfaceReturn(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestNullableInterfaceReturn(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestNullableInterfaceReturn::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestNullableInterfaceReturn::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestExternalInterfaceReturn : public TestExternalInterfaceReturn
{
public:
  explicit inline FastTestExternalInterfaceReturn(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestExternalInterfaceReturn(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestExternalInterfaceReturn::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestExternalInterfaceReturn::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestNullableExternalInterfaceReturn : public TestNullableExternalInterfaceReturn
{
public:
  explicit inline FastTestNullableExternalInterfaceReturn(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestNullableExternalInterfaceReturn(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestNullableExternalInterfaceReturn::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestNullableExternalInterfaceReturn::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestCallbackInterfaceReturn : public TestCallbackInterfaceReturn
{
public:
  explicit inline FastTestCallbackInterfaceReturn(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestCallbackInterfaceReturn(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestCallbackInterfaceReturn::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestCallbackInterfaceReturn::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestNullableCallbackInterfaceReturn : public TestNullableCallbackInterfaceReturn
{
public:
  explicit inline FastTestNullableCallbackInterfaceReturn(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestNullableCallbackInterfaceReturn(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestNullableCallbackInterfaceReturn::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestNullableCallbackInterfaceReturn::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestCallbackReturn : public TestCallbackReturn
{
public:
  explicit inline FastTestCallbackReturn(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestCallbackReturn(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestCallbackReturn::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestCallbackReturn::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestNullableCallbackReturn : public TestNullableCallbackReturn
{
public:
  explicit inline FastTestNullableCallbackReturn(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestNullableCallbackReturn(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestNullableCallbackReturn::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestNullableCallbackReturn::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestObjectReturn : public TestObjectReturn
{
public:
  explicit inline FastTestObjectReturn(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestObjectReturn(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestObjectReturn::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestObjectReturn::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestNullableObjectReturn : public TestNullableObjectReturn
{
public:
  explicit inline FastTestNullableObjectReturn(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestNullableObjectReturn(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestNullableObjectReturn::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestNullableObjectReturn::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestTypedArrayReturn : public TestTypedArrayReturn
{
public:
  explicit inline FastTestTypedArrayReturn(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestTypedArrayReturn(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestTypedArrayReturn::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestTypedArrayReturn::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestNullableTypedArrayReturn : public TestNullableTypedArrayReturn
{
public:
  explicit inline FastTestNullableTypedArrayReturn(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestNullableTypedArrayReturn(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestNullableTypedArrayReturn::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestNullableTypedArrayReturn::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestSequenceReturn : public TestSequenceReturn
{
public:
  explicit inline FastTestSequenceReturn(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestSequenceReturn(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestSequenceReturn::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestSequenceReturn::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestNullableSequenceReturn : public TestNullableSequenceReturn
{
public:
  explicit inline FastTestNullableSequenceReturn(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestNullableSequenceReturn(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestNullableSequenceReturn::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestNullableSequenceReturn::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestIntegerArguments : public TestIntegerArguments
{
public:
  explicit inline FastTestIntegerArguments(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestIntegerArguments(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestIntegerArguments::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestIntegerArguments::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestInterfaceArguments : public TestInterfaceArguments
{
public:
  explicit inline FastTestInterfaceArguments(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestInterfaceArguments(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestInterfaceArguments::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestInterfaceArguments::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestStringEnumArguments : public TestStringEnumArguments
{
public:
  explicit inline FastTestStringEnumArguments(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestStringEnumArguments(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestStringEnumArguments::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestStringEnumArguments::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestObjectArguments : public TestObjectArguments
{
public:
  explicit inline FastTestObjectArguments(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestObjectArguments(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestObjectArguments::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestObjectArguments::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestOptionalArguments : public TestOptionalArguments
{
public:
  explicit inline FastTestOptionalArguments(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestOptionalArguments(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestOptionalArguments::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestOptionalArguments::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestVoidConstruction : public TestVoidConstruction
{
public:
  explicit inline FastTestVoidConstruction(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestVoidConstruction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestVoidConstruction::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestVoidConstruction::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestIntegerConstruction : public TestIntegerConstruction
{
public:
  explicit inline FastTestIntegerConstruction(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestIntegerConstruction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestIntegerConstruction::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestIntegerConstruction::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestBooleanConstruction : public TestBooleanConstruction
{
public:
  explicit inline FastTestBooleanConstruction(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestBooleanConstruction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestBooleanConstruction::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestBooleanConstruction::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestFloatConstruction : public TestFloatConstruction
{
public:
  explicit inline FastTestFloatConstruction(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestFloatConstruction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestFloatConstruction::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestFloatConstruction::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestStringConstruction : public TestStringConstruction
{
public:
  explicit inline FastTestStringConstruction(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestStringConstruction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestStringConstruction::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestStringConstruction::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestEnumConstruction : public TestEnumConstruction
{
public:
  explicit inline FastTestEnumConstruction(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestEnumConstruction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestEnumConstruction::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestEnumConstruction::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestInterfaceConstruction : public TestInterfaceConstruction
{
public:
  explicit inline FastTestInterfaceConstruction(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestInterfaceConstruction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestInterfaceConstruction::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestInterfaceConstruction::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestExternalInterfaceConstruction : public TestExternalInterfaceConstruction
{
public:
  explicit inline FastTestExternalInterfaceConstruction(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestExternalInterfaceConstruction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestExternalInterfaceConstruction::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestExternalInterfaceConstruction::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestCallbackInterfaceConstruction : public TestCallbackInterfaceConstruction
{
public:
  explicit inline FastTestCallbackInterfaceConstruction(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestCallbackInterfaceConstruction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestCallbackInterfaceConstruction::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestCallbackInterfaceConstruction::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestCallbackConstruction : public TestCallbackConstruction
{
public:
  explicit inline FastTestCallbackConstruction(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestCallbackConstruction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestCallbackConstruction::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestCallbackConstruction::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestObjectConstruction : public TestObjectConstruction
{
public:
  explicit inline FastTestObjectConstruction(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestObjectConstruction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestObjectConstruction::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestObjectConstruction::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestTypedArrayConstruction : public TestTypedArrayConstruction
{
public:
  explicit inline FastTestTypedArrayConstruction(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestTypedArrayConstruction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestTypedArrayConstruction::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestTypedArrayConstruction::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestSequenceConstruction : public TestSequenceConstruction
{
public:
  explicit inline FastTestSequenceConstruction(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestSequenceConstruction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestSequenceConstruction::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestSequenceConstruction::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace OnlyForUseInConstructor_Binding {

  typedef mozilla::dom::OnlyForUseInConstructor NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::OnlyForUseInConstructor* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::OnlyForUseInConstructor,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::OnlyForUseInConstructor,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace OnlyForUseInConstructor_Binding



namespace TestAttributesOnTypes_Binding {

  typedef mozilla::dom::TestAttributesOnTypes NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestAttributesOnTypes* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestAttributesOnTypes,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestAttributesOnTypes,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestAttributesOnTypes_Binding



namespace TestCEReactionsInterface_Binding {

  typedef mozilla::dom::TestCEReactionsInterface NativeType;

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestCEReactionsInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestCEReactionsInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestCEReactionsInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestCEReactionsInterface_Binding



namespace TestChildInterface_Binding {

  typedef mozilla::dom::TestChildInterface NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestChildInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestChildInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestChildInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestChildInterface_Binding



namespace TestConstructorForFuncInterface_Binding {

  typedef mozilla::dom::TestConstructorForFuncInterface NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestConstructorForFuncInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestConstructorForFuncInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestConstructorForFuncInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestConstructorForFuncInterface_Binding



namespace TestConstructorForPrefInterface_Binding {

  typedef mozilla::dom::TestConstructorForPrefInterface NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestConstructorForPrefInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestConstructorForPrefInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestConstructorForPrefInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestConstructorForPrefInterface_Binding



namespace TestConstructorForSCInterface_Binding {

  typedef mozilla::dom::TestConstructorForSCInterface NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestConstructorForSCInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestConstructorForSCInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestConstructorForSCInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestConstructorForSCInterface_Binding



namespace TestCppKeywordNamedMethodsInterface_Binding {

  typedef mozilla::dom::TestCppKeywordNamedMethodsInterface NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestCppKeywordNamedMethodsInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestCppKeywordNamedMethodsInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestCppKeywordNamedMethodsInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestCppKeywordNamedMethodsInterface_Binding



namespace TestDeprecatedInterface_Binding {

  typedef mozilla::dom::TestDeprecatedInterface NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestDeprecatedInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestDeprecatedInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestDeprecatedInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestDeprecatedInterface_Binding



namespace TestFuncConstructorForDifferentFuncInterface_Binding {

  typedef mozilla::dom::TestFuncConstructorForDifferentFuncInterface NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestFuncConstructorForDifferentFuncInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestFuncConstructorForDifferentFuncInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestFuncConstructorForDifferentFuncInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestFuncConstructorForDifferentFuncInterface_Binding



namespace TestFuncConstructorForInterface_Binding {

  typedef mozilla::dom::TestFuncConstructorForInterface NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestFuncConstructorForInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestFuncConstructorForInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestFuncConstructorForInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestFuncConstructorForInterface_Binding



namespace TestHTMLConstructorInterface_Binding {

  typedef mozilla::dom::TestHTMLConstructorInterface NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestHTMLConstructorInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestHTMLConstructorInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestHTMLConstructorInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestHTMLConstructorInterface_Binding



namespace TestIndexedAndNamedGetterAndSetterInterface_Binding {

  typedef mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface NativeType;

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestIndexedAndNamedGetterAndSetterInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestIndexedAndNamedGetterAndSetterInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestIndexedAndNamedGetterAndSetterInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestIndexedAndNamedGetterAndSetterInterface_Binding



namespace TestIndexedAndNamedGetterInterface_Binding {

  typedef mozilla::dom::TestIndexedAndNamedGetterInterface NativeType;

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestIndexedAndNamedGetterInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestIndexedAndNamedGetterInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestIndexedAndNamedGetterInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestIndexedAndNamedGetterInterface_Binding



namespace TestIndexedAndNamedSetterInterface_Binding {

  typedef mozilla::dom::TestIndexedAndNamedSetterInterface NativeType;

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestIndexedAndNamedSetterInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestIndexedAndNamedSetterInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestIndexedAndNamedSetterInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestIndexedAndNamedSetterInterface_Binding



namespace TestIndexedGetterAndSetterAndNamedGetterInterface_Binding {

  typedef mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface NativeType;

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestIndexedGetterAndSetterAndNamedGetterInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestIndexedGetterAndSetterAndNamedGetterInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestIndexedGetterAndSetterAndNamedGetterInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestIndexedGetterAndSetterAndNamedGetterInterface_Binding



namespace TestIndexedGetterInterface_Binding {

  typedef mozilla::dom::TestIndexedGetterInterface NativeType;

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestIndexedGetterInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  ClearCachedCachedAttrValue(mozilla::dom::TestIndexedGetterInterface* aObject);

  bool
  ClearCachedStoreInSlotAttrValue(JSContext* aCx, mozilla::dom::TestIndexedGetterInterface* aObject);

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestIndexedGetterInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestIndexedGetterInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestIndexedGetterInterface_Binding



namespace TestIndexedSetterInterface_Binding {

  typedef mozilla::dom::TestIndexedSetterInterface NativeType;

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestIndexedSetterInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  JSObject*
  GetProtoObject(JSContext* aCx);

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestIndexedSetterInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestIndexedSetterInterface_Binding



namespace TestInterface_Binding {

  typedef mozilla::dom::TestInterface NativeType;

  static const int32_t myLongConstant = 5;
  static const bool nonEnumerableConst = true;
  static const int32_t mixedInConstant = 5;
  MOZ_CAN_RUN_SCRIPT bool
  CollectJSONAttributes(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::TestInterface* self, JS::Rooted<JSObject*>& result);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  bool
  ClearCachedCachedByteValue(JSContext* aCx, mozilla::dom::TestInterface* aObject);

  bool
  ClearCachedCachedWritableByteValue(JSContext* aCx, mozilla::dom::TestInterface* aObject);

  void
  ClearCachedCachedSelfValue(mozilla::dom::TestInterface* aObject);

  void
  ClearCachedReadonlySequenceValue(mozilla::dom::TestInterface* aObject);

  void
  ClearCachedReadonlySequenceOfDictionariesValue(mozilla::dom::TestInterface* aObject);

  void
  ClearCachedReadonlyNullableSequenceOfDictionariesValue(mozilla::dom::TestInterface* aObject);

  void
  ClearCachedReadonlyFrozenSequenceValue(mozilla::dom::TestInterface* aObject);

  void
  ClearCachedReadonlyFrozenNullableSequenceValue(mozilla::dom::TestInterface* aObject);

  void
  ClearCachedReadonlyDictionaryValue(mozilla::dom::TestInterface* aObject);

  void
  ClearCachedReadonlyNullableDictionaryValue(mozilla::dom::TestInterface* aObject);

  void
  ClearCachedWritableDictionaryValue(mozilla::dom::TestInterface* aObject);

  void
  ClearCachedReadonlyFrozenDictionaryValue(mozilla::dom::TestInterface* aObject);

  void
  ClearCachedReadonlyFrozenNullableDictionaryValue(mozilla::dom::TestInterface* aObject);

  void
  ClearCachedWritableFrozenDictionaryValue(mozilla::dom::TestInterface* aObject);

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestInterface_Binding



namespace TestInterfaceWithPromiseConstructorArg_Binding {

  typedef mozilla::dom::TestInterfaceWithPromiseConstructorArg NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestInterfaceWithPromiseConstructorArg* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestInterfaceWithPromiseConstructorArg,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestInterfaceWithPromiseConstructorArg,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestInterfaceWithPromiseConstructorArg_Binding



namespace TestNamedDeleterInterface_Binding {

  typedef mozilla::dom::TestNamedDeleterInterface NativeType;

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestNamedDeleterInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestNamedDeleterInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestNamedDeleterInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestNamedDeleterInterface_Binding



namespace TestNamedDeleterWithRetvalInterface_Binding {

  typedef mozilla::dom::TestNamedDeleterWithRetvalInterface NativeType;

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestNamedDeleterWithRetvalInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestNamedDeleterWithRetvalInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestNamedDeleterWithRetvalInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestNamedDeleterWithRetvalInterface_Binding



namespace TestNamedGetterInterface_Binding {

  typedef mozilla::dom::TestNamedGetterInterface NativeType;

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestNamedGetterInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestNamedGetterInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestNamedGetterInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestNamedGetterInterface_Binding



namespace TestNamedSetterInterface_Binding {

  typedef mozilla::dom::TestNamedSetterInterface NativeType;

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestNamedSetterInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestNamedSetterInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestNamedSetterInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestNamedSetterInterface_Binding



namespace TestNamespace_Binding {

  typedef mozilla::dom::TestNamespace NativeType;

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestNamespace,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestNamespace_Binding



namespace TestNonWrapperCacheInterface_Binding {

  typedef mozilla::dom::TestNonWrapperCacheInterface NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestNonWrapperCacheInterface* aObject, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestNonWrapperCacheInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestNonWrapperCacheInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestNonWrapperCacheInterface_Binding



namespace TestParentInterface_Binding {

  typedef mozilla::dom::TestParentInterface NativeType;

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestParentInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  JSObject*
  GetProtoObject(JSContext* aCx);

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestParentInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestParentInterface_Binding



namespace TestPrefChromeOnlySCFuncConstructorForInterface_Binding {

  typedef mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestPrefChromeOnlySCFuncConstructorForInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestPrefChromeOnlySCFuncConstructorForInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestPrefChromeOnlySCFuncConstructorForInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestPrefChromeOnlySCFuncConstructorForInterface_Binding



namespace TestPrefConstructorForDifferentPrefInterface_Binding {

  typedef mozilla::dom::TestPrefConstructorForDifferentPrefInterface NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestPrefConstructorForDifferentPrefInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestPrefConstructorForDifferentPrefInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestPrefConstructorForDifferentPrefInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestPrefConstructorForDifferentPrefInterface_Binding



namespace TestPrefConstructorForInterface_Binding {

  typedef mozilla::dom::TestPrefConstructorForInterface NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestPrefConstructorForInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestPrefConstructorForInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestPrefConstructorForInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestPrefConstructorForInterface_Binding



namespace TestProtoObjectHackedNamespace_Binding {

  typedef mozilla::dom::TestProtoObjectHackedNamespace NativeType;

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestProtoObjectHackedNamespace,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestProtoObjectHackedNamespace_Binding



namespace TestRenamedInterface_Binding {

  typedef nsRenamedInterface NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, nsRenamedInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestRenamedInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestRenamedInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestRenamedInterface_Binding



namespace TestRenamedNamespace_Binding {

  typedef mozilla::dom::TestRenamedNamespace NativeType;

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestRenamedNamespace,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestRenamedNamespace_Binding



namespace TestSCConstructorForInterface_Binding {

  typedef mozilla::dom::TestSCConstructorForInterface NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestSCConstructorForInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestSCConstructorForInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestSCConstructorForInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestSCConstructorForInterface_Binding



namespace TestSecureContextInterface_Binding {

  typedef mozilla::dom::TestSecureContextInterface NativeType;

  bool
  ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestSecureContextInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestSecureContextInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestSecureContextInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestSecureContextInterface_Binding



namespace TestThrowingConstructorInterface_Binding {

  typedef mozilla::dom::TestThrowingConstructorInterface NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestThrowingConstructorInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestThrowingConstructorInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestThrowingConstructorInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestThrowingConstructorInterface_Binding



namespace TestWorkerExposedInterface_Binding {

  typedef mozilla::dom::TestWorkerExposedInterface NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestWorkerExposedInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestWorkerExposedInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestWorkerExposedInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestWorkerExposedInterface_Binding



class TestCallbackInterface : public CallbackInterface
{
public:
  explicit inline TestCallbackInterface(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackInterface(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
  }

  explicit inline TestCallbackInterface(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackInterface(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  explicit inline TestCallbackInterface(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackInterface(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
  }

  void DoSomething(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  int32_t DoSomethingElse(const nsAString& arg, TestInterface& otherArg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void DoSequenceLongArg(const Sequence<int32_t>& arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void DoSequenceStringArg(const Sequence<nsString>& arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void DoRecordLongArg(const Record<nsString, int32_t>& arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void GetSequenceOfLong(nsTArray<int32_t>& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void GetSequenceOfInterfaces(nsTArray<RefPtr<TestInterface>>& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void GetNullableSequenceOfInterfaces(Nullable<nsTArray<RefPtr<TestInterface>>>& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void GetSequenceOfNullableInterfaces(nsTArray<RefPtr<TestInterface>>& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void GetNullableSequenceOfNullableInterfaces(Nullable<nsTArray<RefPtr<TestInterface>>>& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void GetSequenceOfCallbackInterfaces(nsTArray<RefPtr<TestCallbackInterface>>& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void GetNullableSequenceOfCallbackInterfaces(Nullable<nsTArray<RefPtr<TestCallbackInterface>>>& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void GetSequenceOfNullableCallbackInterfaces(nsTArray<RefPtr<TestCallbackInterface>>& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void GetNullableSequenceOfNullableCallbackInterfaces(Nullable<nsTArray<RefPtr<TestCallbackInterface>>>& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void GetRecordOfLong(Record<nsString, int32_t>& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void GetDictionary(Nullable<Dict>& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void PassArrayBuffer(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void PassNullableArrayBuffer(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void PassOptionalArrayBuffer(const Optional<JS::Handle<JSObject*>>& arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableArrayBuffer(const Optional<JS::Handle<JSObject*>>& arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableArrayBufferWithDefaultValue(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void PassArrayBufferView(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void PassInt8Array(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void PassInt16Array(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void PassInt32Array(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void PassUint8Array(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void PassUint16Array(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void PassUint32Array(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void PassUint8ClampedArray(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void PassFloat32Array(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void PassFloat64Array(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void PassSequenceOfArrayBuffers(const Sequence<JS::Handle<JSObject*>>& arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void PassSequenceOfNullableArrayBuffers(const Sequence<JS::Handle<JSObject*>>& arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void PassVariadicTypedArray(const nsTArray<JS::Handle<JSObject*>>& arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void PassVariadicNullableTypedArray(const nsTArray<JS::Handle<JSObject*>>& arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void ReceiveUint8Array(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  already_AddRefed<Promise> ReceivePromise(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  inline bool
  operator==(const TestCallbackInterface& aOther) const
  {
    return CallbackInterface::operator==(aOther);
  }

  int32_t GetFoo(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void GetBar(nsString& aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void GetUint8ArrayAttr(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void SetBar(const nsAString& arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

  void SetUint8ArrayAttr(JS::Handle<JSObject*> arg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr);

private:
  static bool
  InitIds(JSContext* cx, TestCallbackInterfaceAtoms* atomsCache);
};


class TestSingleOperationCallbackInterface : public CallbackInterface
{
public:
  explicit inline TestSingleOperationCallbackInterface(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackInterface(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
  }

  explicit inline TestSingleOperationCallbackInterface(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackInterface(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  explicit inline TestSingleOperationCallbackInterface(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackInterface(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
  }

  template <typename T>
  inline already_AddRefed<TestInterface>
  DoSomething(const T& thisVal, int16_t arg, const Sequence<double>& anotherArg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestSingleOperationCallbackInterface.doSomething";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return nullptr;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return nullptr;
    }
    return DoSomething(s.GetCallContext(), thisValJS, arg, anotherArg, aRv);
  }

  inline already_AddRefed<TestInterface>
  DoSomething(int16_t arg, const Sequence<double>& anotherArg, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "TestSingleOperationCallbackInterface.doSomething";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return nullptr;
    }
    return DoSomething(s.GetCallContext(), JS::UndefinedHandleValue, arg, anotherArg, aRv);
  }

  template <typename T>
  inline already_AddRefed<TestInterface>
  DoSomething(const T& thisVal, int16_t arg, const Sequence<double>& anotherArg, const char* aExecutionReason = nullptr)
  {
    return DoSomething(thisVal, arg, anotherArg, IgnoreErrors(), aExecutionReason);
  }

  inline already_AddRefed<TestInterface>
  DoSomething(int16_t arg, const Sequence<double>& anotherArg, const char* aExecutionReason = nullptr)
  {
    return DoSomething(arg, anotherArg, IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const TestSingleOperationCallbackInterface& aOther) const
  {
    return CallbackInterface::operator==(aOther);
  }

private:
  already_AddRefed<TestInterface> DoSomething(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, int16_t arg, const Sequence<double>& anotherArg, ErrorResult& aRv);

  static bool
  InitIds(JSContext* cx, TestSingleOperationCallbackInterfaceAtoms* atomsCache);
};


namespace binding_detail {
class FastTestCallbackInterface : public TestCallbackInterface
{
public:
  explicit inline FastTestCallbackInterface(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestCallbackInterface(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestCallbackInterface::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestCallbackInterface::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace binding_detail {
class FastTestSingleOperationCallbackInterface : public TestSingleOperationCallbackInterface
{
public:
  explicit inline FastTestSingleOperationCallbackInterface(JSObject* aCallback, JSObject* aCallbackGlobal)
    : TestSingleOperationCallbackInterface(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    TestSingleOperationCallbackInterface::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    TestSingleOperationCallbackInterface::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


} // namespace dom
} // namespace mozilla

#endif // mozilla_dom_TestCodeGenBinding_h
