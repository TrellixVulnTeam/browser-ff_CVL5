/* THIS FILE IS AUTOGENERATED FROM MediaTrackSupportedConstraints.webidl BY Codegen.py - DO NOT EDIT */

#include <type_traits>
#include "AtomList.h"
#include "GeckoProfiler.h"
#include "MediaTrackSupportedConstraintsBinding.h"
#include "js/Object.h"
#include "js/experimental/JitInfo.h"
#include "mozilla/OwningNonNull.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/PrimitiveConversions.h"
#include "mozilla/dom/ScriptSettings.h"
#include "mozilla/dom/SimpleGlobalObject.h"

namespace mozilla {
namespace dom {

namespace binding_detail {}; // Just to make sure it's known as a namespace
using namespace mozilla::dom::binding_detail;



MediaTrackSupportedConstraints::MediaTrackSupportedConstraints()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
MediaTrackSupportedConstraints::InitIds(JSContext* cx, MediaTrackSupportedConstraintsAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->width_id.init(cx, "width") ||
      !atomsCache->volume_id.init(cx, "volume") ||
      !atomsCache->viewportWidth_id.init(cx, "viewportWidth") ||
      !atomsCache->viewportOffsetY_id.init(cx, "viewportOffsetY") ||
      !atomsCache->viewportOffsetX_id.init(cx, "viewportOffsetX") ||
      !atomsCache->viewportHeight_id.init(cx, "viewportHeight") ||
      !atomsCache->scrollWithPage_id.init(cx, "scrollWithPage") ||
      !atomsCache->sampleSize_id.init(cx, "sampleSize") ||
      !atomsCache->sampleRate_id.init(cx, "sampleRate") ||
      !atomsCache->noiseSuppression_id.init(cx, "noiseSuppression") ||
      !atomsCache->mediaSource_id.init(cx, "mediaSource") ||
      !atomsCache->latency_id.init(cx, "latency") ||
      !atomsCache->height_id.init(cx, "height") ||
      !atomsCache->groupId_id.init(cx, "groupId") ||
      !atomsCache->frameRate_id.init(cx, "frameRate") ||
      !atomsCache->facingMode_id.init(cx, "facingMode") ||
      !atomsCache->echoCancellation_id.init(cx, "echoCancellation") ||
      !atomsCache->deviceId_id.init(cx, "deviceId") ||
      !atomsCache->channelCount_id.init(cx, "channelCount") ||
      !atomsCache->browserWindow_id.init(cx, "browserWindow") ||
      !atomsCache->autoGainControl_id.init(cx, "autoGainControl") ||
      !atomsCache->aspectRatio_id.init(cx, "aspectRatio")) {
    return false;
  }
  return true;
}

bool
MediaTrackSupportedConstraints::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mAutoGainControl = true;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mBrowserWindow = true;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mChannelCount = true;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mDeviceId = true;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mEchoCancellation = true;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mFacingMode = true;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mFrameRate = true;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mGroupId = true;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mHeight = true;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mMediaSource = true;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mNoiseSuppression = true;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mScrollWithPage = true;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mViewportHeight = true;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mViewportOffsetX = true;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mViewportOffsetY = true;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mViewportWidth = true;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mWidth = true;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
MediaTrackSupportedConstraints::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  MediaTrackSupportedConstraintsAtoms* atomsCache = GetAtomCache<MediaTrackSupportedConstraintsAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  if (mAspectRatio.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      bool const & currentValue = mAspectRatio.InternalValue();
      temp.setBoolean(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->aspectRatio_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mAutoGainControl;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->autoGainControl_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mBrowserWindow;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->browserWindow_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mChannelCount;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->channelCount_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mDeviceId;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->deviceId_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mEchoCancellation;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->echoCancellation_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mFacingMode;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->facingMode_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mFrameRate;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->frameRate_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mGroupId;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->groupId_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mHeight;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->height_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mLatency.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      bool const & currentValue = mLatency.InternalValue();
      temp.setBoolean(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->latency_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mMediaSource;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->mediaSource_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mNoiseSuppression;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->noiseSuppression_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mSampleRate.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      bool const & currentValue = mSampleRate.InternalValue();
      temp.setBoolean(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->sampleRate_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mSampleSize.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      bool const & currentValue = mSampleSize.InternalValue();
      temp.setBoolean(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->sampleSize_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mScrollWithPage;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->scrollWithPage_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mViewportHeight;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->viewportHeight_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mViewportOffsetX;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->viewportOffsetX_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mViewportOffsetY;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->viewportOffsetY_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mViewportWidth;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->viewportWidth_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mVolume.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      bool const & currentValue = mVolume.InternalValue();
      temp.setBoolean(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->volume_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mWidth;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->width_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
MediaTrackSupportedConstraints::TraceDictionary(JSTracer* trc)
{
}

MediaTrackSupportedConstraints&
MediaTrackSupportedConstraints::operator=(const MediaTrackSupportedConstraints& aOther)
{
  DictionaryBase::operator=(aOther);
  mAspectRatio.Reset();
  if (aOther.mAspectRatio.WasPassed()) {
    mAspectRatio.Construct(aOther.mAspectRatio.Value());
  }
  mAutoGainControl = aOther.mAutoGainControl;
  mBrowserWindow = aOther.mBrowserWindow;
  mChannelCount = aOther.mChannelCount;
  mDeviceId = aOther.mDeviceId;
  mEchoCancellation = aOther.mEchoCancellation;
  mFacingMode = aOther.mFacingMode;
  mFrameRate = aOther.mFrameRate;
  mGroupId = aOther.mGroupId;
  mHeight = aOther.mHeight;
  mLatency.Reset();
  if (aOther.mLatency.WasPassed()) {
    mLatency.Construct(aOther.mLatency.Value());
  }
  mMediaSource = aOther.mMediaSource;
  mNoiseSuppression = aOther.mNoiseSuppression;
  mSampleRate.Reset();
  if (aOther.mSampleRate.WasPassed()) {
    mSampleRate.Construct(aOther.mSampleRate.Value());
  }
  mSampleSize.Reset();
  if (aOther.mSampleSize.WasPassed()) {
    mSampleSize.Construct(aOther.mSampleSize.Value());
  }
  mScrollWithPage = aOther.mScrollWithPage;
  mViewportHeight = aOther.mViewportHeight;
  mViewportOffsetX = aOther.mViewportOffsetX;
  mViewportOffsetY = aOther.mViewportOffsetY;
  mViewportWidth = aOther.mViewportWidth;
  mVolume.Reset();
  if (aOther.mVolume.WasPassed()) {
    mVolume.Construct(aOther.mVolume.Value());
  }
  mWidth = aOther.mWidth;
  return *this;
}

bool
MediaTrackSupportedConstraints::operator==(const MediaTrackSupportedConstraints& aOther) const
{
  if (mAspectRatio != aOther.mAspectRatio) {
      return false;
  }
  if (mAutoGainControl != aOther.mAutoGainControl) {
      return false;
  }
  if (mBrowserWindow != aOther.mBrowserWindow) {
      return false;
  }
  if (mChannelCount != aOther.mChannelCount) {
      return false;
  }
  if (mDeviceId != aOther.mDeviceId) {
      return false;
  }
  if (mEchoCancellation != aOther.mEchoCancellation) {
      return false;
  }
  if (mFacingMode != aOther.mFacingMode) {
      return false;
  }
  if (mFrameRate != aOther.mFrameRate) {
      return false;
  }
  if (mGroupId != aOther.mGroupId) {
      return false;
  }
  if (mHeight != aOther.mHeight) {
      return false;
  }
  if (mLatency != aOther.mLatency) {
      return false;
  }
  if (mMediaSource != aOther.mMediaSource) {
      return false;
  }
  if (mNoiseSuppression != aOther.mNoiseSuppression) {
      return false;
  }
  if (mSampleRate != aOther.mSampleRate) {
      return false;
  }
  if (mSampleSize != aOther.mSampleSize) {
      return false;
  }
  if (mScrollWithPage != aOther.mScrollWithPage) {
      return false;
  }
  if (mViewportHeight != aOther.mViewportHeight) {
      return false;
  }
  if (mViewportOffsetX != aOther.mViewportOffsetX) {
      return false;
  }
  if (mViewportOffsetY != aOther.mViewportOffsetY) {
      return false;
  }
  if (mViewportWidth != aOther.mViewportWidth) {
      return false;
  }
  if (mVolume != aOther.mVolume) {
      return false;
  }
  if (mWidth != aOther.mWidth) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail


} // namespace dom
} // namespace mozilla
