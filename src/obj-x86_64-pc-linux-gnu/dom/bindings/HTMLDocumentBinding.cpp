/* THIS FILE IS AUTOGENERATED FROM HTMLDocument.webidl BY Codegen.py - DO NOT EDIT */

#include <type_traits>
#include "DocumentBinding.h"
#include "GeckoProfiler.h"
#include "HTMLDocumentBinding.h"
#include "WrapperFactory.h"
#include "XrayWrapper.h"
#include "js/Object.h"
#include "js/String.h"
#include "js/experimental/JitInfo.h"
#include "mozilla/Atomics.h"
#include "mozilla/OwningNonNull.h"
#include "mozilla/StaticPrefs_dom.h"
#include "mozilla/UseCounter.h"
#include "mozilla/dom/BindingCallContext.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/DOMJSClass.h"
#include "mozilla/dom/DOMJSProxyHandler.h"
#include "mozilla/dom/Location.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/XrayExpandoClass.h"
#include "nsHTMLDocument.h"

namespace mozilla {
namespace dom {

namespace binding_detail {}; // Just to make sure it's known as a namespace
using namespace mozilla::dom::binding_detail;


namespace HTMLDocument_Binding {

static_assert(IsRefcounted<NativeType>::value == IsRefcounted<Document_Binding::NativeType>::value,
              "Can't inherit from an interface with a different ownership model.");

MOZ_CAN_RUN_SCRIPT static bool
get_location(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "HTMLDocument", "location", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<nsHTMLDocument*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::Location>(MOZ_KnownLive(self)->GetLocation()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_location(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "HTMLDocument.location setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "HTMLDocument", "location", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::Rooted<JS::Value> v(cx);
  if (!JS_GetProperty(cx, obj, "location", &v)) {
    return false;
  }

  if (!v.isObject()) {
    return cx.ThrowErrorMessage<MSG_NOT_OBJECT>("HTMLDocument.location");
  }

  JS::Rooted<JSObject*> targetObj(cx, &v.toObject());
  return JS_SetProperty(cx, targetObj, "href", args[0]);
}

static const JSJitInfo location_getterinfo = {
  { get_location },
  { prototypes::id::HTMLDocument },
  { PrototypeTraits<prototypes::id::HTMLDocument>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 2, "There is no slot for us");
static const JSJitInfo location_setterinfo = {
  { (JSJitGetterOp)set_location },
  { prototypes::id::HTMLDocument },
  { PrototypeTraits<prototypes::id::HTMLDocument>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 2, "There is no slot for us");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "HTMLDocument", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sUnforgeableAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("location", JSPROP_ENUMERATE | JSPROP_PERMANENT, GenericGetter<NormalThisPolicy, ThrowExceptions>, &location_getterinfo, GenericSetter<NormalThisPolicy>, &location_setterinfo),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sUnforgeableAttributes[] = {
  { nullptr, &sUnforgeableAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[2];
static PropertyInfo sNativeProperties_propertyInfos[2];

static const NativePropertiesN<2> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  true,  1 /* sUnforgeableAttributes */,
  false, 0,
  -1,
  2,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] },
    { sUnforgeableAttributes, &sNativeProperties_propertyInfos[1] }
  }
};
static_assert(2 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  sNativePropertyHooks,
  "function HTMLDocument() {\n    [native code]\n}",
  Document_Binding::GetConstructorObject
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "HTMLDocumentPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE + 1 /* slot for the JSObject holding the unforgeable properties */),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::HTMLDocument,
  PrototypeTraits<prototypes::id::HTMLDocument>::Depth,
  sNativePropertyHooks,
  nullptr,
  Document_Binding::GetProtoObject
};

bool
CountMaybeMissingProperty(JS::Handle<JSObject*> proxy, JS::Handle<jsid> id)
{
  MOZ_ASSERT(StaticPrefs::dom_missing_prop_counters_enabled() && JSID_IS_ATOM(id));
  Maybe<UseCounter> counter;
  {
    // Scope for our no-GC section, so we don't need to rely on SetUseCounter not GCing.
    JS::AutoCheckCannotGC nogc;
    JSLinearString* str = JS::AtomToLinearString(JSID_TO_ATOM(id));
    // Don't waste time fetching the chars until we've done the length switch.
    switch (JS::GetLinearStringLength(str)) {
      case 10: {
        if (JS_LinearStringEqualsLiteral(str, "xmlVersion")) {
          counter.emplace(eUseCounter_HTMLDocument_xmlVersion);
        }
        break;
      }
      case 11: {
        StringIdChars chars(nogc, str);
        switch (chars[0]) {
          case 'o': {
            if (JS_LinearStringEqualsLiteral(str, "onbeforecut")) {
              counter.emplace(eUseCounter_HTMLDocument_onbeforecut);
            }
            break;
          }
          case 'x': {
            if (JS_LinearStringEqualsLiteral(str, "xmlEncoding")) {
              counter.emplace(eUseCounter_HTMLDocument_xmlEncoding);
            }
            break;
          }
        }
        break;
      }
      case 12: {
        StringIdChars chars(nogc, str);
        switch (chars[0]) {
          case 'o': {
            switch (chars[2]) {
              case 'b': {
                if (JS_LinearStringEqualsLiteral(str, "onbeforecopy")) {
                  counter.emplace(eUseCounter_HTMLDocument_onbeforecopy);
                }
                break;
              }
              case 'm': {
                if (JS_LinearStringEqualsLiteral(str, "onmousewheel")) {
                  counter.emplace(eUseCounter_HTMLDocument_onmousewheel);
                }
                break;
              }
            }
            break;
          }
          case 'w': {
            switch (chars[1]) {
              case 'a': {
                if (JS_LinearStringEqualsLiteral(str, "wasDiscarded")) {
                  counter.emplace(eUseCounter_HTMLDocument_wasDiscarded);
                }
                break;
              }
              case 'e': {
                if (JS_LinearStringEqualsLiteral(str, "webkitHidden")) {
                  counter.emplace(eUseCounter_HTMLDocument_webkitHidden);
                }
                break;
              }
            }
            break;
          }
        }
        break;
      }
      case 13: {
        StringIdChars chars(nogc, str);
        switch (chars[0]) {
          case 'f': {
            if (JS_LinearStringEqualsLiteral(str, "featurePolicy")) {
              counter.emplace(eUseCounter_HTMLDocument_featurePolicy);
            }
            break;
          }
          case 'o': {
            if (JS_LinearStringEqualsLiteral(str, "onbeforepaste")) {
              counter.emplace(eUseCounter_HTMLDocument_onbeforepaste);
            }
            break;
          }
          case 'x': {
            if (JS_LinearStringEqualsLiteral(str, "xmlStandalone")) {
              counter.emplace(eUseCounter_HTMLDocument_xmlStandalone);
            }
            break;
          }
        }
        break;
      }
      case 15: {
        if (JS_LinearStringEqualsLiteral(str, "registerElement")) {
          counter.emplace(eUseCounter_HTMLDocument_registerElement);
        }
        break;
      }
      case 18: {
        StringIdChars chars(nogc, str);
        switch (chars[0]) {
          case 'a': {
            if (JS_LinearStringEqualsLiteral(str, "adoptedStyleSheets")) {
              counter.emplace(eUseCounter_HTMLDocument_adoptedStyleSheets);
            }
            break;
          }
          case 'w': {
            if (JS_LinearStringEqualsLiteral(str, "webkitIsFullScreen")) {
              counter.emplace(eUseCounter_HTMLDocument_webkitIsFullScreen);
            }
            break;
          }
        }
        break;
      }
      case 19: {
        if (JS_LinearStringEqualsLiteral(str, "caretRangeFromPoint")) {
          counter.emplace(eUseCounter_HTMLDocument_caretRangeFromPoint);
        }
        break;
      }
      case 20: {
        StringIdChars chars(nogc, str);
        switch (chars[0]) {
          case 'e': {
            if (JS_LinearStringEqualsLiteral(str, "exitPictureInPicture")) {
              counter.emplace(eUseCounter_HTMLDocument_exitPictureInPicture);
            }
            break;
          }
          case 'w': {
            if (JS_LinearStringEqualsLiteral(str, "webkitExitFullscreen")) {
              counter.emplace(eUseCounter_HTMLDocument_webkitExitFullscreen);
            }
            break;
          }
        }
        break;
      }
      case 21: {
        if (JS_LinearStringEqualsLiteral(str, "webkitVisibilityState")) {
          counter.emplace(eUseCounter_HTMLDocument_webkitVisibilityState);
        }
        break;
      }
      case 22: {
        if (JS_LinearStringEqualsLiteral(str, "webkitCancelFullScreen")) {
          counter.emplace(eUseCounter_HTMLDocument_webkitCancelFullScreen);
        }
        break;
      }
      case 23: {
        StringIdChars chars(nogc, str);
        switch (chars[0]) {
          case 'o': {
            if (JS_LinearStringEqualsLiteral(str, "onwebkitfullscreenerror")) {
              counter.emplace(eUseCounter_HTMLDocument_onwebkitfullscreenerror);
            }
            break;
          }
          case 'p': {
            switch (chars[17]) {
              case 'l': {
                if (JS_LinearStringEqualsLiteral(str, "pictureInPictureElement")) {
                  counter.emplace(eUseCounter_HTMLDocument_pictureInPictureElement);
                }
                break;
              }
              case 'n': {
                if (JS_LinearStringEqualsLiteral(str, "pictureInPictureEnabled")) {
                  counter.emplace(eUseCounter_HTMLDocument_pictureInPictureEnabled);
                }
                break;
              }
            }
            break;
          }
          case 'w': {
            switch (chars[17]) {
              case 'l': {
                if (JS_LinearStringEqualsLiteral(str, "webkitFullscreenElement")) {
                  counter.emplace(eUseCounter_HTMLDocument_webkitFullscreenElement);
                }
                break;
              }
              case 'n': {
                if (JS_LinearStringEqualsLiteral(str, "webkitFullscreenEnabled")) {
                  counter.emplace(eUseCounter_HTMLDocument_webkitFullscreenEnabled);
                }
                break;
              }
            }
            break;
          }
        }
        break;
      }
      case 24: {
        if (JS_LinearStringEqualsLiteral(str, "onwebkitfullscreenchange")) {
          counter.emplace(eUseCounter_HTMLDocument_onwebkitfullscreenchange);
        }
        break;
      }
      case 25: {
        if (JS_LinearStringEqualsLiteral(str, "onsecuritypolicyviolation")) {
          counter.emplace(eUseCounter_HTMLDocument_onsecuritypolicyviolation);
        }
        break;
      }
      case 30: {
        if (JS_LinearStringEqualsLiteral(str, "webkitCurrentFullScreenElement")) {
          counter.emplace(eUseCounter_HTMLDocument_webkitCurrentFullScreenElement);
        }
        break;
      }
      case 5: {
        if (JS_LinearStringEqualsLiteral(str, "clear")) {
          counter.emplace(eUseCounter_HTMLDocument_clear);
        }
        break;
      }
      case 8: {
        StringIdChars chars(nogc, str);
        switch (chars[2]) {
          case 'c': {
            if (JS_LinearStringEqualsLiteral(str, "oncancel")) {
              counter.emplace(eUseCounter_HTMLDocument_oncancel);
            }
            break;
          }
          case 'f': {
            if (JS_LinearStringEqualsLiteral(str, "onfreeze")) {
              counter.emplace(eUseCounter_HTMLDocument_onfreeze);
            }
            break;
          }
          case 'r': {
            if (JS_LinearStringEqualsLiteral(str, "onresume")) {
              counter.emplace(eUseCounter_HTMLDocument_onresume);
            }
            break;
          }
          case 's': {
            if (JS_LinearStringEqualsLiteral(str, "onsearch")) {
              counter.emplace(eUseCounter_HTMLDocument_onsearch);
            }
            break;
          }
        }
        break;
      }
    }
  }
  if (counter) {
    SetUseCounter(proxy, *counter);
    return true;
  }

  return false;
}

static_assert(std::is_base_of_v<nsISupports, nsHTMLDocument>,
                  "We don't support non-nsISupports native classes for "
                  "proxy-based bindings yet");


class DOMProxyHandler : public ShadowingDOMProxyHandler
{
public:
  explicit constexpr DOMProxyHandler()
  {
  }

  bool
  getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const override;

  bool
  defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const override;

  using mozilla::dom::DOMProxyHandler::defineProperty;

  bool
  ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const override;

  bool
  hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const override;

  bool
  get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const override;

  const char*
  className(JSContext* cx, JS::Handle<JSObject*> proxy) const override;

  bool
  finalizeInBackground(const JS::Value& priv) const override;

  void
  finalize(JSFreeOp* fop, JSObject* proxy) const override;

  static const DOMProxyHandler*
  getInstance();

  bool
  delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const override;

  size_t
  objectMoved(JSObject* obj, JSObject* old) const override;
};

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE nsHTMLDocument*
UnwrapProxy(JSObject* obj)
{
  MOZ_ASSERT(js::IsProxy(obj));
  if (js::GetProxyHandler(obj) != DOMProxyHandler::getInstance()) {
    MOZ_ASSERT(xpc::WrapperFactory::IsXrayWrapper(obj));
    obj = js::UncheckedUnwrap(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<nsHTMLDocument*>(js::GetProxyReservedSlot(obj, DOM_OBJECT_SLOT).toPrivate());
}

bool
DOMProxyHandler::getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);
  if (StaticPrefs::dom_missing_prop_counters_enabled() && JSID_IS_ATOM(id)) {
    CountMaybeMissingProperty(proxy, id);
  }

  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = GetExpandoObject(proxy))) {
    if (!JS_GetOwnPropertyDescriptorById(cx, expando, id, desc)) {
      return false;
    }
    if (desc.object()) {
      // Pretend the property lives on the wrapper.
      desc.object().set(proxy);
      return true;
    }
  }

  bool callNamedGetter = false;
  if (!ignoreNamedProps) {
    if (!isXray) {
      callNamedGetter = true;
    } else {
      bool hasOnProto;
      if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
        return false;
      }
      callNamedGetter = !hasOnProto;
    }
  }
  if (callNamedGetter) {
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      nsHTMLDocument* self = UnwrapProxy(proxy);
      bool found = false;
      FastErrorResult rv;
      JS::Rooted<JSObject*> result(cx);
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(cx, NonNullHelper(Constify(name)), found, &result, rv))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedGetter(cx, NonNullHelper(Constify(name)), found, &result, rv);
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "HTMLDocument named getter"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));

      if (found) {
        JS::ExposeObjectToActiveJS(result);
        desc.value().setObject(*result);
        if (!MaybeWrapObjectValue(cx, desc.value())) {
          return false;
        }
        FillPropertyDescriptor(desc, proxy, true, true);
        return true;
      }
    }
  }

  desc.object().set(nullptr);
  return true;
}

bool
DOMProxyHandler::defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const
{
  JSContext* cx = cx_;
  bool found = false;
  FakeString<char16_t> name;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, name, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    nsHTMLDocument* self = UnwrapProxy(proxy);
    FastErrorResult rv;
    JS::Rooted<JSObject*> result(cx);
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(cx, NonNullHelper(Constify(name)), found, &result, rv))>, "Should be returning void here");
    MOZ_KnownLive(self)->NamedGetter(cx, NonNullHelper(Constify(name)), found, &result, rv);
    if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "HTMLDocument named getter"))) {
      return false;
    }
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;
  }

  if (found) {
    *done = true;
    return opresult.failNoNamedSetter();
  }
  return mozilla::dom::DOMProxyHandler::defineProperty(cx_, proxy, id, desc, opresult, done);
}


bool
DOMProxyHandler::ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);

  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, !isXray, props)) {
    return false;
  }

  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyKeys(cx, expando, flags, props)) {
    return false;
  }

  return true;
}

bool
DOMProxyHandler::hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");

  if (StaticPrefs::dom_missing_prop_counters_enabled() && JSID_IS_ATOM(id)) {
    CountMaybeMissingProperty(proxy, id);
  }

  JS::Rooted<JSObject*> expando(cx, GetExpandoObject(proxy));
  if (expando) {
    bool b = true;
    bool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  bool found = false;
  FakeString<char16_t> name;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, name, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    nsHTMLDocument* self = UnwrapProxy(proxy);
    FastErrorResult rv;
    JS::Rooted<JSObject*> result(cx);
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(cx, NonNullHelper(Constify(name)), found, &result, rv))>, "Should be returning void here");
    MOZ_KnownLive(self)->NamedGetter(cx, NonNullHelper(Constify(name)), found, &result, rv);
    if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "HTMLDocument named getter"))) {
      return false;
    }
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;
  }

  *bp = found;

  return true;
}

bool
DOMProxyHandler::get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  JS::Rooted<JS::Value> rootedReceiver(cx, receiver);

  if (StaticPrefs::dom_missing_prop_counters_enabled() && JSID_IS_ATOM(id)) {
    CountMaybeMissingProperty(proxy, id);
  }

  bool expandoHasProp = false;
  { // Scope for expando
    JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
    if (expando) {
      if (!JS_HasPropertyById(cx, expando, id, &expandoHasProp)) {
        return false;
      }

      if (expandoHasProp) {
        // Forward the get to the expando object, but our receiver is whatever our
        // receiver is.
        if (!JS_ForwardGetPropertyTo(cx, expando, id, rootedReceiver, vp)) {
          return false;
        }
      }
    }
  }

  if (expandoHasProp) {
    return true;
  }

  FakeString<char16_t> name;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, name, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    nsHTMLDocument* self = UnwrapProxy(proxy);
    bool found = false;
    FastErrorResult rv;
    JS::Rooted<JSObject*> result(cx);
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(cx, NonNullHelper(Constify(name)), found, &result, rv))>, "Should be returning void here");
    MOZ_KnownLive(self)->NamedGetter(cx, NonNullHelper(Constify(name)), found, &result, rv);
    if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "HTMLDocument named getter"))) {
      return false;
    }
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    if (found) {
      JS::ExposeObjectToActiveJS(result);
      vp.setObject(*result);
      if (!MaybeWrapObjectValue(cx, vp)) {
        return false;
      }
      return true;
    }
  }

  bool foundOnPrototype;
  if (!GetPropertyOnPrototype(cx, proxy, rootedReceiver, id, &foundOnPrototype, vp)) {
    return false;
  }

  if (foundOnPrototype) {
    return true;
  }

  vp.setUndefined();
  return true;
}

const char*
DOMProxyHandler::className(JSContext* cx, JS::Handle<JSObject*> proxy) const
{
  return "HTMLDocument";
}

bool
DOMProxyHandler::finalizeInBackground(const JS::Value& priv) const
{
  return false;
}

void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy) const
{
  nsHTMLDocument* self = UnwrapPossiblyNotInitializedDOMObject<nsHTMLDocument>(proxy);
  if (self) {
    JS::SetReservedSlot(proxy, DOM_OBJECT_SLOT, JS::UndefinedValue());
    // Either our proxy created an expando object or not.  If it did,
    // then we would have preserved ourselves, and hence if we're going
    // away so is our C++ object and we should reset its expando value.
    // It's possible that in this situation the C++ object's reflector
    // pointer has been nulled out, but if not it's pointing to us.  If
    // our proxy did _not_ create an expando object then it's possible
    // that we're no longer the reflector for our C++ object (and
    // incremental finalization is finally getting to us), and that in
    // the meantime the new reflector has created an expando object.
    // In that case we do NOT want to clear the expando pointer in the
    // C++ object.
    //
    // It's important to do this before we ClearWrapper, of course.
    JSObject* reflector = self->GetWrapperMaybeDead();
    if (!reflector || reflector == proxy) {
      self->mExpandoAndGeneration.expando = JS::UndefinedValue();
    }
    ClearWrapper(self, self, proxy);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(proxy, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<nsHTMLDocument>(self);
  }
}

const DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static const DOMProxyHandler instance;
  return &instance;
}

bool
DOMProxyHandler::delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");

  // Try named delete only if the named property visibility
  // algorithm says the property is visible.
  bool tryNamedDelete = true;
  { // Scope for expando
    JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
    if (expando) {
      bool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }
      tryNamedDelete = !hasProp;
    }
  }
  if (tryNamedDelete) {
    bool found = false;
    bool deleteSucceeded;
    FakeString<char16_t> name;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, name, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      nsHTMLDocument* self = UnwrapProxy(proxy);
      FastErrorResult rv;
      JS::Rooted<JSObject*> result(cx);
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedGetter(cx, NonNullHelper(Constify(name)), found, &result, rv))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedGetter(cx, NonNullHelper(Constify(name)), found, &result, rv);
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "HTMLDocument named getter"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      (void)result;
    }
    deleteSucceeded = !found;
    if (found) {
      return deleteSucceeded ? opresult.succeed() : opresult.failCantDelete();
    }
  }

  return dom::DOMProxyHandler::delete_(cx, proxy, id, opresult);
}

size_t
DOMProxyHandler::objectMoved(JSObject* obj, JSObject* old) const
{
  nsHTMLDocument* self = UnwrapPossiblyNotInitializedDOMObject<nsHTMLDocument>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

static const DOMJSClass sClass = {
  PROXY_CLASS_DEF("HTMLDocument",
                  JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(2)),
  { prototypes::id::EventTarget, prototypes::id::Node, prototypes::id::Document, prototypes::id::HTMLDocument, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, nsHTMLDocument>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<nsHTMLDocument>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<nsHTMLDocument>::Get(),
  nullptr,
  nullptr
};

bool
Wrap(JSContext* aCx, nsHTMLDocument* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, nsHTMLDocument>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<nsHTMLDocument*>(aObject) ==
             reinterpret_cast<nsHTMLDocument*>(aObject),
             "Multiple inheritance for nsHTMLDocument is broken.");
  MOZ_ASSERT(static_cast<mozilla::dom::Document*>(aObject) ==
             reinterpret_cast<mozilla::dom::Document*>(aObject),
             "Multiple inheritance for mozilla::dom::Document is broken.");
  MOZ_ASSERT(static_cast<nsINode*>(aObject) ==
             reinterpret_cast<nsINode*>(aObject),
             "Multiple inheritance for nsINode is broken.");
  MOZ_ASSERT(static_cast<mozilla::dom::EventTarget*>(aObject) ==
             reinterpret_cast<mozilla::dom::EventTarget*>(aObject),
             "Multiple inheritance for mozilla::dom::EventTarget is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    DOMProxyHandler::getInstance()->finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<nsHTMLDocument> creator(aCx);
  aObject->mExpandoAndGeneration.expando.setUndefined();
  JS::Rooted<JS::Value> expandoValue(aCx, JS::PrivateValue(&aObject->mExpandoAndGeneration));
  creator.CreateProxyObject(aCx, &sClass.mBase, DOMProxyHandler::getInstance(),
                            proto, /* aLazyProto = */ false, aObject,
                            expandoValue, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);

  // Important: do unforgeable property setup after we have handed
  // over ownership of the C++ object to obj as needed, so that if
  // we fail and it ends up GCed it won't have problems in the
  // finalizer trying to drop its ownership of the C++ object.
  JS::Rooted<JSObject*> expando(aCx,
    DOMProxyHandler::EnsureExpandoObject(aCx, aReflector));
  if (!expando) {
    aCache->ReleaseWrapper(aObject);
    aCache->ClearWrapper();
    return false;
  }
  JS::Rooted<JSObject*> unforgeableHolder(aCx,
    &JS::GetReservedSlot(canonicalProto, DOM_INTERFACE_PROTO_SLOTS_BASE).toObject());
  if (!JS_InitializePropertiesFromCompatibleNativeObject(aCx, expando, unforgeableHolder)) {
    aCache->ReleaseWrapper(aObject);
    aCache->ClearWrapper();
    return false;
  }
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

static bool
ResolveOwnProperty(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::MutableHandle<JS::PropertyDescriptor> desc)
{
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc);
}

static bool
EnumerateOwnProperties(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::MutableHandleVector<jsid> props)
{
  return js::GetProxyHandler(obj)->ownPropertyKeys(cx, wrapper, props);
}

// This may allocate too many slots, because we only really need
// slots for our non-interface-typed members that we cache.  But
// allocating slots only for those would make the slot index
// computations much more complicated, so let's do this the simple
// way for now.
DEFINE_XRAY_EXPANDO_CLASS(static, sXrayExpandoObjectClass, 1);

const NativePropertyHooks sNativePropertyHooks[] = { {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::HTMLDocument,
  constructors::id::HTMLDocument,
  Document_Binding::sNativePropertyHooks,
  &sXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Handle<JSObject*> parentProto(Document_Binding::GetProtoObjectHandle(aCx));
  if (!parentProto) {
    return;
  }

  JS::Handle<JSObject*> constructorProto(Document_Binding::GetConstructorObjectHandle(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::HTMLDocument);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::HTMLDocument);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "HTMLDocument", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);

  JS::Rooted<JSObject*> unforgeableHolder(aCx);
  {
    JS::Rooted<JSObject*> holderProto(aCx, nullptr);
    unforgeableHolder = JS_NewObjectWithoutMetadata(aCx, nullptr, holderProto);
    if (!unforgeableHolder) {
      *protoCache = nullptr;
      if (interfaceCache) {
        *interfaceCache = nullptr;
      }
      return;
    }
  }

  if (!DefineUnforgeableAttributes(aCx, unforgeableHolder, sUnforgeableAttributes)) {
    *protoCache = nullptr;
    if (interfaceCache) {
      *interfaceCache = nullptr;
    }
    return;
  }

  if (*protoCache) {
    JS::SetReservedSlot(*protoCache, DOM_INTERFACE_PROTO_SLOTS_BASE,
                        JS::ObjectValue(*unforgeableHolder));
  }
}

JSObject*
GetProtoObject(JSContext* aCx)
{
  return GetProtoObjectHandle(aCx);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace HTMLDocument_Binding



} // namespace dom
} // namespace mozilla
