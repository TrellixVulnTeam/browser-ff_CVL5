/* THIS FILE IS AUTOGENERATED FROM TestJSImplGen.webidl BY Codegen.py - DO NOT EDIT */

#include <type_traits>
#include "AtomList.h"
#include "GeckoProfiler.h"
#include "TestBindingHeader.h"
#include "TestCImplementedInterface.h"
#include "TestCodeGenBinding.h"
#include "TestDictionaryBinding.h"
#include "TestJSImplGenBinding.h"
#include "WrapperFactory.h"
#include "js/Array.h"
#include "js/ForOfIterator.h"
#include "js/Object.h"
#include "js/experimental/JitInfo.h"
#include "jsapi.h"
#include "jsfriendapi.h"
#include "mozilla/Atomics.h"
#include "mozilla/FloatingPoint.h"
#include "mozilla/OwningNonNull.h"
#include "mozilla/dom/BindingCallContext.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/CustomElementRegistry.h"
#include "mozilla/dom/DOMJSClass.h"
#include "mozilla/dom/DocGroup.h"
#include "mozilla/dom/Document.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/PrimitiveConversions.h"
#include "mozilla/dom/Promise.h"
#include "mozilla/dom/RootedDictionary.h"
#include "mozilla/dom/ToJSValue.h"
#include "mozilla/dom/UnionConversions.h"
#include "mozilla/dom/UnionTypes.h"
#include "mozilla/dom/WebIDLPrefs.h"
#include "mozilla/dom/XrayExpandoClass.h"
#include "nsContentUtils.h"
#include "nsGenericHTMLElement.h"
#include "nsIGlobalObject.h"

namespace mozilla {
namespace dom {

namespace binding_detail {}; // Just to make sure it's known as a namespace
using namespace mozilla::dom::binding_detail;


namespace MyTestEnumValues {
extern const EnumEntry strings[3] = {
  {"a", 1},
  {"b", 1},
  { nullptr, 0 }
};
} // namespace MyTestEnumValues

bool
ToJSValue(JSContext* aCx, MyTestEnum aArgument, JS::MutableHandle<JS::Value> aValue)
{
  MOZ_ASSERT(uint32_t(aArgument) < ArrayLength(MyTestEnumValues::strings));
  JSString* resultStr =
    JS_NewStringCopyN(aCx, MyTestEnumValues::strings[uint32_t(aArgument)].value,
                      MyTestEnumValues::strings[uint32_t(aArgument)].length);
  if (!resultStr) {
    return false;
  }
  aValue.setString(resultStr);
  return true;
}


MOZ_CAN_RUN_SCRIPT void
MyTestCallback::Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}



namespace binding_detail {
} // namespace binding_detail


namespace TestCImplementedInterface_Binding {

static_assert(IsRefcounted<NativeType>::value == IsRefcounted<TestJSImplInterface_Binding::NativeType>::value,
              "Can't inherit from an interface with a different ownership model.");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestCImplementedInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestCImplementedInterface,
  PrototypeTraits<prototypes::id::TestCImplementedInterface>::Depth,
  sNativePropertyHooks,
  "function TestCImplementedInterface() {\n    [native code]\n}",
  TestJSImplInterface_Binding::GetConstructorObject
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestCImplementedInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestCImplementedInterface,
  PrototypeTraits<prototypes::id::TestCImplementedInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  TestJSImplInterface_Binding::GetProtoObject
};

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestCImplementedInterface,
  constructors::id::TestCImplementedInterface,
  TestJSImplInterface_Binding::sNativePropertyHooks,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Handle<JSObject*> parentProto(TestJSImplInterface_Binding::GetProtoObjectHandle(aCx));
  if (!parentProto) {
    return;
  }

  JS::Handle<JSObject*> constructorProto(TestJSImplInterface_Binding::GetConstructorObjectHandle(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestCImplementedInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestCImplementedInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestCImplementedInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetProtoObject(JSContext* aCx)
{
  return GetProtoObjectHandle(aCx);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestCImplementedInterface_Binding



namespace TestCImplementedInterface2_Binding {

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestCImplementedInterface2", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestCImplementedInterface2,
  PrototypeTraits<prototypes::id::TestCImplementedInterface2>::Depth,
  sNativePropertyHooks,
  "function TestCImplementedInterface2() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestCImplementedInterface2Prototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestCImplementedInterface2,
  PrototypeTraits<prototypes::id::TestCImplementedInterface2>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestCImplementedInterface2,
  constructors::id::TestCImplementedInterface2,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestCImplementedInterface2);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestCImplementedInterface2);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestCImplementedInterface2", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetProtoObject(JSContext* aCx)
{
  return GetProtoObjectHandle(aCx);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestCImplementedInterface2_Binding



namespace TestJSImplInterface_Binding {

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "readonlyByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int8_t result(MOZ_KnownLive(self)->GetReadonlyByte(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.readonlyByte getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo readonlyByte_getterinfo = {
  { get_readonlyByte },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int8_t result(MOZ_KnownLive(self)->GetWritableByte(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableByte getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableByte(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableByte(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableByte setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableByte_getterinfo = {
  { get_writableByte },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo writableByte_setterinfo = {
  { (JSJitGetterOp)set_writableByte },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passByte", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassByte(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassByte(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passByte"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passByte_methodinfo = {
  { (JSJitGetterOp)passByte },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int8_t result(MOZ_KnownLive(self)->ReceiveByte(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveByte"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo receiveByte_methodinfo = {
  { (JSJitGetterOp)receiveByte },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<int8_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalByte(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalByte(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalByte"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalByte_methodinfo = {
  { (JSJitGetterOp)passOptionalByte },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalByteBeforeRequired(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalByteBeforeRequired", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passOptionalByteBeforeRequired", 2)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<int8_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  int8_t arg1;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalByteBeforeRequired(Constify(arg0), arg1, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalByteBeforeRequired(Constify(arg0), arg1, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalByteBeforeRequired"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalByteBeforeRequired_methodinfo = {
  { (JSJitGetterOp)passOptionalByteBeforeRequired },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalByteWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalByteWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int8_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 0;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalByteWithDefault(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalByteWithDefault(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalByteWithDefault"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalByteWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalByteWithDefault },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalByteWithDefaultBeforeRequired(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalByteWithDefaultBeforeRequired", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passOptionalByteWithDefaultBeforeRequired", 2)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int8_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 0;
  }
  int8_t arg1;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalByteWithDefaultBeforeRequired(arg0, arg1, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalByteWithDefaultBeforeRequired(arg0, arg1, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalByteWithDefaultBeforeRequired"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalByteWithDefaultBeforeRequired_methodinfo = {
  { (JSJitGetterOp)passOptionalByteWithDefaultBeforeRequired },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableByte", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<int8_t> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableByte(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableByte(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableByte"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableByte_methodinfo = {
  { (JSJitGetterOp)passNullableByte },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Nullable<int8_t>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value().SetValue())) {
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableByte(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableByte(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableByte"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableByte_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableByte },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passVariadicByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  AutoSequence<int8_t> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      int8_t& slot = *arg0.AppendElement();
      if (!ValueToPrimitive<int8_t, eDefault>(cx, args[variadicArg], "Argument 1", &slot)) {
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicByte(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicByte(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passVariadicByte"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicByte_methodinfo = {
  { (JSJitGetterOp)passVariadicByte },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_sideEffectFreeByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "sideEffectFreeByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int8_t result(MOZ_KnownLive(self)->GetSideEffectFreeByte(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.sideEffectFreeByte getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_sideEffectFreeByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "sideEffectFreeByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetSideEffectFreeByte(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetSideEffectFreeByte(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.sideEffectFreeByte setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo sideEffectFreeByte_getterinfo = {
  { get_sideEffectFreeByte },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo sideEffectFreeByte_setterinfo = {
  { (JSJitGetterOp)set_sideEffectFreeByte },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_domDependentByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "domDependentByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int8_t result(MOZ_KnownLive(self)->GetDomDependentByte(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.domDependentByte getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_domDependentByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "domDependentByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetDomDependentByte(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetDomDependentByte(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.domDependentByte setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo domDependentByte_getterinfo = {
  { get_domDependentByte },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo domDependentByte_setterinfo = {
  { (JSJitGetterOp)set_domDependentByte },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_constantByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "constantByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int8_t result(MOZ_KnownLive(self)->GetConstantByte(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.constantByte getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo constantByte_getterinfo = {
  { get_constantByte },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasNone, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_deviceStateDependentByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "deviceStateDependentByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int8_t result(MOZ_KnownLive(self)->GetDeviceStateDependentByte(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.deviceStateDependentByte getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo deviceStateDependentByte_getterinfo = {
  { get_deviceStateDependentByte },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasNone, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
returnByteSideEffectFree(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "returnByteSideEffectFree", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int8_t result(MOZ_KnownLive(self)->ReturnByteSideEffectFree(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.returnByteSideEffectFree"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo::ArgType returnByteSideEffectFree_methodinfo_argTypes[] = { JSJitInfo::ArgTypeListEnd };
static const JSTypedMethodJitInfo returnByteSideEffectFree_methodinfo = {
  {
    { (JSJitGetterOp)returnByteSideEffectFree },
    { prototypes::id::TestJSImplInterface },
    { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
    JSJitInfo::Method,
    JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
    JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
    false,  /* isInfallible. False in setters. */
    false,  /* isMovable.  Not relevant for setters. */
    false, /* isEliminatable.  Not relevant for setters. */
    false, /* isAlwaysInSlot.  Only relevant for getters. */
    false, /* isLazilyCachedInSlot.  Only relevant for getters. */
    true,  /* isTypedMethod.  Only relevant for methods. */
    0   /* Reserved slot index, if we're stored in a slot, else 0. */
  },
  returnByteSideEffectFree_methodinfo_argTypes
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
returnDOMDependentByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "returnDOMDependentByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int8_t result(MOZ_KnownLive(self)->ReturnDOMDependentByte(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.returnDOMDependentByte"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo::ArgType returnDOMDependentByte_methodinfo_argTypes[] = { JSJitInfo::ArgTypeListEnd };
static const JSTypedMethodJitInfo returnDOMDependentByte_methodinfo = {
  {
    { (JSJitGetterOp)returnDOMDependentByte },
    { prototypes::id::TestJSImplInterface },
    { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
    JSJitInfo::Method,
    JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
    JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
    false,  /* isInfallible. False in setters. */
    false,  /* isMovable.  Not relevant for setters. */
    false, /* isEliminatable.  Not relevant for setters. */
    false, /* isAlwaysInSlot.  Only relevant for getters. */
    false, /* isLazilyCachedInSlot.  Only relevant for getters. */
    true,  /* isTypedMethod.  Only relevant for methods. */
    0   /* Reserved slot index, if we're stored in a slot, else 0. */
  },
  returnDOMDependentByte_methodinfo_argTypes
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
returnConstantByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "returnConstantByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int8_t result(MOZ_KnownLive(self)->ReturnConstantByte(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.returnConstantByte"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo::ArgType returnConstantByte_methodinfo_argTypes[] = { JSJitInfo::ArgTypeListEnd };
static const JSTypedMethodJitInfo returnConstantByte_methodinfo = {
  {
    { (JSJitGetterOp)returnConstantByte },
    { prototypes::id::TestJSImplInterface },
    { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
    JSJitInfo::Method,
    JSJitInfo::AliasNone, /* aliasSet.  Not relevant for setters. */
    JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
    false,  /* isInfallible. False in setters. */
    false,  /* isMovable.  Not relevant for setters. */
    false, /* isEliminatable.  Not relevant for setters. */
    false, /* isAlwaysInSlot.  Only relevant for getters. */
    false, /* isLazilyCachedInSlot.  Only relevant for getters. */
    true,  /* isTypedMethod.  Only relevant for methods. */
    0   /* Reserved slot index, if we're stored in a slot, else 0. */
  },
  returnConstantByte_methodinfo_argTypes
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
returnDeviceStateDependentByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "returnDeviceStateDependentByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int8_t result(MOZ_KnownLive(self)->ReturnDeviceStateDependentByte(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.returnDeviceStateDependentByte"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo::ArgType returnDeviceStateDependentByte_methodinfo_argTypes[] = { JSJitInfo::ArgTypeListEnd };
static const JSTypedMethodJitInfo returnDeviceStateDependentByte_methodinfo = {
  {
    { (JSJitGetterOp)returnDeviceStateDependentByte },
    { prototypes::id::TestJSImplInterface },
    { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
    JSJitInfo::Method,
    JSJitInfo::AliasNone, /* aliasSet.  Not relevant for setters. */
    JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
    false,  /* isInfallible. False in setters. */
    false,  /* isMovable.  Not relevant for setters. */
    false, /* isEliminatable.  Not relevant for setters. */
    false, /* isAlwaysInSlot.  Only relevant for getters. */
    false, /* isLazilyCachedInSlot.  Only relevant for getters. */
    true,  /* isTypedMethod.  Only relevant for methods. */
    0   /* Reserved slot index, if we're stored in a slot, else 0. */
  },
  returnDeviceStateDependentByte_methodinfo_argTypes
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "readonlyShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int16_t result(MOZ_KnownLive(self)->GetReadonlyShort(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.readonlyShort getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo readonlyShort_getterinfo = {
  { get_readonlyShort },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int16_t result(MOZ_KnownLive(self)->GetWritableShort(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableShort getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int16_t arg0;
  if (!ValueToPrimitive<int16_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableShort(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableShort(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableShort setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableShort_getterinfo = {
  { get_writableShort },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo writableShort_setterinfo = {
  { (JSJitGetterOp)set_writableShort },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passShort", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int16_t arg0;
  if (!ValueToPrimitive<int16_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassShort(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassShort(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passShort"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passShort_methodinfo = {
  { (JSJitGetterOp)passShort },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int16_t result(MOZ_KnownLive(self)->ReceiveShort(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveShort"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo receiveShort_methodinfo = {
  { (JSJitGetterOp)receiveShort },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<int16_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<int16_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalShort(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalShort(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalShort"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalShort_methodinfo = {
  { (JSJitGetterOp)passOptionalShort },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalShortWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalShortWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int16_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<int16_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 5;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalShortWithDefault(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalShortWithDefault(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalShortWithDefault"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalShortWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalShortWithDefault },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "readonlyLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int32_t result(MOZ_KnownLive(self)->GetReadonlyLong(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.readonlyLong getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo readonlyLong_getterinfo = {
  { get_readonlyLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int32_t result(MOZ_KnownLive(self)->GetWritableLong(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableLong getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableLong(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableLong(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableLong setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableLong_getterinfo = {
  { get_writableLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo writableLong_setterinfo = {
  { (JSJitGetterOp)set_writableLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passLong", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassLong(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassLong(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passLong"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passLong_methodinfo = {
  { (JSJitGetterOp)passLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int32_t result(MOZ_KnownLive(self)->ReceiveLong(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveLong"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo receiveLong_methodinfo = {
  { (JSJitGetterOp)receiveLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<int32_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalLong(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalLong(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalLong"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalLong_methodinfo = {
  { (JSJitGetterOp)passOptionalLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalLongWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalLongWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int32_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 7;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalLongWithDefault(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalLongWithDefault(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalLongWithDefault"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalLongWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalLongWithDefault },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "readonlyLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int64_t result(MOZ_KnownLive(self)->GetReadonlyLongLong(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.readonlyLongLong getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo readonlyLongLong_getterinfo = {
  { get_readonlyLongLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int64_t result(MOZ_KnownLive(self)->GetWritableLongLong(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableLongLong getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int64_t arg0;
  if (!ValueToPrimitive<int64_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableLongLong(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableLongLong(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableLongLong setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableLongLong_getterinfo = {
  { get_writableLongLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo writableLongLong_setterinfo = {
  { (JSJitGetterOp)set_writableLongLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passLongLong", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int64_t arg0;
  if (!ValueToPrimitive<int64_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassLongLong(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassLongLong(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passLongLong"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passLongLong_methodinfo = {
  { (JSJitGetterOp)passLongLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int64_t result(MOZ_KnownLive(self)->ReceiveLongLong(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveLongLong"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo receiveLongLong_methodinfo = {
  { (JSJitGetterOp)receiveLongLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<int64_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<int64_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalLongLong(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalLongLong(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalLongLong"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalLongLong_methodinfo = {
  { (JSJitGetterOp)passOptionalLongLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalLongLongWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalLongLongWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int64_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<int64_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = -12LL;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalLongLongWithDefault(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalLongLongWithDefault(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalLongLongWithDefault"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalLongLongWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalLongLongWithDefault },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyOctet(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "readonlyOctet", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  uint8_t result(MOZ_KnownLive(self)->GetReadonlyOctet(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.readonlyOctet getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo readonlyOctet_getterinfo = {
  { get_readonlyOctet },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableOctet(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableOctet", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  uint8_t result(MOZ_KnownLive(self)->GetWritableOctet(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableOctet getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableOctet(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableOctet", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  uint8_t arg0;
  if (!ValueToPrimitive<uint8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableOctet(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableOctet(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableOctet setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableOctet_getterinfo = {
  { get_writableOctet },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo writableOctet_setterinfo = {
  { (JSJitGetterOp)set_writableOctet },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOctet(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOctet", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passOctet", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  uint8_t arg0;
  if (!ValueToPrimitive<uint8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOctet(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOctet(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOctet"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOctet_methodinfo = {
  { (JSJitGetterOp)passOctet },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveOctet(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveOctet", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  uint8_t result(MOZ_KnownLive(self)->ReceiveOctet(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveOctet"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo receiveOctet_methodinfo = {
  { (JSJitGetterOp)receiveOctet },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalOctet(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalOctet", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<uint8_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<uint8_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalOctet(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalOctet(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalOctet"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalOctet_methodinfo = {
  { (JSJitGetterOp)passOptionalOctet },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalOctetWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalOctetWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  uint8_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<uint8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 19;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalOctetWithDefault(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalOctetWithDefault(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalOctetWithDefault"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalOctetWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalOctetWithDefault },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyUnsignedShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "readonlyUnsignedShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  uint16_t result(MOZ_KnownLive(self)->GetReadonlyUnsignedShort(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.readonlyUnsignedShort getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo readonlyUnsignedShort_getterinfo = {
  { get_readonlyUnsignedShort },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnsignedShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableUnsignedShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  uint16_t result(MOZ_KnownLive(self)->GetWritableUnsignedShort(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableUnsignedShort getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnsignedShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableUnsignedShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  uint16_t arg0;
  if (!ValueToPrimitive<uint16_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnsignedShort(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnsignedShort(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableUnsignedShort setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnsignedShort_getterinfo = {
  { get_writableUnsignedShort },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo writableUnsignedShort_setterinfo = {
  { (JSJitGetterOp)set_writableUnsignedShort },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnsignedShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnsignedShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passUnsignedShort", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  uint16_t arg0;
  if (!ValueToPrimitive<uint16_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnsignedShort(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnsignedShort(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnsignedShort"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnsignedShort_methodinfo = {
  { (JSJitGetterOp)passUnsignedShort },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUnsignedShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveUnsignedShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  uint16_t result(MOZ_KnownLive(self)->ReceiveUnsignedShort(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveUnsignedShort"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo receiveUnsignedShort_methodinfo = {
  { (JSJitGetterOp)receiveUnsignedShort },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnsignedShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalUnsignedShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<uint16_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<uint16_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnsignedShort(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnsignedShort(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalUnsignedShort"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnsignedShort_methodinfo = {
  { (JSJitGetterOp)passOptionalUnsignedShort },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnsignedShortWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalUnsignedShortWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  uint16_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<uint16_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 2;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnsignedShortWithDefault(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnsignedShortWithDefault(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalUnsignedShortWithDefault"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnsignedShortWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalUnsignedShortWithDefault },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyUnsignedLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "readonlyUnsignedLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  uint32_t result(MOZ_KnownLive(self)->GetReadonlyUnsignedLong(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.readonlyUnsignedLong getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setNumber(result);
  return true;
}

static const JSJitInfo readonlyUnsignedLong_getterinfo = {
  { get_readonlyUnsignedLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnsignedLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableUnsignedLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  uint32_t result(MOZ_KnownLive(self)->GetWritableUnsignedLong(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableUnsignedLong getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setNumber(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnsignedLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableUnsignedLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnsignedLong(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnsignedLong(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableUnsignedLong setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnsignedLong_getterinfo = {
  { get_writableUnsignedLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo writableUnsignedLong_setterinfo = {
  { (JSJitGetterOp)set_writableUnsignedLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnsignedLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnsignedLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passUnsignedLong", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnsignedLong(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnsignedLong(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnsignedLong"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnsignedLong_methodinfo = {
  { (JSJitGetterOp)passUnsignedLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUnsignedLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveUnsignedLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  uint32_t result(MOZ_KnownLive(self)->ReceiveUnsignedLong(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveUnsignedLong"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setNumber(result);
  return true;
}

static const JSJitInfo receiveUnsignedLong_methodinfo = {
  { (JSJitGetterOp)receiveUnsignedLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnsignedLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalUnsignedLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<uint32_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnsignedLong(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnsignedLong(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalUnsignedLong"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnsignedLong_methodinfo = {
  { (JSJitGetterOp)passOptionalUnsignedLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnsignedLongWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalUnsignedLongWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  uint32_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 6U;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnsignedLongWithDefault(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnsignedLongWithDefault(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalUnsignedLongWithDefault"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnsignedLongWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalUnsignedLongWithDefault },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyUnsignedLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "readonlyUnsignedLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  uint64_t result(MOZ_KnownLive(self)->GetReadonlyUnsignedLongLong(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.readonlyUnsignedLongLong getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo readonlyUnsignedLongLong_getterinfo = {
  { get_readonlyUnsignedLongLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnsignedLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableUnsignedLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  uint64_t result(MOZ_KnownLive(self)->GetWritableUnsignedLongLong(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableUnsignedLongLong getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnsignedLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableUnsignedLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  uint64_t arg0;
  if (!ValueToPrimitive<uint64_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnsignedLongLong(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnsignedLongLong(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableUnsignedLongLong setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnsignedLongLong_getterinfo = {
  { get_writableUnsignedLongLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo writableUnsignedLongLong_setterinfo = {
  { (JSJitGetterOp)set_writableUnsignedLongLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnsignedLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnsignedLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passUnsignedLongLong", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  uint64_t arg0;
  if (!ValueToPrimitive<uint64_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnsignedLongLong(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnsignedLongLong(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnsignedLongLong"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnsignedLongLong_methodinfo = {
  { (JSJitGetterOp)passUnsignedLongLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUnsignedLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveUnsignedLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  uint64_t result(MOZ_KnownLive(self)->ReceiveUnsignedLongLong(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveUnsignedLongLong"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo receiveUnsignedLongLong_methodinfo = {
  { (JSJitGetterOp)receiveUnsignedLongLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnsignedLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalUnsignedLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<uint64_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<uint64_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnsignedLongLong(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnsignedLongLong(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalUnsignedLongLong"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnsignedLongLong_methodinfo = {
  { (JSJitGetterOp)passOptionalUnsignedLongLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnsignedLongLongWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalUnsignedLongLongWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  uint64_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<uint64_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 17ULL;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnsignedLongLongWithDefault(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnsignedLongLongWithDefault(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalUnsignedLongLongWithDefault"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnsignedLongLongWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalUnsignedLongLongWithDefault },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableFloat(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  float result(MOZ_KnownLive(self)->GetWritableFloat(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableFloat getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableFloat(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.writableFloat setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Value being assigned");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableFloat(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableFloat(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableFloat setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableFloat_getterinfo = {
  { get_writableFloat },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo writableFloat_setterinfo = {
  { (JSJitGetterOp)set_writableFloat },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnrestrictedFloat(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableUnrestrictedFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  float result(MOZ_KnownLive(self)->GetWritableUnrestrictedFloat(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableUnrestrictedFloat getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnrestrictedFloat(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableUnrestrictedFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnrestrictedFloat(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnrestrictedFloat(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableUnrestrictedFloat setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnrestrictedFloat_getterinfo = {
  { get_writableUnrestrictedFloat },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo writableUnrestrictedFloat_setterinfo = {
  { (JSJitGetterOp)set_writableUnrestrictedFloat },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableNullableFloat(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableNullableFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Nullable<float> result(MOZ_KnownLive(self)->GetWritableNullableFloat(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableNullableFloat getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  args.rval().set(JS_NumberValue(double(result.Value())));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableNullableFloat(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.writableNullableFloat setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableNullableFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<float> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Value being assigned", &arg0.SetValue())) {
    return false;
  } else if (!mozilla::IsFinite(arg0.Value())) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Value being assigned");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableNullableFloat(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableNullableFloat(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableNullableFloat setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableNullableFloat_getterinfo = {
  { get_writableNullableFloat },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo writableNullableFloat_setterinfo = {
  { (JSJitGetterOp)set_writableNullableFloat },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableNullableUnrestrictedFloat(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableNullableUnrestrictedFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Nullable<float> result(MOZ_KnownLive(self)->GetWritableNullableUnrestrictedFloat(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableNullableUnrestrictedFloat getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  args.rval().set(JS_NumberValue(double(result.Value())));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableNullableUnrestrictedFloat(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableNullableUnrestrictedFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<float> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Value being assigned", &arg0.SetValue())) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableNullableUnrestrictedFloat(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableNullableUnrestrictedFloat(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableNullableUnrestrictedFloat setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableNullableUnrestrictedFloat_getterinfo = {
  { get_writableNullableUnrestrictedFloat },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo writableNullableUnrestrictedFloat_setterinfo = {
  { (JSJitGetterOp)set_writableNullableUnrestrictedFloat },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableDouble(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  double result(MOZ_KnownLive(self)->GetWritableDouble(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableDouble getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableDouble(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.writableDouble setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Value being assigned");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableDouble(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableDouble(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableDouble setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableDouble_getterinfo = {
  { get_writableDouble },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo writableDouble_setterinfo = {
  { (JSJitGetterOp)set_writableDouble },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnrestrictedDouble(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableUnrestrictedDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  double result(MOZ_KnownLive(self)->GetWritableUnrestrictedDouble(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableUnrestrictedDouble getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnrestrictedDouble(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableUnrestrictedDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnrestrictedDouble(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnrestrictedDouble(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableUnrestrictedDouble setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnrestrictedDouble_getterinfo = {
  { get_writableUnrestrictedDouble },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo writableUnrestrictedDouble_setterinfo = {
  { (JSJitGetterOp)set_writableUnrestrictedDouble },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableNullableDouble(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableNullableDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Nullable<double> result(MOZ_KnownLive(self)->GetWritableNullableDouble(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableNullableDouble getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  args.rval().set(JS_NumberValue(double(result.Value())));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableNullableDouble(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.writableNullableDouble setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableNullableDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<double> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0.SetValue())) {
    return false;
  } else if (!mozilla::IsFinite(arg0.Value())) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Value being assigned");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableNullableDouble(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableNullableDouble(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableNullableDouble setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableNullableDouble_getterinfo = {
  { get_writableNullableDouble },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo writableNullableDouble_setterinfo = {
  { (JSJitGetterOp)set_writableNullableDouble },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableNullableUnrestrictedDouble(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableNullableUnrestrictedDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Nullable<double> result(MOZ_KnownLive(self)->GetWritableNullableUnrestrictedDouble(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableNullableUnrestrictedDouble getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  args.rval().set(JS_NumberValue(double(result.Value())));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableNullableUnrestrictedDouble(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableNullableUnrestrictedDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<double> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0.SetValue())) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableNullableUnrestrictedDouble(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableNullableUnrestrictedDouble(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableNullableUnrestrictedDouble setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableNullableUnrestrictedDouble_getterinfo = {
  { get_writableNullableUnrestrictedDouble },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo writableNullableUnrestrictedDouble_setterinfo = {
  { (JSJitGetterOp)set_writableNullableUnrestrictedDouble },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passFloat(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passFloat");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passFloat", 16)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 1");
    return false;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  }
  Nullable<float> arg2;
  if (args[2].isNullOrUndefined()) {
    arg2.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, args[2], "Argument 3", &arg2.SetValue())) {
    return false;
  } else if (!mozilla::IsFinite(arg2.Value())) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 3");
    return false;
  }
  Nullable<float> arg3;
  if (args[3].isNullOrUndefined()) {
    arg3.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, args[3], "Argument 4", &arg3.SetValue())) {
    return false;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
    return false;
  } else if (!mozilla::IsFinite(arg4)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 5");
    return false;
  }
  double arg5;
  if (!ValueToPrimitive<double, eDefault>(cx, args[5], "Argument 6", &arg5)) {
    return false;
  }
  Nullable<double> arg6;
  if (args[6].isNullOrUndefined()) {
    arg6.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, args[6], "Argument 7", &arg6.SetValue())) {
    return false;
  } else if (!mozilla::IsFinite(arg6.Value())) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 7");
    return false;
  }
  Nullable<double> arg7;
  if (args[7].isNullOrUndefined()) {
    arg7.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, args[7], "Argument 8", &arg7.SetValue())) {
    return false;
  }
  binding_detail::AutoSequence<float> arg8;
  if (args[8].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[8], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 9");
      return false;
    }
    binding_detail::AutoSequence<float> &arr = arg8;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      float* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      float& slot = *slotPtr;
      if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 9", &slot)) {
        return false;
      } else if (!mozilla::IsFinite(slot)) {
        cx.ThrowErrorMessage<MSG_NOT_FINITE>("Element of argument 9");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 9");
    return false;
  }
  binding_detail::AutoSequence<float> arg9;
  if (args[9].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[9], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 10");
      return false;
    }
    binding_detail::AutoSequence<float> &arr = arg9;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      float* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      float& slot = *slotPtr;
      if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 10", &slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 10");
    return false;
  }
  binding_detail::AutoSequence<Nullable<float>> arg10;
  if (args[10].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[10], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 11");
      return false;
    }
    binding_detail::AutoSequence<Nullable<float>> &arr = arg10;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<float>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<float>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 11", &slot.SetValue())) {
        return false;
      } else if (!mozilla::IsFinite(slot.Value())) {
        cx.ThrowErrorMessage<MSG_NOT_FINITE>("Element of argument 11");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 11");
    return false;
  }
  binding_detail::AutoSequence<Nullable<float>> arg11;
  if (args[11].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[11], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 12");
      return false;
    }
    binding_detail::AutoSequence<Nullable<float>> &arr = arg11;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<float>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<float>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 12", &slot.SetValue())) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 12");
    return false;
  }
  binding_detail::AutoSequence<double> arg12;
  if (args[12].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[12], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 13");
      return false;
    }
    binding_detail::AutoSequence<double> &arr = arg12;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      double* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      double& slot = *slotPtr;
      if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 13", &slot)) {
        return false;
      } else if (!mozilla::IsFinite(slot)) {
        cx.ThrowErrorMessage<MSG_NOT_FINITE>("Element of argument 13");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 13");
    return false;
  }
  binding_detail::AutoSequence<double> arg13;
  if (args[13].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[13], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 14");
      return false;
    }
    binding_detail::AutoSequence<double> &arr = arg13;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      double* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      double& slot = *slotPtr;
      if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 14", &slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 14");
    return false;
  }
  binding_detail::AutoSequence<Nullable<double>> arg14;
  if (args[14].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[14], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 15");
      return false;
    }
    binding_detail::AutoSequence<Nullable<double>> &arr = arg14;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<double>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<double>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 15", &slot.SetValue())) {
        return false;
      } else if (!mozilla::IsFinite(slot.Value())) {
        cx.ThrowErrorMessage<MSG_NOT_FINITE>("Element of argument 15");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 15");
    return false;
  }
  binding_detail::AutoSequence<Nullable<double>> arg15;
  if (args[15].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[15], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 16");
      return false;
    }
    binding_detail::AutoSequence<Nullable<double>> &arr = arg15;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<double>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<double>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 16", &slot.SetValue())) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 16");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassFloat(arg0, arg1, Constify(arg2), Constify(arg3), arg4, arg5, Constify(arg6), Constify(arg7), Constify(arg8), Constify(arg9), Constify(arg10), Constify(arg11), Constify(arg12), Constify(arg13), Constify(arg14), Constify(arg15), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassFloat(arg0, arg1, Constify(arg2), Constify(arg3), arg4, arg5, Constify(arg6), Constify(arg7), Constify(arg8), Constify(arg9), Constify(arg10), Constify(arg11), Constify(arg12), Constify(arg13), Constify(arg14), Constify(arg15), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passFloat"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passFloat_methodinfo = {
  { (JSJitGetterOp)passFloat },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passLenientFloat(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passLenientFloat");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passLenientFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passLenientFloat", 16)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  }
  Nullable<float> arg2;
  if (args[2].isNullOrUndefined()) {
    arg2.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, args[2], "Argument 3", &arg2.SetValue())) {
    return false;
  } else if (!mozilla::IsFinite(arg2.Value())) {
    foundNonFiniteFloat = true;
  }
  Nullable<float> arg3;
  if (args[3].isNullOrUndefined()) {
    arg3.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, args[3], "Argument 4", &arg3.SetValue())) {
    return false;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
    return false;
  } else if (!mozilla::IsFinite(arg4)) {
    foundNonFiniteFloat = true;
  }
  double arg5;
  if (!ValueToPrimitive<double, eDefault>(cx, args[5], "Argument 6", &arg5)) {
    return false;
  }
  Nullable<double> arg6;
  if (args[6].isNullOrUndefined()) {
    arg6.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, args[6], "Argument 7", &arg6.SetValue())) {
    return false;
  } else if (!mozilla::IsFinite(arg6.Value())) {
    foundNonFiniteFloat = true;
  }
  Nullable<double> arg7;
  if (args[7].isNullOrUndefined()) {
    arg7.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, args[7], "Argument 8", &arg7.SetValue())) {
    return false;
  }
  binding_detail::AutoSequence<float> arg8;
  if (args[8].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[8], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 9");
      return false;
    }
    binding_detail::AutoSequence<float> &arr = arg8;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      float* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      float& slot = *slotPtr;
      if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 9", &slot)) {
        return false;
      } else if (!mozilla::IsFinite(slot)) {
        foundNonFiniteFloat = true;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 9");
    return false;
  }
  binding_detail::AutoSequence<float> arg9;
  if (args[9].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[9], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 10");
      return false;
    }
    binding_detail::AutoSequence<float> &arr = arg9;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      float* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      float& slot = *slotPtr;
      if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 10", &slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 10");
    return false;
  }
  binding_detail::AutoSequence<Nullable<float>> arg10;
  if (args[10].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[10], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 11");
      return false;
    }
    binding_detail::AutoSequence<Nullable<float>> &arr = arg10;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<float>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<float>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 11", &slot.SetValue())) {
        return false;
      } else if (!mozilla::IsFinite(slot.Value())) {
        foundNonFiniteFloat = true;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 11");
    return false;
  }
  binding_detail::AutoSequence<Nullable<float>> arg11;
  if (args[11].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[11], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 12");
      return false;
    }
    binding_detail::AutoSequence<Nullable<float>> &arr = arg11;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<float>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<float>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 12", &slot.SetValue())) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 12");
    return false;
  }
  binding_detail::AutoSequence<double> arg12;
  if (args[12].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[12], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 13");
      return false;
    }
    binding_detail::AutoSequence<double> &arr = arg12;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      double* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      double& slot = *slotPtr;
      if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 13", &slot)) {
        return false;
      } else if (!mozilla::IsFinite(slot)) {
        foundNonFiniteFloat = true;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 13");
    return false;
  }
  binding_detail::AutoSequence<double> arg13;
  if (args[13].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[13], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 14");
      return false;
    }
    binding_detail::AutoSequence<double> &arr = arg13;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      double* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      double& slot = *slotPtr;
      if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 14", &slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 14");
    return false;
  }
  binding_detail::AutoSequence<Nullable<double>> arg14;
  if (args[14].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[14], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 15");
      return false;
    }
    binding_detail::AutoSequence<Nullable<double>> &arr = arg14;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<double>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<double>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 15", &slot.SetValue())) {
        return false;
      } else if (!mozilla::IsFinite(slot.Value())) {
        foundNonFiniteFloat = true;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 15");
    return false;
  }
  binding_detail::AutoSequence<Nullable<double>> arg15;
  if (args[15].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[15], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 16");
      return false;
    }
    binding_detail::AutoSequence<Nullable<double>> &arr = arg15;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<double>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<double>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 16", &slot.SetValue())) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 16");
    return false;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassLenientFloat(arg0, arg1, Constify(arg2), Constify(arg3), arg4, arg5, Constify(arg6), Constify(arg7), Constify(arg8), Constify(arg9), Constify(arg10), Constify(arg11), Constify(arg12), Constify(arg13), Constify(arg14), Constify(arg15), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassLenientFloat(arg0, arg1, Constify(arg2), Constify(arg3), arg4, arg5, Constify(arg6), Constify(arg7), Constify(arg8), Constify(arg9), Constify(arg10), Constify(arg11), Constify(arg12), Constify(arg13), Constify(arg14), Constify(arg15), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passLenientFloat"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passLenientFloat_methodinfo = {
  { (JSJitGetterOp)passLenientFloat },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_lenientFloatAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "lenientFloatAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  float result(MOZ_KnownLive(self)->GetLenientFloatAttr(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.lenientFloatAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_lenientFloatAttr(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.lenientFloatAttr setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "lenientFloatAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  bool foundNonFiniteFloat = false;
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    return true;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetLenientFloatAttr(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetLenientFloatAttr(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.lenientFloatAttr setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo lenientFloatAttr_getterinfo = {
  { get_lenientFloatAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo lenientFloatAttr_setterinfo = {
  { (JSJitGetterOp)set_lenientFloatAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_lenientDoubleAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "lenientDoubleAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  double result(MOZ_KnownLive(self)->GetLenientDoubleAttr(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.lenientDoubleAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_lenientDoubleAttr(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.lenientDoubleAttr setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "lenientDoubleAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  bool foundNonFiniteFloat = false;
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    return true;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetLenientDoubleAttr(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetLenientDoubleAttr(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.lenientDoubleAttr setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo lenientDoubleAttr_getterinfo = {
  { get_lenientDoubleAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo lenientDoubleAttr_setterinfo = {
  { (JSJitGetterOp)set_lenientDoubleAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveSelf(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestJSImplInterface>(MOZ_KnownLive(self)->ReceiveSelf(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveSelf"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo receiveSelf_methodinfo = {
  { (JSJitGetterOp)receiveSelf },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableSelf(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestJSImplInterface>(MOZ_KnownLive(self)->ReceiveNullableSelf(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableSelf"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableSelf_methodinfo = {
  { (JSJitGetterOp)receiveNullableSelf },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakSelf(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveWeakSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestJSImplInterface>(MOZ_KnownLive(self)->ReceiveWeakSelf(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveWeakSelf"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo receiveWeakSelf_methodinfo = {
  { (JSJitGetterOp)receiveWeakSelf },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakNullableSelf(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveWeakNullableSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestJSImplInterface>(MOZ_KnownLive(self)->ReceiveWeakNullableSelf(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveWeakNullableSelf"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo receiveWeakNullableSelf_methodinfo = {
  { (JSJitGetterOp)receiveWeakNullableSelf },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSelf(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passSelf");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passSelf", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  NonNull<mozilla::dom::TestJSImplInterface> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestJSImplInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSelf(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSelf(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passSelf"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSelf_methodinfo = {
  { (JSJitGetterOp)passSelf },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableSelf(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableSelf");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableSelf", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  mozilla::dom::TestJSImplInterface* arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestJSImplInterface");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableSelf(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableSelf(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableSelf"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableSelf_methodinfo = {
  { (JSJitGetterOp)passNullableSelf },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nonNullSelf(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "nonNullSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestJSImplInterface>(MOZ_KnownLive(self)->GetNonNullSelf(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.nonNullSelf getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_nonNullSelf(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.nonNullSelf setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "nonNullSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  NonNull<mozilla::dom::TestJSImplInterface> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "TestJSImplInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNonNullSelf(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNonNullSelf(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.nonNullSelf setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nonNullSelf_getterinfo = {
  { get_nonNullSelf },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo nonNullSelf_setterinfo = {
  { (JSJitGetterOp)set_nonNullSelf },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nullableSelf(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "nullableSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestJSImplInterface>(MOZ_KnownLive(self)->GetNullableSelf(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.nullableSelf getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_nullableSelf(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.nullableSelf setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "nullableSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  mozilla::dom::TestJSImplInterface* arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "TestJSImplInterface");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNullableSelf(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNullableSelf(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.nullableSelf setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nullableSelf_getterinfo = {
  { get_nullableSelf },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo nullableSelf_setterinfo = {
  { (JSJitGetterOp)set_nullableSelf },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSelf(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalSelf");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<mozilla::dom::TestJSImplInterface*> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      {
        // Our JSContext should be in the right global to do unwrapping in.
        nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(args[0], arg0.Value(), cx);
        if (NS_FAILED(rv)) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestJSImplInterface");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value() = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSelf(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSelf(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalSelf"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSelf_methodinfo = {
  { (JSJitGetterOp)passOptionalSelf },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNonNullSelf(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNonNullSelf");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNonNullSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<NonNull<mozilla::dom::TestJSImplInterface>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      {
        // Our JSContext should be in the right global to do unwrapping in.
        nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(args[0], arg0.Value(), cx);
        if (NS_FAILED(rv)) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestJSImplInterface");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNonNullSelf(MOZ_KnownLive(NonNullHelper(Constify(arg0))), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNonNullSelf(MOZ_KnownLive(NonNullHelper(Constify(arg0))), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNonNullSelf"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNonNullSelf_methodinfo = {
  { (JSJitGetterOp)passOptionalNonNullSelf },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSelfWithDefault(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalSelfWithDefault");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalSelfWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  mozilla::dom::TestJSImplInterface* arg0;
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      {
        // Our JSContext should be in the right global to do unwrapping in.
        nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(args[0], arg0, cx);
        if (NS_FAILED(rv)) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestJSImplInterface");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSelfWithDefault(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSelfWithDefault(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalSelfWithDefault"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSelfWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalSelfWithDefault },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNonWrapperCacheInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNonWrapperCacheInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestNonWrapperCacheInterface>(MOZ_KnownLive(self)->ReceiveNonWrapperCacheInterface(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNonWrapperCacheInterface"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo receiveNonWrapperCacheInterface_methodinfo = {
  { (JSJitGetterOp)receiveNonWrapperCacheInterface },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableNonWrapperCacheInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableNonWrapperCacheInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestNonWrapperCacheInterface>(MOZ_KnownLive(self)->ReceiveNullableNonWrapperCacheInterface(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableNonWrapperCacheInterface"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableNonWrapperCacheInterface_methodinfo = {
  { (JSJitGetterOp)receiveNullableNonWrapperCacheInterface },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNonWrapperCacheInterfaceSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNonWrapperCacheInterfaceSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  nsTArray<StrongPtrForMember<mozilla::dom::TestNonWrapperCacheInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNonWrapperCacheInterfaceSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNonWrapperCacheInterfaceSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNonWrapperCacheInterfaceSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapNewBindingNonWrapperCachedObject(cx, returnArray, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNonWrapperCacheInterfaceSequence_methodinfo = {
  { (JSJitGetterOp)receiveNonWrapperCacheInterfaceSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableNonWrapperCacheInterfaceSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableNonWrapperCacheInterfaceSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  nsTArray<StrongPtrForMember<mozilla::dom::TestNonWrapperCacheInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableNonWrapperCacheInterfaceSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableNonWrapperCacheInterfaceSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableNonWrapperCacheInterfaceSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result[sequenceIdx0]) {
          tmp.setNull();
          break;
        }
        if (!WrapNewBindingNonWrapperCachedObject(cx, returnArray, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableNonWrapperCacheInterfaceSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableNonWrapperCacheInterfaceSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNonWrapperCacheInterfaceNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNonWrapperCacheInterfaceNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Nullable<nsTArray<StrongPtrForMember<mozilla::dom::TestNonWrapperCacheInterface>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNonWrapperCacheInterfaceNullableSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNonWrapperCacheInterfaceNullableSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNonWrapperCacheInterfaceNullableSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapNewBindingNonWrapperCachedObject(cx, returnArray, result.Value()[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNonWrapperCacheInterfaceNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveNonWrapperCacheInterfaceNullableSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableNonWrapperCacheInterfaceNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableNonWrapperCacheInterfaceNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Nullable<nsTArray<StrongPtrForMember<mozilla::dom::TestNonWrapperCacheInterface>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableNonWrapperCacheInterfaceNullableSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableNonWrapperCacheInterfaceNullableSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableNonWrapperCacheInterfaceNullableSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result.Value()[sequenceIdx0]) {
          tmp.setNull();
          break;
        }
        if (!WrapNewBindingNonWrapperCachedObject(cx, returnArray, result.Value()[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableNonWrapperCacheInterfaceNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableNonWrapperCacheInterfaceNullableSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveExternal(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestExternalInterface>(MOZ_KnownLive(self)->ReceiveExternal(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveExternal"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveExternal_methodinfo = {
  { (JSJitGetterOp)receiveExternal },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableExternal(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestExternalInterface>(MOZ_KnownLive(self)->ReceiveNullableExternal(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableExternal"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableExternal_methodinfo = {
  { (JSJitGetterOp)receiveNullableExternal },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakExternal(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveWeakExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestExternalInterface>(MOZ_KnownLive(self)->ReceiveWeakExternal(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveWeakExternal"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveWeakExternal_methodinfo = {
  { (JSJitGetterOp)receiveWeakExternal },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakNullableExternal(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveWeakNullableExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestExternalInterface>(MOZ_KnownLive(self)->ReceiveWeakNullableExternal(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveWeakNullableExternal"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveWeakNullableExternal_methodinfo = {
  { (JSJitGetterOp)receiveWeakNullableExternal },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passExternal(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passExternal");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passExternal", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  mozilla::dom::TestExternalInterface* arg0;
  RefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  if (args[0].isObject()) {
    JS::Rooted<JSObject*> source(cx, &args[0].toObject());
    if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestExternalInterface");
      return false;
    }
    MOZ_ASSERT(arg0_holder);
    arg0 = arg0_holder;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassExternal(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassExternal(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passExternal"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passExternal_methodinfo = {
  { (JSJitGetterOp)passExternal },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableExternal(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableExternal");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableExternal", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  mozilla::dom::TestExternalInterface* arg0;
  RefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  if (args[0].isObject()) {
    JS::Rooted<JSObject*> source(cx, &args[0].toObject());
    if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestExternalInterface");
      return false;
    }
    MOZ_ASSERT(arg0_holder);
    arg0 = arg0_holder;
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableExternal(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableExternal(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableExternal"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableExternal_methodinfo = {
  { (JSJitGetterOp)passNullableExternal },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nonNullExternal(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "nonNullExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestExternalInterface>(MOZ_KnownLive(self)->GetNonNullExternal(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.nonNullExternal getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_nonNullExternal(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.nonNullExternal setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "nonNullExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  mozilla::dom::TestExternalInterface* arg0;
  RefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  if (args[0].isObject()) {
    JS::Rooted<JSObject*> source(cx, &args[0].toObject());
    if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "TestExternalInterface");
      return false;
    }
    MOZ_ASSERT(arg0_holder);
    arg0 = arg0_holder;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNonNullExternal(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNonNullExternal(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.nonNullExternal setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nonNullExternal_getterinfo = {
  { get_nonNullExternal },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo nonNullExternal_setterinfo = {
  { (JSJitGetterOp)set_nonNullExternal },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nullableExternal(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "nullableExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestExternalInterface>(MOZ_KnownLive(self)->GetNullableExternal(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.nullableExternal getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_nullableExternal(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.nullableExternal setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "nullableExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  mozilla::dom::TestExternalInterface* arg0;
  RefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  if (args[0].isObject()) {
    JS::Rooted<JSObject*> source(cx, &args[0].toObject());
    if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "TestExternalInterface");
      return false;
    }
    MOZ_ASSERT(arg0_holder);
    arg0 = arg0_holder;
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNullableExternal(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNullableExternal(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.nullableExternal setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nullableExternal_getterinfo = {
  { get_nullableExternal },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo nullableExternal_setterinfo = {
  { (JSJitGetterOp)set_nullableExternal },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalExternal(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalExternal");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<mozilla::dom::TestExternalInterface*> arg0;
  Maybe<RefPtr<mozilla::dom::TestExternalInterface>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace();
    if (args[0].isObject()) {
      JS::Rooted<JSObject*> source(cx, &args[0].toObject());
      if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder.ref())))) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestExternalInterface");
        return false;
      }
      MOZ_ASSERT(arg0_holder.ref());
      arg0.Value() = arg0_holder.ref();
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value() = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalExternal(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalExternal(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalExternal"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalExternal_methodinfo = {
  { (JSJitGetterOp)passOptionalExternal },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNonNullExternal(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNonNullExternal");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNonNullExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<mozilla::dom::TestExternalInterface*> arg0;
  Maybe<RefPtr<mozilla::dom::TestExternalInterface>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace();
    if (args[0].isObject()) {
      JS::Rooted<JSObject*> source(cx, &args[0].toObject());
      if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder.ref())))) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestExternalInterface");
        return false;
      }
      MOZ_ASSERT(arg0_holder.ref());
      arg0.Value() = arg0_holder.ref();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNonNullExternal(MOZ_KnownLive(NonNullHelper(Constify(arg0))), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNonNullExternal(MOZ_KnownLive(NonNullHelper(Constify(arg0))), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNonNullExternal"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNonNullExternal_methodinfo = {
  { (JSJitGetterOp)passOptionalNonNullExternal },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalExternalWithDefault(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalExternalWithDefault");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalExternalWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  mozilla::dom::TestExternalInterface* arg0;
  RefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      JS::Rooted<JSObject*> source(cx, &args[0].toObject());
      if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder)))) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestExternalInterface");
        return false;
      }
      MOZ_ASSERT(arg0_holder);
      arg0 = arg0_holder;
    } else if (args[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalExternalWithDefault(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalExternalWithDefault(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalExternalWithDefault"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalExternalWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalExternalWithDefault },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveCallbackInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->ReceiveCallbackInterface(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveCallbackInterface"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveCallbackInterface_methodinfo = {
  { (JSJitGetterOp)receiveCallbackInterface },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableCallbackInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->ReceiveNullableCallbackInterface(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableCallbackInterface"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static const JSJitInfo receiveNullableCallbackInterface_methodinfo = {
  { (JSJitGetterOp)receiveNullableCallbackInterface },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakCallbackInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveWeakCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->ReceiveWeakCallbackInterface(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveWeakCallbackInterface"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveWeakCallbackInterface_methodinfo = {
  { (JSJitGetterOp)receiveWeakCallbackInterface },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakNullableCallbackInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveWeakNullableCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->ReceiveWeakNullableCallbackInterface(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveWeakNullableCallbackInterface"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static const JSJitInfo receiveWeakNullableCallbackInterface_methodinfo = {
  { (JSJitGetterOp)receiveWeakNullableCallbackInterface },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passCallbackInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passCallbackInterface");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passCallbackInterface", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestCallbackInterface>> arg0(cx);
  if (args[0].isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassCallbackInterface(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassCallbackInterface(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passCallbackInterface"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passCallbackInterface_methodinfo = {
  { (JSJitGetterOp)passCallbackInterface },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableCallbackInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableCallbackInterface");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableCallbackInterface", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedCallback<RefPtr<binding_detail::FastTestCallbackInterface>> arg0(cx);
  if (args[0].isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableCallbackInterface(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableCallbackInterface(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableCallbackInterface"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableCallbackInterface_methodinfo = {
  { (JSJitGetterOp)passNullableCallbackInterface },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nonNullCallbackInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "nonNullCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->GetNonNullCallbackInterface(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.nonNullCallbackInterface getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_nonNullCallbackInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.nonNullCallbackInterface setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "nonNullCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestCallbackInterface>> arg0(cx);
  if (args[0].isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNonNullCallbackInterface(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNonNullCallbackInterface(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.nonNullCallbackInterface setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nonNullCallbackInterface_getterinfo = {
  { get_nonNullCallbackInterface },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo nonNullCallbackInterface_setterinfo = {
  { (JSJitGetterOp)set_nonNullCallbackInterface },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nullableCallbackInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "nullableCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->GetNullableCallbackInterface(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.nullableCallbackInterface getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

MOZ_CAN_RUN_SCRIPT static bool
set_nullableCallbackInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.nullableCallbackInterface setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "nullableCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedCallback<RefPtr<binding_detail::FastTestCallbackInterface>> arg0(cx);
  if (args[0].isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNullableCallbackInterface(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNullableCallbackInterface(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.nullableCallbackInterface setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nullableCallbackInterface_getterinfo = {
  { get_nullableCallbackInterface },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo nullableCallbackInterface_setterinfo = {
  { (JSJitGetterOp)set_nullableCallbackInterface },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalCallbackInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalCallbackInterface");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<RefPtr<TestCallbackInterface>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      { // scope for tempRoot and tempGlobalRoot if needed
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
        arg0.Value() = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value() = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalCallbackInterface(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalCallbackInterface(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalCallbackInterface"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalCallbackInterface_methodinfo = {
  { (JSJitGetterOp)passOptionalCallbackInterface },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNonNullCallbackInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNonNullCallbackInterface");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNonNullCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<OwningNonNull<TestCallbackInterface>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      { // scope for tempRoot and tempGlobalRoot if needed
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
        arg0.Value() = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNonNullCallbackInterface(MOZ_KnownLive(NonNullHelper(Constify(arg0))), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNonNullCallbackInterface(MOZ_KnownLive(NonNullHelper(Constify(arg0))), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNonNullCallbackInterface"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNonNullCallbackInterface_methodinfo = {
  { (JSJitGetterOp)passOptionalNonNullCallbackInterface },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalCallbackInterfaceWithDefault(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalCallbackInterfaceWithDefault");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalCallbackInterfaceWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedCallback<RefPtr<binding_detail::FastTestCallbackInterface>> arg0(cx);
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      { // scope for tempRoot and tempGlobalRoot if needed
        arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalCallbackInterfaceWithDefault(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalCallbackInterfaceWithDefault(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalCallbackInterfaceWithDefault"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalCallbackInterfaceWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalCallbackInterfaceWithDefault },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  nsTArray<int32_t> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        tmp.setInt32(int32_t(result[sequenceIdx0]));
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveSequence_methodinfo = {
  { (JSJitGetterOp)receiveSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Nullable<nsTArray<int32_t>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        tmp.setInt32(int32_t(result.Value()[sequenceIdx0]));
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveSequenceOfNullableInts(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveSequenceOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  nsTArray<Nullable<int32_t>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveSequenceOfNullableInts(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveSequenceOfNullableInts(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveSequenceOfNullableInts"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (result[sequenceIdx0].IsNull()) {
          tmp.setNull();
          break;
        }
        tmp.setInt32(int32_t(result[sequenceIdx0].Value()));
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveSequenceOfNullableInts_methodinfo = {
  { (JSJitGetterOp)receiveSequenceOfNullableInts },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableSequenceOfNullableInts(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableSequenceOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Nullable<nsTArray<Nullable<int32_t>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableSequenceOfNullableInts(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableSequenceOfNullableInts(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableSequenceOfNullableInts"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (result.Value()[sequenceIdx0].IsNull()) {
          tmp.setNull();
          break;
        }
        tmp.setInt32(int32_t(result.Value()[sequenceIdx0].Value()));
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableSequenceOfNullableInts_methodinfo = {
  { (JSJitGetterOp)receiveNullableSequenceOfNullableInts },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passSequence", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<int32_t> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<int32_t> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      int32_t& slot = *slotPtr;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequence_methodinfo = {
  { (JSJitGetterOp)passSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableSequence", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<Sequence<int32_t>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    Sequence<int32_t> &arr = arg0.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      int32_t& slot = *slotPtr;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableSequence_methodinfo = {
  { (JSJitGetterOp)passNullableSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfNullableInts(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passSequenceOfNullableInts");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passSequenceOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passSequenceOfNullableInts", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<Nullable<int32_t>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Nullable<int32_t>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<int32_t>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<int32_t>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot.SetValue())) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfNullableInts(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfNullableInts(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passSequenceOfNullableInts"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfNullableInts_methodinfo = {
  { (JSJitGetterOp)passSequenceOfNullableInts },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSequenceOfNullableInts(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalSequenceOfNullableInts");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalSequenceOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Sequence<Nullable<int32_t>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<Nullable<int32_t>> &arr = arg0.Value();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Nullable<int32_t>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Nullable<int32_t>& slot = *slotPtr;
        if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot.SetValue())) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSequenceOfNullableInts(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSequenceOfNullableInts(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalSequenceOfNullableInts"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSequenceOfNullableInts_methodinfo = {
  { (JSJitGetterOp)passOptionalSequenceOfNullableInts },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceOfNullableInts(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableSequenceOfNullableInts");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableSequenceOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Nullable<Sequence<Nullable<int32_t>>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<Nullable<int32_t>> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Nullable<int32_t>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Nullable<int32_t>& slot = *slotPtr;
        if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot.SetValue())) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableInts(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableInts(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableSequenceOfNullableInts"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceOfNullableInts_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceOfNullableInts },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveCastableObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveCastableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  nsTArray<StrongPtrForMember<mozilla::dom::TestJSImplInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveCastableObjectSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveCastableObjectSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveCastableObjectSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!GetOrCreateDOMReflector(cx, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveCastableObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveCastableObjectSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveCallbackObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveCallbackObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  nsTArray<StrongPtrForMember<mozilla::dom::TestCallbackInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveCallbackObjectSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveCallbackObjectSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveCallbackObjectSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        tmp.setObjectOrNull(GetCallbackFromCallbackObject(cx, result[sequenceIdx0]));
        if (!MaybeWrapObjectValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveCallbackObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveCallbackObjectSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableCastableObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableCastableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  nsTArray<StrongPtrForMember<mozilla::dom::TestJSImplInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableCastableObjectSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableCastableObjectSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableCastableObjectSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result[sequenceIdx0]) {
          tmp.setNull();
          break;
        }
        if (!GetOrCreateDOMReflector(cx, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableCastableObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableCastableObjectSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableCallbackObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableCallbackObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  nsTArray<StrongPtrForMember<mozilla::dom::TestCallbackInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableCallbackObjectSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableCallbackObjectSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableCallbackObjectSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (result[sequenceIdx0]) {
          tmp.setObjectOrNull(GetCallbackFromCallbackObject(cx, result[sequenceIdx0]));
          if (!MaybeWrapObjectOrNullValue(cx, &tmp)) {
            return false;
          }
          break;
        } else {
          tmp.setNull();
          break;
        }
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableCallbackObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableCallbackObjectSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveCastableObjectNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveCastableObjectNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Nullable<nsTArray<StrongPtrForMember<mozilla::dom::TestJSImplInterface>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveCastableObjectNullableSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveCastableObjectNullableSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveCastableObjectNullableSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!GetOrCreateDOMReflector(cx, result.Value()[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveCastableObjectNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveCastableObjectNullableSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableCastableObjectNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableCastableObjectNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Nullable<nsTArray<StrongPtrForMember<mozilla::dom::TestJSImplInterface>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableCastableObjectNullableSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableCastableObjectNullableSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableCastableObjectNullableSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result.Value()[sequenceIdx0]) {
          tmp.setNull();
          break;
        }
        if (!GetOrCreateDOMReflector(cx, result.Value()[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableCastableObjectNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableCastableObjectNullableSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakCastableObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveWeakCastableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  nsTArray<StrongPtrForMember<mozilla::dom::TestJSImplInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveWeakCastableObjectSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveWeakCastableObjectSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveWeakCastableObjectSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!GetOrCreateDOMReflector(cx, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveWeakCastableObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveWeakCastableObjectSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakNullableCastableObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveWeakNullableCastableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  nsTArray<StrongPtrForMember<mozilla::dom::TestJSImplInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveWeakNullableCastableObjectSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveWeakNullableCastableObjectSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveWeakNullableCastableObjectSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result[sequenceIdx0]) {
          tmp.setNull();
          break;
        }
        if (!GetOrCreateDOMReflector(cx, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveWeakNullableCastableObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveWeakNullableCastableObjectSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakCastableObjectNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveWeakCastableObjectNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Nullable<nsTArray<StrongPtrForMember<mozilla::dom::TestJSImplInterface>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveWeakCastableObjectNullableSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveWeakCastableObjectNullableSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveWeakCastableObjectNullableSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!GetOrCreateDOMReflector(cx, result.Value()[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveWeakCastableObjectNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveWeakCastableObjectNullableSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakNullableCastableObjectNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveWeakNullableCastableObjectNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Nullable<nsTArray<StrongPtrForMember<mozilla::dom::TestJSImplInterface>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveWeakNullableCastableObjectNullableSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveWeakNullableCastableObjectNullableSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveWeakNullableCastableObjectNullableSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result.Value()[sequenceIdx0]) {
          tmp.setNull();
          break;
        }
        if (!GetOrCreateDOMReflector(cx, result.Value()[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveWeakNullableCastableObjectNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveWeakNullableCastableObjectNullableSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passCastableObjectSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passCastableObjectSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passCastableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passCastableObjectSequence", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<OwningNonNull<mozilla::dom::TestJSImplInterface>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<OwningNonNull<mozilla::dom::TestJSImplInterface>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      OwningNonNull<mozilla::dom::TestJSImplInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      OwningNonNull<mozilla::dom::TestJSImplInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestJSImplInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassCastableObjectSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassCastableObjectSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passCastableObjectSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passCastableObjectSequence_methodinfo = {
  { (JSJitGetterOp)passCastableObjectSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableCastableObjectSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableCastableObjectSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableCastableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableCastableObjectSequence", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<RefPtr<mozilla::dom::TestJSImplInterface>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<RefPtr<mozilla::dom::TestJSImplInterface>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestJSImplInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      RefPtr<mozilla::dom::TestJSImplInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestJSImplInterface");
            return false;
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableCastableObjectSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableCastableObjectSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableCastableObjectSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableCastableObjectSequence_methodinfo = {
  { (JSJitGetterOp)passNullableCastableObjectSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passCastableObjectNullableSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passCastableObjectNullableSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passCastableObjectNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passCastableObjectNullableSequence", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<Sequence<OwningNonNull<mozilla::dom::TestJSImplInterface>>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    Sequence<OwningNonNull<mozilla::dom::TestJSImplInterface>> &arr = arg0.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      OwningNonNull<mozilla::dom::TestJSImplInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      OwningNonNull<mozilla::dom::TestJSImplInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestJSImplInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassCastableObjectNullableSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassCastableObjectNullableSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passCastableObjectNullableSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passCastableObjectNullableSequence_methodinfo = {
  { (JSJitGetterOp)passCastableObjectNullableSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableCastableObjectNullableSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableCastableObjectNullableSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableCastableObjectNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableCastableObjectNullableSequence", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<Sequence<RefPtr<mozilla::dom::TestJSImplInterface>>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    Sequence<RefPtr<mozilla::dom::TestJSImplInterface>> &arr = arg0.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestJSImplInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      RefPtr<mozilla::dom::TestJSImplInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestJSImplInterface");
            return false;
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableCastableObjectNullableSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableCastableObjectNullableSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableCastableObjectNullableSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableCastableObjectNullableSequence_methodinfo = {
  { (JSJitGetterOp)passNullableCastableObjectNullableSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Sequence<int32_t>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<int32_t> &arr = arg0.Value();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSequence_methodinfo = {
  { (JSJitGetterOp)passOptionalSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSequenceWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalSequenceWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalSequenceWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<int32_t> arg0;
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      binding_detail::AutoSequence<int32_t> &arr = arg0;
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  } else {
    /* arg0 array is already empty; nothing to do */
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSequenceWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSequenceWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalSequenceWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSequenceWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalSequenceWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Nullable<Sequence<int32_t>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<int32_t> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequence_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableSequenceWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableSequenceWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<Sequence<int32_t>> arg0;
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<int32_t> &arr = arg0.SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  } else {
    arg0.SetNull();
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableSequenceWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceWithDefaultValue2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableSequenceWithDefaultValue2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableSequenceWithDefaultValue2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<Sequence<int32_t>> arg0;
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<int32_t> &arr = arg0.SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  } else {
    arg0.SetValue();
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceWithDefaultValue2(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceWithDefaultValue2(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableSequenceWithDefaultValue2"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceWithDefaultValue2_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceWithDefaultValue2 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalObjectSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalObjectSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Sequence<OwningNonNull<mozilla::dom::TestJSImplInterface>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<OwningNonNull<mozilla::dom::TestJSImplInterface>> &arr = arg0.Value();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        OwningNonNull<mozilla::dom::TestJSImplInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        OwningNonNull<mozilla::dom::TestJSImplInterface>& slot = *slotPtr;
        if (temp.isObject()) {
          static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(&temp, slot, cx);
            if (NS_FAILED(rv)) {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestJSImplInterface");
              return false;
            }
          }
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalObjectSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalObjectSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalObjectSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalObjectSequence_methodinfo = {
  { (JSJitGetterOp)passOptionalObjectSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passExternalInterfaceSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passExternalInterfaceSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passExternalInterfaceSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passExternalInterfaceSequence", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<RefPtr<mozilla::dom::TestExternalInterface>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<RefPtr<mozilla::dom::TestExternalInterface>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestExternalInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      RefPtr<mozilla::dom::TestExternalInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
        RefPtr<mozilla::dom::TestExternalInterface> tempHolder;
        JS::Rooted<JSObject*> source(cx, &temp.toObject());
        if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(tempHolder)))) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestExternalInterface");
          return false;
        }
        MOZ_ASSERT(tempHolder);
        slot = tempHolder;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassExternalInterfaceSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassExternalInterfaceSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passExternalInterfaceSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passExternalInterfaceSequence_methodinfo = {
  { (JSJitGetterOp)passExternalInterfaceSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableExternalInterfaceSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableExternalInterfaceSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableExternalInterfaceSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableExternalInterfaceSequence", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<RefPtr<mozilla::dom::TestExternalInterface>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<RefPtr<mozilla::dom::TestExternalInterface>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestExternalInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      RefPtr<mozilla::dom::TestExternalInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
        RefPtr<mozilla::dom::TestExternalInterface> tempHolder;
        JS::Rooted<JSObject*> source(cx, &temp.toObject());
        if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(tempHolder)))) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestExternalInterface");
          return false;
        }
        MOZ_ASSERT(tempHolder);
        slot = tempHolder;
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableExternalInterfaceSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableExternalInterfaceSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableExternalInterfaceSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableExternalInterfaceSequence_methodinfo = {
  { (JSJitGetterOp)passNullableExternalInterfaceSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveStringSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveStringSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  nsTArray<nsString> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveStringSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveStringSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveStringSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!xpc::NonVoidStringToJsval(cx, result[sequenceIdx0], &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveStringSequence_methodinfo = {
  { (JSJitGetterOp)receiveStringSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveByteStringSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveByteStringSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  nsTArray<nsCString> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveByteStringSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveByteStringSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveByteStringSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!NonVoidByteStringToJsval(cx, result[sequenceIdx0], &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveByteStringSequence_methodinfo = {
  { (JSJitGetterOp)receiveByteStringSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUTF8StringSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveUTF8StringSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  nsTArray<nsCString> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveUTF8StringSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveUTF8StringSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveUTF8StringSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!NonVoidUTF8StringToJsval(cx, result[sequenceIdx0], &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveUTF8StringSequence_methodinfo = {
  { (JSJitGetterOp)receiveUTF8StringSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveAnySequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveAnySequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  nsTArray<JS::Value> result;
  SequenceRooter<JS::Value > resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveAnySequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveAnySequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveAnySequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        JS::ExposeValueToActiveJS(result[sequenceIdx0]);
        tmp.set(result[sequenceIdx0]);
        if (!MaybeWrapValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveAnySequence_methodinfo = {
  { (JSJitGetterOp)receiveAnySequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableAnySequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableAnySequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Nullable<nsTArray<JS::Value>> result;
  SequenceRooter<JS::Value > resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableAnySequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableAnySequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableAnySequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        JS::ExposeValueToActiveJS(result.Value()[sequenceIdx0]);
        tmp.set(result.Value()[sequenceIdx0]);
        if (!MaybeWrapValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableAnySequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableAnySequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  nsTArray<JSObject*> result;
  SequenceRooter<JSObject* > resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveObjectSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveObjectSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveObjectSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        JS::ExposeObjectToActiveJS(result[sequenceIdx0]);
        tmp.setObject(*result[sequenceIdx0]);
        if (!MaybeWrapObjectValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveObjectSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  nsTArray<JSObject*> result;
  SequenceRooter<JSObject* > resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableObjectSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableObjectSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableObjectSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (result[sequenceIdx0]) {
                      JS::ExposeObjectToActiveJS(result[sequenceIdx0]);
                    }
                    tmp.setObjectOrNull(result[sequenceIdx0]);
        if (!MaybeWrapObjectOrNullValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableObjectSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfSequences(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passSequenceOfSequences");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passSequenceOfSequences", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passSequenceOfSequences", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<Sequence<int32_t>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Sequence<int32_t>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Sequence<int32_t>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Sequence<int32_t>& slot = *slotPtr;
      if (temp.isObject()) {
        JS::ForOfIterator iter1(cx);
        if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
          return false;
        }
        if (!iter1.valueIsIterable()) {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
        Sequence<int32_t> &arr1 = slot;
        JS::Rooted<JS::Value> temp1(cx);
        while (true) {
          bool done1;
          if (!iter1.next(&temp1, &done1)) {
            return false;
          }
          if (done1) {
            break;
          }
          int32_t* slotPtr1 = arr1.AppendElement(mozilla::fallible);
          if (!slotPtr1) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          int32_t& slot1 = *slotPtr1;
          if (!ValueToPrimitive<int32_t, eDefault>(cx, temp1, "Element of element of argument 1", &slot1)) {
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfSequences(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfSequences(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passSequenceOfSequences"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfSequences_methodinfo = {
  { (JSJitGetterOp)passSequenceOfSequences },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfSequencesOfSequences(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passSequenceOfSequencesOfSequences");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passSequenceOfSequencesOfSequences", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passSequenceOfSequencesOfSequences", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<Sequence<Sequence<int32_t>>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Sequence<Sequence<int32_t>>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Sequence<Sequence<int32_t>>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Sequence<Sequence<int32_t>>& slot = *slotPtr;
      if (temp.isObject()) {
        JS::ForOfIterator iter1(cx);
        if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
          return false;
        }
        if (!iter1.valueIsIterable()) {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
        Sequence<Sequence<int32_t>> &arr1 = slot;
        JS::Rooted<JS::Value> temp1(cx);
        while (true) {
          bool done1;
          if (!iter1.next(&temp1, &done1)) {
            return false;
          }
          if (done1) {
            break;
          }
          Sequence<int32_t>* slotPtr1 = arr1.AppendElement(mozilla::fallible);
          if (!slotPtr1) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          Sequence<int32_t>& slot1 = *slotPtr1;
          if (temp1.isObject()) {
            JS::ForOfIterator iter2(cx);
            if (!iter2.init(temp1, JS::ForOfIterator::AllowNonIterable)) {
              return false;
            }
            if (!iter2.valueIsIterable()) {
              cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of element of argument 1");
              return false;
            }
            Sequence<int32_t> &arr2 = slot1;
            JS::Rooted<JS::Value> temp2(cx);
            while (true) {
              bool done2;
              if (!iter2.next(&temp2, &done2)) {
                return false;
              }
              if (done2) {
                break;
              }
              int32_t* slotPtr2 = arr2.AppendElement(mozilla::fallible);
              if (!slotPtr2) {
                JS_ReportOutOfMemory(cx);
                return false;
              }
              int32_t& slot2 = *slotPtr2;
              if (!ValueToPrimitive<int32_t, eDefault>(cx, temp2, "Element of element of element of argument 1", &slot2)) {
                return false;
              }
            }
          } else {
            cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of element of argument 1");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfSequencesOfSequences(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfSequencesOfSequences(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passSequenceOfSequencesOfSequences"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfSequencesOfSequences_methodinfo = {
  { (JSJitGetterOp)passSequenceOfSequencesOfSequences },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passRecord", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Record<nsString, int32_t> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, int32_t>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      int32_t& slot = entry->mValue;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passRecord"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecord_methodinfo = {
  { (JSJitGetterOp)passRecord },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableRecord", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<Record<nsString, int32_t>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.SetValue().Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, int32_t>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      int32_t& slot = entry->mValue;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot)) {
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableRecord"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableRecord_methodinfo = {
  { (JSJitGetterOp)passNullableRecord },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfNullableInts(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passRecordOfNullableInts");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passRecordOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passRecordOfNullableInts", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Record<nsString, Nullable<int32_t>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, Nullable<int32_t>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Nullable<int32_t>& slot = entry->mValue;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot.SetValue())) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfNullableInts(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfNullableInts(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passRecordOfNullableInts"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfNullableInts_methodinfo = {
  { (JSJitGetterOp)passRecordOfNullableInts },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalRecordOfNullableInts(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalRecordOfNullableInts");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalRecordOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Record<nsString, Nullable<int32_t>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, Nullable<int32_t>>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        Nullable<int32_t>& slot = entry->mValue;
        if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot.SetValue())) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalRecordOfNullableInts(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalRecordOfNullableInts(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalRecordOfNullableInts"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalRecordOfNullableInts_methodinfo = {
  { (JSJitGetterOp)passOptionalRecordOfNullableInts },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableRecordOfNullableInts(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableRecordOfNullableInts");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableRecordOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Nullable<Record<nsString, Nullable<int32_t>>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, Nullable<int32_t>>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        Nullable<int32_t>& slot = entry->mValue;
        if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot.SetValue())) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableRecordOfNullableInts(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableRecordOfNullableInts(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableRecordOfNullableInts"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableRecordOfNullableInts_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableRecordOfNullableInts },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passCastableObjectRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passCastableObjectRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passCastableObjectRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passCastableObjectRecord", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Record<nsString, OwningNonNull<mozilla::dom::TestInterface>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, OwningNonNull<mozilla::dom::TestInterface>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      OwningNonNull<mozilla::dom::TestInterface>& slot = entry->mValue;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassCastableObjectRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassCastableObjectRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passCastableObjectRecord"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passCastableObjectRecord_methodinfo = {
  { (JSJitGetterOp)passCastableObjectRecord },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableCastableObjectRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableCastableObjectRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableCastableObjectRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableCastableObjectRecord", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Record<nsString, RefPtr<mozilla::dom::TestInterface>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, RefPtr<mozilla::dom::TestInterface>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      RefPtr<mozilla::dom::TestInterface>& slot = entry->mValue;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestInterface");
            return false;
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableCastableObjectRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableCastableObjectRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableCastableObjectRecord"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableCastableObjectRecord_methodinfo = {
  { (JSJitGetterOp)passNullableCastableObjectRecord },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passCastableObjectNullableRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passCastableObjectNullableRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passCastableObjectNullableRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passCastableObjectNullableRecord", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<Record<nsString, OwningNonNull<mozilla::dom::TestInterface>>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.SetValue().Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, OwningNonNull<mozilla::dom::TestInterface>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      OwningNonNull<mozilla::dom::TestInterface>& slot = entry->mValue;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassCastableObjectNullableRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassCastableObjectNullableRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passCastableObjectNullableRecord"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passCastableObjectNullableRecord_methodinfo = {
  { (JSJitGetterOp)passCastableObjectNullableRecord },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableCastableObjectNullableRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableCastableObjectNullableRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableCastableObjectNullableRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableCastableObjectNullableRecord", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<Record<nsString, RefPtr<mozilla::dom::TestInterface>>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.SetValue().Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, RefPtr<mozilla::dom::TestInterface>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      RefPtr<mozilla::dom::TestInterface>& slot = entry->mValue;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestInterface");
            return false;
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableCastableObjectNullableRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableCastableObjectNullableRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableCastableObjectNullableRecord"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableCastableObjectNullableRecord_methodinfo = {
  { (JSJitGetterOp)passNullableCastableObjectNullableRecord },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Record<nsString, int32_t>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, int32_t>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        int32_t& slot = entry->mValue;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot)) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalRecord"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalRecord_methodinfo = {
  { (JSJitGetterOp)passOptionalRecord },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Nullable<Record<nsString, int32_t>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, int32_t>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        int32_t& slot = entry->mValue;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot)) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableRecord"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableRecord_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableRecord },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableRecordWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableRecordWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableRecordWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<Record<nsString, int32_t>> arg0;
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      auto& recordEntries = arg0.SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, int32_t>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        int32_t& slot = entry->mValue;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot)) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0.SetNull();
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableRecordWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableRecordWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableRecordWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableRecordWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableRecordWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalObjectRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalObjectRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalObjectRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Record<nsString, OwningNonNull<mozilla::dom::TestInterface>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, OwningNonNull<mozilla::dom::TestInterface>>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        OwningNonNull<mozilla::dom::TestInterface>& slot = entry->mValue;
        if (temp.isObject()) {
          static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
            if (NS_FAILED(rv)) {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestInterface");
              return false;
            }
          }
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalObjectRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalObjectRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalObjectRecord"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalObjectRecord_methodinfo = {
  { (JSJitGetterOp)passOptionalObjectRecord },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passExternalInterfaceRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passExternalInterfaceRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passExternalInterfaceRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passExternalInterfaceRecord", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Record<nsString, RefPtr<mozilla::dom::TestExternalInterface>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, RefPtr<mozilla::dom::TestExternalInterface>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      RefPtr<mozilla::dom::TestExternalInterface>& slot = entry->mValue;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
        RefPtr<mozilla::dom::TestExternalInterface> tempHolder;
        JS::Rooted<JSObject*> source(cx, &temp.toObject());
        if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(tempHolder)))) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestExternalInterface");
          return false;
        }
        MOZ_ASSERT(tempHolder);
        slot = tempHolder;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassExternalInterfaceRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassExternalInterfaceRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passExternalInterfaceRecord"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passExternalInterfaceRecord_methodinfo = {
  { (JSJitGetterOp)passExternalInterfaceRecord },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableExternalInterfaceRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableExternalInterfaceRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableExternalInterfaceRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableExternalInterfaceRecord", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Record<nsString, RefPtr<mozilla::dom::TestExternalInterface>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, RefPtr<mozilla::dom::TestExternalInterface>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      RefPtr<mozilla::dom::TestExternalInterface>& slot = entry->mValue;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
        RefPtr<mozilla::dom::TestExternalInterface> tempHolder;
        JS::Rooted<JSObject*> source(cx, &temp.toObject());
        if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(tempHolder)))) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestExternalInterface");
          return false;
        }
        MOZ_ASSERT(tempHolder);
        slot = tempHolder;
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableExternalInterfaceRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableExternalInterfaceRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableExternalInterfaceRecord"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableExternalInterfaceRecord_methodinfo = {
  { (JSJitGetterOp)passNullableExternalInterfaceRecord },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passStringRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passStringRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passStringRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passStringRecord", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Record<nsString, nsString> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, nsString>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      nsString& slot = entry->mValue;
      if (!ConvertJSValueToString(cx, temp, eStringify, eStringify, slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassStringRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassStringRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passStringRecord"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passStringRecord_methodinfo = {
  { (JSJitGetterOp)passStringRecord },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passByteStringRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passByteStringRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passByteStringRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passByteStringRecord", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Record<nsString, nsCString> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, nsCString>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      nsCString& slot = entry->mValue;
      if (!ConvertJSValueToByteString(cx, temp, false, "value in argument 1", slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassByteStringRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassByteStringRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passByteStringRecord"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passByteStringRecord_methodinfo = {
  { (JSJitGetterOp)passByteStringRecord },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUTF8StringRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUTF8StringRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUTF8StringRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passUTF8StringRecord", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Record<nsString, nsCString> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, nsCString>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      nsCString& slot = entry->mValue;
      if (!ConvertJSValueToString(cx, temp, eStringify, eStringify, slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUTF8StringRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUTF8StringRecord(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUTF8StringRecord"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUTF8StringRecord_methodinfo = {
  { (JSJitGetterOp)passUTF8StringRecord },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfRecords(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passRecordOfRecords");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passRecordOfRecords", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passRecordOfRecords", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Record<nsString, Record<nsString, int32_t>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, Record<nsString, int32_t>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Record<nsString, int32_t>& slot = entry->mValue;
      if (temp.isObject()) {
        auto& recordEntries = slot.Entries();

        JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
        JS::RootedVector<jsid> ids(cx);
        if (!js::GetPropertyKeys(cx, recordObj,
                                 JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
          return false;
        }
        if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Rooted<JS::Value> propNameValue(cx);
        JS::Rooted<JS::Value> temp(cx);
        JS::Rooted<jsid> curId(cx);
        JS::Rooted<JS::Value> idVal(cx);
        // Use a hashset to keep track of ids seen, to avoid
        // introducing nasty O(N^2) behavior scanning for them all the
        // time.  Ideally we'd use a data structure with O(1) lookup
        // _and_ ordering for the MozMap, but we don't have one lying
        // around.
        nsTHashtable<nsStringHashKey> idsSeen;
        for (size_t i = 0; i < ids.length(); ++i) {
          curId = ids[i];

          JS::Rooted<JS::PropertyDescriptor> desc(cx);
          if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                               &desc)) {
            return false;
          }

          if (!desc.object() /* == undefined in spec terms */ ||
              !desc.enumerable()) {
            continue;
          }

          idVal = js::IdToValue(curId);
          nsString propName;
          // This will just throw if idVal is a Symbol, like the spec says
          // to do.
          if (!ConvertJSValueToString(cx, idVal, "key of value in argument 1", propName)) {
            return false;
          }

          if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
            return false;
          }

          Record<nsString, int32_t>::EntryType* entry;
          if (!idsSeen.EnsureInserted(propName)) {
            // Find the existing entry.
            auto idx = recordEntries.IndexOf(propName);
            MOZ_ASSERT(idx != recordEntries.NoIndex,
                       "Why is it not found?");
            // Now blow it away to make it look like it was just added
            // to the array, because it's not obvious that it's
            // safe to write to its already-initialized mValue via our
            // normal codegen conversions.  For example, the value
            // could be a union and this would change its type, but
            // codegen assumes we won't do that.
            entry = recordEntries.ReconstructElementAt(idx);
          } else {
            // Safe to do an infallible append here, because we did a
            // SetCapacity above to the right capacity.
            entry = recordEntries.AppendElement();
          }
          entry->mKey = propName;
          int32_t& slot = entry->mValue;
          if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in value in argument 1", &slot)) {
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfRecords(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfRecords(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passRecordOfRecords"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfRecords_methodinfo = {
  { (JSJitGetterOp)passRecordOfRecords },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveRecord(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Record<nsString, int32_t> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveRecord(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveRecord(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveRecord"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
  if (!returnObj) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (auto& entry : result.Entries()) {
      auto& recordValue0 = entry.mValue;
      // Control block to let us common up the JS_DefineUCProperty calls when there
      // are different ways to succeed at wrapping the value.
      do {
        tmp.setInt32(int32_t(recordValue0));
        break;
      } while (false);
      if (!JS_DefineUCProperty(cx, returnObj,
                               entry.mKey.BeginReading(),
                               entry.mKey.Length(), tmp,
                               JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnObj);
  return true;
}

static const JSJitInfo receiveRecord_methodinfo = {
  { (JSJitGetterOp)receiveRecord },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableRecord(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Nullable<Record<nsString, int32_t>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableRecord(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableRecord(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableRecord"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
  if (!returnObj) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (auto& entry : result.Value().Entries()) {
      auto& recordValue0 = entry.mValue;
      // Control block to let us common up the JS_DefineUCProperty calls when there
      // are different ways to succeed at wrapping the value.
      do {
        tmp.setInt32(int32_t(recordValue0));
        break;
      } while (false);
      if (!JS_DefineUCProperty(cx, returnObj,
                               entry.mKey.BeginReading(),
                               entry.mKey.Length(), tmp,
                               JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnObj);
  return true;
}

static const JSJitInfo receiveNullableRecord_methodinfo = {
  { (JSJitGetterOp)receiveNullableRecord },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveRecordOfNullableInts(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveRecordOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Record<nsString, Nullable<int32_t>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveRecordOfNullableInts(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveRecordOfNullableInts(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveRecordOfNullableInts"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
  if (!returnObj) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (auto& entry : result.Entries()) {
      auto& recordValue0 = entry.mValue;
      // Control block to let us common up the JS_DefineUCProperty calls when there
      // are different ways to succeed at wrapping the value.
      do {
        if (recordValue0.IsNull()) {
          tmp.setNull();
          break;
        }
        tmp.setInt32(int32_t(recordValue0.Value()));
        break;
      } while (false);
      if (!JS_DefineUCProperty(cx, returnObj,
                               entry.mKey.BeginReading(),
                               entry.mKey.Length(), tmp,
                               JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnObj);
  return true;
}

static const JSJitInfo receiveRecordOfNullableInts_methodinfo = {
  { (JSJitGetterOp)receiveRecordOfNullableInts },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableRecordOfNullableInts(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableRecordOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Nullable<Record<nsString, Nullable<int32_t>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableRecordOfNullableInts(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableRecordOfNullableInts(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableRecordOfNullableInts"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
  if (!returnObj) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (auto& entry : result.Value().Entries()) {
      auto& recordValue0 = entry.mValue;
      // Control block to let us common up the JS_DefineUCProperty calls when there
      // are different ways to succeed at wrapping the value.
      do {
        if (recordValue0.IsNull()) {
          tmp.setNull();
          break;
        }
        tmp.setInt32(int32_t(recordValue0.Value()));
        break;
      } while (false);
      if (!JS_DefineUCProperty(cx, returnObj,
                               entry.mKey.BeginReading(),
                               entry.mKey.Length(), tmp,
                               JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnObj);
  return true;
}

static const JSJitInfo receiveNullableRecordOfNullableInts_methodinfo = {
  { (JSJitGetterOp)receiveNullableRecordOfNullableInts },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveAnyRecord(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveAnyRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Record<nsString, JS::Value> result;
  RecordRooter<nsString, JS::Value> resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveAnyRecord(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveAnyRecord(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveAnyRecord"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
  if (!returnObj) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (auto& entry : result.Entries()) {
      auto& recordValue0 = entry.mValue;
      // Control block to let us common up the JS_DefineUCProperty calls when there
      // are different ways to succeed at wrapping the value.
      do {
        JS::ExposeValueToActiveJS(recordValue0);
        tmp.set(recordValue0);
        if (!MaybeWrapValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineUCProperty(cx, returnObj,
                               entry.mKey.BeginReading(),
                               entry.mKey.Length(), tmp,
                               JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnObj);
  return true;
}

static const JSJitInfo receiveAnyRecord_methodinfo = {
  { (JSJitGetterOp)receiveAnyRecord },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passArrayBuffer", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<ArrayBuffer> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBuffer");
      return false;
    }
    if (JS::IsSharedArrayBufferObject(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferMaybeShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passArrayBuffer"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passArrayBuffer },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableArrayBuffer", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<Nullable<ArrayBuffer>> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.SetValue().Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferOrNull");
      return false;
    }
    if (JS::IsSharedArrayBufferObject(arg0.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferMaybeShared(arg0.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableArrayBuffer"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passNullableArrayBuffer },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<ArrayBuffer> arg0;
  Maybe<SpiderMonkeyInterfaceRooter<ArrayBuffer>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value());
    if (args[0].isObject()) {
      if (!arg0.Value().Init(&args[0].toObject())) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBuffer");
        return false;
      }
      if (JS::IsSharedArrayBufferObject(arg0.Value().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
        return false;
      }
      if (JS::IsLargeArrayBufferMaybeShared(arg0.Value().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
        return false;
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalArrayBuffer"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passOptionalArrayBuffer },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Nullable<ArrayBuffer>> arg0;
  Maybe<SpiderMonkeyInterfaceRooter<ArrayBuffer>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      if (!arg0.Value().SetValue().Init(&args[0].toObject())) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferOrNull");
        return false;
      }
      if (JS::IsSharedArrayBufferObject(arg0.Value().SetValue().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
        return false;
      }
      if (JS::IsLargeArrayBufferMaybeShared(arg0.Value().SetValue().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
        return false;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableArrayBuffer"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableArrayBuffer },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableArrayBufferWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableArrayBufferWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableArrayBufferWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<Nullable<ArrayBuffer>> arg0(cx);
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      if (!arg0.SetValue().Init(&args[0].toObject())) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferOrNull");
        return false;
      }
      if (JS::IsSharedArrayBufferObject(arg0.SetValue().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
        return false;
      }
      if (JS::IsLargeArrayBufferMaybeShared(arg0.SetValue().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
        return false;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0.SetNull();
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableArrayBufferWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableArrayBufferWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableArrayBufferWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableArrayBufferWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableArrayBufferWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passArrayBufferView(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passArrayBufferView");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passArrayBufferView", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<ArrayBufferView> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferView");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassArrayBufferView(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassArrayBufferView(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passArrayBufferView"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passArrayBufferView_methodinfo = {
  { (JSJitGetterOp)passArrayBufferView },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passInt8Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passInt8Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passInt8Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passInt8Array", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<Int8Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Int8Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassInt8Array(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassInt8Array(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passInt8Array"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passInt8Array_methodinfo = {
  { (JSJitGetterOp)passInt8Array },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passInt16Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passInt16Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passInt16Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passInt16Array", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<Int16Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Int16Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassInt16Array(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassInt16Array(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passInt16Array"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passInt16Array_methodinfo = {
  { (JSJitGetterOp)passInt16Array },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passInt32Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passInt32Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passInt32Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passInt32Array", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<Int32Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Int32Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassInt32Array(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassInt32Array(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passInt32Array"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passInt32Array_methodinfo = {
  { (JSJitGetterOp)passInt32Array },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUint8Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUint8Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUint8Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passUint8Array", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<Uint8Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Uint8Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUint8Array(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUint8Array(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUint8Array"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUint8Array_methodinfo = {
  { (JSJitGetterOp)passUint8Array },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUint16Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUint16Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUint16Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passUint16Array", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<Uint16Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Uint16Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUint16Array(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUint16Array(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUint16Array"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUint16Array_methodinfo = {
  { (JSJitGetterOp)passUint16Array },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUint32Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUint32Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUint32Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passUint32Array", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<Uint32Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Uint32Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUint32Array(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUint32Array(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUint32Array"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUint32Array_methodinfo = {
  { (JSJitGetterOp)passUint32Array },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUint8ClampedArray(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUint8ClampedArray");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUint8ClampedArray", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passUint8ClampedArray", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<Uint8ClampedArray> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Uint8ClampedArray");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUint8ClampedArray(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUint8ClampedArray(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUint8ClampedArray"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUint8ClampedArray_methodinfo = {
  { (JSJitGetterOp)passUint8ClampedArray },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passFloat32Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passFloat32Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passFloat32Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passFloat32Array", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<Float32Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Float32Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassFloat32Array(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassFloat32Array(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passFloat32Array"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passFloat32Array_methodinfo = {
  { (JSJitGetterOp)passFloat32Array },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passFloat64Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passFloat64Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passFloat64Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passFloat64Array", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<Float64Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Float64Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassFloat64Array(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassFloat64Array(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passFloat64Array"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passFloat64Array_methodinfo = {
  { (JSJitGetterOp)passFloat64Array },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfArrayBuffers(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passSequenceOfArrayBuffers");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passSequenceOfArrayBuffers", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passSequenceOfArrayBuffers", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<ArrayBuffer> arg0;
  SequenceRooter<ArrayBuffer> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<ArrayBuffer> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      ArrayBuffer* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      ArrayBuffer& slot = *slotPtr;
      if (temp.isObject()) {
        if (!slot.Init(&temp.toObject())) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "ArrayBuffer");
          return false;
        }
        if (JS::IsSharedArrayBufferObject(slot.Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Element of argument 1");
          return false;
        }
        if (JS::IsLargeArrayBufferMaybeShared(slot.Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Element of argument 1");
          return false;
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfArrayBuffers(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfArrayBuffers(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passSequenceOfArrayBuffers"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfArrayBuffers_methodinfo = {
  { (JSJitGetterOp)passSequenceOfArrayBuffers },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfNullableArrayBuffers(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passSequenceOfNullableArrayBuffers");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passSequenceOfNullableArrayBuffers", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passSequenceOfNullableArrayBuffers", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<Nullable<ArrayBuffer>> arg0;
  SequenceRooter<Nullable<ArrayBuffer>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Nullable<ArrayBuffer>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<ArrayBuffer>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<ArrayBuffer>& slot = *slotPtr;
      if (temp.isObject()) {
        if (!slot.SetValue().Init(&temp.toObject())) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "ArrayBufferOrNull");
          return false;
        }
        if (JS::IsSharedArrayBufferObject(slot.SetValue().Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Element of argument 1");
          return false;
        }
        if (JS::IsLargeArrayBufferMaybeShared(slot.SetValue().Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Element of argument 1");
          return false;
        }
      } else if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfNullableArrayBuffers(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfNullableArrayBuffers(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passSequenceOfNullableArrayBuffers"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfNullableArrayBuffers_methodinfo = {
  { (JSJitGetterOp)passSequenceOfNullableArrayBuffers },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfArrayBuffers(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passRecordOfArrayBuffers");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passRecordOfArrayBuffers", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passRecordOfArrayBuffers", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Record<nsString, ArrayBuffer> arg0;
  RecordRooter<nsString, ArrayBuffer> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, ArrayBuffer>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      ArrayBuffer& slot = entry->mValue;
      if (temp.isObject()) {
        if (!slot.Init(&temp.toObject())) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "ArrayBuffer");
          return false;
        }
        if (JS::IsSharedArrayBufferObject(slot.Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Value in argument 1");
          return false;
        }
        if (JS::IsLargeArrayBufferMaybeShared(slot.Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value in argument 1");
          return false;
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfArrayBuffers(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfArrayBuffers(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passRecordOfArrayBuffers"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfArrayBuffers_methodinfo = {
  { (JSJitGetterOp)passRecordOfArrayBuffers },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfNullableArrayBuffers(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passRecordOfNullableArrayBuffers");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passRecordOfNullableArrayBuffers", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passRecordOfNullableArrayBuffers", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Record<nsString, Nullable<ArrayBuffer>> arg0;
  RecordRooter<nsString, Nullable<ArrayBuffer>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, Nullable<ArrayBuffer>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Nullable<ArrayBuffer>& slot = entry->mValue;
      if (temp.isObject()) {
        if (!slot.SetValue().Init(&temp.toObject())) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "ArrayBufferOrNull");
          return false;
        }
        if (JS::IsSharedArrayBufferObject(slot.SetValue().Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Value in argument 1");
          return false;
        }
        if (JS::IsLargeArrayBufferMaybeShared(slot.SetValue().Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value in argument 1");
          return false;
        }
      } else if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfNullableArrayBuffers(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfNullableArrayBuffers(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passRecordOfNullableArrayBuffers"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfNullableArrayBuffers_methodinfo = {
  { (JSJitGetterOp)passRecordOfNullableArrayBuffers },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicTypedArray(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passVariadicTypedArray");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passVariadicTypedArray", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  AutoSequence<Float32Array> arg0;
  SequenceRooter<Float32Array> arg0_holder(cx, &arg0);
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      Float32Array& slot = *arg0.AppendElement();
      if (args[variadicArg].isObject()) {
        if (!slot.Init(&args[variadicArg].toObject())) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Float32Array");
          return false;
        }
        if (JS::IsArrayBufferViewShared(slot.Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
          return false;
        }
        if (JS::IsLargeArrayBufferView(slot.Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
          return false;
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicTypedArray(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicTypedArray(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passVariadicTypedArray"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicTypedArray_methodinfo = {
  { (JSJitGetterOp)passVariadicTypedArray },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicNullableTypedArray(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passVariadicNullableTypedArray");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passVariadicNullableTypedArray", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  AutoSequence<Nullable<Float32Array>> arg0;
  SequenceRooter<Nullable<Float32Array>> arg0_holder(cx, &arg0);
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      Nullable<Float32Array>& slot = *arg0.AppendElement();
      if (args[variadicArg].isObject()) {
        if (!slot.SetValue().Init(&args[variadicArg].toObject())) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Float32ArrayOrNull");
          return false;
        }
        if (JS::IsArrayBufferViewShared(slot.SetValue().Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
          return false;
        }
        if (JS::IsLargeArrayBufferView(slot.SetValue().Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
          return false;
        }
      } else if (args[variadicArg].isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicNullableTypedArray(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicNullableTypedArray(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passVariadicNullableTypedArray"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicNullableTypedArray_methodinfo = {
  { (JSJitGetterOp)passVariadicNullableTypedArray },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUint8Array(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveUint8Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveUint8Array(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveUint8Array(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveUint8Array"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapNonDOMObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveUint8Array_methodinfo = {
  { (JSJitGetterOp)receiveUint8Array },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_uint8ArrayAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "uint8ArrayAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetUint8ArrayAttr(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetUint8ArrayAttr(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.uint8ArrayAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapNonDOMObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_uint8ArrayAttr(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.uint8ArrayAttr setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "uint8ArrayAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<Uint8Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "Uint8Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Value being assigned");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value being assigned");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetUint8ArrayAttr(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetUint8ArrayAttr(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.uint8ArrayAttr setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo uint8ArrayAttr_getterinfo = {
  { get_uint8ArrayAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo uint8ArrayAttr_setterinfo = {
  { (JSJitGetterOp)set_uint8ArrayAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passString", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassString(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassString(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passString"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passString_methodinfo = {
  { (JSJitGetterOp)passString },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableString", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableString(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableString(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableString"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableString_methodinfo = {
  { (JSJitGetterOp)passNullableString },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<nsAString> arg0;
  binding_detail::FakeString<char16_t> arg0_holder;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0_holder)) {
      return false;
    }
    arg0 = &arg0_holder;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalString(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalString(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalString"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalString_methodinfo = {
  { (JSJitGetterOp)passOptionalString },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalStringWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalStringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::FakeString<char16_t> arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
      return false;
    }
  } else {
    arg0.AssignLiteral(u"abc");
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalStringWithDefaultValue(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalStringWithDefaultValue(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalStringWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalStringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalStringWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<nsAString> arg0;
  binding_detail::FakeString<char16_t> arg0_holder;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0_holder)) {
      return false;
    }
    arg0 = &arg0_holder;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableString(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableString(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableString"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableString_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableString },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableStringWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableStringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::FakeString<char16_t> arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
      return false;
    }
  } else {
    arg0.SetIsVoid(true);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableStringWithDefaultValue(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableStringWithDefaultValue(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableStringWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableStringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableStringWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passVariadicString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  AutoSequence<nsString> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      nsString& slot = *arg0.AppendElement();
      if (!ConvertJSValueToString(cx, args[variadicArg], eStringify, eStringify, slot)) {
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicString(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicString(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passVariadicString"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicString_methodinfo = {
  { (JSJitGetterOp)passVariadicString },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passByteString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passByteString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passByteString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passByteString", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  nsCString arg0;
  if (!ConvertJSValueToByteString(cx, args[0], false, "argument 1", arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassByteString(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassByteString(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passByteString"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passByteString_methodinfo = {
  { (JSJitGetterOp)passByteString },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableByteString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableByteString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableByteString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableByteString", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  nsCString arg0;
  if (!ConvertJSValueToByteString(cx, args[0], true, "argument 1", arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableByteString(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableByteString(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableByteString"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableByteString_methodinfo = {
  { (JSJitGetterOp)passNullableByteString },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalByteString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalByteString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalByteString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<nsCString> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ConvertJSValueToByteString(cx, args[0], false, "argument 1", arg0.Value())) {
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalByteString(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalByteString(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalByteString"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalByteString_methodinfo = {
  { (JSJitGetterOp)passOptionalByteString },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalByteStringWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalByteStringWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalByteStringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  nsCString arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToByteString(cx, args[0], false, "argument 1", arg0)) {
      return false;
    }
  } else {
    arg0.AssignLiteral("abc");
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalByteStringWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalByteStringWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalByteStringWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalByteStringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalByteStringWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableByteString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableByteString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableByteString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<nsCString> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ConvertJSValueToByteString(cx, args[0], true, "argument 1", arg0.Value())) {
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableByteString(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableByteString(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableByteString"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableByteString_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableByteString },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableByteStringWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableByteStringWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableByteStringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  nsCString arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToByteString(cx, args[0], true, "argument 1", arg0)) {
      return false;
    }
  } else {
    arg0.SetIsVoid(true);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableByteStringWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableByteStringWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableByteStringWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableByteStringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableByteStringWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicByteString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passVariadicByteString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passVariadicByteString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  AutoSequence<nsCString> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      nsCString& slot = *arg0.AppendElement();
      if (!ConvertJSValueToByteString(cx, args[variadicArg], false, "argument 1", slot)) {
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicByteString(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicByteString(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passVariadicByteString"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicByteString_methodinfo = {
  { (JSJitGetterOp)passVariadicByteString },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionByteString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionByteString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionByteString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passUnionByteString", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  ByteStringOrLong arg0;
  ByteStringOrLongArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    do {
      if (args[0].isNumber()) {
        done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
        break;
      }
      done = (failed = !arg0_holder.TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
      break;
    } while (false);
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionByteString(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionByteString(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionByteString"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionByteString_methodinfo = {
  { (JSJitGetterOp)passUnionByteString },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnionByteString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalUnionByteString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalUnionByteString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<ByteStringOrLong> arg0;
  Maybe<ByteStringOrLongArgument> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(arg0.Value());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnionByteString(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnionByteString(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalUnionByteString"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnionByteString_methodinfo = {
  { (JSJitGetterOp)passOptionalUnionByteString },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnionByteStringWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalUnionByteStringWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalUnionByteStringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  ByteStringOrLong arg0;
  ByteStringOrLongArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral("abc");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnionByteStringWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnionByteStringWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalUnionByteStringWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnionByteStringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalUnionByteStringWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUTF8String(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUTF8String", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passUTF8String", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::FakeString<char> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUTF8String(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUTF8String(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUTF8String"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUTF8String_methodinfo = {
  { (JSJitGetterOp)passUTF8String },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUTF8String(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUTF8String", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableUTF8String", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::FakeString<char> arg0;
  if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUTF8String(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUTF8String(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUTF8String"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUTF8String_methodinfo = {
  { (JSJitGetterOp)passNullableUTF8String },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUTF8String(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalUTF8String", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<nsACString> arg0;
  binding_detail::FakeString<char> arg0_holder;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0_holder)) {
      return false;
    }
    arg0 = &arg0_holder;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUTF8String(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUTF8String(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalUTF8String"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUTF8String_methodinfo = {
  { (JSJitGetterOp)passOptionalUTF8String },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUTF8StringWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalUTF8StringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::FakeString<char> arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
      return false;
    }
  } else {
    arg0.AssignLiteral("abc");
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUTF8StringWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUTF8StringWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalUTF8StringWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUTF8StringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalUTF8StringWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableUTF8String(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableUTF8String", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<nsACString> arg0;
  binding_detail::FakeString<char> arg0_holder;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0_holder)) {
      return false;
    }
    arg0 = &arg0_holder;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableUTF8String(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableUTF8String(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableUTF8String"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableUTF8String_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableUTF8String },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableUTF8StringWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableUTF8StringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::FakeString<char> arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
      return false;
    }
  } else {
    arg0.SetIsVoid(true);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableUTF8StringWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableUTF8StringWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableUTF8StringWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableUTF8StringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableUTF8StringWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicUTF8String(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passVariadicUTF8String", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  AutoSequence<nsCString> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      nsCString& slot = *arg0.AppendElement();
      if (!ConvertJSValueToString(cx, args[variadicArg], eStringify, eStringify, slot)) {
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicUTF8String(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicUTF8String(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passVariadicUTF8String"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicUTF8String_methodinfo = {
  { (JSJitGetterOp)passVariadicUTF8String },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionUTF8String(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionUTF8String");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionUTF8String", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passUnionUTF8String", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  UTF8StringOrLong arg0;
  UTF8StringOrLongArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    do {
      if (args[0].isNumber()) {
        done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
        break;
      }
      done = (failed = !arg0_holder.TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
      break;
    } while (false);
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionUTF8String(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionUTF8String(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionUTF8String"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionUTF8String_methodinfo = {
  { (JSJitGetterOp)passUnionUTF8String },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnionUTF8String(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalUnionUTF8String");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalUnionUTF8String", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<UTF8StringOrLong> arg0;
  Maybe<UTF8StringOrLongArgument> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(arg0.Value());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnionUTF8String(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnionUTF8String(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalUnionUTF8String"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnionUTF8String_methodinfo = {
  { (JSJitGetterOp)passOptionalUnionUTF8String },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnionUTF8StringWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalUnionUTF8StringWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalUnionUTF8StringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  UTF8StringOrLong arg0;
  UTF8StringOrLongArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral("abc");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnionUTF8StringWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnionUTF8StringWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalUnionUTF8StringWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnionUTF8StringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalUnionUTF8StringWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSVS(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passSVS", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passSVS", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  if (!NormalizeUSVString(arg0)) {
    JS_ReportOutOfMemory(cx);
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSVS(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSVS(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passSVS"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSVS_methodinfo = {
  { (JSJitGetterOp)passSVS },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableSVS(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableSVS", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableSVS", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
    return false;
  }
  if (!NormalizeUSVString(arg0)) {
    JS_ReportOutOfMemory(cx);
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableSVS(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableSVS(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableSVS"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableSVS_methodinfo = {
  { (JSJitGetterOp)passNullableSVS },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSVS(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalSVS", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<nsAString> arg0;
  binding_detail::FakeString<char16_t> arg0_holder;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0_holder)) {
      return false;
    }
    if (!NormalizeUSVString(arg0_holder)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    arg0 = &arg0_holder;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSVS(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSVS(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalSVS"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSVS_methodinfo = {
  { (JSJitGetterOp)passOptionalSVS },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSVSWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalSVSWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::FakeString<char16_t> arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
      return false;
    }
    if (!NormalizeUSVString(arg0)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
  } else {
    arg0.AssignLiteral(u"abc");
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSVSWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSVSWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalSVSWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSVSWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalSVSWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSVS(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableSVS", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<nsAString> arg0;
  binding_detail::FakeString<char16_t> arg0_holder;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0_holder)) {
      return false;
    }
    if (!NormalizeUSVString(arg0_holder)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    arg0 = &arg0_holder;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSVS(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSVS(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableSVS"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSVS_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSVS },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSVSWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableSVSWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::FakeString<char16_t> arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
      return false;
    }
    if (!NormalizeUSVString(arg0)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
  } else {
    arg0.SetIsVoid(true);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSVSWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSVSWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableSVSWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSVSWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSVSWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicSVS(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passVariadicSVS", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  AutoSequence<nsString> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      nsString& slot = *arg0.AppendElement();
      if (!ConvertJSValueToString(cx, args[variadicArg], eStringify, eStringify, slot)) {
        return false;
      }
      if (!NormalizeUSVString(slot)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicSVS(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicSVS(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passVariadicSVS"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicSVS_methodinfo = {
  { (JSJitGetterOp)passVariadicSVS },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveSVS(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveSVS", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  DOMString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveSVS(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveSVS(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveSVS"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveSVS_methodinfo = {
  { (JSJitGetterOp)receiveSVS },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passJSString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passJSString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passJSString", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  JS::Rooted<JSString*> arg0(cx);
  if (!(arg0 = ConvertJSValueToJSString(cx, args[0]))) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassJSString(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassJSString(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passJSString"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passJSString_methodinfo = {
  { (JSJitGetterOp)passJSString },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalJSStringWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalJSStringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  JS::Rooted<JSString*> arg0(cx);
  if (args.hasDefined(0)) {
    if (!(arg0 = ConvertJSValueToJSString(cx, args[0]))) {
      return false;
    }
  } else {
    static const char data[] = { 'a', 'b', 'c', 0 };
    arg0 = JS_NewStringCopyN(cx, data, ArrayLength(data) - 1);
    if (!arg0) {
        return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalJSStringWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalJSStringWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalJSStringWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalJSStringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalJSStringWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveJSString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveJSString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  JS::Rooted<JSString*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveJSString(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveJSString(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveJSString"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setString(result);
  if (!MaybeWrapStringValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveJSString_methodinfo = {
  { (JSJitGetterOp)receiveJSString },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyJSStringAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "readonlyJSStringAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  JS::Rooted<JSString*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlyJSStringAttr(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlyJSStringAttr(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.readonlyJSStringAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setString(result);
  if (!MaybeWrapStringValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo readonlyJSStringAttr_getterinfo = {
  { get_readonlyJSStringAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_jsStringAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "jsStringAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  JS::Rooted<JSString*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetJsStringAttr(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetJsStringAttr(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.jsStringAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setString(result);
  if (!MaybeWrapStringValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_jsStringAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "jsStringAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  JS::Rooted<JSString*> arg0(cx);
  if (!(arg0 = ConvertJSValueToJSString(cx, args[0]))) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetJsStringAttr(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetJsStringAttr(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.jsStringAttr setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo jsStringAttr_getterinfo = {
  { get_jsStringAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo jsStringAttr_setterinfo = {
  { (JSJitGetterOp)set_jsStringAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passEnum(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passEnum");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passEnum", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  MyTestEnum arg0;
  {
    int index;
    if (!FindEnumStringIndex<true>(cx, args[0], MyTestEnumValues::strings, "MyTestEnum", "argument 1", &index)) {
      return false;
    }
    MOZ_ASSERT(index >= 0);
    arg0 = static_cast<MyTestEnum>(index);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassEnum(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassEnum(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passEnum"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passEnum_methodinfo = {
  { (JSJitGetterOp)passEnum },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableEnum(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableEnum");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableEnum", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<MyTestEnum> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    {
      int index;
      if (!FindEnumStringIndex<true>(cx, args[0], MyTestEnumValues::strings, "MyTestEnum", "argument 1", &index)) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      arg0.SetValue() = static_cast<MyTestEnum>(index);
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableEnum(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableEnum(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableEnum"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableEnum_methodinfo = {
  { (JSJitGetterOp)passNullableEnum },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalEnum(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalEnum");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<MyTestEnum> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    {
      int index;
      if (!FindEnumStringIndex<true>(cx, args[0], MyTestEnumValues::strings, "MyTestEnum", "argument 1", &index)) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      arg0.Value() = static_cast<MyTestEnum>(index);
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalEnum(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalEnum(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalEnum"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalEnum_methodinfo = {
  { (JSJitGetterOp)passOptionalEnum },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passEnumWithDefault(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passEnumWithDefault");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passEnumWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  MyTestEnum arg0;
  if (args.hasDefined(0)) {
    {
      int index;
      if (!FindEnumStringIndex<true>(cx, args[0], MyTestEnumValues::strings, "MyTestEnum", "argument 1", &index)) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      arg0 = static_cast<MyTestEnum>(index);
    }
  } else {
    arg0 = MyTestEnum::A;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassEnumWithDefault(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassEnumWithDefault(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passEnumWithDefault"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passEnumWithDefault_methodinfo = {
  { (JSJitGetterOp)passEnumWithDefault },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableEnum(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableEnum");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Nullable<MyTestEnum>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      {
        int index;
        if (!FindEnumStringIndex<true>(cx, args[0], MyTestEnumValues::strings, "MyTestEnum", "argument 1", &index)) {
          return false;
        }
        MOZ_ASSERT(index >= 0);
        arg0.Value().SetValue() = static_cast<MyTestEnum>(index);
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableEnum(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableEnum(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableEnum"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableEnum_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableEnum },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableEnumWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableEnumWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableEnumWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<MyTestEnum> arg0;
  if (args.hasDefined(0)) {
    if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      {
        int index;
        if (!FindEnumStringIndex<true>(cx, args[0], MyTestEnumValues::strings, "MyTestEnum", "argument 1", &index)) {
          return false;
        }
        MOZ_ASSERT(index >= 0);
        arg0.SetValue() = static_cast<MyTestEnum>(index);
      }
    }
  } else {
    arg0.SetNull();
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableEnumWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableEnumWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableEnumWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableEnumWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableEnumWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableEnumWithDefaultValue2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableEnumWithDefaultValue2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableEnumWithDefaultValue2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<MyTestEnum> arg0;
  if (args.hasDefined(0)) {
    if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      {
        int index;
        if (!FindEnumStringIndex<true>(cx, args[0], MyTestEnumValues::strings, "MyTestEnum", "argument 1", &index)) {
          return false;
        }
        MOZ_ASSERT(index >= 0);
        arg0.SetValue() = static_cast<MyTestEnum>(index);
      }
    }
  } else {
    arg0.SetValue() = MyTestEnum::A;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableEnumWithDefaultValue2(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableEnumWithDefaultValue2(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableEnumWithDefaultValue2"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableEnumWithDefaultValue2_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableEnumWithDefaultValue2 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveEnum(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  MyTestEnum result(MOZ_KnownLive(self)->ReceiveEnum(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveEnum"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveEnum_methodinfo = {
  { (JSJitGetterOp)receiveEnum },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableEnum(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Nullable<MyTestEnum> result(MOZ_KnownLive(self)->ReceiveNullableEnum(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableEnum"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  } else {
    if (!ToJSValue(cx, result.Value(), args.rval())) {
      return false;
    }
    return true;
  }
}

static const JSJitInfo receiveNullableEnum_methodinfo = {
  { (JSJitGetterOp)receiveNullableEnum },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_enumAttribute(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "enumAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  MyTestEnum result(MOZ_KnownLive(self)->GetEnumAttribute(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.enumAttribute getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_enumAttribute(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.enumAttribute setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "enumAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  MyTestEnum arg0;
  {
    int index;
    if (!FindEnumStringIndex<false>(cx, args[0], MyTestEnumValues::strings, "MyTestEnum", "value being assigned", &index)) {
      return false;
    }
    if (index < 0) {
      return true;
    }
    arg0 = static_cast<MyTestEnum>(index);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetEnumAttribute(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetEnumAttribute(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.enumAttribute setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo enumAttribute_getterinfo = {
  { get_enumAttribute },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo enumAttribute_setterinfo = {
  { (JSJitGetterOp)set_enumAttribute },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyEnumAttribute(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "readonlyEnumAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  MyTestEnum result(MOZ_KnownLive(self)->GetReadonlyEnumAttribute(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.readonlyEnumAttribute getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo readonlyEnumAttribute_getterinfo = {
  { get_readonlyEnumAttribute },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passCallback(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passCallback");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passCallback", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedCallback<OwningNonNull<binding_detail::FastMyTestCallback>> arg0(cx);
  if (args[0].isObject()) {
    if (JS::IsCallable(&args[0].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastMyTestCallback(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassCallback(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassCallback(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passCallback"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passCallback_methodinfo = {
  { (JSJitGetterOp)passCallback },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableCallback(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableCallback");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableCallback", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedCallback<RefPtr<binding_detail::FastMyTestCallback>> arg0(cx);
  if (args[0].isObject()) {
    if (JS::IsCallable(&args[0].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastMyTestCallback(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
      return false;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableCallback(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableCallback(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableCallback"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableCallback_methodinfo = {
  { (JSJitGetterOp)passNullableCallback },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalCallback(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalCallback");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<OwningNonNull<MyTestCallback>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      if (JS::IsCallable(&args[0].toObject())) {
      { // scope for tempRoot and tempGlobalRoot if needed
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
        arg0.Value() = new MyTestCallback(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
      }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
        return false;
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalCallback(MOZ_KnownLive(NonNullHelper(Constify(arg0))), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalCallback(MOZ_KnownLive(NonNullHelper(Constify(arg0))), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalCallback"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalCallback_methodinfo = {
  { (JSJitGetterOp)passOptionalCallback },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableCallback(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableCallback");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<RefPtr<MyTestCallback>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      if (JS::IsCallable(&args[0].toObject())) {
      { // scope for tempRoot and tempGlobalRoot if needed
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
        arg0.Value() = new MyTestCallback(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
      }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
        return false;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value() = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableCallback(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableCallback(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableCallback"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableCallback_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableCallback },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableCallbackWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableCallbackWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableCallbackWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedCallback<RefPtr<binding_detail::FastMyTestCallback>> arg0(cx);
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      if (JS::IsCallable(&args[0].toObject())) {
      { // scope for tempRoot and tempGlobalRoot if needed
        arg0 = new binding_detail::FastMyTestCallback(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
      }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
        return false;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableCallbackWithDefaultValue(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableCallbackWithDefaultValue(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableCallbackWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableCallbackWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableCallbackWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveCallback(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  RefPtr<MyTestCallback> result(MOZ_KnownLive(self)->ReceiveCallback(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveCallback"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveCallback_methodinfo = {
  { (JSJitGetterOp)receiveCallback },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableCallback(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  RefPtr<MyTestCallback> result(MOZ_KnownLive(self)->ReceiveNullableCallback(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableCallback"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static const JSJitInfo receiveNullableCallback_methodinfo = {
  { (JSJitGetterOp)receiveNullableCallback },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableTreatAsNullCallbackWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableTreatAsNullCallbackWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableTreatAsNullCallbackWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedCallback<RefPtr<binding_detail::FastTestTreatAsNullCallback>> arg0(cx);
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      if (JS::IsCallable(&args[0].toObject())) {
      { // scope for tempRoot and tempGlobalRoot if needed
        arg0 = new binding_detail::FastTestTreatAsNullCallback(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
      }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
        return false;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableTreatAsNullCallbackWithDefaultValue(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableTreatAsNullCallbackWithDefaultValue(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableTreatAsNullCallbackWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableTreatAsNullCallbackWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableTreatAsNullCallbackWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passAny", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  JS::Rooted<JS::Value> arg0(cx);
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
  if ((true) && !CallerSubsumes(args[0])) {
    cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("argument 1");
    return false;
  }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
  arg0 = args[0];
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAny(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAny(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAny_methodinfo = {
  { (JSJitGetterOp)passAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passVariadicAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passVariadicAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  AutoSequence<JS::Value> arg0;
  SequenceRooter<JS::Value> arg0_holder(cx, &arg0);
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      JS::Value& slot = *arg0.AppendElement();
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
      if ((true) && !CallerSubsumes(args[variadicArg])) {
        cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("argument 1");
        return false;
      }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
      slot = args[variadicArg];
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passVariadicAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicAny_methodinfo = {
  { (JSJitGetterOp)passVariadicAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  JS::Rooted<JS::Value> arg0(cx);
  if (args.hasDefined(0)) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
    if ((true) && !CallerSubsumes(args[0])) {
      cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("argument 1");
      return false;
    }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
    arg0 = args[0];
  } else {
    arg0 = JS::UndefinedValue();
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalAny(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalAny(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalAny_methodinfo = {
  { (JSJitGetterOp)passOptionalAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAnyDefaultNull(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passAnyDefaultNull");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passAnyDefaultNull", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  JS::Rooted<JS::Value> arg0(cx);
  if (args.hasDefined(0)) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
    if ((true) && !CallerSubsumes(args[0])) {
      cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("argument 1");
      return false;
    }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
    arg0 = args[0];
  } else {
    arg0 = JS::NullValue();
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAnyDefaultNull(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAnyDefaultNull(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passAnyDefaultNull"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAnyDefaultNull_methodinfo = {
  { (JSJitGetterOp)passAnyDefaultNull },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passSequenceOfAny", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<JS::Value> arg0;
  SequenceRooter<JS::Value> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<JS::Value> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Value& slot = *slotPtr;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
      if ((true) && !CallerSubsumes(temp)) {
        cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of argument 1");
        return false;
      }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
      slot = temp;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passSequenceOfAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passSequenceOfAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableSequenceOfAny", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<Sequence<JS::Value>> arg0;
  SequenceRooter<JS::Value> arg0_holder(cx, &arg0.SetValue());
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    Sequence<JS::Value> &arr = arg0.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Value& slot = *slotPtr;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
      if ((true) && !CallerSubsumes(temp)) {
        cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of argument 1");
        return false;
      }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
      slot = temp;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableSequenceOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableSequenceOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableSequenceOfAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passNullableSequenceOfAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Sequence<JS::Value>> arg0;
  Maybe<SequenceRooter<JS::Value>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value());
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<JS::Value> &arr = arg0.Value();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Value& slot = *slotPtr;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
        if ((true) && !CallerSubsumes(temp)) {
          cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of argument 1");
          return false;
        }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
        slot = temp;
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSequenceOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSequenceOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalSequenceOfAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalSequenceOfAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Nullable<Sequence<JS::Value>>> arg0;
  Maybe<SequenceRooter<JS::Value>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<JS::Value> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Value& slot = *slotPtr;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
        if ((true) && !CallerSubsumes(temp)) {
          cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of argument 1");
          return false;
        }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
        slot = temp;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableSequenceOfAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceOfAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSequenceOfAnyWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalSequenceOfAnyWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalSequenceOfAnyWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<Sequence<JS::Value>> arg0;
  SequenceRooter<JS::Value> arg0_holder(cx, &arg0.SetValue());
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<JS::Value> &arr = arg0.SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Value& slot = *slotPtr;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
        if ((true) && !CallerSubsumes(temp)) {
          cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of argument 1");
          return false;
        }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
        slot = temp;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  } else {
    arg0.SetNull();
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSequenceOfAnyWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSequenceOfAnyWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalSequenceOfAnyWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSequenceOfAnyWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalSequenceOfAnyWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passSequenceOfSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passSequenceOfSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passSequenceOfSequenceOfAny", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<Sequence<JS::Value>> arg0;
  SequenceRooter<Sequence<JS::Value>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Sequence<JS::Value>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Sequence<JS::Value>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Sequence<JS::Value>& slot = *slotPtr;
      if (temp.isObject()) {
        JS::ForOfIterator iter1(cx);
        if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
          return false;
        }
        if (!iter1.valueIsIterable()) {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
        Sequence<JS::Value> &arr1 = slot;
        JS::Rooted<JS::Value> temp1(cx);
        while (true) {
          bool done1;
          if (!iter1.next(&temp1, &done1)) {
            return false;
          }
          if (done1) {
            break;
          }
          JS::Value* slotPtr1 = arr1.AppendElement(mozilla::fallible);
          if (!slotPtr1) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Value& slot1 = *slotPtr1;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
          if ((true) && !CallerSubsumes(temp1)) {
            cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of element of argument 1");
            return false;
          }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
          slot1 = temp1;
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfSequenceOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfSequenceOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passSequenceOfSequenceOfAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passSequenceOfSequenceOfAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfNullableSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passSequenceOfNullableSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passSequenceOfNullableSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passSequenceOfNullableSequenceOfAny", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<Nullable<Sequence<JS::Value>>> arg0;
  SequenceRooter<Nullable<Sequence<JS::Value>>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Nullable<Sequence<JS::Value>>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<Sequence<JS::Value>>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<Sequence<JS::Value>>& slot = *slotPtr;
      if (temp.isObject()) {
        JS::ForOfIterator iter1(cx);
        if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
          return false;
        }
        if (!iter1.valueIsIterable()) {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
        Sequence<JS::Value> &arr1 = slot.SetValue();
        JS::Rooted<JS::Value> temp1(cx);
        while (true) {
          bool done1;
          if (!iter1.next(&temp1, &done1)) {
            return false;
          }
          if (done1) {
            break;
          }
          JS::Value* slotPtr1 = arr1.AppendElement(mozilla::fallible);
          if (!slotPtr1) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Value& slot1 = *slotPtr1;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
          if ((true) && !CallerSubsumes(temp1)) {
            cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of element of argument 1");
            return false;
          }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
          slot1 = temp1;
        }
      } else if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfNullableSequenceOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfNullableSequenceOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passSequenceOfNullableSequenceOfAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfNullableSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passSequenceOfNullableSequenceOfAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableSequenceOfNullableSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableSequenceOfNullableSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableSequenceOfNullableSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableSequenceOfNullableSequenceOfAny", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<Sequence<Nullable<Sequence<JS::Value>>>> arg0;
  SequenceRooter<Nullable<Sequence<JS::Value>>> arg0_holder(cx, &arg0.SetValue());
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    Sequence<Nullable<Sequence<JS::Value>>> &arr = arg0.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<Sequence<JS::Value>>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<Sequence<JS::Value>>& slot = *slotPtr;
      if (temp.isObject()) {
        JS::ForOfIterator iter1(cx);
        if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
          return false;
        }
        if (!iter1.valueIsIterable()) {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
        Sequence<JS::Value> &arr1 = slot.SetValue();
        JS::Rooted<JS::Value> temp1(cx);
        while (true) {
          bool done1;
          if (!iter1.next(&temp1, &done1)) {
            return false;
          }
          if (done1) {
            break;
          }
          JS::Value* slotPtr1 = arr1.AppendElement(mozilla::fallible);
          if (!slotPtr1) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Value& slot1 = *slotPtr1;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
          if ((true) && !CallerSubsumes(temp1)) {
            cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of element of argument 1");
            return false;
          }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
          slot1 = temp1;
        }
      } else if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableSequenceOfNullableSequenceOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableSequenceOfNullableSequenceOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableSequenceOfNullableSequenceOfAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableSequenceOfNullableSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passNullableSequenceOfNullableSequenceOfAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceOfNullableSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableSequenceOfNullableSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableSequenceOfNullableSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Nullable<Sequence<Nullable<Sequence<JS::Value>>>>> arg0;
  Maybe<SequenceRooter<Nullable<Sequence<JS::Value>>>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<Nullable<Sequence<JS::Value>>> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Nullable<Sequence<JS::Value>>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Nullable<Sequence<JS::Value>>& slot = *slotPtr;
        if (temp.isObject()) {
          JS::ForOfIterator iter1(cx);
          if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter1.valueIsIterable()) {
            cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
            return false;
          }
          Sequence<JS::Value> &arr1 = slot.SetValue();
          JS::Rooted<JS::Value> temp1(cx);
          while (true) {
            bool done1;
            if (!iter1.next(&temp1, &done1)) {
              return false;
            }
            if (done1) {
              break;
            }
            JS::Value* slotPtr1 = arr1.AppendElement(mozilla::fallible);
            if (!slotPtr1) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            JS::Value& slot1 = *slotPtr1;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
            if ((true) && !CallerSubsumes(temp1)) {
              cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of element of argument 1");
              return false;
            }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
            slot1 = temp1;
          }
        } else if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableSequenceOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableSequenceOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableSequenceOfNullableSequenceOfAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceOfNullableSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceOfNullableSequenceOfAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passRecordOfAny", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Record<nsString, JS::Value> arg0;
  RecordRooter<nsString, JS::Value> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, JS::Value>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      JS::Value& slot = entry->mValue;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
      if ((true) && !CallerSubsumes(temp)) {
        cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("value in argument 1");
        return false;
      }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
      slot = temp;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passRecordOfAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passRecordOfAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableRecordOfAny", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<Record<nsString, JS::Value>> arg0;
  RecordRooter<nsString, JS::Value> arg0_holder(cx, &arg0.SetValue());
  if (args[0].isObject()) {
    auto& recordEntries = arg0.SetValue().Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, JS::Value>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      JS::Value& slot = entry->mValue;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
      if ((true) && !CallerSubsumes(temp)) {
        cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("value in argument 1");
        return false;
      }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
      slot = temp;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableRecordOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableRecordOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableRecordOfAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passNullableRecordOfAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Record<nsString, JS::Value>> arg0;
  Maybe<RecordRooter<nsString, JS::Value>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value());
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, JS::Value>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        JS::Value& slot = entry->mValue;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
        if ((true) && !CallerSubsumes(temp)) {
          cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("value in argument 1");
          return false;
        }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
        slot = temp;
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalRecordOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalRecordOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalRecordOfAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalRecordOfAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Nullable<Record<nsString, JS::Value>>> arg0;
  Maybe<RecordRooter<nsString, JS::Value>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, JS::Value>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        JS::Value& slot = entry->mValue;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
        if ((true) && !CallerSubsumes(temp)) {
          cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("value in argument 1");
          return false;
        }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
        slot = temp;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableRecordOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableRecordOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableRecordOfAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableRecordOfAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalRecordOfAnyWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalRecordOfAnyWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalRecordOfAnyWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<Record<nsString, JS::Value>> arg0;
  RecordRooter<nsString, JS::Value> arg0_holder(cx, &arg0.SetValue());
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      auto& recordEntries = arg0.SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, JS::Value>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        JS::Value& slot = entry->mValue;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
        if ((true) && !CallerSubsumes(temp)) {
          cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("value in argument 1");
          return false;
        }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
        slot = temp;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0.SetNull();
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalRecordOfAnyWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalRecordOfAnyWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalRecordOfAnyWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalRecordOfAnyWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalRecordOfAnyWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passRecordOfRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passRecordOfRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passRecordOfRecordOfAny", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Record<nsString, Record<nsString, JS::Value>> arg0;
  RecordRooter<nsString, Record<nsString, JS::Value>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, Record<nsString, JS::Value>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Record<nsString, JS::Value>& slot = entry->mValue;
      if (temp.isObject()) {
        auto& recordEntries = slot.Entries();

        JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
        JS::RootedVector<jsid> ids(cx);
        if (!js::GetPropertyKeys(cx, recordObj,
                                 JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
          return false;
        }
        if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Rooted<JS::Value> propNameValue(cx);
        JS::Rooted<JS::Value> temp(cx);
        JS::Rooted<jsid> curId(cx);
        JS::Rooted<JS::Value> idVal(cx);
        // Use a hashset to keep track of ids seen, to avoid
        // introducing nasty O(N^2) behavior scanning for them all the
        // time.  Ideally we'd use a data structure with O(1) lookup
        // _and_ ordering for the MozMap, but we don't have one lying
        // around.
        nsTHashtable<nsStringHashKey> idsSeen;
        for (size_t i = 0; i < ids.length(); ++i) {
          curId = ids[i];

          JS::Rooted<JS::PropertyDescriptor> desc(cx);
          if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                               &desc)) {
            return false;
          }

          if (!desc.object() /* == undefined in spec terms */ ||
              !desc.enumerable()) {
            continue;
          }

          idVal = js::IdToValue(curId);
          nsString propName;
          // This will just throw if idVal is a Symbol, like the spec says
          // to do.
          if (!ConvertJSValueToString(cx, idVal, "key of value in argument 1", propName)) {
            return false;
          }

          if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
            return false;
          }

          Record<nsString, JS::Value>::EntryType* entry;
          if (!idsSeen.EnsureInserted(propName)) {
            // Find the existing entry.
            auto idx = recordEntries.IndexOf(propName);
            MOZ_ASSERT(idx != recordEntries.NoIndex,
                       "Why is it not found?");
            // Now blow it away to make it look like it was just added
            // to the array, because it's not obvious that it's
            // safe to write to its already-initialized mValue via our
            // normal codegen conversions.  For example, the value
            // could be a union and this would change its type, but
            // codegen assumes we won't do that.
            entry = recordEntries.ReconstructElementAt(idx);
          } else {
            // Safe to do an infallible append here, because we did a
            // SetCapacity above to the right capacity.
            entry = recordEntries.AppendElement();
          }
          entry->mKey = propName;
          JS::Value& slot = entry->mValue;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
          if ((true) && !CallerSubsumes(temp)) {
            cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("value in value in argument 1");
            return false;
          }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
          slot = temp;
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfRecordOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfRecordOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passRecordOfRecordOfAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passRecordOfRecordOfAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfNullableRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passRecordOfNullableRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passRecordOfNullableRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passRecordOfNullableRecordOfAny", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Record<nsString, Nullable<Record<nsString, JS::Value>>> arg0;
  RecordRooter<nsString, Nullable<Record<nsString, JS::Value>>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, Nullable<Record<nsString, JS::Value>>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Nullable<Record<nsString, JS::Value>>& slot = entry->mValue;
      if (temp.isObject()) {
        auto& recordEntries = slot.SetValue().Entries();

        JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
        JS::RootedVector<jsid> ids(cx);
        if (!js::GetPropertyKeys(cx, recordObj,
                                 JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
          return false;
        }
        if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Rooted<JS::Value> propNameValue(cx);
        JS::Rooted<JS::Value> temp(cx);
        JS::Rooted<jsid> curId(cx);
        JS::Rooted<JS::Value> idVal(cx);
        // Use a hashset to keep track of ids seen, to avoid
        // introducing nasty O(N^2) behavior scanning for them all the
        // time.  Ideally we'd use a data structure with O(1) lookup
        // _and_ ordering for the MozMap, but we don't have one lying
        // around.
        nsTHashtable<nsStringHashKey> idsSeen;
        for (size_t i = 0; i < ids.length(); ++i) {
          curId = ids[i];

          JS::Rooted<JS::PropertyDescriptor> desc(cx);
          if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                               &desc)) {
            return false;
          }

          if (!desc.object() /* == undefined in spec terms */ ||
              !desc.enumerable()) {
            continue;
          }

          idVal = js::IdToValue(curId);
          nsString propName;
          // This will just throw if idVal is a Symbol, like the spec says
          // to do.
          if (!ConvertJSValueToString(cx, idVal, "key of value in argument 1", propName)) {
            return false;
          }

          if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
            return false;
          }

          Record<nsString, JS::Value>::EntryType* entry;
          if (!idsSeen.EnsureInserted(propName)) {
            // Find the existing entry.
            auto idx = recordEntries.IndexOf(propName);
            MOZ_ASSERT(idx != recordEntries.NoIndex,
                       "Why is it not found?");
            // Now blow it away to make it look like it was just added
            // to the array, because it's not obvious that it's
            // safe to write to its already-initialized mValue via our
            // normal codegen conversions.  For example, the value
            // could be a union and this would change its type, but
            // codegen assumes we won't do that.
            entry = recordEntries.ReconstructElementAt(idx);
          } else {
            // Safe to do an infallible append here, because we did a
            // SetCapacity above to the right capacity.
            entry = recordEntries.AppendElement();
          }
          entry->mKey = propName;
          JS::Value& slot = entry->mValue;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
          if ((true) && !CallerSubsumes(temp)) {
            cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("value in value in argument 1");
            return false;
          }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
          slot = temp;
        }
      } else if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfNullableRecordOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfNullableRecordOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passRecordOfNullableRecordOfAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfNullableRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passRecordOfNullableRecordOfAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableRecordOfNullableRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableRecordOfNullableRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableRecordOfNullableRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableRecordOfNullableRecordOfAny", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<Record<nsString, Nullable<Record<nsString, JS::Value>>>> arg0;
  RecordRooter<nsString, Nullable<Record<nsString, JS::Value>>> arg0_holder(cx, &arg0.SetValue());
  if (args[0].isObject()) {
    auto& recordEntries = arg0.SetValue().Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, Nullable<Record<nsString, JS::Value>>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Nullable<Record<nsString, JS::Value>>& slot = entry->mValue;
      if (temp.isObject()) {
        auto& recordEntries = slot.SetValue().Entries();

        JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
        JS::RootedVector<jsid> ids(cx);
        if (!js::GetPropertyKeys(cx, recordObj,
                                 JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
          return false;
        }
        if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Rooted<JS::Value> propNameValue(cx);
        JS::Rooted<JS::Value> temp(cx);
        JS::Rooted<jsid> curId(cx);
        JS::Rooted<JS::Value> idVal(cx);
        // Use a hashset to keep track of ids seen, to avoid
        // introducing nasty O(N^2) behavior scanning for them all the
        // time.  Ideally we'd use a data structure with O(1) lookup
        // _and_ ordering for the MozMap, but we don't have one lying
        // around.
        nsTHashtable<nsStringHashKey> idsSeen;
        for (size_t i = 0; i < ids.length(); ++i) {
          curId = ids[i];

          JS::Rooted<JS::PropertyDescriptor> desc(cx);
          if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                               &desc)) {
            return false;
          }

          if (!desc.object() /* == undefined in spec terms */ ||
              !desc.enumerable()) {
            continue;
          }

          idVal = js::IdToValue(curId);
          nsString propName;
          // This will just throw if idVal is a Symbol, like the spec says
          // to do.
          if (!ConvertJSValueToString(cx, idVal, "key of value in argument 1", propName)) {
            return false;
          }

          if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
            return false;
          }

          Record<nsString, JS::Value>::EntryType* entry;
          if (!idsSeen.EnsureInserted(propName)) {
            // Find the existing entry.
            auto idx = recordEntries.IndexOf(propName);
            MOZ_ASSERT(idx != recordEntries.NoIndex,
                       "Why is it not found?");
            // Now blow it away to make it look like it was just added
            // to the array, because it's not obvious that it's
            // safe to write to its already-initialized mValue via our
            // normal codegen conversions.  For example, the value
            // could be a union and this would change its type, but
            // codegen assumes we won't do that.
            entry = recordEntries.ReconstructElementAt(idx);
          } else {
            // Safe to do an infallible append here, because we did a
            // SetCapacity above to the right capacity.
            entry = recordEntries.AppendElement();
          }
          entry->mKey = propName;
          JS::Value& slot = entry->mValue;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
          if ((true) && !CallerSubsumes(temp)) {
            cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("value in value in argument 1");
            return false;
          }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
          slot = temp;
        }
      } else if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableRecordOfNullableRecordOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableRecordOfNullableRecordOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableRecordOfNullableRecordOfAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableRecordOfNullableRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passNullableRecordOfNullableRecordOfAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableRecordOfNullableRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableRecordOfNullableRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableRecordOfNullableRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Nullable<Record<nsString, Nullable<Record<nsString, JS::Value>>>>> arg0;
  Maybe<RecordRooter<nsString, Nullable<Record<nsString, JS::Value>>>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, Nullable<Record<nsString, JS::Value>>>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        Nullable<Record<nsString, JS::Value>>& slot = entry->mValue;
        if (temp.isObject()) {
          auto& recordEntries = slot.SetValue().Entries();

          JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
          JS::RootedVector<jsid> ids(cx);
          if (!js::GetPropertyKeys(cx, recordObj,
                                   JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
            return false;
          }
          if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Rooted<JS::Value> propNameValue(cx);
          JS::Rooted<JS::Value> temp(cx);
          JS::Rooted<jsid> curId(cx);
          JS::Rooted<JS::Value> idVal(cx);
          // Use a hashset to keep track of ids seen, to avoid
          // introducing nasty O(N^2) behavior scanning for them all the
          // time.  Ideally we'd use a data structure with O(1) lookup
          // _and_ ordering for the MozMap, but we don't have one lying
          // around.
          nsTHashtable<nsStringHashKey> idsSeen;
          for (size_t i = 0; i < ids.length(); ++i) {
            curId = ids[i];

            JS::Rooted<JS::PropertyDescriptor> desc(cx);
            if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                                 &desc)) {
              return false;
            }

            if (!desc.object() /* == undefined in spec terms */ ||
                !desc.enumerable()) {
              continue;
            }

            idVal = js::IdToValue(curId);
            nsString propName;
            // This will just throw if idVal is a Symbol, like the spec says
            // to do.
            if (!ConvertJSValueToString(cx, idVal, "key of value in argument 1", propName)) {
              return false;
            }

            if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
              return false;
            }

            Record<nsString, JS::Value>::EntryType* entry;
            if (!idsSeen.EnsureInserted(propName)) {
              // Find the existing entry.
              auto idx = recordEntries.IndexOf(propName);
              MOZ_ASSERT(idx != recordEntries.NoIndex,
                         "Why is it not found?");
              // Now blow it away to make it look like it was just added
              // to the array, because it's not obvious that it's
              // safe to write to its already-initialized mValue via our
              // normal codegen conversions.  For example, the value
              // could be a union and this would change its type, but
              // codegen assumes we won't do that.
              entry = recordEntries.ReconstructElementAt(idx);
            } else {
              // Safe to do an infallible append here, because we did a
              // SetCapacity above to the right capacity.
              entry = recordEntries.AppendElement();
            }
            entry->mKey = propName;
            JS::Value& slot = entry->mValue;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
            if ((true) && !CallerSubsumes(temp)) {
              cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("value in value in argument 1");
              return false;
            }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
            slot = temp;
          }
        } else if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableRecordOfNullableRecordOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableRecordOfNullableRecordOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableRecordOfNullableRecordOfAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableRecordOfNullableRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableRecordOfNullableRecordOfAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableRecordOfNullableSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableRecordOfNullableSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableRecordOfNullableSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Nullable<Record<nsString, Nullable<Sequence<JS::Value>>>>> arg0;
  Maybe<RecordRooter<nsString, Nullable<Sequence<JS::Value>>>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, Nullable<Sequence<JS::Value>>>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        Nullable<Sequence<JS::Value>>& slot = entry->mValue;
        if (temp.isObject()) {
          JS::ForOfIterator iter1(cx);
          if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter1.valueIsIterable()) {
            cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Value in argument 1");
            return false;
          }
          Sequence<JS::Value> &arr1 = slot.SetValue();
          JS::Rooted<JS::Value> temp1(cx);
          while (true) {
            bool done1;
            if (!iter1.next(&temp1, &done1)) {
              return false;
            }
            if (done1) {
              break;
            }
            JS::Value* slotPtr1 = arr1.AppendElement(mozilla::fallible);
            if (!slotPtr1) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            JS::Value& slot1 = *slotPtr1;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
            if ((true) && !CallerSubsumes(temp1)) {
              cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of value in argument 1");
              return false;
            }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
            slot1 = temp1;
          }
        } else if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Value in argument 1");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableRecordOfNullableSequenceOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableRecordOfNullableSequenceOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableRecordOfNullableSequenceOfAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableRecordOfNullableSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableRecordOfNullableSequenceOfAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceOfNullableRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableSequenceOfNullableRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableSequenceOfNullableRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Nullable<Sequence<Nullable<Record<nsString, JS::Value>>>>> arg0;
  Maybe<SequenceRooter<Nullable<Record<nsString, JS::Value>>>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<Nullable<Record<nsString, JS::Value>>> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Nullable<Record<nsString, JS::Value>>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Nullable<Record<nsString, JS::Value>>& slot = *slotPtr;
        if (temp.isObject()) {
          auto& recordEntries = slot.SetValue().Entries();

          JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
          JS::RootedVector<jsid> ids(cx);
          if (!js::GetPropertyKeys(cx, recordObj,
                                   JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
            return false;
          }
          if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Rooted<JS::Value> propNameValue(cx);
          JS::Rooted<JS::Value> temp(cx);
          JS::Rooted<jsid> curId(cx);
          JS::Rooted<JS::Value> idVal(cx);
          // Use a hashset to keep track of ids seen, to avoid
          // introducing nasty O(N^2) behavior scanning for them all the
          // time.  Ideally we'd use a data structure with O(1) lookup
          // _and_ ordering for the MozMap, but we don't have one lying
          // around.
          nsTHashtable<nsStringHashKey> idsSeen;
          for (size_t i = 0; i < ids.length(); ++i) {
            curId = ids[i];

            JS::Rooted<JS::PropertyDescriptor> desc(cx);
            if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                                 &desc)) {
              return false;
            }

            if (!desc.object() /* == undefined in spec terms */ ||
                !desc.enumerable()) {
              continue;
            }

            idVal = js::IdToValue(curId);
            nsString propName;
            // This will just throw if idVal is a Symbol, like the spec says
            // to do.
            if (!ConvertJSValueToString(cx, idVal, "key of element of argument 1", propName)) {
              return false;
            }

            if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
              return false;
            }

            Record<nsString, JS::Value>::EntryType* entry;
            if (!idsSeen.EnsureInserted(propName)) {
              // Find the existing entry.
              auto idx = recordEntries.IndexOf(propName);
              MOZ_ASSERT(idx != recordEntries.NoIndex,
                         "Why is it not found?");
              // Now blow it away to make it look like it was just added
              // to the array, because it's not obvious that it's
              // safe to write to its already-initialized mValue via our
              // normal codegen conversions.  For example, the value
              // could be a union and this would change its type, but
              // codegen assumes we won't do that.
              entry = recordEntries.ReconstructElementAt(idx);
            } else {
              // Safe to do an infallible append here, because we did a
              // SetCapacity above to the right capacity.
              entry = recordEntries.AppendElement();
            }
            entry->mKey = propName;
            JS::Value& slot = entry->mValue;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
            if ((true) && !CallerSubsumes(temp)) {
              cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("value in element of argument 1");
              return false;
            }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
            slot = temp;
          }
        } else if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableRecordOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableRecordOfAny(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableSequenceOfNullableRecordOfAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceOfNullableRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceOfNullableRecordOfAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveAny(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  JS::Rooted<JS::Value> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveAny(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveAny(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveAny"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveAny_methodinfo = {
  { (JSJitGetterOp)receiveAny },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passObject", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  JS::Rooted<JSObject*> arg0(cx);
  if (args[0].isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
    if ((true) && !CallerSubsumes(args[0])) {
      cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("argument 1");
      return false;
    }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
    arg0 = &args[0].toObject();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassObject(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassObject(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passObject"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passObject_methodinfo = {
  { (JSJitGetterOp)passObject },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passVariadicObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passVariadicObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  AutoSequence<JSObject*> arg0;
  SequenceRooter<JSObject*> arg0_holder(cx, &arg0);
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      JSObject*& slot = *arg0.AppendElement(nullptr);
      if (args[variadicArg].isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
        if ((true) && !CallerSubsumes(args[variadicArg])) {
          cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("argument 1");
          return false;
        }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
        slot = &args[variadicArg].toObject();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passVariadicObject"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicObject_methodinfo = {
  { (JSJitGetterOp)passVariadicObject },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableObject", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  JS::Rooted<JSObject*> arg0(cx);
  if (args[0].isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
    if ((true) && !CallerSubsumes(args[0])) {
      cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("argument 1");
      return false;
    }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
    arg0 = &args[0].toObject();
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableObject(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableObject(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableObject"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableObject_methodinfo = {
  { (JSJitGetterOp)passNullableObject },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicNullableObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passVariadicNullableObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passVariadicNullableObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  AutoSequence<JSObject*> arg0;
  SequenceRooter<JSObject*> arg0_holder(cx, &arg0);
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      JSObject*& slot = *arg0.AppendElement(nullptr);
      if (args[variadicArg].isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
        if ((true) && !CallerSubsumes(args[variadicArg])) {
          cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("argument 1");
          return false;
        }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
        slot = &args[variadicArg].toObject();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicNullableObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicNullableObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passVariadicNullableObject"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicNullableObject_methodinfo = {
  { (JSJitGetterOp)passVariadicNullableObject },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<JS::Handle<JSObject*>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct(cx);
    if (args[0].isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
      if ((true) && !CallerSubsumes(args[0])) {
        cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("argument 1");
        return false;
      }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
      arg0.Value() = &args[0].toObject();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalObject"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalObject_methodinfo = {
  { (JSJitGetterOp)passOptionalObject },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<JS::Handle<JSObject*>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct(cx);
    if (args[0].isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
      if ((true) && !CallerSubsumes(args[0])) {
        cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("argument 1");
        return false;
      }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
      arg0.Value() = &args[0].toObject();
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value() = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableObject"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableObject_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableObject },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableObjectWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableObjectWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableObjectWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  JS::Rooted<JSObject*> arg0(cx);
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
      if ((true) && !CallerSubsumes(args[0])) {
        cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("argument 1");
        return false;
      }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
      arg0 = &args[0].toObject();
    } else if (args[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableObjectWithDefaultValue(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableObjectWithDefaultValue(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableObjectWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableObjectWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableObjectWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passSequenceOfObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passSequenceOfObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passSequenceOfObject", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<JSObject*> arg0;
  SequenceRooter<JSObject*> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<JSObject*> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      JSObject** slotPtr = arr.AppendElement(nullptr, mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JSObject*& slot = *slotPtr;
      if (temp.isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
        if ((true) && !CallerSubsumes(temp)) {
          cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of argument 1");
          return false;
        }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
        slot = &temp.toObject();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passSequenceOfObject"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfObject_methodinfo = {
  { (JSJitGetterOp)passSequenceOfObject },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfNullableObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passSequenceOfNullableObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passSequenceOfNullableObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passSequenceOfNullableObject", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<JSObject*> arg0;
  SequenceRooter<JSObject*> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<JSObject*> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      JSObject** slotPtr = arr.AppendElement(nullptr, mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JSObject*& slot = *slotPtr;
      if (temp.isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
        if ((true) && !CallerSubsumes(temp)) {
          cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of argument 1");
          return false;
        }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
        slot = &temp.toObject();
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfNullableObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfNullableObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passSequenceOfNullableObject"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfNullableObject_methodinfo = {
  { (JSJitGetterOp)passSequenceOfNullableObject },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableSequenceOfObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableSequenceOfObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableSequenceOfObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableSequenceOfObject", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<Sequence<JSObject*>> arg0;
  SequenceRooter<JSObject*> arg0_holder(cx, &arg0.SetValue());
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    Sequence<JSObject*> &arr = arg0.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      JSObject** slotPtr = arr.AppendElement(nullptr, mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JSObject*& slot = *slotPtr;
      if (temp.isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
        if ((true) && !CallerSubsumes(temp)) {
          cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of argument 1");
          return false;
        }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
        slot = &temp.toObject();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableSequenceOfObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableSequenceOfObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableSequenceOfObject"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableSequenceOfObject_methodinfo = {
  { (JSJitGetterOp)passNullableSequenceOfObject },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceOfNullableSequenceOfObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableSequenceOfNullableSequenceOfObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableSequenceOfNullableSequenceOfObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Nullable<Sequence<Nullable<Sequence<JSObject*>>>>> arg0;
  Maybe<SequenceRooter<Nullable<Sequence<JSObject*>>>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<Nullable<Sequence<JSObject*>>> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Nullable<Sequence<JSObject*>>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Nullable<Sequence<JSObject*>>& slot = *slotPtr;
        if (temp.isObject()) {
          JS::ForOfIterator iter1(cx);
          if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter1.valueIsIterable()) {
            cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
            return false;
          }
          Sequence<JSObject*> &arr1 = slot.SetValue();
          JS::Rooted<JS::Value> temp1(cx);
          while (true) {
            bool done1;
            if (!iter1.next(&temp1, &done1)) {
              return false;
            }
            if (done1) {
              break;
            }
            JSObject** slotPtr1 = arr1.AppendElement(nullptr, mozilla::fallible);
            if (!slotPtr1) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            JSObject*& slot1 = *slotPtr1;
            if (temp1.isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
              if ((true) && !CallerSubsumes(temp1)) {
                cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of element of argument 1");
                return false;
              }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
              slot1 = &temp1.toObject();
            } else {
              cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of element of argument 1");
              return false;
            }
          }
        } else if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableSequenceOfObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableSequenceOfObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableSequenceOfNullableSequenceOfObject"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceOfNullableSequenceOfObject_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceOfNullableSequenceOfObject },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceOfNullableSequenceOfNullableObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableSequenceOfNullableSequenceOfNullableObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableSequenceOfNullableSequenceOfNullableObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Nullable<Sequence<Nullable<Sequence<JSObject*>>>>> arg0;
  Maybe<SequenceRooter<Nullable<Sequence<JSObject*>>>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<Nullable<Sequence<JSObject*>>> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Nullable<Sequence<JSObject*>>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Nullable<Sequence<JSObject*>>& slot = *slotPtr;
        if (temp.isObject()) {
          JS::ForOfIterator iter1(cx);
          if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter1.valueIsIterable()) {
            cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
            return false;
          }
          Sequence<JSObject*> &arr1 = slot.SetValue();
          JS::Rooted<JS::Value> temp1(cx);
          while (true) {
            bool done1;
            if (!iter1.next(&temp1, &done1)) {
              return false;
            }
            if (done1) {
              break;
            }
            JSObject** slotPtr1 = arr1.AppendElement(nullptr, mozilla::fallible);
            if (!slotPtr1) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            JSObject*& slot1 = *slotPtr1;
            if (temp1.isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
              if ((true) && !CallerSubsumes(temp1)) {
                cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of element of argument 1");
                return false;
              }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
              slot1 = &temp1.toObject();
            } else if (temp1.isNullOrUndefined()) {
              slot1 = nullptr;
            } else {
              cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of element of argument 1");
              return false;
            }
          }
        } else if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableSequenceOfNullableObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableSequenceOfNullableObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableSequenceOfNullableSequenceOfNullableObject"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceOfNullableSequenceOfNullableObject_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceOfNullableSequenceOfNullableObject },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passRecordOfObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passRecordOfObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passRecordOfObject", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Record<nsString, JSObject*> arg0;
  RecordRooter<nsString, JSObject*> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, JSObject*>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      JSObject*& slot = entry->mValue;
      if (temp.isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
        if ((true) && !CallerSubsumes(temp)) {
          cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("value in argument 1");
          return false;
        }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
        slot = &temp.toObject();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passRecordOfObject"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfObject_methodinfo = {
  { (JSJitGetterOp)passRecordOfObject },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveObject(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveObject(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveObject(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveObject"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveObject_methodinfo = {
  { (JSJitGetterOp)receiveObject },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableObject(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableObject(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableObject(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableObject"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
                JS::ExposeObjectToActiveJS(result);
              }
              args.rval().setObjectOrNull(result);
  if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableObject_methodinfo = {
  { (JSJitGetterOp)receiveNullableObject },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnion");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passUnion", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  ObjectOrLong arg0;
  ObjectOrLongArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      if (!arg0_holder.SetToObject(cx, &args[0].toObject(), true)) {
        return false;
      }
      done = true;
    } else {
      do {
        done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnion(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnion(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnion"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnion_methodinfo = {
  { (JSJitGetterOp)passUnion },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithNullable(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithNullable");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithNullable", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passUnionWithNullable", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  ObjectOrNullOrLong arg0;
  ObjectOrNullOrLongArgument arg0_holder(arg0);
  if (args[0].isNullOrUndefined()) {
    arg0_holder.SetNull();
  } else {
    {
      bool done = false, failed = false, tryNext;
      if (args[0].isObject()) {
        if (!arg0_holder.SetToObject(cx, &args[0].toObject(), true)) {
          return false;
        }
        done = true;
      } else {
        do {
          done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithNullable(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithNullable(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithNullable"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithNullable_methodinfo = {
  { (JSJitGetterOp)passUnionWithNullable },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnion");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passNullableUnion", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<ObjectOrLong > arg0;
  Maybe<ObjectOrLongArgument> arg0_holder;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      if (args[0].isObject()) {
        if (!arg0_holder.ref().SetToObject(cx, &args[0].toObject(), true)) {
          return false;
        }
        done = true;
      } else {
        do {
          done = (failed = !arg0_holder.ref().TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnion(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnion(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnion"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnion_methodinfo = {
  { (JSJitGetterOp)passNullableUnion },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalUnion");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<ObjectOrLong> arg0;
  Maybe<ObjectOrLongArgument> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(arg0.Value());
    {
      bool done = false, failed = false, tryNext;
      if (args[0].isObject()) {
        if (!arg0_holder.ref().SetToObject(cx, &args[0].toObject(), true)) {
          return false;
        }
        done = true;
      } else {
        do {
          done = (failed = !arg0_holder.ref().TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnion(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnion(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalUnion"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnion_methodinfo = {
  { (JSJitGetterOp)passOptionalUnion },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableUnion");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<Nullable<ObjectOrLong >> arg0;
  Maybe<ObjectOrLongArgument> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      arg0_holder.emplace(arg0.Value().SetValue());
      {
        bool done = false, failed = false, tryNext;
        if (args[0].isObject()) {
          if (!arg0_holder.ref().SetToObject(cx, &args[0].toObject(), true)) {
            return false;
          }
          done = true;
        } else {
          do {
            done = (failed = !arg0_holder.ref().TrySetToLong(cx, args[0], tryNext)) || !tryNext;
            break;
          } while (false);
        }
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableUnion(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableUnion(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableUnion"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableUnion_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableUnion },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableUnionWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOptionalNullableUnionWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalNullableUnionWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<ObjectOrLong > arg0;
  Maybe<ObjectOrLongArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      if (args[0].isObject()) {
        if (!arg0_holder.ref().SetToObject(cx, &args[0].toObject(), true)) {
          return false;
        }
        done = true;
      } else {
        do {
          done = (failed = !arg0_holder.ref().TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableUnionWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableUnionWithDefaultValue(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalNullableUnionWithDefaultValue"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableUnionWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableUnionWithDefaultValue },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passUnionWithArrayBuffer", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  ArrayBufferOrLong arg0;
  ArrayBufferOrLongArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      done = (failed = !arg0_holder.TrySetToArrayBuffer(cx, args[0], tryNext, true)) || !tryNext;

    }
    if (!done) {
      do {
        done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "ArrayBuffer");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithArrayBuffer"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passUnionWithArrayBuffer },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passUnionWithString", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  StringOrObject arg0;
  StringOrObjectArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      if (!arg0_holder.SetToObject(cx, &args[0].toObject(), true)) {
        return false;
      }
      done = true;
    } else {
      do {
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithString(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithString(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithString"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithString_methodinfo = {
  { (JSJitGetterOp)passUnionWithString },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithEnum(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithEnum");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passUnionWithEnum", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  SupportedTypeOrObject arg0;
  SupportedTypeOrObjectArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      if (!arg0_holder.SetToObject(cx, &args[0].toObject(), true)) {
        return false;
      }
      done = true;
    } else {
      do {
        done = (failed = !arg0_holder.TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithEnum(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithEnum(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithEnum"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithEnum_methodinfo = {
  { (JSJitGetterOp)passUnionWithEnum },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passUnionWithObject", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  ObjectOrLong arg0;
  ObjectOrLongArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      if (!arg0_holder.SetToObject(cx, &args[0].toObject(), true)) {
        return false;
      }
      done = true;
    } else {
      do {
        done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithObject(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithObject"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithObject_methodinfo = {
  { (JSJitGetterOp)passUnionWithObject },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue1(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue1");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue1", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  DoubleOrString arg0;
  DoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral(u"");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue1(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue1(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue1"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue1_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue1 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  DoubleOrString arg0;
  DoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.0;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue2(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue2(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue2"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue2_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue2 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue3(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue3");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  DoubleOrString arg0;
  DoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.5;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue3(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue3(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue3"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue3_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue3 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue4(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue4");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue4", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  FloatOrString arg0;
  FloatOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral(u"");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue4(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue4(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue4"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue4_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue4 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue5(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue5");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue5", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  FloatOrString arg0;
  FloatOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsFloat() = 1.0F;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue5(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue5(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue5"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue5_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue5 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue6(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue6");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue6", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  FloatOrString arg0;
  FloatOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsFloat() = 1.5F;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue6(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue6(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue6"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue6_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue6 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue7(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue7");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue7", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  UnrestrictedDoubleOrString arg0;
  UnrestrictedDoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral(u"");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue7(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue7(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue7"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue7_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue7 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue8(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue8");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue8", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  UnrestrictedDoubleOrString arg0;
  UnrestrictedDoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsUnrestrictedDouble() = 1.0;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue8(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue8(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue8"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue8_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue8 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue9(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue9");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue9", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  UnrestrictedDoubleOrString arg0;
  UnrestrictedDoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsUnrestrictedDouble() = 1.5;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue9(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue9(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue9"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue9_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue9 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue10(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue10");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue10", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  UnrestrictedDoubleOrString arg0;
  UnrestrictedDoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsUnrestrictedDouble() = mozilla::PositiveInfinity<double>();
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue10(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue10(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue10"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue10_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue10 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue11(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue11");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue11", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  UnrestrictedFloatOrString arg0;
  UnrestrictedFloatOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral(u"");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue11(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue11(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue11"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue11_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue11 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue12(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue12");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue12", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  UnrestrictedFloatOrString arg0;
  UnrestrictedFloatOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsUnrestrictedFloat() = 1.0F;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue12(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue12(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue12"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue12_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue12 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue13(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue13");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue13", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  UnrestrictedFloatOrString arg0;
  UnrestrictedFloatOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsUnrestrictedFloat() = mozilla::PositiveInfinity<float>();
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue13(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue13(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue13"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue13_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue13 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue14(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue14");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue14", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  DoubleOrByteString arg0;
  DoubleOrByteStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral("");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue14(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue14(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue14"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue14_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue14 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue15(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue15");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue15", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  DoubleOrByteString arg0;
  DoubleOrByteStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.0;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue15(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue15(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue15"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue15_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue15 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue16(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue16");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue16", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  DoubleOrByteString arg0;
  DoubleOrByteStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.5;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue16(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue16(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue16"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue16_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue16 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue17(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue17");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue17", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  DoubleOrSupportedType arg0;
  DoubleOrSupportedTypeArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsSupportedType() = SupportedType::Text_html;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue17(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue17(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue17"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue17_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue17 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue18(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue18");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue18", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  DoubleOrSupportedType arg0;
  DoubleOrSupportedTypeArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.0;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue18(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue18(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue18"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue18_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue18 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue19(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue19");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue19", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  DoubleOrSupportedType arg0;
  DoubleOrSupportedTypeArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.5;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue19(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue19(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue19"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue19_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue19 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue20(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue20");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue20", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  DoubleOrUSVString arg0;
  DoubleOrUSVStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral(u"abc");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue20(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue20(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue20"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue20_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue20 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue21(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue21");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue21", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  DoubleOrUSVString arg0;
  DoubleOrUSVStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.0;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue21(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue21(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue21"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue21_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue21 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue22(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue22");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue22", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  DoubleOrUSVString arg0;
  DoubleOrUSVStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.5;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue22(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue22(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue22"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue22_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue22 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue23(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue23");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue23", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  DoubleOrUTF8String arg0;
  DoubleOrUTF8StringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral("");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue23(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue23(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue23"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue23_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue23 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue24(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue24");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue24", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  DoubleOrUTF8String arg0;
  DoubleOrUTF8StringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.0;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue24(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue24(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue24"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue24_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue24 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue25(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionWithDefaultValue25");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionWithDefaultValue25", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  DoubleOrUTF8String arg0;
  DoubleOrUTF8StringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.5;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue25(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue25(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionWithDefaultValue25"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue25_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue25 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue1(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue1");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue1", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<DoubleOrString > arg0;
  Maybe<DoubleOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral(u"");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue1(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue1(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue1"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue1_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue1 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<DoubleOrString > arg0;
  Maybe<DoubleOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.0;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue2(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue2(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue2"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue2_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue2 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue3(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue3");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<DoubleOrString > arg0;
  Maybe<DoubleOrStringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue3(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue3(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue3"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue3_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue3 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue4(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue4");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue4", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<FloatOrString > arg0;
  Maybe<FloatOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral(u"");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToFloat(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue4(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue4(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue4"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue4_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue4 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue5(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue5");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue5", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<FloatOrString > arg0;
  Maybe<FloatOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsFloat() = 1.0F;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToFloat(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue5(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue5(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue5"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue5_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue5 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue6(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue6");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue6", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<FloatOrString > arg0;
  Maybe<FloatOrStringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue6(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue6(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue6"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue6_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue6 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue7(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue7");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue7", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<UnrestrictedDoubleOrString > arg0;
  Maybe<UnrestrictedDoubleOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral(u"");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue7(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue7(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue7"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue7_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue7 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue8(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue8");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue8", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<UnrestrictedDoubleOrString > arg0;
  Maybe<UnrestrictedDoubleOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsUnrestrictedDouble() = 1.0;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue8(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue8(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue8"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue8_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue8 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue9(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue9");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue9", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<UnrestrictedDoubleOrString > arg0;
  Maybe<UnrestrictedDoubleOrStringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue9(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue9(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue9"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue9_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue9 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue10(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue10");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue10", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<UnrestrictedFloatOrString > arg0;
  Maybe<UnrestrictedFloatOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral(u"");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToUnrestrictedFloat(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue10(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue10(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue10"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue10_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue10 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue11(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue11");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue11", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<UnrestrictedFloatOrString > arg0;
  Maybe<UnrestrictedFloatOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsUnrestrictedFloat() = 1.0F;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToUnrestrictedFloat(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue11(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue11(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue11"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue11_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue11 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue12(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue12");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue12", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<UnrestrictedFloatOrString > arg0;
  Maybe<UnrestrictedFloatOrStringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToUnrestrictedFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue12(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue12(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue12"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue12_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue12 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue13(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue13");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue13", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<DoubleOrByteString > arg0;
  Maybe<DoubleOrByteStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral("");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue13(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue13(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue13"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue13_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue13 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue14(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue14");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue14", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<DoubleOrByteString > arg0;
  Maybe<DoubleOrByteStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.0;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue14(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue14(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue14"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue14_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue14 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue15(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue15");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue15", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<DoubleOrByteString > arg0;
  Maybe<DoubleOrByteStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.5;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue15(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue15(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue15"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue15_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue15 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue16(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue16");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue16", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<DoubleOrByteString > arg0;
  Maybe<DoubleOrByteStringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue16(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue16(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue16"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue16_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue16 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue17(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue17");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue17", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<DoubleOrSupportedType > arg0;
  Maybe<DoubleOrSupportedTypeArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsSupportedType() = SupportedType::Text_html;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue17(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue17(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue17"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue17_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue17 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue18(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue18");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue18", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<DoubleOrSupportedType > arg0;
  Maybe<DoubleOrSupportedTypeArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.0;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue18(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue18(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue18"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue18_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue18 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue19(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue19");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue19", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<DoubleOrSupportedType > arg0;
  Maybe<DoubleOrSupportedTypeArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.5;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue19(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue19(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue19"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue19_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue19 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue20(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue20");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue20", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<DoubleOrSupportedType > arg0;
  Maybe<DoubleOrSupportedTypeArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue20(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue20(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue20"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue20_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue20 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue21(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue21");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue21", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<DoubleOrUSVString > arg0;
  Maybe<DoubleOrUSVStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral(u"abc");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue21(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue21(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue21"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue21_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue21 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue22(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue22");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue22", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<DoubleOrUSVString > arg0;
  Maybe<DoubleOrUSVStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.0;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue22(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue22(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue22"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue22_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue22 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue23(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue23");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue23", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<DoubleOrUSVString > arg0;
  Maybe<DoubleOrUSVStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.5;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue23(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue23(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue23"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue23_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue23 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue24(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue24");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue24", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<DoubleOrUSVString > arg0;
  Maybe<DoubleOrUSVStringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue24(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue24(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue24"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue24_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue24 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue25(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue25");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue25", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<DoubleOrUTF8String > arg0;
  Maybe<DoubleOrUTF8StringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral("");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue25(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue25(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue25"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue25_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue25 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue26(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue26");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue26", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<DoubleOrUTF8String > arg0;
  Maybe<DoubleOrUTF8StringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.0;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue26(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue26(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue26"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue26_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue26 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue27(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue27");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue27", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<DoubleOrUTF8String > arg0;
  Maybe<DoubleOrUTF8StringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.5;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue27(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue27(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue27"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue27_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue27 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue28(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passNullableUnionWithDefaultValue28");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passNullableUnionWithDefaultValue28", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<DoubleOrUTF8String > arg0;
  Maybe<DoubleOrUTF8StringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue28(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue28(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passNullableUnionWithDefaultValue28"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue28_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue28 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfUnions(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passSequenceOfUnions");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passSequenceOfUnions", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passSequenceOfUnions", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<OwningCanvasPatternOrCanvasGradient> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<OwningCanvasPatternOrCanvasGradient> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      OwningCanvasPatternOrCanvasGradient* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      OwningCanvasPatternOrCanvasGradient& slot = *slotPtr;
      {
        bool done = false, failed = false, tryNext;
        if (temp.isObject()) {
          done = (failed = !slot.TrySetToCanvasPattern(cx, temp, tryNext, true)) || !tryNext ||
                 (failed = !slot.TrySetToCanvasGradient(cx, temp, tryNext, true)) || !tryNext;

        }
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Element of argument 1", "CanvasPattern, CanvasGradient");
          return false;
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfUnions(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfUnions(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passSequenceOfUnions"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfUnions_methodinfo = {
  { (JSJitGetterOp)passSequenceOfUnions },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfUnions2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passSequenceOfUnions2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passSequenceOfUnions2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passSequenceOfUnions2", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<OwningObjectOrLong> arg0;
  SequenceRooter<OwningObjectOrLong> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<OwningObjectOrLong> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      OwningObjectOrLong* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      OwningObjectOrLong& slot = *slotPtr;
      {
        bool done = false, failed = false, tryNext;
        if (temp.isObject()) {
          if (!slot.SetToObject(cx, &temp.toObject(), true)) {
            return false;
          }
          done = true;
        } else {
          do {
            done = (failed = !slot.TrySetToLong(cx, temp, tryNext)) || !tryNext;
            break;
          } while (false);
        }
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Element of argument 1", "object");
          return false;
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfUnions2(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfUnions2(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passSequenceOfUnions2"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfUnions2_methodinfo = {
  { (JSJitGetterOp)passSequenceOfUnions2 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passVariadicUnion");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passVariadicUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  AutoSequence<OwningCanvasPatternOrCanvasGradient> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      OwningCanvasPatternOrCanvasGradient& slot = *arg0.AppendElement();
      {
        bool done = false, failed = false, tryNext;
        if (args[variadicArg].isObject()) {
          done = (failed = !slot.TrySetToCanvasPattern(cx, args[variadicArg], tryNext, true)) || !tryNext ||
                 (failed = !slot.TrySetToCanvasGradient(cx, args[variadicArg], tryNext, true)) || !tryNext;

        }
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "CanvasPattern, CanvasGradient");
          return false;
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicUnion(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicUnion(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passVariadicUnion"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicUnion_methodinfo = {
  { (JSJitGetterOp)passVariadicUnion },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfNullableUnions(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passSequenceOfNullableUnions");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passSequenceOfNullableUnions", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passSequenceOfNullableUnions", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<Nullable<OwningCanvasPatternOrCanvasGradient >> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Nullable<OwningCanvasPatternOrCanvasGradient >> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<OwningCanvasPatternOrCanvasGradient >* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<OwningCanvasPatternOrCanvasGradient >& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        {
          bool done = false, failed = false, tryNext;
          if (temp.isObject()) {
            done = (failed = !slot.SetValue().TrySetToCanvasPattern(cx, temp, tryNext, true)) || !tryNext ||
                   (failed = !slot.SetValue().TrySetToCanvasGradient(cx, temp, tryNext, true)) || !tryNext;

          }
          if (failed) {
            return false;
          }
          if (!done) {
            cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Element of argument 1", "CanvasPattern, CanvasGradient");
            return false;
          }
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfNullableUnions(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfNullableUnions(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passSequenceOfNullableUnions"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfNullableUnions_methodinfo = {
  { (JSJitGetterOp)passSequenceOfNullableUnions },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicNullableUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passVariadicNullableUnion");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passVariadicNullableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  AutoSequence<Nullable<OwningCanvasPatternOrCanvasGradient >> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      Nullable<OwningCanvasPatternOrCanvasGradient >& slot = *arg0.AppendElement();
      if (args[variadicArg].isNullOrUndefined()) {
        slot.SetNull();
      } else {
        {
          bool done = false, failed = false, tryNext;
          if (args[variadicArg].isObject()) {
            done = (failed = !slot.SetValue().TrySetToCanvasPattern(cx, args[variadicArg], tryNext, true)) || !tryNext ||
                   (failed = !slot.SetValue().TrySetToCanvasGradient(cx, args[variadicArg], tryNext, true)) || !tryNext;

          }
          if (failed) {
            return false;
          }
          if (!done) {
            cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "CanvasPattern, CanvasGradient");
            return false;
          }
        }
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicNullableUnion(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicNullableUnion(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passVariadicNullableUnion"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicNullableUnion_methodinfo = {
  { (JSJitGetterOp)passVariadicNullableUnion },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfUnions(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passRecordOfUnions");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passRecordOfUnions", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passRecordOfUnions", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Record<nsString, OwningCanvasPatternOrCanvasGradient> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, OwningCanvasPatternOrCanvasGradient>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      OwningCanvasPatternOrCanvasGradient& slot = entry->mValue;
      {
        bool done = false, failed = false, tryNext;
        if (temp.isObject()) {
          done = (failed = !slot.TrySetToCanvasPattern(cx, temp, tryNext, true)) || !tryNext ||
                 (failed = !slot.TrySetToCanvasGradient(cx, temp, tryNext, true)) || !tryNext;

        }
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Value in argument 1", "CanvasPattern, CanvasGradient");
          return false;
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfUnions(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfUnions(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passRecordOfUnions"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfUnions_methodinfo = {
  { (JSJitGetterOp)passRecordOfUnions },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUnion(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  OwningCanvasPatternOrCanvasGradient result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveUnion(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveUnion(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveUnion"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveUnion_methodinfo = {
  { (JSJitGetterOp)receiveUnion },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUnion2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveUnion2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  RootedUnion<OwningObjectOrLong> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveUnion2(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveUnion2(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveUnion2"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveUnion2_methodinfo = {
  { (JSJitGetterOp)receiveUnion2 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUnionContainingNull(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveUnionContainingNull", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  OwningCanvasPatternOrNullOrCanvasGradient result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveUnionContainingNull(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveUnionContainingNull(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveUnionContainingNull"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveUnionContainingNull_methodinfo = {
  { (JSJitGetterOp)receiveUnionContainingNull },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableUnion(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Nullable<OwningCanvasPatternOrCanvasGradient> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableUnion(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableUnion(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableUnion"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  if (!result.Value().ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableUnion_methodinfo = {
  { (JSJitGetterOp)receiveNullableUnion },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableUnion2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableUnion2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  NullableRootedUnion<OwningObjectOrLong> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableUnion2(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableUnion2(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableUnion2"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  if (!result.Value().ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableUnion2_methodinfo = {
  { (JSJitGetterOp)receiveNullableUnion2 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnion(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  OwningCanvasPatternOrCanvasGradient result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetWritableUnion(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetWritableUnion(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableUnion getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.writableUnion setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  CanvasPatternOrCanvasGradient arg0;
  CanvasPatternOrCanvasGradientArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      done = (failed = !arg0_holder.TrySetToCanvasPattern(cx, args[0], tryNext, true)) || !tryNext ||
             (failed = !arg0_holder.TrySetToCanvasGradient(cx, args[0], tryNext, true)) || !tryNext;

    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Value being assigned", "CanvasPattern, CanvasGradient");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnion(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnion(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableUnion setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnion_getterinfo = {
  { get_writableUnion },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo writableUnion_setterinfo = {
  { (JSJitGetterOp)set_writableUnion },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnionContainingNull(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableUnionContainingNull", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  OwningCanvasPatternOrNullOrCanvasGradient result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetWritableUnionContainingNull(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetWritableUnionContainingNull(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableUnionContainingNull getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnionContainingNull(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.writableUnionContainingNull setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableUnionContainingNull", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  CanvasPatternOrNullOrCanvasGradient arg0;
  CanvasPatternOrNullOrCanvasGradientArgument arg0_holder(arg0);
  if (args[0].isNullOrUndefined()) {
    arg0_holder.SetNull();
  } else {
    {
      bool done = false, failed = false, tryNext;
      if (args[0].isObject()) {
        done = (failed = !arg0_holder.TrySetToCanvasPattern(cx, args[0], tryNext, true)) || !tryNext ||
               (failed = !arg0_holder.TrySetToCanvasGradient(cx, args[0], tryNext, true)) || !tryNext;

      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Value being assigned", "CanvasPattern, CanvasGradient");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnionContainingNull(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnionContainingNull(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableUnionContainingNull setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnionContainingNull_getterinfo = {
  { get_writableUnionContainingNull },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo writableUnionContainingNull_setterinfo = {
  { (JSJitGetterOp)set_writableUnionContainingNull },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableNullableUnion(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableNullableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Nullable<OwningCanvasPatternOrCanvasGradient> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetWritableNullableUnion(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetWritableNullableUnion(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableNullableUnion getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  if (!result.Value().ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableNullableUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.writableNullableUnion setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "writableNullableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<CanvasPatternOrCanvasGradient > arg0;
  Maybe<CanvasPatternOrCanvasGradientArgument> arg0_holder;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      if (args[0].isObject()) {
        done = (failed = !arg0_holder.ref().TrySetToCanvasPattern(cx, args[0], tryNext, true)) || !tryNext ||
               (failed = !arg0_holder.ref().TrySetToCanvasGradient(cx, args[0], tryNext, true)) || !tryNext;

      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Value being assigned", "CanvasPattern, CanvasGradient");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableNullableUnion(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableNullableUnion(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.writableNullableUnion setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableNullableUnion_getterinfo = {
  { get_writableNullableUnion },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo writableNullableUnion_setterinfo = {
  { (JSJitGetterOp)set_writableNullableUnion },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passPromise(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passPromise", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passPromise", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  OwningNonNull<Promise> arg0;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoRealm,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx);
    globalObj = JS::CurrentGlobalOrNull(cx);
    JSAutoRealm ar(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      return false;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, args[0]);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      return false;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      MOZ_ALWAYS_TRUE(promiseRv.MaybeSetPendingException(cx));
      return false;
    }
    arg0 = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassPromise(NonNullHelper(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassPromise(NonNullHelper(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passPromise"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passPromise_methodinfo = {
  { (JSJitGetterOp)passPromise },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalPromise(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOptionalPromise", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<OwningNonNull<Promise>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    { // Scope for our GlobalObject, FastErrorResult, JSAutoRealm,
      // etc.

      JS::Rooted<JSObject*> globalObj(cx);
      globalObj = JS::CurrentGlobalOrNull(cx);
      JSAutoRealm ar(cx, globalObj);
      GlobalObject promiseGlobal(cx, globalObj);
      if (promiseGlobal.Failed()) {
        return false;
      }

      JS::Rooted<JS::Value> valueToResolve(cx, args[0]);
      if (!JS_WrapValue(cx, &valueToResolve)) {
        return false;
      }
      binding_detail::FastErrorResult promiseRv;
      nsCOMPtr<nsIGlobalObject> global =
        do_QueryInterface(promiseGlobal.GetAsSupports());
      if (!global) {
        promiseRv.Throw(NS_ERROR_UNEXPECTED);
        MOZ_ALWAYS_TRUE(promiseRv.MaybeSetPendingException(cx));
        return false;
      }
      arg0.Value() = Promise::Resolve(global, cx, valueToResolve,
                                      promiseRv);
      if (promiseRv.MaybeSetPendingException(cx)) {
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalPromise(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalPromise(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOptionalPromise"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalPromise_methodinfo = {
  { (JSJitGetterOp)passOptionalPromise },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passPromiseSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passPromiseSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passPromiseSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passPromiseSequence", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<OwningNonNull<Promise>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<OwningNonNull<Promise>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      OwningNonNull<Promise>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      OwningNonNull<Promise>& slot = *slotPtr;
      { // Scope for our GlobalObject, FastErrorResult, JSAutoRealm,
        // etc.

        JS::Rooted<JSObject*> globalObj(cx);
        globalObj = JS::CurrentGlobalOrNull(cx);
        JSAutoRealm ar(cx, globalObj);
        GlobalObject promiseGlobal(cx, globalObj);
        if (promiseGlobal.Failed()) {
          return false;
        }

        JS::Rooted<JS::Value> valueToResolve(cx, temp);
        if (!JS_WrapValue(cx, &valueToResolve)) {
          return false;
        }
        binding_detail::FastErrorResult promiseRv;
        nsCOMPtr<nsIGlobalObject> global =
          do_QueryInterface(promiseGlobal.GetAsSupports());
        if (!global) {
          promiseRv.Throw(NS_ERROR_UNEXPECTED);
          MOZ_ALWAYS_TRUE(promiseRv.MaybeSetPendingException(cx));
          return false;
        }
        slot = Promise::Resolve(global, cx, valueToResolve,
                                        promiseRv);
        if (promiseRv.MaybeSetPendingException(cx)) {
          return false;
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassPromiseSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassPromiseSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passPromiseSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passPromiseSequence_methodinfo = {
  { (JSJitGetterOp)passPromiseSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receivePromise(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receivePromise", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<Promise>(MOZ_KnownLive(self)->ReceivePromise(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receivePromise"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
receivePromise_promiseWrapper(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  bool ok = receivePromise(cx, obj, void_self, args);
  if (ok) {
    return true;
  }
  return ConvertExceptionToPromise(cx, args.rval());
}

static const JSJitInfo receivePromise_methodinfo = {
  { (JSJitGetterOp)receivePromise_promiseWrapper },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveAddrefedPromise(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveAddrefedPromise", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<Promise>(MOZ_KnownLive(self)->ReceiveAddrefedPromise(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveAddrefedPromise"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
receiveAddrefedPromise_promiseWrapper(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  bool ok = receiveAddrefedPromise(cx, obj, void_self, args);
  if (ok) {
    return true;
  }
  return ConvertExceptionToPromise(cx, args.rval());
}

static const JSJitInfo receiveAddrefedPromise_methodinfo = {
  { (JSJitGetterOp)receiveAddrefedPromise_promiseWrapper },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
methodRenamedFrom(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.methodRenamedFrom");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "methodRenamedFrom", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->MethodRenamedTo(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->MethodRenamedTo(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.methodRenamedFrom"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      int8_t arg0;
      if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->MethodRenamedTo(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->MethodRenamedTo(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.methodRenamedFrom"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo methodRenamedFrom_methodinfo = {
  { (JSJitGetterOp)methodRenamedFrom },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_attributeGetterRenamedFrom(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "attributeGetterRenamedFrom", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int8_t result(MOZ_KnownLive(self)->GetAttributeGetterRenamedTo(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.attributeGetterRenamedFrom getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo attributeGetterRenamedFrom_getterinfo = {
  { get_attributeGetterRenamedFrom },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_attributeRenamedFrom(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "attributeRenamedFrom", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int8_t result(MOZ_KnownLive(self)->GetAttributeRenamedTo(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.attributeRenamedFrom getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_attributeRenamedFrom(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "attributeRenamedFrom", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAttributeRenamedTo(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAttributeRenamedTo(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.attributeRenamedFrom setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo attributeRenamedFrom_getterinfo = {
  { get_attributeRenamedFrom },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo attributeRenamedFrom_setterinfo = {
  { (JSJitGetterOp)set_attributeRenamedFrom },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passDictionary(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passDictionary");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedDictionary<binding_detail::FastDict> arg0(cx);
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", true)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictionary(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassDictionary(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passDictionary"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passDictionary_methodinfo = {
  { (JSJitGetterOp)passDictionary },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passDictionary2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passDictionary2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passDictionary2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passDictionary2", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedDictionary<binding_detail::FastDict> arg0(cx);
  if (!arg0.Init(cx, args[0], "Argument 1", true)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictionary2(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassDictionary2(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passDictionary2"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passDictionary2_methodinfo = {
  { (JSJitGetterOp)passDictionary2 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveDictionary(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  RootedDictionary<Dict> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveDictionary(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveDictionary(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveDictionary"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToObjectInternal(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveDictionary_methodinfo = {
  { (JSJitGetterOp)receiveDictionary },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableDictionary(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveNullableDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  NullableRootedDictionary<Dict> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableDictionary(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableDictionary(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveNullableDictionary"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  if (!result.Value().ToObjectInternal(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableDictionary_methodinfo = {
  { (JSJitGetterOp)receiveNullableDictionary },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOtherDictionary(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passOtherDictionary");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passOtherDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::FastGrandparentDict arg0;
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", true)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOtherDictionary(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOtherDictionary(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passOtherDictionary"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOtherDictionary_methodinfo = {
  { (JSJitGetterOp)passOtherDictionary },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfDictionaries(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passSequenceOfDictionaries");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passSequenceOfDictionaries", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passSequenceOfDictionaries", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::AutoSequence<Dict> arg0;
  SequenceRooter<Dict> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Dict> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Dict* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Dict& slot = *slotPtr;
      if (!slot.Init(cx, temp, "Element of argument 1", true)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfDictionaries(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfDictionaries(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passSequenceOfDictionaries"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfDictionaries_methodinfo = {
  { (JSJitGetterOp)passSequenceOfDictionaries },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfDictionaries(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passRecordOfDictionaries");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passRecordOfDictionaries", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passRecordOfDictionaries", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Record<nsString, GrandparentDict> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, GrandparentDict>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      GrandparentDict& slot = entry->mValue;
      if (!slot.Init(cx, temp, "Value in argument 1", true)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfDictionaries(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfDictionaries(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passRecordOfDictionaries"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfDictionaries_methodinfo = {
  { (JSJitGetterOp)passRecordOfDictionaries },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passDictionaryOrLong(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passDictionaryOrLong");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passDictionaryOrLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      RootedDictionary<binding_detail::FastDict> arg0(cx);
      if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", true)) {
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictionaryOrLong(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->PassDictionaryOrLong(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passDictionaryOrLong"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isNullOrUndefined()) {
        RootedDictionary<binding_detail::FastDict> arg0(cx);
        if (!arg0.Init(cx, args[0], "Argument 1", true)) {
          return false;
        }
        Maybe<JS::Rooted<JSObject*> > unwrappedObj;
        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        if (objIsXray) {
          unwrappedObj.emplace(cx, obj);
        }
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
          if (!unwrappedObj.ref()) {
            return false;
          }
        }
        FastErrorResult rv;
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictionaryOrLong(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
        MOZ_KnownLive(self)->PassDictionaryOrLong(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
        if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passDictionaryOrLong"))) {
          return false;
        }
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isObject()) {
        do {
          RootedDictionary<binding_detail::FastDict> arg0(cx);
          if (!arg0.Init(cx, args[0], "Argument 1", true)) {
            return false;
          }
          Maybe<JS::Rooted<JSObject*> > unwrappedObj;
          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          if (objIsXray) {
            unwrappedObj.emplace(cx, obj);
          }
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
            if (!unwrappedObj.ref()) {
              return false;
            }
          }
          FastErrorResult rv;
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictionaryOrLong(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
          MOZ_KnownLive(self)->PassDictionaryOrLong(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passDictionaryOrLong"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictionaryOrLong(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->PassDictionaryOrLong(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passDictionaryOrLong"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo passDictionaryOrLong_methodinfo = {
  { (JSJitGetterOp)passDictionaryOrLong },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passDictContainingDict(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passDictContainingDict");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passDictContainingDict", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedDictionary<binding_detail::FastDictContainingDict> arg0(cx);
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", true)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictContainingDict(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassDictContainingDict(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passDictContainingDict"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passDictContainingDict_methodinfo = {
  { (JSJitGetterOp)passDictContainingDict },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passDictContainingSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passDictContainingSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passDictContainingSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedDictionary<binding_detail::FastDictContainingSequence> arg0(cx);
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", true)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictContainingSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassDictContainingSequence(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passDictContainingSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passDictContainingSequence_methodinfo = {
  { (JSJitGetterOp)passDictContainingSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveDictContainingSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "receiveDictContainingSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  RootedDictionary<DictContainingSequence> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveDictContainingSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveDictContainingSequence(result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.receiveDictContainingSequence"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToObjectInternal(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveDictContainingSequence_methodinfo = {
  { (JSJitGetterOp)receiveDictContainingSequence },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicDictionary(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passVariadicDictionary");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passVariadicDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  AutoSequence<Dict> arg0;
  SequenceRooter<Dict> arg0_holder(cx, &arg0);
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      Dict& slot = *arg0.AppendElement();
      if (!slot.Init(cx, args[variadicArg], "Argument 1", true)) {
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicDictionary(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicDictionary(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passVariadicDictionary"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicDictionary_methodinfo = {
  { (JSJitGetterOp)passVariadicDictionary },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
dontEnforceRangeOrClamp(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "dontEnforceRangeOrClamp", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.dontEnforceRangeOrClamp", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DontEnforceRangeOrClamp(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->DontEnforceRangeOrClamp(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.dontEnforceRangeOrClamp"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo dontEnforceRangeOrClamp_methodinfo = {
  { (JSJitGetterOp)dontEnforceRangeOrClamp },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
doEnforceRange(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.doEnforceRange");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "doEnforceRange", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.doEnforceRange", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eEnforceRange>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DoEnforceRange(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->DoEnforceRange(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.doEnforceRange"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo doEnforceRange_methodinfo = {
  { (JSJitGetterOp)doEnforceRange },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
doEnforceRangeNullable(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.doEnforceRangeNullable");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "doEnforceRangeNullable", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.doEnforceRangeNullable", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<int8_t> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<int8_t, eEnforceRange>(cx, args[0], "Argument 1", &arg0.SetValue())) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DoEnforceRangeNullable(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->DoEnforceRangeNullable(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.doEnforceRangeNullable"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo doEnforceRangeNullable_methodinfo = {
  { (JSJitGetterOp)doEnforceRangeNullable },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
doClamp(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "doClamp", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.doClamp", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eClamp>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DoClamp(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->DoClamp(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.doClamp"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo doClamp_methodinfo = {
  { (JSJitGetterOp)doClamp },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
doClampNullable(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "doClampNullable", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.doClampNullable", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<int8_t> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<int8_t, eClamp>(cx, args[0], "Argument 1", &arg0.SetValue())) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DoClampNullable(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->DoClampNullable(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.doClampNullable"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo doClampNullable_methodinfo = {
  { (JSJitGetterOp)doClampNullable },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_enforcedByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "enforcedByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int8_t result(MOZ_KnownLive(self)->GetEnforcedByte(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.enforcedByte getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_enforcedByte(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.enforcedByte setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "enforcedByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eEnforceRange>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetEnforcedByte(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetEnforcedByte(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.enforcedByte setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo enforcedByte_getterinfo = {
  { get_enforcedByte },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo enforcedByte_setterinfo = {
  { (JSJitGetterOp)set_enforcedByte },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_enforcedByteNullable(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "enforcedByteNullable", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Nullable<int8_t> result(MOZ_KnownLive(self)->GetEnforcedByteNullable(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.enforcedByteNullable getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  args.rval().setInt32(int32_t(result.Value()));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_enforcedByteNullable(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.enforcedByteNullable setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "enforcedByteNullable", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<int8_t> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<int8_t, eEnforceRange>(cx, args[0], "Value being assigned", &arg0.SetValue())) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetEnforcedByteNullable(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetEnforcedByteNullable(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.enforcedByteNullable setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo enforcedByteNullable_getterinfo = {
  { get_enforcedByteNullable },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo enforcedByteNullable_setterinfo = {
  { (JSJitGetterOp)set_enforcedByteNullable },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_clampedByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "clampedByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int8_t result(MOZ_KnownLive(self)->GetClampedByte(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.clampedByte getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_clampedByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "clampedByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eClamp>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetClampedByte(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetClampedByte(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.clampedByte setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo clampedByte_getterinfo = {
  { get_clampedByte },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo clampedByte_setterinfo = {
  { (JSJitGetterOp)set_clampedByte },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_clampedByteNullable(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "clampedByteNullable", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  Nullable<int8_t> result(MOZ_KnownLive(self)->GetClampedByteNullable(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.clampedByteNullable getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  args.rval().setInt32(int32_t(result.Value()));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_clampedByteNullable(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "clampedByteNullable", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Nullable<int8_t> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<int8_t, eClamp>(cx, args[0], "Value being assigned", &arg0.SetValue())) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetClampedByteNullable(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetClampedByteNullable(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.clampedByteNullable setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo clampedByteNullable_getterinfo = {
  { get_clampedByteNullable },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo clampedByteNullable_setterinfo = {
  { (JSJitGetterOp)set_clampedByteNullable },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
exerciseTypedefInterfaces1(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.exerciseTypedefInterfaces1");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "exerciseTypedefInterfaces1", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.exerciseTypedefInterfaces1", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  NonNull<mozilla::dom::TestJSImplInterface> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestJSImplInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ExerciseTypedefInterfaces1(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ExerciseTypedefInterfaces1(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.exerciseTypedefInterfaces1"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo exerciseTypedefInterfaces1_methodinfo = {
  { (JSJitGetterOp)exerciseTypedefInterfaces1 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
exerciseTypedefInterfaces2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.exerciseTypedefInterfaces2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "exerciseTypedefInterfaces2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.exerciseTypedefInterfaces2", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  mozilla::dom::TestJSImplInterface* arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestJSImplInterface");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestJSImplInterface>(MOZ_KnownLive(self)->ExerciseTypedefInterfaces2(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.exerciseTypedefInterfaces2"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo exerciseTypedefInterfaces2_methodinfo = {
  { (JSJitGetterOp)exerciseTypedefInterfaces2 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
exerciseTypedefInterfaces3(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.exerciseTypedefInterfaces3");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "exerciseTypedefInterfaces3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.exerciseTypedefInterfaces3", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  NonNull<mozilla::dom::TestJSImplInterface> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestJSImplInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ExerciseTypedefInterfaces3(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ExerciseTypedefInterfaces3(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.exerciseTypedefInterfaces3"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo exerciseTypedefInterfaces3_methodinfo = {
  { (JSJitGetterOp)exerciseTypedefInterfaces3 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_deprecatedAttribute(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "deprecatedAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int8_t result(MOZ_KnownLive(self)->GetDeprecatedAttribute(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.deprecatedAttribute getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_deprecatedAttribute(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "deprecatedAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetDeprecatedAttribute(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetDeprecatedAttribute(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.deprecatedAttribute setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo deprecatedAttribute_getterinfo = {
  { get_deprecatedAttribute },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo deprecatedAttribute_setterinfo = {
  { (JSJitGetterOp)set_deprecatedAttribute },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
deprecatedMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "deprecatedMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int8_t result(MOZ_KnownLive(self)->DeprecatedMethod(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.deprecatedMethod"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo deprecatedMethod_methodinfo = {
  { (JSJitGetterOp)deprecatedMethod },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
deprecatedMethodWithContext(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.deprecatedMethodWithContext");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "deprecatedMethodWithContext", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.deprecatedMethodWithContext", 1)) {
    return false;
  }
  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  JS::Rooted<JS::Value> arg0(cx);
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
  if ((true) && !CallerSubsumes(args[0])) {
    cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("argument 1");
    return false;
  }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
  arg0 = args[0];
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DeprecatedMethodWithContext(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->DeprecatedMethodWithContext(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.deprecatedMethodWithContext"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo deprecatedMethodWithContext_methodinfo = {
  { (JSJitGetterOp)deprecatedMethodWithContext },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload1(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.overload1");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "overload1", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 2u);
  switch (argcount) {
    case 1: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      NonNull<mozilla::dom::TestJSImplInterface> arg0;
      if (args[0].isObject()) {
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(args[0], arg0, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestJSImplInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      bool result(MOZ_KnownLive(self)->Overload1(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload1"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setBoolean(result);
      return true;
      break;
    }
    case 2: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      NonNull<mozilla::dom::TestJSImplInterface> arg1;
      if (args[1].isObject()) {
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(args[1], arg1, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 2", "TestJSImplInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 2");
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      auto result(StrongOrRawPtr<mozilla::dom::TestJSImplInterface>(MOZ_KnownLive(self)->Overload1(NonNullHelper(Constify(arg0)), MOZ_KnownLive(NonNullHelper(arg1)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload1"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload1_methodinfo = {
  { (JSJitGetterOp)overload1 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.overload2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "overload2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      RootedDictionary<binding_detail::FastDict> arg0(cx);
      if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", true)) {
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload2(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload2(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload2"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isNullOrUndefined()) {
        RootedDictionary<binding_detail::FastDict> arg0(cx);
        if (!arg0.Init(cx, args[0], "Argument 1", true)) {
          return false;
        }
        Maybe<JS::Rooted<JSObject*> > unwrappedObj;
        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        if (objIsXray) {
          unwrappedObj.emplace(cx, obj);
        }
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
          if (!unwrappedObj.ref()) {
            return false;
          }
        }
        FastErrorResult rv;
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload2(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload2(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
        if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload2"))) {
          return false;
        }
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestJSImplInterface> arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          Maybe<JS::Rooted<JSObject*> > unwrappedObj;
          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          if (objIsXray) {
            unwrappedObj.emplace(cx, obj);
          }
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
            if (!unwrappedObj.ref()) {
              return false;
            }
          }
          FastErrorResult rv;
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload2(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload2(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload2"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          RootedDictionary<binding_detail::FastDict> arg0(cx);
          if (!arg0.Init(cx, args[0], "Argument 1", true)) {
            return false;
          }
          Maybe<JS::Rooted<JSObject*> > unwrappedObj;
          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          if (objIsXray) {
            unwrappedObj.emplace(cx, obj);
          }
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
            if (!unwrappedObj.ref()) {
              return false;
            }
          }
          FastErrorResult rv;
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload2(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload2(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload2"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      if (args[0].isBoolean()) {
        Maybe<JS::Rooted<JSObject*> > unwrappedObj;
        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        if (objIsXray) {
          unwrappedObj.emplace(cx, obj);
        }
        bool arg0;
        if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
          if (!unwrappedObj.ref()) {
            return false;
          }
        }
        FastErrorResult rv;
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload2(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload2(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
        if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload2"))) {
          return false;
        }
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload2(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload2(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload2"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload2_methodinfo = {
  { (JSJitGetterOp)overload2 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload3(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.overload3");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "overload3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestJSImplInterface> arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          Maybe<JS::Rooted<JSObject*> > unwrappedObj;
          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          if (objIsXray) {
            unwrappedObj.emplace(cx, obj);
          }
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
            if (!unwrappedObj.ref()) {
              return false;
            }
          }
          FastErrorResult rv;
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload3(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload3(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload3"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          RootedCallback<OwningNonNull<binding_detail::FastMyTestCallback>> arg0(cx);
          if (JS::IsCallable(&args[0].toObject())) {
          { // scope for tempRoot and tempGlobalRoot if needed
            arg0 = new binding_detail::FastMyTestCallback(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
          }
          } else {
            break;
          }
          Maybe<JS::Rooted<JSObject*> > unwrappedObj;
          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          if (objIsXray) {
            unwrappedObj.emplace(cx, obj);
          }
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
            if (!unwrappedObj.ref()) {
              return false;
            }
          }
          FastErrorResult rv;
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload3(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload3(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload3"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      bool arg0;
      if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload3(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload3(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload3"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload3_methodinfo = {
  { (JSJitGetterOp)overload3 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload4(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.overload4");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "overload4", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestJSImplInterface> arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          Maybe<JS::Rooted<JSObject*> > unwrappedObj;
          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          if (objIsXray) {
            unwrappedObj.emplace(cx, obj);
          }
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
            if (!unwrappedObj.ref()) {
              return false;
            }
          }
          FastErrorResult rv;
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload4(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload4(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload4"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          RootedCallback<OwningNonNull<binding_detail::FastTestCallbackInterface>> arg0(cx);
          { // scope for tempRoot and tempGlobalRoot if needed
            arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
          }
          Maybe<JS::Rooted<JSObject*> > unwrappedObj;
          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          if (objIsXray) {
            unwrappedObj.emplace(cx, obj);
          }
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
            if (!unwrappedObj.ref()) {
              return false;
            }
          }
          FastErrorResult rv;
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload4(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload4(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload4"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload4(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload4(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload4"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload4_methodinfo = {
  { (JSJitGetterOp)overload4 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload5(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.overload5");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "overload5", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isNumber()) {
        Maybe<JS::Rooted<JSObject*> > unwrappedObj;
        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        if (objIsXray) {
          unwrappedObj.emplace(cx, obj);
        }
        int32_t arg0;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
          if (!unwrappedObj.ref()) {
            return false;
          }
        }
        FastErrorResult rv;
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload5(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload5(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
        if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload5"))) {
          return false;
        }
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      MyTestEnum arg0;
      {
        int index;
        if (!FindEnumStringIndex<true>(cx, args[0], MyTestEnumValues::strings, "MyTestEnum", "argument 1", &index)) {
          return false;
        }
        MOZ_ASSERT(index >= 0);
        arg0 = static_cast<MyTestEnum>(index);
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload5(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload5(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload5"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload5_methodinfo = {
  { (JSJitGetterOp)overload5 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload6(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.overload6");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "overload6", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isBoolean()) {
        Maybe<JS::Rooted<JSObject*> > unwrappedObj;
        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        if (objIsXray) {
          unwrappedObj.emplace(cx, obj);
        }
        bool arg0;
        if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
          if (!unwrappedObj.ref()) {
            return false;
          }
        }
        FastErrorResult rv;
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload6(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload6(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
        if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload6"))) {
          return false;
        }
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload6(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload6(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload6"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload6_methodinfo = {
  { (JSJitGetterOp)overload6 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload7(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.overload7");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "overload7", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isBoolean()) {
        Maybe<JS::Rooted<JSObject*> > unwrappedObj;
        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        if (objIsXray) {
          unwrappedObj.emplace(cx, obj);
        }
        bool arg0;
        if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
          if (!unwrappedObj.ref()) {
            return false;
          }
        }
        FastErrorResult rv;
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload7(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload7(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
        if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload7"))) {
          return false;
        }
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isNumber()) {
        Maybe<JS::Rooted<JSObject*> > unwrappedObj;
        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        if (objIsXray) {
          unwrappedObj.emplace(cx, obj);
        }
        int32_t arg0;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
          if (!unwrappedObj.ref()) {
            return false;
          }
        }
        FastErrorResult rv;
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload7(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload7(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
        if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload7"))) {
          return false;
        }
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      nsCString arg0;
      if (!ConvertJSValueToByteString(cx, args[0], false, "argument 1", arg0)) {
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload7(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload7(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload7"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload7_methodinfo = {
  { (JSJitGetterOp)overload7 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload8(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.overload8");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "overload8", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestJSImplInterface> arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          Maybe<JS::Rooted<JSObject*> > unwrappedObj;
          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          if (objIsXray) {
            unwrappedObj.emplace(cx, obj);
          }
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
            if (!unwrappedObj.ref()) {
              return false;
            }
          }
          FastErrorResult rv;
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload8(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload8(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload8"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload8(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload8(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload8"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload8_methodinfo = {
  { (JSJitGetterOp)overload8 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload9(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.overload9");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "overload9", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isNullOrUndefined()) {
        Nullable<int32_t> arg0;
        if (args[0].isNullOrUndefined()) {
          arg0.SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
          return false;
        }
        Maybe<JS::Rooted<JSObject*> > unwrappedObj;
        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        if (objIsXray) {
          unwrappedObj.emplace(cx, obj);
        }
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
          if (!unwrappedObj.ref()) {
            return false;
          }
        }
        FastErrorResult rv;
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload9(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload9(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
        if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload9"))) {
          return false;
        }
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isNumber()) {
        Maybe<JS::Rooted<JSObject*> > unwrappedObj;
        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        if (objIsXray) {
          unwrappedObj.emplace(cx, obj);
        }
        Nullable<int32_t> arg0;
        if (args[0].isNullOrUndefined()) {
          arg0.SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
          return false;
        }
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
          if (!unwrappedObj.ref()) {
            return false;
          }
        }
        FastErrorResult rv;
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload9(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload9(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
        if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload9"))) {
          return false;
        }
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload9(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload9(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload9"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload9_methodinfo = {
  { (JSJitGetterOp)overload9 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload10(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.overload10");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "overload10", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isObject()) {
        do {
          JS::Rooted<JSObject*> arg0(cx);
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
          if ((true) && !CallerSubsumes(args[0])) {
            cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("argument 1");
            return false;
          }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
          arg0 = &args[0].toObject();
          Maybe<JS::Rooted<JSObject*> > unwrappedObj;
          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          if (objIsXray) {
            unwrappedObj.emplace(cx, obj);
          }
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
            if (!unwrappedObj.ref()) {
              return false;
            }
          }
          FastErrorResult rv;
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload10(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload10(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload10"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      Nullable<int32_t> arg0;
      if (args[0].isNullOrUndefined()) {
        arg0.SetNull();
      } else if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload10(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload10(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload10"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload10_methodinfo = {
  { (JSJitGetterOp)overload10 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload11(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.overload11");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "overload11", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isNumber()) {
        Maybe<JS::Rooted<JSObject*> > unwrappedObj;
        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        if (objIsXray) {
          unwrappedObj.emplace(cx, obj);
        }
        int32_t arg0;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
          if (!unwrappedObj.ref()) {
            return false;
          }
        }
        FastErrorResult rv;
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload11(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload11(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
        if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload11"))) {
          return false;
        }
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload11(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload11(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload11"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload11_methodinfo = {
  { (JSJitGetterOp)overload11 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload12(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.overload12");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "overload12", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isNullOrUndefined()) {
        Nullable<bool> arg0;
        if (args[0].isNullOrUndefined()) {
          arg0.SetNull();
        } else if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
          return false;
        }
        Maybe<JS::Rooted<JSObject*> > unwrappedObj;
        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        if (objIsXray) {
          unwrappedObj.emplace(cx, obj);
        }
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
          if (!unwrappedObj.ref()) {
            return false;
          }
        }
        FastErrorResult rv;
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload12(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload12(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
        if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload12"))) {
          return false;
        }
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isBoolean()) {
        Maybe<JS::Rooted<JSObject*> > unwrappedObj;
        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        if (objIsXray) {
          unwrappedObj.emplace(cx, obj);
        }
        Nullable<bool> arg0;
        if (args[0].isNullOrUndefined()) {
          arg0.SetNull();
        } else if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
          return false;
        }
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
          if (!unwrappedObj.ref()) {
            return false;
          }
        }
        FastErrorResult rv;
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload12(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload12(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
        if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload12"))) {
          return false;
        }
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload12(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload12(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload12"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload12_methodinfo = {
  { (JSJitGetterOp)overload12 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload13(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.overload13");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "overload13", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isBoolean()) {
        Maybe<JS::Rooted<JSObject*> > unwrappedObj;
        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        if (objIsXray) {
          unwrappedObj.emplace(cx, obj);
        }
        bool arg0;
        if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
          if (!unwrappedObj.ref()) {
            return false;
          }
        }
        FastErrorResult rv;
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload13(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload13(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
        if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload13"))) {
          return false;
        }
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      Nullable<int32_t> arg0;
      if (args[0].isNullOrUndefined()) {
        arg0.SetNull();
      } else if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload13(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload13(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload13"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload13_methodinfo = {
  { (JSJitGetterOp)overload13 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload14(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.overload14");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "overload14", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      Optional<int32_t> arg0;
      if (args.hasDefined(0)) {
        arg0.Construct();
        if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
          return false;
        }
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload14(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload14(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload14"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          Maybe<JS::Rooted<JSObject*> > unwrappedObj;
          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          if (objIsXray) {
            unwrappedObj.emplace(cx, obj);
          }
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
            if (!unwrappedObj.ref()) {
              return false;
            }
          }
          FastErrorResult rv;
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload14(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload14(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload14"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      Optional<int32_t> arg0;
      if (args.hasDefined(0)) {
        arg0.Construct();
        if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
          return false;
        }
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload14(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload14(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload14"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload14_methodinfo = {
  { (JSJitGetterOp)overload14 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload15(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.overload15");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "overload15", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      Optional<NonNull<mozilla::dom::TestInterface>> arg0;
      if (args.hasDefined(0)) {
        arg0.Construct();
        if (args[0].isObject()) {
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0.Value(), cx);
            if (NS_FAILED(rv)) {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
              return false;
            }
          }
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
          return false;
        }
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload15(MOZ_KnownLive(NonNullHelper(Constify(arg0))), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload15(MOZ_KnownLive(NonNullHelper(Constify(arg0))), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload15"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isUndefined()) {
        Optional<NonNull<mozilla::dom::TestInterface>> arg0;
        if (args.hasDefined(0)) {
          arg0.Construct();
          if (args[0].isObject()) {
            {
              // Our JSContext should be in the right global to do unwrapping in.
              nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0.Value(), cx);
              if (NS_FAILED(rv)) {
                cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
                return false;
              }
            }
          } else {
            cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
            return false;
          }
        }
        Maybe<JS::Rooted<JSObject*> > unwrappedObj;
        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        if (objIsXray) {
          unwrappedObj.emplace(cx, obj);
        }
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
          if (!unwrappedObj.ref()) {
            return false;
          }
        }
        FastErrorResult rv;
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload15(MOZ_KnownLive(NonNullHelper(Constify(arg0))), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload15(MOZ_KnownLive(NonNullHelper(Constify(arg0))), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
        if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload15"))) {
          return false;
        }
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isObject()) {
        do {
          Optional<NonNull<mozilla::dom::TestInterface>> arg0;
          if (args.hasDefined(0)) {
            arg0.Construct();
            {
              // Our JSContext should be in the right global to do unwrapping in.
              nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0.Value(), cx);
              if (NS_FAILED(rv)) {
                break;
              }
            }
          }
          Maybe<JS::Rooted<JSObject*> > unwrappedObj;
          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          if (objIsXray) {
            unwrappedObj.emplace(cx, obj);
          }
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
            if (!unwrappedObj.ref()) {
              return false;
            }
          }
          FastErrorResult rv;
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload15(MOZ_KnownLive(NonNullHelper(Constify(arg0))), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload15(MOZ_KnownLive(NonNullHelper(Constify(arg0))), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload15"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload15(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload15(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload15"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload15_methodinfo = {
  { (JSJitGetterOp)overload15 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload16(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.overload16");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "overload16", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      Optional<mozilla::dom::TestInterface*> arg0;
      if (args.hasDefined(0)) {
        arg0.Construct();
        if (args[0].isObject()) {
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0.Value(), cx);
            if (NS_FAILED(rv)) {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
              return false;
            }
          }
        } else if (args[0].isNullOrUndefined()) {
          arg0.Value() = nullptr;
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
          return false;
        }
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload16(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload16(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload16"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isNullOrUndefined()) {
        Optional<mozilla::dom::TestInterface*> arg0;
        if (args.hasDefined(0)) {
          arg0.Construct();
          arg0.Value() = nullptr;
        }
        Maybe<JS::Rooted<JSObject*> > unwrappedObj;
        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        if (objIsXray) {
          unwrappedObj.emplace(cx, obj);
        }
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
          if (!unwrappedObj.ref()) {
            return false;
          }
        }
        FastErrorResult rv;
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload16(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload16(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
        if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload16"))) {
          return false;
        }
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isObject()) {
        do {
          Optional<mozilla::dom::TestInterface*> arg0;
          if (args.hasDefined(0)) {
            arg0.Construct();
            {
              // Our JSContext should be in the right global to do unwrapping in.
              nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0.Value(), cx);
              if (NS_FAILED(rv)) {
                break;
              }
            }
          }
          Maybe<JS::Rooted<JSObject*> > unwrappedObj;
          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          if (objIsXray) {
            unwrappedObj.emplace(cx, obj);
          }
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
            if (!unwrappedObj.ref()) {
              return false;
            }
          }
          FastErrorResult rv;
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload16(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload16(MOZ_KnownLive(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload16"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload16(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload16(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload16"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload16_methodinfo = {
  { (JSJitGetterOp)overload16 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload17(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.overload17");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "overload17", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isObject()) {
        do {
          binding_detail::AutoSequence<int32_t> arg0;
          JS::ForOfIterator iter(cx);
          if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter.valueIsIterable()) {
            break;
          }
          binding_detail::AutoSequence<int32_t> &arr = arg0;
          JS::Rooted<JS::Value> temp(cx);
          while (true) {
            bool done;
            if (!iter.next(&temp, &done)) {
              return false;
            }
            if (done) {
              break;
            }
            int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
            if (!slotPtr) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            int32_t& slot = *slotPtr;
            if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
              return false;
            }
          }
          Maybe<JS::Rooted<JSObject*> > unwrappedObj;
          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          if (objIsXray) {
            unwrappedObj.emplace(cx, obj);
          }
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
            if (!unwrappedObj.ref()) {
              return false;
            }
          }
          FastErrorResult rv;
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload17(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload17(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload17"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          Record<nsString, int32_t> arg0;
          auto& recordEntries = arg0.Entries();

          JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
          JS::RootedVector<jsid> ids(cx);
          if (!js::GetPropertyKeys(cx, recordObj,
                                   JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
            return false;
          }
          if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Rooted<JS::Value> propNameValue(cx);
          JS::Rooted<JS::Value> temp(cx);
          JS::Rooted<jsid> curId(cx);
          JS::Rooted<JS::Value> idVal(cx);
          // Use a hashset to keep track of ids seen, to avoid
          // introducing nasty O(N^2) behavior scanning for them all the
          // time.  Ideally we'd use a data structure with O(1) lookup
          // _and_ ordering for the MozMap, but we don't have one lying
          // around.
          nsTHashtable<nsStringHashKey> idsSeen;
          for (size_t i = 0; i < ids.length(); ++i) {
            curId = ids[i];

            JS::Rooted<JS::PropertyDescriptor> desc(cx);
            if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                                 &desc)) {
              return false;
            }

            if (!desc.object() /* == undefined in spec terms */ ||
                !desc.enumerable()) {
              continue;
            }

            idVal = js::IdToValue(curId);
            nsString propName;
            // This will just throw if idVal is a Symbol, like the spec says
            // to do.
            if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
              return false;
            }

            if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
              return false;
            }

            Record<nsString, int32_t>::EntryType* entry;
            if (!idsSeen.EnsureInserted(propName)) {
              // Find the existing entry.
              auto idx = recordEntries.IndexOf(propName);
              MOZ_ASSERT(idx != recordEntries.NoIndex,
                         "Why is it not found?");
              // Now blow it away to make it look like it was just added
              // to the array, because it's not obvious that it's
              // safe to write to its already-initialized mValue via our
              // normal codegen conversions.  For example, the value
              // could be a union and this would change its type, but
              // codegen assumes we won't do that.
              entry = recordEntries.ReconstructElementAt(idx);
            } else {
              // Safe to do an infallible append here, because we did a
              // SetCapacity above to the right capacity.
              entry = recordEntries.AppendElement();
            }
            entry->mKey = propName;
            int32_t& slot = entry->mValue;
            if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot)) {
              return false;
            }
          }
          Maybe<JS::Rooted<JSObject*> > unwrappedObj;
          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          if (objIsXray) {
            unwrappedObj.emplace(cx, obj);
          }
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
            if (!unwrappedObj.ref()) {
              return false;
            }
          }
          FastErrorResult rv;
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload17(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload17(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload17"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      return cx.ThrowErrorMessage<MSG_OVERLOAD_RESOLUTION_FAILED>("1", "1");
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload17_methodinfo = {
  { (JSJitGetterOp)overload17 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload18(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.overload18");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "overload18", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isObject()) {
        do {
          binding_detail::AutoSequence<nsString> arg0;
          JS::ForOfIterator iter(cx);
          if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter.valueIsIterable()) {
            break;
          }
          binding_detail::AutoSequence<nsString> &arr = arg0;
          JS::Rooted<JS::Value> temp(cx);
          while (true) {
            bool done;
            if (!iter.next(&temp, &done)) {
              return false;
            }
            if (done) {
              break;
            }
            nsString* slotPtr = arr.AppendElement(mozilla::fallible);
            if (!slotPtr) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            nsString& slot = *slotPtr;
            if (!ConvertJSValueToString(cx, temp, eStringify, eStringify, slot)) {
              return false;
            }
          }
          Maybe<JS::Rooted<JSObject*> > unwrappedObj;
          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          if (objIsXray) {
            unwrappedObj.emplace(cx, obj);
          }
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
            if (!unwrappedObj.ref()) {
              return false;
            }
          }
          FastErrorResult rv;
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload18(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload18(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload18"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          Record<nsString, nsString> arg0;
          auto& recordEntries = arg0.Entries();

          JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
          JS::RootedVector<jsid> ids(cx);
          if (!js::GetPropertyKeys(cx, recordObj,
                                   JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
            return false;
          }
          if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Rooted<JS::Value> propNameValue(cx);
          JS::Rooted<JS::Value> temp(cx);
          JS::Rooted<jsid> curId(cx);
          JS::Rooted<JS::Value> idVal(cx);
          // Use a hashset to keep track of ids seen, to avoid
          // introducing nasty O(N^2) behavior scanning for them all the
          // time.  Ideally we'd use a data structure with O(1) lookup
          // _and_ ordering for the MozMap, but we don't have one lying
          // around.
          nsTHashtable<nsStringHashKey> idsSeen;
          for (size_t i = 0; i < ids.length(); ++i) {
            curId = ids[i];

            JS::Rooted<JS::PropertyDescriptor> desc(cx);
            if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                                 &desc)) {
              return false;
            }

            if (!desc.object() /* == undefined in spec terms */ ||
                !desc.enumerable()) {
              continue;
            }

            idVal = js::IdToValue(curId);
            nsString propName;
            // This will just throw if idVal is a Symbol, like the spec says
            // to do.
            if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
              return false;
            }

            if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
              return false;
            }

            Record<nsString, nsString>::EntryType* entry;
            if (!idsSeen.EnsureInserted(propName)) {
              // Find the existing entry.
              auto idx = recordEntries.IndexOf(propName);
              MOZ_ASSERT(idx != recordEntries.NoIndex,
                         "Why is it not found?");
              // Now blow it away to make it look like it was just added
              // to the array, because it's not obvious that it's
              // safe to write to its already-initialized mValue via our
              // normal codegen conversions.  For example, the value
              // could be a union and this would change its type, but
              // codegen assumes we won't do that.
              entry = recordEntries.ReconstructElementAt(idx);
            } else {
              // Safe to do an infallible append here, because we did a
              // SetCapacity above to the right capacity.
              entry = recordEntries.AppendElement();
            }
            entry->mKey = propName;
            nsString& slot = entry->mValue;
            if (!ConvertJSValueToString(cx, temp, eStringify, eStringify, slot)) {
              return false;
            }
          }
          Maybe<JS::Rooted<JSObject*> > unwrappedObj;
          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          if (objIsXray) {
            unwrappedObj.emplace(cx, obj);
          }
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
            if (!unwrappedObj.ref()) {
              return false;
            }
          }
          FastErrorResult rv;
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload18(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload18(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload18"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      return cx.ThrowErrorMessage<MSG_OVERLOAD_RESOLUTION_FAILED>("1", "1");
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload18_methodinfo = {
  { (JSJitGetterOp)overload18 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload19(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.overload19");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "overload19", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      RootedDictionary<binding_detail::FastDict> arg0(cx);
      if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", true)) {
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload19(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload19(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload19"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isNullOrUndefined()) {
        RootedDictionary<binding_detail::FastDict> arg0(cx);
        if (!arg0.Init(cx, args[0], "Argument 1", true)) {
          return false;
        }
        Maybe<JS::Rooted<JSObject*> > unwrappedObj;
        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        if (objIsXray) {
          unwrappedObj.emplace(cx, obj);
        }
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
          if (!unwrappedObj.ref()) {
            return false;
          }
        }
        FastErrorResult rv;
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload19(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload19(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
        if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload19"))) {
          return false;
        }
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isObject()) {
        do {
          binding_detail::AutoSequence<int32_t> arg0;
          JS::ForOfIterator iter(cx);
          if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter.valueIsIterable()) {
            break;
          }
          binding_detail::AutoSequence<int32_t> &arr = arg0;
          JS::Rooted<JS::Value> temp(cx);
          while (true) {
            bool done;
            if (!iter.next(&temp, &done)) {
              return false;
            }
            if (done) {
              break;
            }
            int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
            if (!slotPtr) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            int32_t& slot = *slotPtr;
            if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
              return false;
            }
          }
          Maybe<JS::Rooted<JSObject*> > unwrappedObj;
          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          if (objIsXray) {
            unwrappedObj.emplace(cx, obj);
          }
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
            if (!unwrappedObj.ref()) {
              return false;
            }
          }
          FastErrorResult rv;
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload19(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload19(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload19"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          RootedDictionary<binding_detail::FastDict> arg0(cx);
          if (!arg0.Init(cx, args[0], "Argument 1", true)) {
            return false;
          }
          Maybe<JS::Rooted<JSObject*> > unwrappedObj;
          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          if (objIsXray) {
            unwrappedObj.emplace(cx, obj);
          }
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
            if (!unwrappedObj.ref()) {
              return false;
            }
          }
          FastErrorResult rv;
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload19(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload19(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload19"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      return cx.ThrowErrorMessage<MSG_OVERLOAD_RESOLUTION_FAILED>("1", "1");
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload19_methodinfo = {
  { (JSJitGetterOp)overload19 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload20(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.overload20");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "overload20", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      RootedDictionary<binding_detail::FastDict> arg0(cx);
      if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", true)) {
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload20(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload20(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload20"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isNullOrUndefined()) {
        RootedDictionary<binding_detail::FastDict> arg0(cx);
        if (!arg0.Init(cx, args[0], "Argument 1", true)) {
          return false;
        }
        Maybe<JS::Rooted<JSObject*> > unwrappedObj;
        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        if (objIsXray) {
          unwrappedObj.emplace(cx, obj);
        }
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
          if (!unwrappedObj.ref()) {
            return false;
          }
        }
        FastErrorResult rv;
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload20(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload20(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
        if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload20"))) {
          return false;
        }
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isObject()) {
        do {
          binding_detail::AutoSequence<int32_t> arg0;
          JS::ForOfIterator iter(cx);
          if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter.valueIsIterable()) {
            break;
          }
          binding_detail::AutoSequence<int32_t> &arr = arg0;
          JS::Rooted<JS::Value> temp(cx);
          while (true) {
            bool done;
            if (!iter.next(&temp, &done)) {
              return false;
            }
            if (done) {
              break;
            }
            int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
            if (!slotPtr) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            int32_t& slot = *slotPtr;
            if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
              return false;
            }
          }
          Maybe<JS::Rooted<JSObject*> > unwrappedObj;
          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          if (objIsXray) {
            unwrappedObj.emplace(cx, obj);
          }
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
            if (!unwrappedObj.ref()) {
              return false;
            }
          }
          FastErrorResult rv;
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload20(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload20(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload20"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          RootedDictionary<binding_detail::FastDict> arg0(cx);
          if (!arg0.Init(cx, args[0], "Argument 1", true)) {
            return false;
          }
          Maybe<JS::Rooted<JSObject*> > unwrappedObj;
          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          if (objIsXray) {
            unwrappedObj.emplace(cx, obj);
          }
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
            if (!unwrappedObj.ref()) {
              return false;
            }
          }
          FastErrorResult rv;
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload20(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload20(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.overload20"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      return cx.ThrowErrorMessage<MSG_OVERLOAD_RESOLUTION_FAILED>("1", "1");
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload20_methodinfo = {
  { (JSJitGetterOp)overload20 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicThirdArg(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passVariadicThirdArg");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passVariadicThirdArg", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passVariadicThirdArg", 2)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  }
  AutoSequence<OwningNonNull<mozilla::dom::TestJSImplInterface>> arg2;
  if (args.length() > 2) {
    if (!arg2.SetCapacity(args.length() - 2, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 2; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      OwningNonNull<mozilla::dom::TestJSImplInterface>& slot = *arg2.AppendElement();
      if (args[variadicArg].isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(args[variadicArg], slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 3", "TestJSImplInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 3");
        return false;
      }
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicThirdArg(NonNullHelper(Constify(arg0)), arg1, MOZ_KnownLive(NonNullHelper(Constify(arg2))), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicThirdArg(NonNullHelper(Constify(arg0)), arg1, MOZ_KnownLive(NonNullHelper(Constify(arg2))), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passVariadicThirdArg"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicThirdArg_methodinfo = {
  { (JSJitGetterOp)passVariadicThirdArg },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable1(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "prefable1", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetPrefable1(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.prefable1 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable1_getterinfo = {
  { get_prefable1 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "prefable2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetPrefable2(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.prefable2 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable2_getterinfo = {
  { get_prefable2 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable3(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "prefable3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetPrefable3(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.prefable3 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable3_getterinfo = {
  { get_prefable3 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable4(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "prefable4", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetPrefable4(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.prefable4 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable4_getterinfo = {
  { get_prefable4 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable5(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "prefable5", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetPrefable5(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.prefable5 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable5_getterinfo = {
  { get_prefable5 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable6(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "prefable6", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetPrefable6(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.prefable6 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable6_getterinfo = {
  { get_prefable6 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable7(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "prefable7", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetPrefable7(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.prefable7 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable7_getterinfo = {
  { get_prefable7 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable8(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "prefable8", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetPrefable8(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.prefable8 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable8_getterinfo = {
  { get_prefable8 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable9(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "prefable9", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetPrefable9(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.prefable9 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable9_getterinfo = {
  { get_prefable9 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
prefable10(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "prefable10", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Prefable10(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->Prefable10(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.prefable10"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo prefable10_methodinfo = {
  { (JSJitGetterOp)prefable10 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
prefable11(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "prefable11", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Prefable11(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->Prefable11(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.prefable11"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo prefable11_methodinfo = {
  { (JSJitGetterOp)prefable11 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable12(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "prefable12", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetPrefable12(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.prefable12 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable12_getterinfo = {
  { get_prefable12 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
prefable13(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "prefable13", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Prefable13(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->Prefable13(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.prefable13"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo prefable13_methodinfo = {
  { (JSJitGetterOp)prefable13 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable14(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "prefable14", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetPrefable14(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.prefable14 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable14_getterinfo = {
  { get_prefable14 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable15(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "prefable15", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetPrefable15(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.prefable15 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable15_getterinfo = {
  { get_prefable15 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable16(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "prefable16", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetPrefable16(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.prefable16 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable16_getterinfo = {
  { get_prefable16 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
prefable17(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "prefable17", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Prefable17(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->Prefable17(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.prefable17"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo prefable17_methodinfo = {
  { (JSJitGetterOp)prefable17 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
prefable18(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "prefable18", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Prefable18(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->Prefable18(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.prefable18"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo prefable18_methodinfo = {
  { (JSJitGetterOp)prefable18 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
prefable19(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "prefable19", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Prefable19(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->Prefable19(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.prefable19"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo prefable19_methodinfo = {
  { (JSJitGetterOp)prefable19 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
prefable20(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "prefable20", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Prefable20(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->Prefable20(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.prefable20"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo prefable20_methodinfo = {
  { (JSJitGetterOp)prefable20 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_conditionalOnSecureContext1(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "conditionalOnSecureContext1", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetConditionalOnSecureContext1(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.conditionalOnSecureContext1 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo conditionalOnSecureContext1_getterinfo = {
  { get_conditionalOnSecureContext1 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_conditionalOnSecureContext2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "conditionalOnSecureContext2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetConditionalOnSecureContext2(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.conditionalOnSecureContext2 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo conditionalOnSecureContext2_getterinfo = {
  { get_conditionalOnSecureContext2 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_conditionalOnSecureContext3(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "conditionalOnSecureContext3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetConditionalOnSecureContext3(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.conditionalOnSecureContext3 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo conditionalOnSecureContext3_getterinfo = {
  { get_conditionalOnSecureContext3 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_conditionalOnSecureContext4(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "conditionalOnSecureContext4", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetConditionalOnSecureContext4(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.conditionalOnSecureContext4 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo conditionalOnSecureContext4_getterinfo = {
  { get_conditionalOnSecureContext4 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
conditionalOnSecureContext5(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "conditionalOnSecureContext5", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ConditionalOnSecureContext5(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ConditionalOnSecureContext5(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.conditionalOnSecureContext5"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo conditionalOnSecureContext5_methodinfo = {
  { (JSJitGetterOp)conditionalOnSecureContext5 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
conditionalOnSecureContext6(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "conditionalOnSecureContext6", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ConditionalOnSecureContext6(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ConditionalOnSecureContext6(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.conditionalOnSecureContext6"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo conditionalOnSecureContext6_methodinfo = {
  { (JSJitGetterOp)conditionalOnSecureContext6 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
conditionalOnSecureContext7(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "conditionalOnSecureContext7", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ConditionalOnSecureContext7(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ConditionalOnSecureContext7(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.conditionalOnSecureContext7"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo conditionalOnSecureContext7_methodinfo = {
  { (JSJitGetterOp)conditionalOnSecureContext7 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
conditionalOnSecureContext8(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "conditionalOnSecureContext8", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ConditionalOnSecureContext8(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ConditionalOnSecureContext8(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.conditionalOnSecureContext8"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo conditionalOnSecureContext8_methodinfo = {
  { (JSJitGetterOp)conditionalOnSecureContext8 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_attrWithLenientThis(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "attrWithLenientThis", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int32_t result(MOZ_KnownLive(self)->GetAttrWithLenientThis(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.attrWithLenientThis getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_attrWithLenientThis(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "attrWithLenientThis", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAttrWithLenientThis(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAttrWithLenientThis(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.attrWithLenientThis setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo attrWithLenientThis_getterinfo = {
  { get_attrWithLenientThis },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo attrWithLenientThis_setterinfo = {
  { (JSJitGetterOp)set_attrWithLenientThis },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRenamedInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passRenamedInterface");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passRenamedInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passRenamedInterface", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  NonNull<nsRenamedInterface> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestRenamedInterface, nsRenamedInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestRenamedInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRenamedInterface(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRenamedInterface(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passRenamedInterface"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRenamedInterface_methodinfo = {
  { (JSJitGetterOp)passRenamedInterface },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_putForwardsAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "putForwardsAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestJSImplInterface>(MOZ_KnownLive(self)->GetPutForwardsAttr(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.putForwardsAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_putForwardsAttr(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.putForwardsAttr setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "putForwardsAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::Rooted<JS::Value> v(cx);
  if (!JS_GetProperty(cx, obj, "putForwardsAttr", &v)) {
    return false;
  }

  if (!v.isObject()) {
    return cx.ThrowErrorMessage<MSG_NOT_OBJECT>("TestJSImplInterface.putForwardsAttr");
  }

  JS::Rooted<JSObject*> targetObj(cx, &v.toObject());
  return JS_SetProperty(cx, targetObj, "writableByte", args[0]);
}

static const JSJitInfo putForwardsAttr_getterinfo = {
  { get_putForwardsAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo putForwardsAttr_setterinfo = {
  { (JSJitGetterOp)set_putForwardsAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_putForwardsAttr2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "putForwardsAttr2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestJSImplInterface>(MOZ_KnownLive(self)->GetPutForwardsAttr2(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.putForwardsAttr2 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_putForwardsAttr2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.putForwardsAttr2 setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "putForwardsAttr2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::Rooted<JS::Value> v(cx);
  if (!JS_GetProperty(cx, obj, "putForwardsAttr2", &v)) {
    return false;
  }

  if (!v.isObject()) {
    return cx.ThrowErrorMessage<MSG_NOT_OBJECT>("TestJSImplInterface.putForwardsAttr2");
  }

  JS::Rooted<JSObject*> targetObj(cx, &v.toObject());
  return JS_SetProperty(cx, targetObj, "writableByte", args[0]);
}

static const JSJitInfo putForwardsAttr2_getterinfo = {
  { get_putForwardsAttr2 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo putForwardsAttr2_setterinfo = {
  { (JSJitGetterOp)set_putForwardsAttr2 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_putForwardsAttr3(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "putForwardsAttr3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestJSImplInterface>(MOZ_KnownLive(self)->GetPutForwardsAttr3(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.putForwardsAttr3 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_putForwardsAttr3(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.putForwardsAttr3 setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "putForwardsAttr3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::Rooted<JS::Value> v(cx);
  if (!JS_GetProperty(cx, obj, "putForwardsAttr3", &v)) {
    return false;
  }

  if (!v.isObject()) {
    return cx.ThrowErrorMessage<MSG_NOT_OBJECT>("TestJSImplInterface.putForwardsAttr3");
  }

  JS::Rooted<JSObject*> targetObj(cx, &v.toObject());
  return JS_SetProperty(cx, targetObj, "writableByte", args[0]);
}

static const JSJitInfo putForwardsAttr3_getterinfo = {
  { get_putForwardsAttr3 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo putForwardsAttr3_setterinfo = {
  { (JSJitGetterOp)set_putForwardsAttr3 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
throwingMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "throwingMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ThrowingMethod(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ThrowingMethod(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.throwingMethod"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo throwingMethod_methodinfo = {
  { (JSJitGetterOp)throwingMethod },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_throwingAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "throwingAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetThrowingAttr(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.throwingAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_throwingAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "throwingAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetThrowingAttr(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetThrowingAttr(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.throwingAttr setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo throwingAttr_getterinfo = {
  { get_throwingAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo throwingAttr_setterinfo = {
  { (JSJitGetterOp)set_throwingAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_throwingGetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "throwingGetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetThrowingGetterAttr(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.throwingGetterAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_throwingGetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "throwingGetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetThrowingGetterAttr(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetThrowingGetterAttr(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.throwingGetterAttr setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo throwingGetterAttr_getterinfo = {
  { get_throwingGetterAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo throwingGetterAttr_setterinfo = {
  { (JSJitGetterOp)set_throwingGetterAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_throwingSetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "throwingSetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetThrowingSetterAttr(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.throwingSetterAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_throwingSetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "throwingSetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetThrowingSetterAttr(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetThrowingSetterAttr(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.throwingSetterAttr setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo throwingSetterAttr_getterinfo = {
  { get_throwingSetterAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo throwingSetterAttr_setterinfo = {
  { (JSJitGetterOp)set_throwingSetterAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
canOOMMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "canOOMMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->CanOOMMethod(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->CanOOMMethod(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.canOOMMethod"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo canOOMMethod_methodinfo = {
  { (JSJitGetterOp)canOOMMethod },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_canOOMAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "canOOMAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetCanOOMAttr(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.canOOMAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_canOOMAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "canOOMAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetCanOOMAttr(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetCanOOMAttr(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.canOOMAttr setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo canOOMAttr_getterinfo = {
  { get_canOOMAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo canOOMAttr_setterinfo = {
  { (JSJitGetterOp)set_canOOMAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_canOOMGetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "canOOMGetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetCanOOMGetterAttr(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.canOOMGetterAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_canOOMGetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "canOOMGetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetCanOOMGetterAttr(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetCanOOMGetterAttr(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.canOOMGetterAttr setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo canOOMGetterAttr_getterinfo = {
  { get_canOOMGetterAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo canOOMGetterAttr_setterinfo = {
  { (JSJitGetterOp)set_canOOMGetterAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_canOOMSetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "canOOMSetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetCanOOMSetterAttr(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.canOOMSetterAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_canOOMSetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "canOOMSetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetCanOOMSetterAttr(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetCanOOMSetterAttr(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.canOOMSetterAttr setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo canOOMSetterAttr_getterinfo = {
  { get_canOOMSetterAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo canOOMSetterAttr_setterinfo = {
  { (JSJitGetterOp)set_canOOMSetterAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
ceReactionsMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "ceReactionsMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  Maybe<AutoCEReaction> ceReaction;
  DocGroup* docGroup = self->GetDocGroup();
  if (docGroup) {
    ceReaction.emplace(docGroup->CustomElementReactionsStack(), cx);
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->CeReactionsMethod(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->CeReactionsMethod(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.ceReactionsMethod"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo ceReactionsMethod_methodinfo = {
  { (JSJitGetterOp)ceReactionsMethod },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
ceReactionsMethodOverload(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.ceReactionsMethodOverload");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "ceReactionsMethodOverload", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      Maybe<AutoCEReaction> ceReaction;
      DocGroup* docGroup = self->GetDocGroup();
      if (docGroup) {
        ceReaction.emplace(docGroup->CustomElementReactionsStack(), cx);
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->CeReactionsMethodOverload(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->CeReactionsMethodOverload(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.ceReactionsMethodOverload"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      Maybe<AutoCEReaction> ceReaction;
      DocGroup* docGroup = self->GetDocGroup();
      if (docGroup) {
        ceReaction.emplace(docGroup->CustomElementReactionsStack(), cx);
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->CeReactionsMethodOverload(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
      MOZ_KnownLive(self)->CeReactionsMethodOverload(NonNullHelper(Constify(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.ceReactionsMethodOverload"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo ceReactionsMethodOverload_methodinfo = {
  { (JSJitGetterOp)ceReactionsMethodOverload },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_ceReactionsAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "ceReactionsAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetCeReactionsAttr(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.ceReactionsAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_ceReactionsAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "ceReactionsAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  Maybe<AutoCEReaction> ceReaction;
  DocGroup* docGroup = self->GetDocGroup();
  if (docGroup) {
    ceReaction.emplace(docGroup->CustomElementReactionsStack(), cx);
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetCeReactionsAttr(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetCeReactionsAttr(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.ceReactionsAttr setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ceReactionsAttr_getterinfo = {
  { get_ceReactionsAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo ceReactionsAttr_setterinfo = {
  { (JSJitGetterOp)set_ceReactionsAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passArgsWithDefaults(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passArgsWithDefaults");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passArgsWithDefaults", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  Optional<int32_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  mozilla::dom::TestInterface* arg1;
  if (args.hasDefined(1)) {
    if (args[1].isObject()) {
      {
        // Our JSContext should be in the right global to do unwrapping in.
        nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[1], arg1, cx);
        if (NS_FAILED(rv)) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 2", "TestInterface");
          return false;
        }
      }
    } else if (args[1].isNullOrUndefined()) {
      arg1 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 2");
      return false;
    }
  } else {
    arg1 = nullptr;
  }
  RootedDictionary<binding_detail::FastDict> arg2(cx);
  if (!arg2.Init(cx, (args.hasDefined(2)) ? args[2] : JS::NullHandleValue, "Argument 3", true)) {
    return false;
  }
  double arg3;
  if (args.hasDefined(3)) {
    if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
      return false;
    } else if (!mozilla::IsFinite(arg3)) {
      cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 4");
      return false;
    }
  } else {
    arg3 = 5.0;
  }
  Optional<float> arg4;
  if (args.hasDefined(4)) {
    arg4.Construct();
    if (!ValueToPrimitive<float, eDefault>(cx, args[4], "Argument 5", &arg4.Value())) {
      return false;
    } else if (!mozilla::IsFinite(arg4.Value())) {
      cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 5");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassArgsWithDefaults(Constify(arg0), MOZ_KnownLive(Constify(arg1)), Constify(arg2), arg3, Constify(arg4), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassArgsWithDefaults(Constify(arg0), MOZ_KnownLive(Constify(arg1)), Constify(arg2), arg3, Constify(arg4), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passArgsWithDefaults"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passArgsWithDefaults_methodinfo = {
  { (JSJitGetterOp)passArgsWithDefaults },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_toJSONShouldSkipThis(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "toJSONShouldSkipThis", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  JS::Rooted<JS::Value> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetToJSONShouldSkipThis(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetToJSONShouldSkipThis(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.toJSONShouldSkipThis getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_toJSONShouldSkipThis(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.toJSONShouldSkipThis setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "toJSONShouldSkipThis", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  JS::Rooted<JS::Value> arg0(cx);
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
  if ((true) && !CallerSubsumes(args[0])) {
    cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("value being assigned");
    return false;
  }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
  arg0 = args[0];
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetToJSONShouldSkipThis(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetToJSONShouldSkipThis(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.toJSONShouldSkipThis setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo toJSONShouldSkipThis_getterinfo = {
  { get_toJSONShouldSkipThis },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo toJSONShouldSkipThis_setterinfo = {
  { (JSJitGetterOp)set_toJSONShouldSkipThis },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_toJSONShouldSkipThis2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "toJSONShouldSkipThis2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestParentInterface>(MOZ_KnownLive(self)->GetToJSONShouldSkipThis2(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.toJSONShouldSkipThis2 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_toJSONShouldSkipThis2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.toJSONShouldSkipThis2 setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "toJSONShouldSkipThis2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  NonNull<mozilla::dom::TestParentInterface> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestParentInterface, mozilla::dom::TestParentInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "TestParentInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetToJSONShouldSkipThis2(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetToJSONShouldSkipThis2(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.toJSONShouldSkipThis2 setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo toJSONShouldSkipThis2_getterinfo = {
  { get_toJSONShouldSkipThis2 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo toJSONShouldSkipThis2_setterinfo = {
  { (JSJitGetterOp)set_toJSONShouldSkipThis2 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_toJSONShouldSkipThis3(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "toJSONShouldSkipThis3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->GetToJSONShouldSkipThis3(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.toJSONShouldSkipThis3 getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_toJSONShouldSkipThis3(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.toJSONShouldSkipThis3 setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "toJSONShouldSkipThis3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestCallbackInterface>> arg0(cx);
  if (args[0].isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetToJSONShouldSkipThis3(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetToJSONShouldSkipThis3(MOZ_KnownLive(NonNullHelper(arg0)), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.toJSONShouldSkipThis3 setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo toJSONShouldSkipThis3_getterinfo = {
  { get_toJSONShouldSkipThis3 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo toJSONShouldSkipThis3_setterinfo = {
  { (JSJitGetterOp)set_toJSONShouldSkipThis3 },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_dashed_attribute(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "dashed-attribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  int8_t result(MOZ_KnownLive(self)->GetDashed_attribute(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.dashed-attribute getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_dashed_attribute(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "dashed-attribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetDashed_attribute(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetDashed_attribute(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.dashed-attribute setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo dashed_attribute_getterinfo = {
  { get_dashed_attribute },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo dashed_attribute_setterinfo = {
  { (JSJitGetterOp)set_dashed_attribute },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
dashed_method(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "dashed-method", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Dashed_method(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->Dashed_method(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.dashed-method"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo dashed_method_methodinfo = {
  { (JSJitGetterOp)dashed_method },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nonEnumerableAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "nonEnumerableAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetNonEnumerableAttr(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.nonEnumerableAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_nonEnumerableAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "nonEnumerableAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNonEnumerableAttr(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNonEnumerableAttr(arg0, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.nonEnumerableAttr setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nonEnumerableAttr_getterinfo = {
  { get_nonEnumerableAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo nonEnumerableAttr_setterinfo = {
  { (JSJitGetterOp)set_nonEnumerableAttr },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
nonEnumerableMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "nonEnumerableMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NonEnumerableMethod(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->NonEnumerableMethod(rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.nonEnumerableMethod"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo nonEnumerableMethod_methodinfo = {
  { (JSJitGetterOp)nonEnumerableMethod },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_allowSharedArrayBufferViewTypedef(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "allowSharedArrayBufferViewTypedef", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetAllowSharedArrayBufferViewTypedef(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetAllowSharedArrayBufferViewTypedef(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.allowSharedArrayBufferViewTypedef getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapNonDOMObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_allowSharedArrayBufferViewTypedef(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.allowSharedArrayBufferViewTypedef setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "allowSharedArrayBufferViewTypedef", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<ArrayBufferView> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "ArrayBufferView");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value being assigned");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAllowSharedArrayBufferViewTypedef(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAllowSharedArrayBufferViewTypedef(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.allowSharedArrayBufferViewTypedef setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo allowSharedArrayBufferViewTypedef_getterinfo = {
  { get_allowSharedArrayBufferViewTypedef },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo allowSharedArrayBufferViewTypedef_setterinfo = {
  { (JSJitGetterOp)set_allowSharedArrayBufferViewTypedef },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_allowSharedArrayBufferView(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "allowSharedArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetAllowSharedArrayBufferView(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetAllowSharedArrayBufferView(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.allowSharedArrayBufferView getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapNonDOMObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_allowSharedArrayBufferView(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.allowSharedArrayBufferView setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "allowSharedArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<ArrayBufferView> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "ArrayBufferView");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value being assigned");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAllowSharedArrayBufferView(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAllowSharedArrayBufferView(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.allowSharedArrayBufferView setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo allowSharedArrayBufferView_getterinfo = {
  { get_allowSharedArrayBufferView },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo allowSharedArrayBufferView_setterinfo = {
  { (JSJitGetterOp)set_allowSharedArrayBufferView },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_allowSharedNullableArrayBufferView(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "allowSharedNullableArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetAllowSharedNullableArrayBufferView(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetAllowSharedNullableArrayBufferView(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.allowSharedNullableArrayBufferView getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
                JS::ExposeObjectToActiveJS(result);
              }
              args.rval().setObjectOrNull(result);
  if (!MaybeWrapNonDOMObjectOrNullValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_allowSharedNullableArrayBufferView(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.allowSharedNullableArrayBufferView setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "allowSharedNullableArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<Nullable<ArrayBufferView>> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.SetValue().Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "ArrayBufferViewOrNull");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value being assigned");
      return false;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAllowSharedNullableArrayBufferView(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAllowSharedNullableArrayBufferView(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.allowSharedNullableArrayBufferView setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo allowSharedNullableArrayBufferView_getterinfo = {
  { get_allowSharedNullableArrayBufferView },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo allowSharedNullableArrayBufferView_setterinfo = {
  { (JSJitGetterOp)set_allowSharedNullableArrayBufferView },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_allowSharedArrayBuffer(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "allowSharedArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetAllowSharedArrayBuffer(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetAllowSharedArrayBuffer(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.allowSharedArrayBuffer getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapNonDOMObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_allowSharedArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.allowSharedArrayBuffer setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "allowSharedArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<ArrayBuffer> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "ArrayBuffer");
      return false;
    }
    if (JS::IsLargeArrayBufferMaybeShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value being assigned");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAllowSharedArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAllowSharedArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.allowSharedArrayBuffer setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo allowSharedArrayBuffer_getterinfo = {
  { get_allowSharedArrayBuffer },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo allowSharedArrayBuffer_setterinfo = {
  { (JSJitGetterOp)set_allowSharedArrayBuffer },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_allowSharedNullableArrayBuffer(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "allowSharedNullableArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetAllowSharedNullableArrayBuffer(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetAllowSharedNullableArrayBuffer(&result, rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.allowSharedNullableArrayBuffer getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
                JS::ExposeObjectToActiveJS(result);
              }
              args.rval().setObjectOrNull(result);
  if (!MaybeWrapNonDOMObjectOrNullValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_allowSharedNullableArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.allowSharedNullableArrayBuffer setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "allowSharedNullableArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<Nullable<ArrayBuffer>> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.SetValue().Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "ArrayBufferOrNull");
      return false;
    }
    if (JS::IsLargeArrayBufferMaybeShared(arg0.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value being assigned");
      return false;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAllowSharedNullableArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAllowSharedNullableArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.allowSharedNullableArrayBuffer setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo allowSharedNullableArrayBuffer_getterinfo = {
  { get_allowSharedNullableArrayBuffer },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo allowSharedNullableArrayBuffer_setterinfo = {
  { (JSJitGetterOp)set_allowSharedNullableArrayBuffer },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAllowSharedArrayBufferViewTypedef(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passAllowSharedArrayBufferViewTypedef");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passAllowSharedArrayBufferViewTypedef", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passAllowSharedArrayBufferViewTypedef", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<ArrayBufferView> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferView");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAllowSharedArrayBufferViewTypedef(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAllowSharedArrayBufferViewTypedef(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passAllowSharedArrayBufferViewTypedef"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAllowSharedArrayBufferViewTypedef_methodinfo = {
  { (JSJitGetterOp)passAllowSharedArrayBufferViewTypedef },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAllowSharedArrayBufferView(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passAllowSharedArrayBufferView");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passAllowSharedArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passAllowSharedArrayBufferView", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<ArrayBufferView> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferView");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAllowSharedArrayBufferView(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAllowSharedArrayBufferView(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passAllowSharedArrayBufferView"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAllowSharedArrayBufferView_methodinfo = {
  { (JSJitGetterOp)passAllowSharedArrayBufferView },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAllowSharedNullableArrayBufferView(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passAllowSharedNullableArrayBufferView");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passAllowSharedNullableArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passAllowSharedNullableArrayBufferView", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<Nullable<ArrayBufferView>> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.SetValue().Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferViewOrNull");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAllowSharedNullableArrayBufferView(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAllowSharedNullableArrayBufferView(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passAllowSharedNullableArrayBufferView"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAllowSharedNullableArrayBufferView_methodinfo = {
  { (JSJitGetterOp)passAllowSharedNullableArrayBufferView },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAllowSharedArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passAllowSharedArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passAllowSharedArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passAllowSharedArrayBuffer", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<ArrayBuffer> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBuffer");
      return false;
    }
    if (JS::IsLargeArrayBufferMaybeShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAllowSharedArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAllowSharedArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passAllowSharedArrayBuffer"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAllowSharedArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passAllowSharedArrayBuffer },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAllowSharedNullableArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passAllowSharedNullableArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passAllowSharedNullableArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passAllowSharedNullableArrayBuffer", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedSpiderMonkeyInterface<Nullable<ArrayBuffer>> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.SetValue().Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferOrNull");
      return false;
    }
    if (JS::IsLargeArrayBufferMaybeShared(arg0.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAllowSharedNullableArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAllowSharedNullableArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passAllowSharedNullableArrayBuffer"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAllowSharedNullableArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passAllowSharedNullableArrayBuffer },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passUnionArrayBuffer", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  StringOrArrayBuffer arg0;
  StringOrArrayBufferArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      done = (failed = !arg0_holder.TrySetToArrayBuffer(cx, args[0], tryNext, true)) || !tryNext;

    }
    if (!done) {
      do {
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "ArrayBuffer");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionArrayBuffer"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passUnionArrayBuffer },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionAllowSharedArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestJSImplInterface.passUnionAllowSharedArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "passUnionAllowSharedArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestJSImplInterface.passUnionAllowSharedArrayBuffer", 1)) {
    return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  StringOrMaybeSharedArrayBuffer arg0;
  StringOrMaybeSharedArrayBufferArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      done = (failed = !arg0_holder.TrySetToArrayBuffer(cx, args[0], tryNext, true)) || !tryNext;

    }
    if (!done) {
      do {
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "ArrayBuffer");
      return false;
    }
  }
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    unwrappedObj.ref() = js::CheckedUnwrapStatic(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionAllowSharedArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionAllowSharedArrayBuffer(Constify(arg0), rv, (unwrappedObj ? js::GetNonCCWObjectRealm(*unwrappedObj) : js::GetContextRealm(cx)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface.passUnionAllowSharedArrayBuffer"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionAllowSharedArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passUnionAllowSharedArrayBuffer },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
toJSON(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "toJSON", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestJSImplInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx, JS_NewPlainObject(cx));
  if (!result) {
    return false;
  }
  if (!TestJSImplInterface_Binding::CollectJSONAttributes(cx, obj, MOZ_KnownLive(self), result)) {
    return false;
  }
  args.rval().setObject(*result);
  return true;
}

static const JSJitInfo toJSON_methodinfo = {
  { (JSJitGetterOp)toJSON },
  { prototypes::id::TestJSImplInterface },
  { PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestJSImplInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestJSImplInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestJSImplInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestJSImplInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestJSImplInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestJSImplInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestJSImplInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestJSImplInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestJSImplInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sChromeStaticMethods_specs[] = {
  JS_FNSPEC("_create", TestJSImplInterface::_Create, nullptr, 2, 0, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sChromeStaticMethods[] = {
  { nullptr, &sChromeStaticMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("passByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passByte_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalByteBeforeRequired", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalByteBeforeRequired_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalByteWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalByteWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalByteWithDefaultBeforeRequired", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalByteWithDefaultBeforeRequired_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableByte_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("returnByteSideEffectFree", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&returnByteSideEffectFree_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("returnDOMDependentByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&returnDOMDependentByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("returnConstantByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&returnConstantByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("returnDeviceStateDependentByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&returnDeviceStateDependentByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passShort", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passShort_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveShort", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveShort_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalShort", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalShort_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalShortWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalShortWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passLong_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalLongWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalLongWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passLongLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passLongLong_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveLongLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveLongLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalLongLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalLongLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalLongLongWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalLongLongWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOctet", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOctet_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveOctet", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveOctet_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalOctet", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalOctet_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalOctetWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalOctetWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnsignedShort", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnsignedShort_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUnsignedShort", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUnsignedShort_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnsignedShort", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnsignedShort_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnsignedShortWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnsignedShortWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnsignedLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnsignedLong_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUnsignedLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUnsignedLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnsignedLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnsignedLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnsignedLongWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnsignedLongWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnsignedLongLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnsignedLongLong_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUnsignedLongLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUnsignedLongLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnsignedLongLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnsignedLongLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnsignedLongLongWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnsignedLongLongWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passFloat", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passFloat_methodinfo), 16, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passLenientFloat", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passLenientFloat_methodinfo), 16, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveSelf_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableSelf_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakSelf_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakNullableSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakNullableSelf_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSelf_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableSelf_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSelf_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNonNullSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNonNullSelf_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSelfWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSelfWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNonWrapperCacheInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNonWrapperCacheInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableNonWrapperCacheInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableNonWrapperCacheInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNonWrapperCacheInterfaceSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNonWrapperCacheInterfaceSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableNonWrapperCacheInterfaceSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableNonWrapperCacheInterfaceSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNonWrapperCacheInterfaceNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNonWrapperCacheInterfaceNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableNonWrapperCacheInterfaceNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableNonWrapperCacheInterfaceNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveExternal_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableExternal_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakExternal_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakNullableExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakNullableExternal_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passExternal_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableExternal_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalExternal_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNonNullExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNonNullExternal_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalExternalWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalExternalWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveCallbackInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableCallbackInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakCallbackInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakNullableCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakNullableCallbackInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passCallbackInterface_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableCallbackInterface_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalCallbackInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNonNullCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNonNullCallbackInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalCallbackInterfaceWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalCallbackInterfaceWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveSequenceOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveSequenceOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableSequenceOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableSequenceOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfNullableInts_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSequenceOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSequenceOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveCastableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveCastableObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveCallbackObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveCallbackObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableCastableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableCastableObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableCallbackObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableCallbackObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveCastableObjectNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveCastableObjectNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableCastableObjectNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableCastableObjectNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakCastableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakCastableObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakNullableCastableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakNullableCastableObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakCastableObjectNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakCastableObjectNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakNullableCastableObjectNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakNullableCastableObjectNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passCastableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passCastableObjectSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableCastableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableCastableObjectSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passCastableObjectNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passCastableObjectNullableSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableCastableObjectNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableCastableObjectNullableSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSequenceWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSequenceWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceWithDefaultValue2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceWithDefaultValue2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passExternalInterfaceSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passExternalInterfaceSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableExternalInterfaceSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableExternalInterfaceSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveStringSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveStringSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveByteStringSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveByteStringSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUTF8StringSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUTF8StringSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveAnySequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveAnySequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableAnySequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableAnySequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfSequences", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfSequences_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfSequencesOfSequences", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfSequencesOfSequences_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfNullableInts_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalRecordOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalRecordOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableRecordOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableRecordOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passCastableObjectRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passCastableObjectRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableCastableObjectRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableCastableObjectRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passCastableObjectNullableRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passCastableObjectNullableRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableCastableObjectNullableRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableCastableObjectNullableRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalRecord_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableRecord_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableRecordWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableRecordWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalObjectRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalObjectRecord_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passExternalInterfaceRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passExternalInterfaceRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableExternalInterfaceRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableExternalInterfaceRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passStringRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passStringRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passByteStringRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passByteStringRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUTF8StringRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUTF8StringRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfRecords", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfRecords_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveRecord_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableRecord_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveRecordOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveRecordOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableRecordOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableRecordOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveAnyRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveAnyRecord_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalArrayBuffer_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableArrayBuffer_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableArrayBufferWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableArrayBufferWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passArrayBufferView", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passArrayBufferView_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passInt8Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passInt8Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passInt16Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passInt16Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passInt32Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passInt32Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUint8Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUint8Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUint16Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUint16Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUint32Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUint32Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUint8ClampedArray", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUint8ClampedArray_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passFloat32Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passFloat32Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passFloat64Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passFloat64Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfArrayBuffers", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfArrayBuffers_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfNullableArrayBuffers", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfNullableArrayBuffers_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfArrayBuffers", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfArrayBuffers_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfNullableArrayBuffers", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfNullableArrayBuffers_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicTypedArray", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicTypedArray_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicNullableTypedArray", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicNullableTypedArray_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUint8Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUint8Array_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passString_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableString_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalStringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalStringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableStringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableStringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passByteString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passByteString_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableByteString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableByteString_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalByteString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalByteString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalByteStringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalByteStringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableByteString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableByteString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableByteStringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableByteStringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicByteString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicByteString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionByteString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionByteString_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnionByteString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnionByteString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnionByteStringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnionByteStringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUTF8String", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUTF8String_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUTF8String", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUTF8String_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUTF8String", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUTF8String_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUTF8StringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUTF8StringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableUTF8String", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableUTF8String_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableUTF8StringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableUTF8StringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicUTF8String", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicUTF8String_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionUTF8String", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionUTF8String_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnionUTF8String", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnionUTF8String_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnionUTF8StringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnionUTF8StringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSVS", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSVS_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableSVS", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableSVS_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSVS", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSVS_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSVSWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSVSWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSVS", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSVS_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSVSWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSVSWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicSVS", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicSVS_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveSVS", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveSVS_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passJSString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passJSString_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalJSStringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalJSStringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveJSString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveJSString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passEnum_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableEnum_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalEnum_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passEnumWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passEnumWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableEnum_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableEnumWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableEnumWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableEnumWithDefaultValue2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableEnumWithDefaultValue2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveEnum_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableEnum_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passCallback_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableCallback_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalCallback_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableCallback_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableCallbackWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableCallbackWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveCallback_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableCallback_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableTreatAsNullCallbackWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableTreatAsNullCallbackWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passAnyDefaultNull", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAnyDefaultNull_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableSequenceOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSequenceOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSequenceOfAnyWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSequenceOfAnyWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfSequenceOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfNullableSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfNullableSequenceOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableSequenceOfNullableSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableSequenceOfNullableSequenceOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceOfNullableSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceOfNullableSequenceOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableRecordOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalRecordOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableRecordOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalRecordOfAnyWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalRecordOfAnyWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfRecordOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfNullableRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfNullableRecordOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableRecordOfNullableRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableRecordOfNullableRecordOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableRecordOfNullableRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableRecordOfNullableRecordOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableRecordOfNullableSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableRecordOfNullableSequenceOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceOfNullableRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceOfNullableRecordOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicNullableObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicNullableObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableObjectWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableObjectWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfNullableObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfNullableObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableSequenceOfObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableSequenceOfObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceOfNullableSequenceOfObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceOfNullableSequenceOfObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceOfNullableSequenceOfNullableObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceOfNullableSequenceOfNullableObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnion_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithNullable", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithNullable_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnion_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnion_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableUnion_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableUnionWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableUnionWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithString_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithEnum_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue1", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue1_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue3", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue3_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue4", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue4_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue5", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue5_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue6", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue6_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue7", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue7_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue8", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue8_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue9", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue9_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue10", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue10_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue11", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue11_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue12", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue12_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue13", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue13_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue14", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue14_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue15", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue15_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue16", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue16_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue17", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue17_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue18", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue18_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue19", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue19_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue20", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue20_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue21", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue21_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue22", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue22_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue23", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue23_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue24", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue24_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue25", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue25_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue1", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue1_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue3", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue3_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue4", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue4_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue5", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue5_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue6", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue6_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue7", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue7_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue8", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue8_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue9", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue9_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue10", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue10_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue11", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue11_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue12", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue12_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue13", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue13_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue14", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue14_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue15", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue15_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue16", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue16_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue17", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue17_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue18", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue18_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue19", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue19_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue20", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue20_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue21", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue21_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue22", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue22_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue23", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue23_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue24", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue24_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue25", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue25_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue26", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue26_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue27", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue27_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue28", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue28_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfUnions", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfUnions_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfUnions2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfUnions2_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicUnion_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfNullableUnions", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfNullableUnions_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicNullableUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicNullableUnion_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfUnions", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfUnions_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUnion_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUnion2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUnion2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUnionContainingNull", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUnionContainingNull_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableUnion_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableUnion2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableUnion2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passPromise", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passPromise_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalPromise", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalPromise_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passPromiseSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passPromiseSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receivePromise", (GenericMethod<NormalThisPolicy, ConvertExceptionsToPromises>), reinterpret_cast<const JSJitInfo*>(&receivePromise_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveAddrefedPromise", (GenericMethod<NormalThisPolicy, ConvertExceptionsToPromises>), reinterpret_cast<const JSJitInfo*>(&receiveAddrefedPromise_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("methodRenamedFrom", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&methodRenamedFrom_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passDictionary", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passDictionary_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passDictionary2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passDictionary2_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveDictionary", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveDictionary_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableDictionary", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableDictionary_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOtherDictionary", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOtherDictionary_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfDictionaries", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfDictionaries_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfDictionaries", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfDictionaries_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passDictionaryOrLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passDictionaryOrLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passDictContainingDict", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passDictContainingDict_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passDictContainingSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passDictContainingSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveDictContainingSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveDictContainingSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicDictionary", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicDictionary_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("dontEnforceRangeOrClamp", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&dontEnforceRangeOrClamp_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("doEnforceRange", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&doEnforceRange_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("doEnforceRangeNullable", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&doEnforceRangeNullable_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("doClamp", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&doClamp_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("doClampNullable", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&doClampNullable_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("exerciseTypedefInterfaces1", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&exerciseTypedefInterfaces1_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("exerciseTypedefInterfaces2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&exerciseTypedefInterfaces2_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("exerciseTypedefInterfaces3", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&exerciseTypedefInterfaces3_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("deprecatedMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&deprecatedMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("deprecatedMethodWithContext", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&deprecatedMethodWithContext_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload1", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload1_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload3", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload3_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload4", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload4_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload5", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload5_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload6", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload6_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload7", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload7_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload8", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload8_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload9", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload9_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload10", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload10_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload11", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload11_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload12", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload12_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload13", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload13_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload14", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload14_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload15", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload15_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload16", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload16_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload17", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload17_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload18", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload18_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload19", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload19_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload20", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload20_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicThirdArg", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicThirdArg_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("prefable10", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&prefable10_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("prefable11", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&prefable11_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("prefable13", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&prefable13_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("prefable17", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&prefable17_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("prefable18", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&prefable18_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("prefable19", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&prefable19_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("conditionalOnSecureContext5", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&conditionalOnSecureContext5_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("conditionalOnSecureContext6", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&conditionalOnSecureContext6_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("conditionalOnSecureContext7", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&conditionalOnSecureContext7_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("conditionalOnSecureContext8", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&conditionalOnSecureContext8_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("passRenamedInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRenamedInterface_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("throwingMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&throwingMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("canOOMMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&canOOMMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("ceReactionsMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&ceReactionsMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("ceReactionsMethodOverload", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&ceReactionsMethodOverload_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passArgsWithDefaults", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passArgsWithDefaults_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("toJSON", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&toJSON_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("dashed-method", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&dashed_method_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("nonEnumerableMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&nonEnumerableMethod_methodinfo), 0, 0, nullptr),
  JS_FNSPEC("passAllowSharedArrayBufferViewTypedef", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAllowSharedArrayBufferViewTypedef_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passAllowSharedArrayBufferView", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAllowSharedArrayBufferView_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passAllowSharedNullableArrayBufferView", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAllowSharedNullableArrayBufferView_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passAllowSharedArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAllowSharedArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passAllowSharedNullableArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAllowSharedNullableArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionAllowSharedArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionAllowSharedArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};

static const PrefableDisablers sMethods_disablers381 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, nullptr
};

static const PrefableDisablers sMethods_disablers383 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, &nsGenericHTMLElement::LegacyTouchAPIEnabled
};

static const PrefableDisablers sMethods_disablers386 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, &TestFuncControlledMember
};

static const PrefableDisablers sMethods_disablers388 = {
  WebIDLPrefIndex::NoPref, false, 0, &TestFuncControlledMember
};

static const PrefableDisablers sMethods_disablers391 = {
  WebIDLPrefIndex::NoPref, true, 0, nullptr
};

static const PrefableDisablers sMethods_disablers393 = {
  WebIDLPrefIndex::dom_webidl_test1, true, 0, nullptr
};

static const PrefableDisablers sMethods_disablers395 = {
  WebIDLPrefIndex::dom_webidl_test1, true, 0, &nsGenericHTMLElement::LegacyTouchAPIEnabled
};

static const PrefableDisablers sMethods_disablers397 = {
  WebIDLPrefIndex::dom_webidl_test1, true, 0, &TestFuncControlledMember
};

static const Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { &sMethods_disablers381, &sMethods_specs[381] },
  { &sMethods_disablers383, &sMethods_specs[383] },
  { &sMethods_disablers386, &sMethods_specs[386] },
  { &sMethods_disablers388, &sMethods_specs[388] },
  { &sMethods_disablers391, &sMethods_specs[391] },
  { &sMethods_disablers393, &sMethods_specs[393] },
  { &sMethods_disablers395, &sMethods_specs[395] },
  { &sMethods_disablers397, &sMethods_specs[397] },
  { nullptr, &sMethods_specs[399] },
  { nullptr, nullptr }
};

static_assert(10 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(380 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNSPEC("prefable20", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&prefable20_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};

static const PrefableDisablers sChromeMethods_disablers0 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, &TestFuncControlledMember
};

static const Prefable<const JSFunctionSpec> sChromeMethods[] = {
  { &sChromeMethods_disablers0, &sChromeMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("readonlyByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyByte_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableByte_getterinfo, GenericSetter<NormalThisPolicy>, &writableByte_setterinfo),
  JSPropertySpec::nativeAccessors("sideEffectFreeByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &sideEffectFreeByte_getterinfo, GenericSetter<NormalThisPolicy>, &sideEffectFreeByte_setterinfo),
  JSPropertySpec::nativeAccessors("domDependentByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &domDependentByte_getterinfo, GenericSetter<NormalThisPolicy>, &domDependentByte_setterinfo),
  JSPropertySpec::nativeAccessors("constantByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &constantByte_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("deviceStateDependentByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &deviceStateDependentByte_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("readonlyShort", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyShort_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableShort", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableShort_getterinfo, GenericSetter<NormalThisPolicy>, &writableShort_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyLong_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableLong_getterinfo, GenericSetter<NormalThisPolicy>, &writableLong_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyLongLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyLongLong_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableLongLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableLongLong_getterinfo, GenericSetter<NormalThisPolicy>, &writableLongLong_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyOctet", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyOctet_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableOctet", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableOctet_getterinfo, GenericSetter<NormalThisPolicy>, &writableOctet_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyUnsignedShort", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyUnsignedShort_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableUnsignedShort", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnsignedShort_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnsignedShort_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyUnsignedLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyUnsignedLong_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableUnsignedLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnsignedLong_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnsignedLong_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyUnsignedLongLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyUnsignedLongLong_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableUnsignedLongLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnsignedLongLong_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnsignedLongLong_setterinfo),
  JSPropertySpec::nativeAccessors("writableFloat", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableFloat_getterinfo, GenericSetter<NormalThisPolicy>, &writableFloat_setterinfo),
  JSPropertySpec::nativeAccessors("writableUnrestrictedFloat", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnrestrictedFloat_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnrestrictedFloat_setterinfo),
  JSPropertySpec::nativeAccessors("writableNullableFloat", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableNullableFloat_getterinfo, GenericSetter<NormalThisPolicy>, &writableNullableFloat_setterinfo),
  JSPropertySpec::nativeAccessors("writableNullableUnrestrictedFloat", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableNullableUnrestrictedFloat_getterinfo, GenericSetter<NormalThisPolicy>, &writableNullableUnrestrictedFloat_setterinfo),
  JSPropertySpec::nativeAccessors("writableDouble", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableDouble_getterinfo, GenericSetter<NormalThisPolicy>, &writableDouble_setterinfo),
  JSPropertySpec::nativeAccessors("writableUnrestrictedDouble", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnrestrictedDouble_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnrestrictedDouble_setterinfo),
  JSPropertySpec::nativeAccessors("writableNullableDouble", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableNullableDouble_getterinfo, GenericSetter<NormalThisPolicy>, &writableNullableDouble_setterinfo),
  JSPropertySpec::nativeAccessors("writableNullableUnrestrictedDouble", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableNullableUnrestrictedDouble_getterinfo, GenericSetter<NormalThisPolicy>, &writableNullableUnrestrictedDouble_setterinfo),
  JSPropertySpec::nativeAccessors("lenientFloatAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &lenientFloatAttr_getterinfo, GenericSetter<NormalThisPolicy>, &lenientFloatAttr_setterinfo),
  JSPropertySpec::nativeAccessors("lenientDoubleAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &lenientDoubleAttr_getterinfo, GenericSetter<NormalThisPolicy>, &lenientDoubleAttr_setterinfo),
  JSPropertySpec::nativeAccessors("nonNullSelf", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nonNullSelf_getterinfo, GenericSetter<NormalThisPolicy>, &nonNullSelf_setterinfo),
  JSPropertySpec::nativeAccessors("nullableSelf", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nullableSelf_getterinfo, GenericSetter<NormalThisPolicy>, &nullableSelf_setterinfo),
  JSPropertySpec::nativeAccessors("nonNullExternal", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nonNullExternal_getterinfo, GenericSetter<NormalThisPolicy>, &nonNullExternal_setterinfo),
  JSPropertySpec::nativeAccessors("nullableExternal", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nullableExternal_getterinfo, GenericSetter<NormalThisPolicy>, &nullableExternal_setterinfo),
  JSPropertySpec::nativeAccessors("nonNullCallbackInterface", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nonNullCallbackInterface_getterinfo, GenericSetter<NormalThisPolicy>, &nonNullCallbackInterface_setterinfo),
  JSPropertySpec::nativeAccessors("nullableCallbackInterface", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nullableCallbackInterface_getterinfo, GenericSetter<NormalThisPolicy>, &nullableCallbackInterface_setterinfo),
  JSPropertySpec::nativeAccessors("uint8ArrayAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &uint8ArrayAttr_getterinfo, GenericSetter<NormalThisPolicy>, &uint8ArrayAttr_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyJSStringAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyJSStringAttr_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("jsStringAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &jsStringAttr_getterinfo, GenericSetter<NormalThisPolicy>, &jsStringAttr_setterinfo),
  JSPropertySpec::nativeAccessors("enumAttribute", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &enumAttribute_getterinfo, GenericSetter<NormalThisPolicy>, &enumAttribute_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyEnumAttribute", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyEnumAttribute_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableUnion", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnion_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnion_setterinfo),
  JSPropertySpec::nativeAccessors("writableUnionContainingNull", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnionContainingNull_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnionContainingNull_setterinfo),
  JSPropertySpec::nativeAccessors("writableNullableUnion", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableNullableUnion_getterinfo, GenericSetter<NormalThisPolicy>, &writableNullableUnion_setterinfo),
  JSPropertySpec::nativeAccessors("attributeGetterRenamedFrom", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &attributeGetterRenamedFrom_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("attributeRenamedFrom", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &attributeRenamedFrom_getterinfo, GenericSetter<NormalThisPolicy>, &attributeRenamedFrom_setterinfo),
  JSPropertySpec::nativeAccessors("enforcedByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &enforcedByte_getterinfo, GenericSetter<NormalThisPolicy>, &enforcedByte_setterinfo),
  JSPropertySpec::nativeAccessors("enforcedByteNullable", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &enforcedByteNullable_getterinfo, GenericSetter<NormalThisPolicy>, &enforcedByteNullable_setterinfo),
  JSPropertySpec::nativeAccessors("clampedByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &clampedByte_getterinfo, GenericSetter<NormalThisPolicy>, &clampedByte_setterinfo),
  JSPropertySpec::nativeAccessors("clampedByteNullable", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &clampedByteNullable_getterinfo, GenericSetter<NormalThisPolicy>, &clampedByteNullable_setterinfo),
  JSPropertySpec::nativeAccessors("deprecatedAttribute", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &deprecatedAttribute_getterinfo, GenericSetter<NormalThisPolicy>, &deprecatedAttribute_setterinfo),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable1", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable1_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("prefable2", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable2_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable3", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable3_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("prefable4", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable4_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable5", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable5_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable6", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable6_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("prefable7", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable7_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable8", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable8_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable9", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable9_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable12", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable12_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("prefable14", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable14_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable15", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable15_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("prefable16", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable16_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("conditionalOnSecureContext1", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &conditionalOnSecureContext1_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("conditionalOnSecureContext2", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &conditionalOnSecureContext2_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("conditionalOnSecureContext3", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &conditionalOnSecureContext3_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("conditionalOnSecureContext4", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &conditionalOnSecureContext4_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("attrWithLenientThis", JSPROP_ENUMERATE, GenericGetter<LenientThisPolicy, ThrowExceptions>, &attrWithLenientThis_getterinfo, GenericSetter<LenientThisPolicy>, &attrWithLenientThis_setterinfo),
  JSPropertySpec::nativeAccessors("putForwardsAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &putForwardsAttr_getterinfo, GenericSetter<NormalThisPolicy>, &putForwardsAttr_setterinfo),
  JSPropertySpec::nativeAccessors("putForwardsAttr2", JSPROP_ENUMERATE, GenericGetter<LenientThisPolicy, ThrowExceptions>, &putForwardsAttr2_getterinfo, GenericSetter<LenientThisPolicy>, &putForwardsAttr2_setterinfo),
  JSPropertySpec::nativeAccessors("throwingAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &throwingAttr_getterinfo, GenericSetter<NormalThisPolicy>, &throwingAttr_setterinfo),
  JSPropertySpec::nativeAccessors("throwingGetterAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &throwingGetterAttr_getterinfo, GenericSetter<NormalThisPolicy>, &throwingGetterAttr_setterinfo),
  JSPropertySpec::nativeAccessors("throwingSetterAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &throwingSetterAttr_getterinfo, GenericSetter<NormalThisPolicy>, &throwingSetterAttr_setterinfo),
  JSPropertySpec::nativeAccessors("canOOMAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &canOOMAttr_getterinfo, GenericSetter<NormalThisPolicy>, &canOOMAttr_setterinfo),
  JSPropertySpec::nativeAccessors("canOOMGetterAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &canOOMGetterAttr_getterinfo, GenericSetter<NormalThisPolicy>, &canOOMGetterAttr_setterinfo),
  JSPropertySpec::nativeAccessors("canOOMSetterAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &canOOMSetterAttr_getterinfo, GenericSetter<NormalThisPolicy>, &canOOMSetterAttr_setterinfo),
  JSPropertySpec::nativeAccessors("ceReactionsAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &ceReactionsAttr_getterinfo, GenericSetter<NormalThisPolicy>, &ceReactionsAttr_setterinfo),
  JSPropertySpec::nativeAccessors("toJSONShouldSkipThis", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &toJSONShouldSkipThis_getterinfo, GenericSetter<NormalThisPolicy>, &toJSONShouldSkipThis_setterinfo),
  JSPropertySpec::nativeAccessors("toJSONShouldSkipThis2", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &toJSONShouldSkipThis2_getterinfo, GenericSetter<NormalThisPolicy>, &toJSONShouldSkipThis2_setterinfo),
  JSPropertySpec::nativeAccessors("toJSONShouldSkipThis3", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &toJSONShouldSkipThis3_getterinfo, GenericSetter<NormalThisPolicy>, &toJSONShouldSkipThis3_setterinfo),
  JSPropertySpec::nativeAccessors("dashed-attribute", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &dashed_attribute_getterinfo, GenericSetter<NormalThisPolicy>, &dashed_attribute_setterinfo),
  JSPropertySpec::nativeAccessors("nonEnumerableAttr", 0, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nonEnumerableAttr_getterinfo, GenericSetter<NormalThisPolicy>, &nonEnumerableAttr_setterinfo),
  JSPropertySpec::nativeAccessors("allowSharedArrayBufferViewTypedef", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &allowSharedArrayBufferViewTypedef_getterinfo, GenericSetter<NormalThisPolicy>, &allowSharedArrayBufferViewTypedef_setterinfo),
  JSPropertySpec::nativeAccessors("allowSharedArrayBufferView", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &allowSharedArrayBufferView_getterinfo, GenericSetter<NormalThisPolicy>, &allowSharedArrayBufferView_setterinfo),
  JSPropertySpec::nativeAccessors("allowSharedNullableArrayBufferView", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &allowSharedNullableArrayBufferView_getterinfo, GenericSetter<NormalThisPolicy>, &allowSharedNullableArrayBufferView_setterinfo),
  JSPropertySpec::nativeAccessors("allowSharedArrayBuffer", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &allowSharedArrayBuffer_getterinfo, GenericSetter<NormalThisPolicy>, &allowSharedArrayBuffer_setterinfo),
  JSPropertySpec::nativeAccessors("allowSharedNullableArrayBuffer", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &allowSharedNullableArrayBuffer_getterinfo, GenericSetter<NormalThisPolicy>, &allowSharedNullableArrayBuffer_setterinfo),
  JS_STRING_SYM_PS(toStringTag, "TestJSImplInterface", JSPROP_READONLY),
  JS_PS_END
};

static const PrefableDisablers sAttributes_disablers52 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, nullptr
};

static const PrefableDisablers sAttributes_disablers55 = {
  WebIDLPrefIndex::dom_webidl_test2, false, 0, nullptr
};

static const PrefableDisablers sAttributes_disablers58 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, nullptr
};

static const PrefableDisablers sAttributes_disablers60 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, &nsGenericHTMLElement::LegacyTouchAPIEnabled
};

static const PrefableDisablers sAttributes_disablers63 = {
  WebIDLPrefIndex::dom_webidl_test2, false, 0, &nsGenericHTMLElement::LegacyTouchAPIEnabled
};

static const PrefableDisablers sAttributes_disablers65 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, &nsGenericHTMLElement::LegacyTouchAPIEnabled
};

static const PrefableDisablers sAttributes_disablers67 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, &TestFuncControlledMember
};

static const PrefableDisablers sAttributes_disablers70 = {
  WebIDLPrefIndex::NoPref, false, 0, &TestFuncControlledMember
};

static const PrefableDisablers sAttributes_disablers73 = {
  WebIDLPrefIndex::NoPref, true, 0, nullptr
};

static const PrefableDisablers sAttributes_disablers75 = {
  WebIDLPrefIndex::dom_webidl_test1, true, 0, nullptr
};

static const PrefableDisablers sAttributes_disablers77 = {
  WebIDLPrefIndex::dom_webidl_test1, true, 0, &nsGenericHTMLElement::LegacyTouchAPIEnabled
};

static const PrefableDisablers sAttributes_disablers79 = {
  WebIDLPrefIndex::dom_webidl_test1, true, 0, &TestFuncControlledMember
};

static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { &sAttributes_disablers52, &sAttributes_specs[52] },
  { &sAttributes_disablers55, &sAttributes_specs[55] },
  { &sAttributes_disablers58, &sAttributes_specs[58] },
  { &sAttributes_disablers60, &sAttributes_specs[60] },
  { &sAttributes_disablers63, &sAttributes_specs[63] },
  { &sAttributes_disablers65, &sAttributes_specs[65] },
  { &sAttributes_disablers67, &sAttributes_specs[67] },
  { &sAttributes_disablers70, &sAttributes_specs[70] },
  { &sAttributes_disablers73, &sAttributes_specs[73] },
  { &sAttributes_disablers75, &sAttributes_specs[75] },
  { &sAttributes_disablers77, &sAttributes_specs[77] },
  { &sAttributes_disablers79, &sAttributes_specs[79] },
  { nullptr, &sAttributes_specs[81] },
  { nullptr, nullptr }
};

static_assert(14 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(51 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sChromeAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("putForwardsAttr3", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &putForwardsAttr3_getterinfo, GenericSetter<NormalThisPolicy>, &putForwardsAttr3_setterinfo),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sChromeAttributes[] = {
  { nullptr, &sChromeAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const ConstantSpec sConstants_specs[] = {
  { "myLongConstant", JS::Int32Value(5) },
  { "nonEnumerableConst", JS::BooleanValue(true) },
  { 0, JS::UndefinedValue() }
};


static const Prefable<const ConstantSpec> sConstants[] = {
  { nullptr, &sConstants_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(2 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[497];
static PropertyInfo sNativeProperties_propertyInfos[497];

static const NativePropertiesN<3> sNativeProperties = {
  false, 0,
  false, 0,
  true,  0 /* sMethods */,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  true,  2 /* sConstants */,
  -1,
  497,
  sNativeProperties_sortedPropertyIndices,
  {
    { sMethods, &sNativeProperties_propertyInfos[0] },
    { sAttributes, &sNativeProperties_propertyInfos[406] },
    { sConstants, &sNativeProperties_propertyInfos[495] }
  }
};
static_assert(497 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static uint16_t sChromeOnlyNativeProperties_sortedPropertyIndices[3];
static PropertyInfo sChromeOnlyNativeProperties_propertyInfos[3];

static const NativePropertiesN<3> sChromeOnlyNativeProperties = {
  true,  0 /* sChromeStaticMethods */,
  false, 0,
  true,  1 /* sChromeMethods */,
  true,  2 /* sChromeAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  3,
  sChromeOnlyNativeProperties_sortedPropertyIndices,
  {
    { sChromeStaticMethods, &sChromeOnlyNativeProperties_propertyInfos[0] },
    { sChromeMethods, &sChromeOnlyNativeProperties_propertyInfos[1] },
    { sChromeAttributes, &sChromeOnlyNativeProperties_propertyInfos[2] }
  }
};
static_assert(3 < 1ull << (CHAR_BIT * sizeof(sChromeOnlyNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

MOZ_CAN_RUN_SCRIPT bool
CollectJSONAttributes(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::TestJSImplInterface* self, JS::Rooted<JSObject*>& result)
{
  JS::Rooted<JSObject*> unwrappedObj(cx, js::CheckedUnwrapStatic(obj));
  if (!unwrappedObj) {
    // How did that happen?  We managed to get called with that
    // object as "this"!  Just give up on sanity.
    return false;
  }

  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_sideEffectFreeByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "sideEffectFreeByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_domDependentByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "domDependentByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_constantByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "constantByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_deviceStateDependentByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "deviceStateDependentByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyShort(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyShort", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableShort(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableShort", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyLongLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyLongLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableLongLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableLongLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyOctet(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyOctet", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableOctet(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableOctet", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyUnsignedShort(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyUnsignedShort", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableUnsignedShort(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableUnsignedShort", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyUnsignedLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyUnsignedLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableUnsignedLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableUnsignedLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyUnsignedLongLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyUnsignedLongLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableUnsignedLongLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableUnsignedLongLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableFloat(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableFloat", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableUnrestrictedFloat(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableUnrestrictedFloat", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableNullableFloat(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableNullableFloat", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableNullableUnrestrictedFloat(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableNullableUnrestrictedFloat", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableDouble(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableDouble", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableUnrestrictedDouble(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableUnrestrictedDouble", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableNullableDouble(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableNullableDouble", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableNullableUnrestrictedDouble(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableNullableUnrestrictedDouble", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_lenientFloatAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "lenientFloatAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_lenientDoubleAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "lenientDoubleAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_nonNullSelf(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "nonNullSelf", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_nullableSelf(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "nullableSelf", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyJSStringAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyJSStringAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_jsStringAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "jsStringAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_enumAttribute(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "enumAttribute", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyEnumAttribute(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyEnumAttribute", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_attributeGetterRenamedFrom(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "attributeGetterRenamedFrom", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_attributeRenamedFrom(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "attributeRenamedFrom", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_enforcedByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "enforcedByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_enforcedByteNullable(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "enforcedByteNullable", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_clampedByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "clampedByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_clampedByteNullable(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "clampedByteNullable", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_deprecatedAttribute(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "deprecatedAttribute", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable1, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable1(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable1", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable2, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable2(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable2", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable3, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable3(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable3", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable4, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable4(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable4", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable5, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable5(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable5", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable6, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable6(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable6", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable7, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable7(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable7", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable8, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable8(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable8", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable9, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable9(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable9", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable12, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable12(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable12", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable14, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable14(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable14", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable15, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable15(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable15", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable16, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable16(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable16", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_conditionalOnSecureContext1, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_conditionalOnSecureContext1(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "conditionalOnSecureContext1", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_conditionalOnSecureContext2, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_conditionalOnSecureContext2(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "conditionalOnSecureContext2", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_conditionalOnSecureContext3, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_conditionalOnSecureContext3(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "conditionalOnSecureContext3", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_conditionalOnSecureContext4, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_conditionalOnSecureContext4(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "conditionalOnSecureContext4", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_attrWithLenientThis(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "attrWithLenientThis", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_putForwardsAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "putForwardsAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_putForwardsAttr2(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "putForwardsAttr2", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_putForwardsAttr3(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "putForwardsAttr3", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_throwingAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "throwingAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_throwingGetterAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "throwingGetterAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_throwingSetterAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "throwingSetterAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_canOOMAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "canOOMAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_canOOMGetterAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "canOOMGetterAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_canOOMSetterAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "canOOMSetterAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_ceReactionsAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "ceReactionsAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_dashed_attribute(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "dashed_attribute", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_nonEnumerableAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "nonEnumerableAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  return true;
}

static bool
_constructor(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "TestJSImplInterface constructor");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestJSImplInterface", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "TestJSImplInterface");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestJSImplInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  if (!args.requireAtLeast(cx, "TestJSImplInterface constructor", 15)) {
    return false;
  }
  GlobalObject global(cx, obj);
  if (global.Failed()) {
    return false;
  }

  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  uint32_t arg1;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  }
  Nullable<bool> arg2;
  if (args[2].isNullOrUndefined()) {
    arg2.SetNull();
  } else if (!ValueToPrimitive<bool, eDefault>(cx, args[2], "Argument 3", &arg2.SetValue())) {
    return false;
  }
  mozilla::dom::TestInterface* arg3;
  if (args[3].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[3], arg3, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 4", "TestInterface");
        return false;
      }
    }
  } else if (args[3].isNullOrUndefined()) {
    arg3 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 4");
    return false;
  }
  int32_t arg4;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[4], "Argument 5", &arg4)) {
    return false;
  }
  RootedDictionary<binding_detail::FastDictForConstructor> arg5(cx);
  if (!arg5.Init(cx, args[5], "Argument 6", true)) {
    return false;
  }
  JS::Rooted<JS::Value> arg6(cx);
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
  if ((true) && !CallerSubsumes(args[6])) {
    cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("argument 7");
    return false;
  }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
  arg6 = args[6];
  JS::Rooted<JSObject*> arg7(cx);
  if (args[7].isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
    if ((true) && !CallerSubsumes(args[7])) {
      cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("argument 8");
      return false;
    }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
    arg7 = &args[7].toObject();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 8");
    return false;
  }
  JS::Rooted<JSObject*> arg8(cx);
  if (args[8].isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
    if ((true) && !CallerSubsumes(args[8])) {
      cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("argument 9");
      return false;
    }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
    arg8 = &args[8].toObject();
  } else if (args[8].isNullOrUndefined()) {
    arg8 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 9");
    return false;
  }
  binding_detail::AutoSequence<Dict> arg9;
  SequenceRooter<Dict> arg9_holder(cx, &arg9);
  if (args[9].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[9], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 10");
      return false;
    }
    binding_detail::AutoSequence<Dict> &arr = arg9;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Dict* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Dict& slot = *slotPtr;
      if (!slot.Init(cx, temp, "Element of argument 10", true)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 10");
    return false;
  }
  JS::Rooted<JS::Value> arg10(cx);
  if (args.hasDefined(10)) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
    if ((true) && !CallerSubsumes(args[10])) {
      cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("argument 11");
      return false;
    }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
    arg10 = args[10];
  } else {
    arg10 = JS::UndefinedValue();
  }
  Optional<JS::Handle<JSObject*>> arg11;
  if (args.hasDefined(11)) {
    arg11.Construct(cx);
    if (args[11].isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
      if ((true) && !CallerSubsumes(args[11])) {
        cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("argument 12");
        return false;
      }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
      arg11.Value() = &args[11].toObject();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 12");
      return false;
    }
  }
  Optional<JS::Handle<JSObject*>> arg12;
  if (args.hasDefined(12)) {
    arg12.Construct(cx);
    if (args[12].isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
      if ((true) && !CallerSubsumes(args[12])) {
        cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("argument 13");
        return false;
      }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
      arg12.Value() = &args[12].toObject();
    } else if (args[12].isNullOrUndefined()) {
      arg12.Value() = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 13");
      return false;
    }
  }
  RootedSpiderMonkeyInterface<Uint8Array> arg13(cx);
  if (args[13].isObject()) {
    if (!arg13.Init(&args[13].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 14", "Uint8Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg13.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 14");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg13.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 14");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 14");
    return false;
  }
  RootedSpiderMonkeyInterface<ArrayBuffer> arg14(cx);
  if (args[14].isObject()) {
    if (!arg14.Init(&args[14].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 15", "ArrayBuffer");
      return false;
    }
    if (JS::IsSharedArrayBufferObject(arg14.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 15");
      return false;
    }
    if (JS::IsLargeArrayBufferMaybeShared(arg14.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 15");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 15");
    return false;
  }
  Maybe<JSAutoRealm> ar;
  if (objIsXray) {
    // Since our object is an Xray, we can just CheckedUnwrapStatic:
    // we know Xrays have no dynamic unwrap behavior.
    obj = js::CheckedUnwrapStatic(obj);
    if (!obj) {
      return false;
    }
    ar.emplace(cx, obj);
    if (!JS_WrapObject(cx, &desiredProto)) {
      return false;
    }
    if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mAny1))) {
      return false;
    }
    if (arg5.mDict.WasPassed()) {
      if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mDict.Value().mAnotherAny))) {
        return false;
      }
      if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mDict.Value().mAnotherObj))) {
        return false;
      }
      if (arg5.mDict.Value().mArrayBuffer.WasPassed()) {
        if (!arg5.mDict.Value().mArrayBuffer.Value().WrapIntoNewCompartment(cx)) {
          return false;
        }
      }
      if (arg5.mDict.Value().mCustomEventInit.WasPassed()) {
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mDict.Value().mCustomEventInit.Value().mDetail))) {
          return false;
        }
      }
      if (arg5.mDict.Value().mDictionaryTypedef.WasPassed()) {
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mDict.Value().mDictionaryTypedef.Value().mDetail))) {
          return false;
        }
      }
      if (!arg5.mDict.Value().mFloat64Array.IsNull()) {
        if (!arg5.mDict.Value().mFloat64Array.Value().WrapIntoNewCompartment(cx)) {
          return false;
        }
      }
      if (arg5.mDict.Value().mNullableArrayBuffer.WasPassed()) {
        if (!arg5.mDict.Value().mNullableArrayBuffer.Value().IsNull()) {
          if (!arg5.mDict.Value().mNullableArrayBuffer.Value().Value().WrapIntoNewCompartment(cx)) {
            return false;
          }
        }
      }
      if (arg5.mDict.Value().mObjectOrLong.WasPassed()) {
        if (arg5.mDict.Value().mObjectOrLong.Value().IsObject()) {
          if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mDict.Value().mObjectOrLong.Value().GetAsObject()))) {
            return false;
          }
        }
      }
      if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mDict.Value().mRequiredObject))) {
        return false;
      }
      if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mDict.Value().mSomeAny))) {
        return false;
      }
      if (arg5.mDict.Value().mSomeObj.WasPassed()) {
        if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mDict.Value().mSomeObj.Value()))) {
          return false;
        }
      }
      if (arg5.mDict.Value().mUint8Array.WasPassed()) {
        if (!arg5.mDict.Value().mUint8Array.Value().WrapIntoNewCompartment(cx)) {
          return false;
        }
      }
      if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mDict.Value().mParentAny))) {
        return false;
      }
    }
    if (arg5.mDict2.WasPassed()) {
      if (arg5.mDict2.Value().mMemberDict.WasPassed()) {
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mDict2.Value().mMemberDict.Value().mAnotherAny))) {
          return false;
        }
        if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mDict2.Value().mMemberDict.Value().mAnotherObj))) {
          return false;
        }
        if (arg5.mDict2.Value().mMemberDict.Value().mArrayBuffer.WasPassed()) {
          if (!arg5.mDict2.Value().mMemberDict.Value().mArrayBuffer.Value().WrapIntoNewCompartment(cx)) {
            return false;
          }
        }
        if (arg5.mDict2.Value().mMemberDict.Value().mCustomEventInit.WasPassed()) {
          if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mDict2.Value().mMemberDict.Value().mCustomEventInit.Value().mDetail))) {
            return false;
          }
        }
        if (arg5.mDict2.Value().mMemberDict.Value().mDictionaryTypedef.WasPassed()) {
          if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mDict2.Value().mMemberDict.Value().mDictionaryTypedef.Value().mDetail))) {
            return false;
          }
        }
        if (!arg5.mDict2.Value().mMemberDict.Value().mFloat64Array.IsNull()) {
          if (!arg5.mDict2.Value().mMemberDict.Value().mFloat64Array.Value().WrapIntoNewCompartment(cx)) {
            return false;
          }
        }
        if (arg5.mDict2.Value().mMemberDict.Value().mNullableArrayBuffer.WasPassed()) {
          if (!arg5.mDict2.Value().mMemberDict.Value().mNullableArrayBuffer.Value().IsNull()) {
            if (!arg5.mDict2.Value().mMemberDict.Value().mNullableArrayBuffer.Value().Value().WrapIntoNewCompartment(cx)) {
              return false;
            }
          }
        }
        if (arg5.mDict2.Value().mMemberDict.Value().mObjectOrLong.WasPassed()) {
          if (arg5.mDict2.Value().mMemberDict.Value().mObjectOrLong.Value().IsObject()) {
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mDict2.Value().mMemberDict.Value().mObjectOrLong.Value().GetAsObject()))) {
              return false;
            }
          }
        }
        if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mDict2.Value().mMemberDict.Value().mRequiredObject))) {
          return false;
        }
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mDict2.Value().mMemberDict.Value().mSomeAny))) {
          return false;
        }
        if (arg5.mDict2.Value().mMemberDict.Value().mSomeObj.WasPassed()) {
          if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mDict2.Value().mMemberDict.Value().mSomeObj.Value()))) {
            return false;
          }
        }
        if (arg5.mDict2.Value().mMemberDict.Value().mUint8Array.WasPassed()) {
          if (!arg5.mDict2.Value().mMemberDict.Value().mUint8Array.Value().WrapIntoNewCompartment(cx)) {
            return false;
          }
        }
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mDict2.Value().mMemberDict.Value().mParentAny))) {
          return false;
        }
      }
    }
    if (arg5.mObj1.WasPassed()) {
      if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mObj1.Value()))) {
        return false;
      }
    }
    if (arg5.mObj2.WasPassed()) {
      if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mObj2.Value()))) {
        return false;
      }
    }
    if (arg5.mSeq1.WasPassed()) {
      for (uint32_t indexName0 = 0; indexName0 < arg5.mSeq1.Value().Length(); ++indexName0) {
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mSeq1.Value()[indexName0].mAnotherAny))) {
          return false;
        }
        if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mSeq1.Value()[indexName0].mAnotherObj))) {
          return false;
        }
        if (arg5.mSeq1.Value()[indexName0].mArrayBuffer.WasPassed()) {
          if (!arg5.mSeq1.Value()[indexName0].mArrayBuffer.Value().WrapIntoNewCompartment(cx)) {
            return false;
          }
        }
        if (arg5.mSeq1.Value()[indexName0].mCustomEventInit.WasPassed()) {
          if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mSeq1.Value()[indexName0].mCustomEventInit.Value().mDetail))) {
            return false;
          }
        }
        if (arg5.mSeq1.Value()[indexName0].mDictionaryTypedef.WasPassed()) {
          if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mSeq1.Value()[indexName0].mDictionaryTypedef.Value().mDetail))) {
            return false;
          }
        }
        if (!arg5.mSeq1.Value()[indexName0].mFloat64Array.IsNull()) {
          if (!arg5.mSeq1.Value()[indexName0].mFloat64Array.Value().WrapIntoNewCompartment(cx)) {
            return false;
          }
        }
        if (arg5.mSeq1.Value()[indexName0].mNullableArrayBuffer.WasPassed()) {
          if (!arg5.mSeq1.Value()[indexName0].mNullableArrayBuffer.Value().IsNull()) {
            if (!arg5.mSeq1.Value()[indexName0].mNullableArrayBuffer.Value().Value().WrapIntoNewCompartment(cx)) {
              return false;
            }
          }
        }
        if (arg5.mSeq1.Value()[indexName0].mObjectOrLong.WasPassed()) {
          if (arg5.mSeq1.Value()[indexName0].mObjectOrLong.Value().IsObject()) {
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mSeq1.Value()[indexName0].mObjectOrLong.Value().GetAsObject()))) {
              return false;
            }
          }
        }
        if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mSeq1.Value()[indexName0].mRequiredObject))) {
          return false;
        }
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mSeq1.Value()[indexName0].mSomeAny))) {
          return false;
        }
        if (arg5.mSeq1.Value()[indexName0].mSomeObj.WasPassed()) {
          if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mSeq1.Value()[indexName0].mSomeObj.Value()))) {
            return false;
          }
        }
        if (arg5.mSeq1.Value()[indexName0].mUint8Array.WasPassed()) {
          if (!arg5.mSeq1.Value()[indexName0].mUint8Array.Value().WrapIntoNewCompartment(cx)) {
            return false;
          }
        }
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mSeq1.Value()[indexName0].mParentAny))) {
          return false;
        }
      }
    }
    if (arg5.mSeq2.WasPassed()) {
      if (!arg5.mSeq2.Value().IsNull()) {
        for (uint32_t indexName0 = 0; indexName0 < arg5.mSeq2.Value().Value().Length(); ++indexName0) {
          for (uint32_t indexName1 = 0; indexName1 < arg5.mSeq2.Value().Value()[indexName0].Length(); ++indexName1) {
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mSeq2.Value().Value()[indexName0][indexName1].mAnotherAny))) {
              return false;
            }
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mSeq2.Value().Value()[indexName0][indexName1].mAnotherObj))) {
              return false;
            }
            if (arg5.mSeq2.Value().Value()[indexName0][indexName1].mArrayBuffer.WasPassed()) {
              if (!arg5.mSeq2.Value().Value()[indexName0][indexName1].mArrayBuffer.Value().WrapIntoNewCompartment(cx)) {
                return false;
              }
            }
            if (arg5.mSeq2.Value().Value()[indexName0][indexName1].mCustomEventInit.WasPassed()) {
              if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mSeq2.Value().Value()[indexName0][indexName1].mCustomEventInit.Value().mDetail))) {
                return false;
              }
            }
            if (arg5.mSeq2.Value().Value()[indexName0][indexName1].mDictionaryTypedef.WasPassed()) {
              if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mSeq2.Value().Value()[indexName0][indexName1].mDictionaryTypedef.Value().mDetail))) {
                return false;
              }
            }
            if (!arg5.mSeq2.Value().Value()[indexName0][indexName1].mFloat64Array.IsNull()) {
              if (!arg5.mSeq2.Value().Value()[indexName0][indexName1].mFloat64Array.Value().WrapIntoNewCompartment(cx)) {
                return false;
              }
            }
            if (arg5.mSeq2.Value().Value()[indexName0][indexName1].mNullableArrayBuffer.WasPassed()) {
              if (!arg5.mSeq2.Value().Value()[indexName0][indexName1].mNullableArrayBuffer.Value().IsNull()) {
                if (!arg5.mSeq2.Value().Value()[indexName0][indexName1].mNullableArrayBuffer.Value().Value().WrapIntoNewCompartment(cx)) {
                  return false;
                }
              }
            }
            if (arg5.mSeq2.Value().Value()[indexName0][indexName1].mObjectOrLong.WasPassed()) {
              if (arg5.mSeq2.Value().Value()[indexName0][indexName1].mObjectOrLong.Value().IsObject()) {
                if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mSeq2.Value().Value()[indexName0][indexName1].mObjectOrLong.Value().GetAsObject()))) {
                  return false;
                }
              }
            }
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mSeq2.Value().Value()[indexName0][indexName1].mRequiredObject))) {
              return false;
            }
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mSeq2.Value().Value()[indexName0][indexName1].mSomeAny))) {
              return false;
            }
            if (arg5.mSeq2.Value().Value()[indexName0][indexName1].mSomeObj.WasPassed()) {
              if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mSeq2.Value().Value()[indexName0][indexName1].mSomeObj.Value()))) {
                return false;
              }
            }
            if (arg5.mSeq2.Value().Value()[indexName0][indexName1].mUint8Array.WasPassed()) {
              if (!arg5.mSeq2.Value().Value()[indexName0][indexName1].mUint8Array.Value().WrapIntoNewCompartment(cx)) {
                return false;
              }
            }
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mSeq2.Value().Value()[indexName0][indexName1].mParentAny))) {
              return false;
            }
          }
        }
      }
    }
    if (arg5.mSeq3.WasPassed()) {
      for (uint32_t indexName0 = 0; indexName0 < arg5.mSeq3.Value().Length(); ++indexName0) {
        if (!arg5.mSeq3.Value()[indexName0].IsNull()) {
          for (uint32_t indexName1 = 0; indexName1 < arg5.mSeq3.Value()[indexName0].Value().Length(); ++indexName1) {
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mSeq3.Value()[indexName0].Value()[indexName1].mAnotherAny))) {
              return false;
            }
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mSeq3.Value()[indexName0].Value()[indexName1].mAnotherObj))) {
              return false;
            }
            if (arg5.mSeq3.Value()[indexName0].Value()[indexName1].mArrayBuffer.WasPassed()) {
              if (!arg5.mSeq3.Value()[indexName0].Value()[indexName1].mArrayBuffer.Value().WrapIntoNewCompartment(cx)) {
                return false;
              }
            }
            if (arg5.mSeq3.Value()[indexName0].Value()[indexName1].mCustomEventInit.WasPassed()) {
              if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mSeq3.Value()[indexName0].Value()[indexName1].mCustomEventInit.Value().mDetail))) {
                return false;
              }
            }
            if (arg5.mSeq3.Value()[indexName0].Value()[indexName1].mDictionaryTypedef.WasPassed()) {
              if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mSeq3.Value()[indexName0].Value()[indexName1].mDictionaryTypedef.Value().mDetail))) {
                return false;
              }
            }
            if (!arg5.mSeq3.Value()[indexName0].Value()[indexName1].mFloat64Array.IsNull()) {
              if (!arg5.mSeq3.Value()[indexName0].Value()[indexName1].mFloat64Array.Value().WrapIntoNewCompartment(cx)) {
                return false;
              }
            }
            if (arg5.mSeq3.Value()[indexName0].Value()[indexName1].mNullableArrayBuffer.WasPassed()) {
              if (!arg5.mSeq3.Value()[indexName0].Value()[indexName1].mNullableArrayBuffer.Value().IsNull()) {
                if (!arg5.mSeq3.Value()[indexName0].Value()[indexName1].mNullableArrayBuffer.Value().Value().WrapIntoNewCompartment(cx)) {
                  return false;
                }
              }
            }
            if (arg5.mSeq3.Value()[indexName0].Value()[indexName1].mObjectOrLong.WasPassed()) {
              if (arg5.mSeq3.Value()[indexName0].Value()[indexName1].mObjectOrLong.Value().IsObject()) {
                if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mSeq3.Value()[indexName0].Value()[indexName1].mObjectOrLong.Value().GetAsObject()))) {
                  return false;
                }
              }
            }
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mSeq3.Value()[indexName0].Value()[indexName1].mRequiredObject))) {
              return false;
            }
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mSeq3.Value()[indexName0].Value()[indexName1].mSomeAny))) {
              return false;
            }
            if (arg5.mSeq3.Value()[indexName0].Value()[indexName1].mSomeObj.WasPassed()) {
              if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mSeq3.Value()[indexName0].Value()[indexName1].mSomeObj.Value()))) {
                return false;
              }
            }
            if (arg5.mSeq3.Value()[indexName0].Value()[indexName1].mUint8Array.WasPassed()) {
              if (!arg5.mSeq3.Value()[indexName0].Value()[indexName1].mUint8Array.Value().WrapIntoNewCompartment(cx)) {
                return false;
              }
            }
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mSeq3.Value()[indexName0].Value()[indexName1].mParentAny))) {
              return false;
            }
          }
        }
      }
    }
    if (arg5.mSeq4.WasPassed()) {
      for (uint32_t indexName0 = 0; indexName0 < arg5.mSeq4.Value().Length(); ++indexName0) {
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mSeq4.Value()[indexName0]))) {
          return false;
        }
      }
    }
    if (arg5.mSeq5.WasPassed()) {
      for (uint32_t indexName0 = 0; indexName0 < arg5.mSeq5.Value().Length(); ++indexName0) {
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mSeq5.Value()[indexName0]))) {
          return false;
        }
      }
    }
    if (arg5.mSeq6.WasPassed()) {
      for (uint32_t indexName0 = 0; indexName0 < arg5.mSeq6.Value().Length(); ++indexName0) {
        if (arg5.mSeq6.Value()[indexName0].mOurSequence3.WasPassed()) {
          for (uint32_t indexName1 = 0; indexName1 < arg5.mSeq6.Value()[indexName0].mOurSequence3.Value().Length(); ++indexName1) {
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg5.mSeq6.Value()[indexName0].mOurSequence3.Value()[indexName1]))) {
              return false;
            }
          }
        }
        if (arg5.mSeq6.Value()[indexName0].mOurSequence4.WasPassed()) {
          for (uint32_t indexName1 = 0; indexName1 < arg5.mSeq6.Value()[indexName0].mOurSequence4.Value().Length(); ++indexName1) {
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mSeq6.Value()[indexName0].mOurSequence4.Value()[indexName1]))) {
              return false;
            }
          }
        }
        if (arg5.mSeq6.Value()[indexName0].mOurSequence5.WasPassed()) {
          for (uint32_t indexName1 = 0; indexName1 < arg5.mSeq6.Value()[indexName0].mOurSequence5.Value().Length(); ++indexName1) {
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mSeq6.Value()[indexName0].mOurSequence5.Value()[indexName1]))) {
              return false;
            }
          }
        }
        if (arg5.mSeq6.Value()[indexName0].mOurSequence6.WasPassed()) {
          if (!arg5.mSeq6.Value()[indexName0].mOurSequence6.Value().IsNull()) {
            for (uint32_t indexName1 = 0; indexName1 < arg5.mSeq6.Value()[indexName0].mOurSequence6.Value().Value().Length(); ++indexName1) {
              if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mSeq6.Value()[indexName0].mOurSequence6.Value().Value()[indexName1]))) {
                return false;
              }
            }
          }
        }
        if (arg5.mSeq6.Value()[indexName0].mOurSequence7.WasPassed()) {
          if (!arg5.mSeq6.Value()[indexName0].mOurSequence7.Value().IsNull()) {
            for (uint32_t indexName1 = 0; indexName1 < arg5.mSeq6.Value()[indexName0].mOurSequence7.Value().Value().Length(); ++indexName1) {
              if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mSeq6.Value()[indexName0].mOurSequence7.Value().Value()[indexName1]))) {
                return false;
              }
            }
          }
        }
        if (!arg5.mSeq6.Value()[indexName0].mOurSequence8.IsNull()) {
          for (uint32_t indexName1 = 0; indexName1 < arg5.mSeq6.Value()[indexName0].mOurSequence8.Value().Length(); ++indexName1) {
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mSeq6.Value()[indexName0].mOurSequence8.Value()[indexName1]))) {
              return false;
            }
          }
        }
        if (!arg5.mSeq6.Value()[indexName0].mOurSequence9.IsNull()) {
          for (uint32_t indexName1 = 0; indexName1 < arg5.mSeq6.Value()[indexName0].mOurSequence9.Value().Length(); ++indexName1) {
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg5.mSeq6.Value()[indexName0].mOurSequence9.Value()[indexName1]))) {
              return false;
            }
          }
        }
      }
    }
    if (!JS_WrapValue(cx, &arg6)) {
      return false;
    }
    if (!JS_WrapObject(cx, &arg7)) {
      return false;
    }
    if (!JS_WrapObject(cx, &arg8)) {
      return false;
    }
    for (uint32_t indexName0 = 0; indexName0 < arg9.Length(); ++indexName0) {
      if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg9[indexName0].mAnotherAny))) {
        return false;
      }
      if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg9[indexName0].mAnotherObj))) {
        return false;
      }
      if (arg9[indexName0].mArrayBuffer.WasPassed()) {
        if (!arg9[indexName0].mArrayBuffer.Value().WrapIntoNewCompartment(cx)) {
          return false;
        }
      }
      if (arg9[indexName0].mCustomEventInit.WasPassed()) {
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg9[indexName0].mCustomEventInit.Value().mDetail))) {
          return false;
        }
      }
      if (arg9[indexName0].mDictionaryTypedef.WasPassed()) {
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg9[indexName0].mDictionaryTypedef.Value().mDetail))) {
          return false;
        }
      }
      if (!arg9[indexName0].mFloat64Array.IsNull()) {
        if (!arg9[indexName0].mFloat64Array.Value().WrapIntoNewCompartment(cx)) {
          return false;
        }
      }
      if (arg9[indexName0].mNullableArrayBuffer.WasPassed()) {
        if (!arg9[indexName0].mNullableArrayBuffer.Value().IsNull()) {
          if (!arg9[indexName0].mNullableArrayBuffer.Value().Value().WrapIntoNewCompartment(cx)) {
            return false;
          }
        }
      }
      if (arg9[indexName0].mObjectOrLong.WasPassed()) {
        if (arg9[indexName0].mObjectOrLong.Value().IsObject()) {
          if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg9[indexName0].mObjectOrLong.Value().GetAsObject()))) {
            return false;
          }
        }
      }
      if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg9[indexName0].mRequiredObject))) {
        return false;
      }
      if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg9[indexName0].mSomeAny))) {
        return false;
      }
      if (arg9[indexName0].mSomeObj.WasPassed()) {
        if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg9[indexName0].mSomeObj.Value()))) {
          return false;
        }
      }
      if (arg9[indexName0].mUint8Array.WasPassed()) {
        if (!arg9[indexName0].mUint8Array.Value().WrapIntoNewCompartment(cx)) {
          return false;
        }
      }
      if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg9[indexName0].mParentAny))) {
        return false;
      }
    }
    if (!JS_WrapValue(cx, &arg10)) {
      return false;
    }
    if (arg11.WasPassed()) {
      if (!JS_WrapObject(cx, &arg11.Value())) {
        return false;
      }
    }
    if (arg12.WasPassed()) {
      if (!JS_WrapObject(cx, &arg12.Value())) {
        return false;
      }
    }
    if (!arg13.WrapIntoNewCompartment(cx)) {
      return false;
    }
    if (!arg14.WrapIntoNewCompartment(cx)) {
      return false;
    }
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TestJSImplInterface>(mozilla::dom::TestJSImplInterface::Constructor(global, cx, NonNullHelper(Constify(arg0)), arg1, Constify(arg2), MOZ_KnownLive(Constify(arg3)), arg4, Constify(arg5), arg6, arg7, arg8, Constify(arg9), arg10, Constify(arg11), Constify(arg12), Constify(arg13), Constify(arg14), rv, desiredProto)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestJSImplInterface constructor"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSClassOps sInterfaceObjectClassOps = {
    nullptr,               /* addProperty */
    nullptr,               /* delProperty */
    nullptr,               /* enumerate */
    nullptr,               /* newEnumerate */
    nullptr,               /* resolve */
    nullptr,               /* mayResolve */
    nullptr,               /* finalize */
    _constructor, /* call */
    nullptr,               /* hasInstance */
    _constructor, /* construct */
    nullptr,               /* trace */
};

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sInterfaceObjectClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestJSImplInterface,
  PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth,
  sNativePropertyHooks,
  "function TestJSImplInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestJSImplInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestJSImplInterface,
  PrototypeTraits<prototypes::id::TestJSImplInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestJSImplInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestJSImplInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestJSImplInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestJSImplInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestJSImplInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestJSImplInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestJSImplInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestJSImplInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestJSImplInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestJSImplInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestJSImplInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), sChromeOnlyNativeProperties.Upcast() },
  prototypes::id::TestJSImplInterface,
  constructors::id::TestJSImplInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    if (!InitIds(aCx, sChromeOnlyNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestJSImplInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestJSImplInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 15, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              sChromeOnlyNativeProperties.Upcast(),
                              "TestJSImplInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetProtoObject(JSContext* aCx)
{
  return GetProtoObjectHandle(aCx);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestJSImplInterface_Binding



namespace TestJSImplNoInterfaceObject_Binding {

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestJSImplNoInterfaceObject* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestJSImplNoInterfaceObject>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestJSImplNoInterfaceObject* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestJSImplNoInterfaceObject>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestJSImplNoInterfaceObject>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestJSImplNoInterfaceObject* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestJSImplNoInterfaceObject>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestJSImplNoInterfaceObject* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestJSImplNoInterfaceObject>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestJSImplNoInterfaceObject", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestJSImplNoInterfaceObjectPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestJSImplNoInterfaceObject,
  PrototypeTraits<prototypes::id::TestJSImplNoInterfaceObject>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestJSImplNoInterfaceObject",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestJSImplNoInterfaceObject, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestJSImplNoInterfaceObject>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestJSImplNoInterfaceObject>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestJSImplNoInterfaceObject>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestJSImplNoInterfaceObject* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestJSImplNoInterfaceObject>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestJSImplNoInterfaceObject*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestJSImplNoInterfaceObject*>(aObject),
             "Multiple inheritance for mozilla::dom::TestJSImplNoInterfaceObject is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestJSImplNoInterfaceObject> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestJSImplNoInterfaceObject,
  constructors::id::_ID_Count,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestJSImplNoInterfaceObject);
  JS::Heap<JSObject*>* interfaceCache = nullptr;
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              nullptr, nullptr, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              nullptr, aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

} // namespace TestJSImplNoInterfaceObject_Binding



void
TestJSImplInterfaceJSImpl::PassByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passByte_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

int8_t
TestJSImplInterfaceJSImpl::ReceiveByte(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveByte_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return int8_t(0);
  }
  int8_t rvalDecl;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.receiveByte", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  return rvalDecl;
}

void
TestJSImplInterfaceJSImpl::PassOptionalByte(const Optional<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      argv[0].setInt32(int32_t(arg.Value()));
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalByte_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalByteBeforeRequired(const Optional<int8_t>& arg1, int8_t arg2, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalByteBeforeRequired", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(2)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 2;

  do {
    argv[1].setInt32(int32_t(arg2));
    break;
  } while (false);

  do {
    if (arg1.WasPassed()) {
      argv[0].setInt32(int32_t(arg1.Value()));
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalByteBeforeRequired_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalByteWithDefault(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalByteWithDefault", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalByteWithDefault_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalByteWithDefaultBeforeRequired(int8_t arg1, int8_t arg2, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalByteWithDefaultBeforeRequired", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(2)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 2;

  do {
    argv[1].setInt32(int32_t(arg2));
    break;
  } while (false);

  do {
    argv[0].setInt32(int32_t(arg1));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalByteWithDefaultBeforeRequired_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableByte(const Nullable<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    argv[0].setInt32(int32_t(arg.Value()));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableByte_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableByte(const Optional<Nullable<int8_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (arg.Value().IsNull()) {
        argv[0].setNull();
        break;
      }
      argv[0].setInt32(int32_t(arg.Value().Value()));
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableByte_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassVariadicByte(const nsTArray<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passVariadicByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize((1 - 1) + arg.Length())) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = (1 - 1) + arg.Length();

  do {
    for (uint32_t idx = 0; idx < arg.Length(); ++idx) {
      argv[0 + idx].setInt32(int32_t(arg[idx]));
      continue;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passVariadicByte_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

int8_t
TestJSImplInterfaceJSImpl::ReturnByteSideEffectFree(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.returnByteSideEffectFree", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->returnByteSideEffectFree_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return int8_t(0);
  }
  int8_t rvalDecl;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.returnByteSideEffectFree", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  return rvalDecl;
}

int8_t
TestJSImplInterfaceJSImpl::ReturnDOMDependentByte(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.returnDOMDependentByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->returnDOMDependentByte_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return int8_t(0);
  }
  int8_t rvalDecl;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.returnDOMDependentByte", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  return rvalDecl;
}

int8_t
TestJSImplInterfaceJSImpl::ReturnConstantByte(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.returnConstantByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->returnConstantByte_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return int8_t(0);
  }
  int8_t rvalDecl;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.returnConstantByte", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  return rvalDecl;
}

int8_t
TestJSImplInterfaceJSImpl::ReturnDeviceStateDependentByte(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.returnDeviceStateDependentByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->returnDeviceStateDependentByte_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return int8_t(0);
  }
  int8_t rvalDecl;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.returnDeviceStateDependentByte", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  return rvalDecl;
}

void
TestJSImplInterfaceJSImpl::PassShort(int16_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passShort", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passShort_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

int16_t
TestJSImplInterfaceJSImpl::ReceiveShort(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveShort", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int16_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveShort_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int16_t(0);
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return int16_t(0);
  }
  int16_t rvalDecl;
  if (!ValueToPrimitive<int16_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.receiveShort", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int16_t(0);
  }
  return rvalDecl;
}

void
TestJSImplInterfaceJSImpl::PassOptionalShort(const Optional<int16_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalShort", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      argv[0].setInt32(int32_t(arg.Value()));
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalShort_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalShortWithDefault(int16_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalShortWithDefault", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalShortWithDefault_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassLong(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passLong_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

int32_t
TestJSImplInterfaceJSImpl::ReceiveLong(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int32_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveLong_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int32_t(0);
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return int32_t(0);
  }
  int32_t rvalDecl;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.receiveLong", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int32_t(0);
  }
  return rvalDecl;
}

void
TestJSImplInterfaceJSImpl::PassOptionalLong(const Optional<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      argv[0].setInt32(int32_t(arg.Value()));
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalLong_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalLongWithDefault(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalLongWithDefault", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalLongWithDefault_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassLongLong(int64_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passLongLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].set(JS_NumberValue(double(arg)));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passLongLong_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

int64_t
TestJSImplInterfaceJSImpl::ReceiveLongLong(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveLongLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int64_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveLongLong_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int64_t(0);
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return int64_t(0);
  }
  int64_t rvalDecl;
  if (!ValueToPrimitive<int64_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.receiveLongLong", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int64_t(0);
  }
  return rvalDecl;
}

void
TestJSImplInterfaceJSImpl::PassOptionalLongLong(const Optional<int64_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalLongLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      argv[0].set(JS_NumberValue(double(arg.Value())));
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalLongLong_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalLongLongWithDefault(int64_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalLongLongWithDefault", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].set(JS_NumberValue(double(arg)));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalLongLongWithDefault_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOctet(uint8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOctet", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOctet_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

uint8_t
TestJSImplInterfaceJSImpl::ReceiveOctet(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveOctet", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return uint8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveOctet_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint8_t(0);
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return uint8_t(0);
  }
  uint8_t rvalDecl;
  if (!ValueToPrimitive<uint8_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.receiveOctet", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint8_t(0);
  }
  return rvalDecl;
}

void
TestJSImplInterfaceJSImpl::PassOptionalOctet(const Optional<uint8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalOctet", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      argv[0].setInt32(int32_t(arg.Value()));
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalOctet_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalOctetWithDefault(uint8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalOctetWithDefault", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalOctetWithDefault_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnsignedShort(uint16_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnsignedShort", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnsignedShort_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

uint16_t
TestJSImplInterfaceJSImpl::ReceiveUnsignedShort(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveUnsignedShort", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return uint16_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveUnsignedShort_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint16_t(0);
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return uint16_t(0);
  }
  uint16_t rvalDecl;
  if (!ValueToPrimitive<uint16_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.receiveUnsignedShort", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint16_t(0);
  }
  return rvalDecl;
}

void
TestJSImplInterfaceJSImpl::PassOptionalUnsignedShort(const Optional<uint16_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalUnsignedShort", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      argv[0].setInt32(int32_t(arg.Value()));
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalUnsignedShort_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalUnsignedShortWithDefault(uint16_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalUnsignedShortWithDefault", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalUnsignedShortWithDefault_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnsignedLong(uint32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnsignedLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setNumber(arg);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnsignedLong_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

uint32_t
TestJSImplInterfaceJSImpl::ReceiveUnsignedLong(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveUnsignedLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return uint32_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveUnsignedLong_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint32_t(0);
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return uint32_t(0);
  }
  uint32_t rvalDecl;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.receiveUnsignedLong", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint32_t(0);
  }
  return rvalDecl;
}

void
TestJSImplInterfaceJSImpl::PassOptionalUnsignedLong(const Optional<uint32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalUnsignedLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      argv[0].setNumber(arg.Value());
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalUnsignedLong_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalUnsignedLongWithDefault(uint32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalUnsignedLongWithDefault", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setNumber(arg);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalUnsignedLongWithDefault_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnsignedLongLong(uint64_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnsignedLongLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].set(JS_NumberValue(double(arg)));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnsignedLongLong_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

uint64_t
TestJSImplInterfaceJSImpl::ReceiveUnsignedLongLong(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveUnsignedLongLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return uint64_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveUnsignedLongLong_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint64_t(0);
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return uint64_t(0);
  }
  uint64_t rvalDecl;
  if (!ValueToPrimitive<uint64_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.receiveUnsignedLongLong", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint64_t(0);
  }
  return rvalDecl;
}

void
TestJSImplInterfaceJSImpl::PassOptionalUnsignedLongLong(const Optional<uint64_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalUnsignedLongLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      argv[0].set(JS_NumberValue(double(arg.Value())));
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalUnsignedLongLong_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalUnsignedLongLongWithDefault(uint64_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalUnsignedLongLongWithDefault", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].set(JS_NumberValue(double(arg)));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalUnsignedLongLongWithDefault_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassFloat(float arg1, float arg2, const Nullable<float>& arg3, const Nullable<float>& arg4, double arg5, double arg6, const Nullable<double>& arg7, const Nullable<double>& arg8, const Sequence<float>& arg9, const Sequence<float>& arg10, const Sequence<Nullable<float>>& arg11, const Sequence<Nullable<float>>& arg12, const Sequence<double>& arg13, const Sequence<double>& arg14, const Sequence<Nullable<double>>& arg15, const Sequence<Nullable<double>>& arg16, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passFloat", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(16)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 16;

  do {

    uint32_t length = arg16.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (arg16[sequenceIdx0].IsNull()) {
            tmp.setNull();
            break;
          }
          tmp.set(JS_NumberValue(double(arg16[sequenceIdx0].Value())));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[15].setObject(*returnArray);
    break;
  } while (false);

  do {

    uint32_t length = arg15.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (arg15[sequenceIdx0].IsNull()) {
            tmp.setNull();
            break;
          }
          tmp.set(JS_NumberValue(double(arg15[sequenceIdx0].Value())));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[14].setObject(*returnArray);
    break;
  } while (false);

  do {

    uint32_t length = arg14.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.set(JS_NumberValue(double(arg14[sequenceIdx0])));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[13].setObject(*returnArray);
    break;
  } while (false);

  do {

    uint32_t length = arg13.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.set(JS_NumberValue(double(arg13[sequenceIdx0])));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[12].setObject(*returnArray);
    break;
  } while (false);

  do {

    uint32_t length = arg12.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (arg12[sequenceIdx0].IsNull()) {
            tmp.setNull();
            break;
          }
          tmp.set(JS_NumberValue(double(arg12[sequenceIdx0].Value())));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[11].setObject(*returnArray);
    break;
  } while (false);

  do {

    uint32_t length = arg11.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (arg11[sequenceIdx0].IsNull()) {
            tmp.setNull();
            break;
          }
          tmp.set(JS_NumberValue(double(arg11[sequenceIdx0].Value())));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[10].setObject(*returnArray);
    break;
  } while (false);

  do {

    uint32_t length = arg10.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.set(JS_NumberValue(double(arg10[sequenceIdx0])));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[9].setObject(*returnArray);
    break;
  } while (false);

  do {

    uint32_t length = arg9.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.set(JS_NumberValue(double(arg9[sequenceIdx0])));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[8].setObject(*returnArray);
    break;
  } while (false);

  do {
    if (arg8.IsNull()) {
      argv[7].setNull();
      break;
    }
    argv[7].set(JS_NumberValue(double(arg8.Value())));
    break;
  } while (false);

  do {
    if (arg7.IsNull()) {
      argv[6].setNull();
      break;
    }
    argv[6].set(JS_NumberValue(double(arg7.Value())));
    break;
  } while (false);

  do {
    argv[5].set(JS_NumberValue(double(arg6)));
    break;
  } while (false);

  do {
    argv[4].set(JS_NumberValue(double(arg5)));
    break;
  } while (false);

  do {
    if (arg4.IsNull()) {
      argv[3].setNull();
      break;
    }
    argv[3].set(JS_NumberValue(double(arg4.Value())));
    break;
  } while (false);

  do {
    if (arg3.IsNull()) {
      argv[2].setNull();
      break;
    }
    argv[2].set(JS_NumberValue(double(arg3.Value())));
    break;
  } while (false);

  do {
    argv[1].set(JS_NumberValue(double(arg2)));
    break;
  } while (false);

  do {
    argv[0].set(JS_NumberValue(double(arg1)));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passFloat_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassLenientFloat(float arg1, float arg2, const Nullable<float>& arg3, const Nullable<float>& arg4, double arg5, double arg6, const Nullable<double>& arg7, const Nullable<double>& arg8, const Sequence<float>& arg9, const Sequence<float>& arg10, const Sequence<Nullable<float>>& arg11, const Sequence<Nullable<float>>& arg12, const Sequence<double>& arg13, const Sequence<double>& arg14, const Sequence<Nullable<double>>& arg15, const Sequence<Nullable<double>>& arg16, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passLenientFloat", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(16)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 16;

  do {

    uint32_t length = arg16.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (arg16[sequenceIdx0].IsNull()) {
            tmp.setNull();
            break;
          }
          tmp.set(JS_NumberValue(double(arg16[sequenceIdx0].Value())));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[15].setObject(*returnArray);
    break;
  } while (false);

  do {

    uint32_t length = arg15.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (arg15[sequenceIdx0].IsNull()) {
            tmp.setNull();
            break;
          }
          tmp.set(JS_NumberValue(double(arg15[sequenceIdx0].Value())));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[14].setObject(*returnArray);
    break;
  } while (false);

  do {

    uint32_t length = arg14.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.set(JS_NumberValue(double(arg14[sequenceIdx0])));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[13].setObject(*returnArray);
    break;
  } while (false);

  do {

    uint32_t length = arg13.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.set(JS_NumberValue(double(arg13[sequenceIdx0])));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[12].setObject(*returnArray);
    break;
  } while (false);

  do {

    uint32_t length = arg12.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (arg12[sequenceIdx0].IsNull()) {
            tmp.setNull();
            break;
          }
          tmp.set(JS_NumberValue(double(arg12[sequenceIdx0].Value())));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[11].setObject(*returnArray);
    break;
  } while (false);

  do {

    uint32_t length = arg11.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (arg11[sequenceIdx0].IsNull()) {
            tmp.setNull();
            break;
          }
          tmp.set(JS_NumberValue(double(arg11[sequenceIdx0].Value())));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[10].setObject(*returnArray);
    break;
  } while (false);

  do {

    uint32_t length = arg10.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.set(JS_NumberValue(double(arg10[sequenceIdx0])));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[9].setObject(*returnArray);
    break;
  } while (false);

  do {

    uint32_t length = arg9.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.set(JS_NumberValue(double(arg9[sequenceIdx0])));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[8].setObject(*returnArray);
    break;
  } while (false);

  do {
    if (arg8.IsNull()) {
      argv[7].setNull();
      break;
    }
    argv[7].set(JS_NumberValue(double(arg8.Value())));
    break;
  } while (false);

  do {
    if (arg7.IsNull()) {
      argv[6].setNull();
      break;
    }
    argv[6].set(JS_NumberValue(double(arg7.Value())));
    break;
  } while (false);

  do {
    argv[5].set(JS_NumberValue(double(arg6)));
    break;
  } while (false);

  do {
    argv[4].set(JS_NumberValue(double(arg5)));
    break;
  } while (false);

  do {
    if (arg4.IsNull()) {
      argv[3].setNull();
      break;
    }
    argv[3].set(JS_NumberValue(double(arg4.Value())));
    break;
  } while (false);

  do {
    if (arg3.IsNull()) {
      argv[2].setNull();
      break;
    }
    argv[2].set(JS_NumberValue(double(arg3.Value())));
    break;
  } while (false);

  do {
    argv[1].set(JS_NumberValue(double(arg2)));
    break;
  } while (false);

  do {
    argv[0].set(JS_NumberValue(double(arg1)));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passLenientFloat_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

already_AddRefed<TestJSImplInterface>
TestJSImplInterfaceJSImpl::ReceiveSelf(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveSelf", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveSelf_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestJSImplInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(rval, rvalDecl, cx);
      if (NS_FAILED(rv)) {
        // Be careful to not wrap random DOM objects here, even if
        // they're wrapped in opaque security wrappers for some reason.
        // XXXbz Wish we could check for a JS-implemented object
        // that already has a content reflection...
        if (!IsDOMObject(js::UncheckedUnwrap(&rval.toObject()))) {
          nsCOMPtr<nsIGlobalObject> contentGlobal;
          JS::Rooted<JSObject*> callback(cx, CallbackOrNull());
          if (!callback ||
              !GetContentGlobalForJSImplementedObject(cx, callback, getter_AddRefs(contentGlobal))) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return nullptr;
          }
          JS::Rooted<JSObject*> jsImplSourceObj(cx, &rval.toObject());
          MOZ_RELEASE_ASSERT(!js::IsWrapper(jsImplSourceObj),
                             "Don't return JS implementations from other compartments");
          JS::Rooted<JSObject*> jsImplSourceGlobal(cx, JS::GetNonCCWObjectGlobal(jsImplSourceObj));
          rvalDecl = new mozilla::dom::TestJSImplInterface(jsImplSourceObj, jsImplSourceGlobal, contentGlobal);
        } else {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.receiveSelf", "TestJSImplInterface");
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return nullptr;
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveSelf");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<TestJSImplInterface>
TestJSImplInterfaceJSImpl::ReceiveNullableSelf(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableSelf", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableSelf_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestJSImplInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(rval, rvalDecl, cx);
      if (NS_FAILED(rv)) {
        // Be careful to not wrap random DOM objects here, even if
        // they're wrapped in opaque security wrappers for some reason.
        // XXXbz Wish we could check for a JS-implemented object
        // that already has a content reflection...
        if (!IsDOMObject(js::UncheckedUnwrap(&rval.toObject()))) {
          nsCOMPtr<nsIGlobalObject> contentGlobal;
          JS::Rooted<JSObject*> callback(cx, CallbackOrNull());
          if (!callback ||
              !GetContentGlobalForJSImplementedObject(cx, callback, getter_AddRefs(contentGlobal))) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return nullptr;
          }
          JS::Rooted<JSObject*> jsImplSourceObj(cx, &rval.toObject());
          MOZ_RELEASE_ASSERT(!js::IsWrapper(jsImplSourceObj),
                             "Don't return JS implementations from other compartments");
          JS::Rooted<JSObject*> jsImplSourceGlobal(cx, JS::GetNonCCWObjectGlobal(jsImplSourceObj));
          rvalDecl = new mozilla::dom::TestJSImplInterface(jsImplSourceObj, jsImplSourceGlobal, contentGlobal);
        } else {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.receiveNullableSelf", "TestJSImplInterface");
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return nullptr;
        }
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveNullableSelf");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<TestJSImplInterface>
TestJSImplInterfaceJSImpl::ReceiveWeakSelf(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveWeakSelf", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveWeakSelf_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestJSImplInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(rval, rvalDecl, cx);
      if (NS_FAILED(rv)) {
        // Be careful to not wrap random DOM objects here, even if
        // they're wrapped in opaque security wrappers for some reason.
        // XXXbz Wish we could check for a JS-implemented object
        // that already has a content reflection...
        if (!IsDOMObject(js::UncheckedUnwrap(&rval.toObject()))) {
          nsCOMPtr<nsIGlobalObject> contentGlobal;
          JS::Rooted<JSObject*> callback(cx, CallbackOrNull());
          if (!callback ||
              !GetContentGlobalForJSImplementedObject(cx, callback, getter_AddRefs(contentGlobal))) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return nullptr;
          }
          JS::Rooted<JSObject*> jsImplSourceObj(cx, &rval.toObject());
          MOZ_RELEASE_ASSERT(!js::IsWrapper(jsImplSourceObj),
                             "Don't return JS implementations from other compartments");
          JS::Rooted<JSObject*> jsImplSourceGlobal(cx, JS::GetNonCCWObjectGlobal(jsImplSourceObj));
          rvalDecl = new mozilla::dom::TestJSImplInterface(jsImplSourceObj, jsImplSourceGlobal, contentGlobal);
        } else {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.receiveWeakSelf", "TestJSImplInterface");
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return nullptr;
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveWeakSelf");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<TestJSImplInterface>
TestJSImplInterfaceJSImpl::ReceiveWeakNullableSelf(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveWeakNullableSelf", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveWeakNullableSelf_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestJSImplInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(rval, rvalDecl, cx);
      if (NS_FAILED(rv)) {
        // Be careful to not wrap random DOM objects here, even if
        // they're wrapped in opaque security wrappers for some reason.
        // XXXbz Wish we could check for a JS-implemented object
        // that already has a content reflection...
        if (!IsDOMObject(js::UncheckedUnwrap(&rval.toObject()))) {
          nsCOMPtr<nsIGlobalObject> contentGlobal;
          JS::Rooted<JSObject*> callback(cx, CallbackOrNull());
          if (!callback ||
              !GetContentGlobalForJSImplementedObject(cx, callback, getter_AddRefs(contentGlobal))) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return nullptr;
          }
          JS::Rooted<JSObject*> jsImplSourceObj(cx, &rval.toObject());
          MOZ_RELEASE_ASSERT(!js::IsWrapper(jsImplSourceObj),
                             "Don't return JS implementations from other compartments");
          JS::Rooted<JSObject*> jsImplSourceGlobal(cx, JS::GetNonCCWObjectGlobal(jsImplSourceObj));
          rvalDecl = new mozilla::dom::TestJSImplInterface(jsImplSourceObj, jsImplSourceGlobal, contentGlobal);
        } else {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.receiveWeakNullableSelf", "TestJSImplInterface");
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return nullptr;
        }
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveWeakNullableSelf");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

void
TestJSImplInterfaceJSImpl::PassSelf(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passSelf", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!GetOrCreateDOMReflector(cx, arg, argv[0])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passSelf_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableSelf(TestJSImplInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableSelf", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!arg) {
      argv[0].setNull();
      break;
    }
    if (!GetOrCreateDOMReflector(cx, arg, argv[0])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableSelf_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalSelf(const Optional<TestJSImplInterface*>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalSelf", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (!arg.Value()) {
        argv[0].setNull();
        break;
      }
      if (!GetOrCreateDOMReflector(cx, arg.Value(), argv[0])) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalSelf_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNonNullSelf(const Optional<NonNull<TestJSImplInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNonNullSelf", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (!GetOrCreateDOMReflector(cx, arg.Value(), argv[0])) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNonNullSelf_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalSelfWithDefault(TestJSImplInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalSelfWithDefault", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!arg) {
      argv[0].setNull();
      break;
    }
    if (!GetOrCreateDOMReflector(cx, arg, argv[0])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalSelfWithDefault_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

already_AddRefed<TestNonWrapperCacheInterface>
TestJSImplInterfaceJSImpl::ReceiveNonWrapperCacheInterface(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNonWrapperCacheInterface", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNonWrapperCacheInterface_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestNonWrapperCacheInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestNonWrapperCacheInterface>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestNonWrapperCacheInterface, mozilla::dom::TestNonWrapperCacheInterface>(rval, rvalDecl, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.receiveNonWrapperCacheInterface", "TestNonWrapperCacheInterface");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return nullptr;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveNonWrapperCacheInterface");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<TestNonWrapperCacheInterface>
TestJSImplInterfaceJSImpl::ReceiveNullableNonWrapperCacheInterface(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableNonWrapperCacheInterface", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableNonWrapperCacheInterface_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestNonWrapperCacheInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestNonWrapperCacheInterface>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestNonWrapperCacheInterface, mozilla::dom::TestNonWrapperCacheInterface>(rval, rvalDecl, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.receiveNullableNonWrapperCacheInterface", "TestNonWrapperCacheInterface");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return nullptr;
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveNullableNonWrapperCacheInterface");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

void
TestJSImplInterfaceJSImpl::ReceiveNonWrapperCacheInterfaceSequence(nsTArray<RefPtr<TestNonWrapperCacheInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNonWrapperCacheInterfaceSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNonWrapperCacheInterfaceSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<RefPtr<mozilla::dom::TestNonWrapperCacheInterface>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNonWrapperCacheInterfaceSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<mozilla::dom::TestNonWrapperCacheInterface>> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestNonWrapperCacheInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<mozilla::dom::TestNonWrapperCacheInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestNonWrapperCacheInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestNonWrapperCacheInterface, mozilla::dom::TestNonWrapperCacheInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of return value of TestJSImplInterface.receiveNonWrapperCacheInterfaceSequence", "TestNonWrapperCacheInterface");
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestJSImplInterface.receiveNonWrapperCacheInterfaceSequence");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNonWrapperCacheInterfaceSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::ReceiveNullableNonWrapperCacheInterfaceSequence(nsTArray<RefPtr<TestNonWrapperCacheInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableNonWrapperCacheInterfaceSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableNonWrapperCacheInterfaceSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<RefPtr<mozilla::dom::TestNonWrapperCacheInterface>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNullableNonWrapperCacheInterfaceSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<mozilla::dom::TestNonWrapperCacheInterface>> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestNonWrapperCacheInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<mozilla::dom::TestNonWrapperCacheInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestNonWrapperCacheInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestNonWrapperCacheInterface, mozilla::dom::TestNonWrapperCacheInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of return value of TestJSImplInterface.receiveNullableNonWrapperCacheInterfaceSequence", "TestNonWrapperCacheInterface");
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestJSImplInterface.receiveNullableNonWrapperCacheInterfaceSequence");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNullableNonWrapperCacheInterfaceSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::ReceiveNonWrapperCacheInterfaceNullableSequence(Nullable<nsTArray<RefPtr<TestNonWrapperCacheInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNonWrapperCacheInterfaceNullableSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNonWrapperCacheInterfaceNullableSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Nullable<Sequence<RefPtr<mozilla::dom::TestNonWrapperCacheInterface>>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNonWrapperCacheInterfaceNullableSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<mozilla::dom::TestNonWrapperCacheInterface>> &arr = rvalDecl.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestNonWrapperCacheInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<mozilla::dom::TestNonWrapperCacheInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestNonWrapperCacheInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestNonWrapperCacheInterface, mozilla::dom::TestNonWrapperCacheInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of return value of TestJSImplInterface.receiveNonWrapperCacheInterfaceNullableSequence", "TestNonWrapperCacheInterface");
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestJSImplInterface.receiveNonWrapperCacheInterfaceNullableSequence");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNonWrapperCacheInterfaceNullableSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  if (rvalDecl.IsNull()) {
    aRetVal.SetNull();
  } else {
    aRetVal.SetValue() = std::move(rvalDecl.Value());
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveNullableNonWrapperCacheInterfaceNullableSequence(Nullable<nsTArray<RefPtr<TestNonWrapperCacheInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableNonWrapperCacheInterfaceNullableSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableNonWrapperCacheInterfaceNullableSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Nullable<Sequence<RefPtr<mozilla::dom::TestNonWrapperCacheInterface>>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNullableNonWrapperCacheInterfaceNullableSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<mozilla::dom::TestNonWrapperCacheInterface>> &arr = rvalDecl.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestNonWrapperCacheInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<mozilla::dom::TestNonWrapperCacheInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestNonWrapperCacheInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestNonWrapperCacheInterface, mozilla::dom::TestNonWrapperCacheInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of return value of TestJSImplInterface.receiveNullableNonWrapperCacheInterfaceNullableSequence", "TestNonWrapperCacheInterface");
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestJSImplInterface.receiveNullableNonWrapperCacheInterfaceNullableSequence");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNullableNonWrapperCacheInterfaceNullableSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  if (rvalDecl.IsNull()) {
    aRetVal.SetNull();
  } else {
    aRetVal.SetValue() = std::move(rvalDecl.Value());
  }
}

already_AddRefed<TestExternalInterface>
TestJSImplInterfaceJSImpl::ReceiveExternal(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveExternal", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveExternal_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestExternalInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
    RefPtr<mozilla::dom::TestExternalInterface> rvalHolder;
    JS::Rooted<JSObject*> source(cx, &rval.toObject());
    if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(rvalHolder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.receiveExternal", "TestExternalInterface");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    MOZ_ASSERT(rvalHolder);
    rvalDecl = rvalHolder;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveExternal");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<TestExternalInterface>
TestJSImplInterfaceJSImpl::ReceiveNullableExternal(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableExternal", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableExternal_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestExternalInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
    RefPtr<mozilla::dom::TestExternalInterface> rvalHolder;
    JS::Rooted<JSObject*> source(cx, &rval.toObject());
    if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(rvalHolder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.receiveNullableExternal", "TestExternalInterface");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    MOZ_ASSERT(rvalHolder);
    rvalDecl = rvalHolder;
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveNullableExternal");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<TestExternalInterface>
TestJSImplInterfaceJSImpl::ReceiveWeakExternal(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveWeakExternal", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveWeakExternal_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestExternalInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
    RefPtr<mozilla::dom::TestExternalInterface> rvalHolder;
    JS::Rooted<JSObject*> source(cx, &rval.toObject());
    if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(rvalHolder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.receiveWeakExternal", "TestExternalInterface");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    MOZ_ASSERT(rvalHolder);
    rvalDecl = rvalHolder;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveWeakExternal");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<TestExternalInterface>
TestJSImplInterfaceJSImpl::ReceiveWeakNullableExternal(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveWeakNullableExternal", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveWeakNullableExternal_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestExternalInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
    RefPtr<mozilla::dom::TestExternalInterface> rvalHolder;
    JS::Rooted<JSObject*> source(cx, &rval.toObject());
    if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(rvalHolder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.receiveWeakNullableExternal", "TestExternalInterface");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    MOZ_ASSERT(rvalHolder);
    rvalDecl = rvalHolder;
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveWeakNullableExternal");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

void
TestJSImplInterfaceJSImpl::PassExternal(TestExternalInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passExternal", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!WrapObject(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passExternal_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableExternal(TestExternalInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableExternal", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!arg) {
      argv[0].setNull();
      break;
    }
    if (!WrapObject(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableExternal_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalExternal(const Optional<TestExternalInterface*>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalExternal", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (!arg.Value()) {
        argv[0].setNull();
        break;
      }
      if (!WrapObject(cx, arg.Value(), argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalExternal_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNonNullExternal(const Optional<TestExternalInterface*>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNonNullExternal", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (!WrapObject(cx, arg.Value(), argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNonNullExternal_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalExternalWithDefault(TestExternalInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalExternalWithDefault", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!arg) {
      argv[0].setNull();
      break;
    }
    if (!WrapObject(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalExternalWithDefault_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

already_AddRefed<TestCallbackInterface>
TestJSImplInterfaceJSImpl::ReceiveCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveCallbackInterface", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveCallbackInterface_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<TestCallbackInterface> rvalDecl;
  if (rval.isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
      JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
      rvalDecl = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveCallbackInterface");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<TestCallbackInterface>
TestJSImplInterfaceJSImpl::ReceiveNullableCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableCallbackInterface", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableCallbackInterface_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<TestCallbackInterface> rvalDecl;
  if (rval.isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
      JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
      rvalDecl = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveNullableCallbackInterface");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<TestCallbackInterface>
TestJSImplInterfaceJSImpl::ReceiveWeakCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveWeakCallbackInterface", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveWeakCallbackInterface_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<TestCallbackInterface> rvalDecl;
  if (rval.isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
      JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
      rvalDecl = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveWeakCallbackInterface");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<TestCallbackInterface>
TestJSImplInterfaceJSImpl::ReceiveWeakNullableCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveWeakNullableCallbackInterface", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveWeakNullableCallbackInterface_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<TestCallbackInterface> rvalDecl;
  if (rval.isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
      JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
      rvalDecl = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveWeakNullableCallbackInterface");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

void
TestJSImplInterfaceJSImpl::PassCallbackInterface(TestCallbackInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passCallbackInterface", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setObjectOrNull(GetCallbackFromCallbackObject(cx, arg));
    if (!MaybeWrapObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passCallbackInterface_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableCallbackInterface(TestCallbackInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableCallbackInterface", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg) {
      argv[0].setObjectOrNull(GetCallbackFromCallbackObject(cx, arg));
      if (!MaybeWrapObjectOrNullValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else {
      argv[0].setNull();
      break;
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableCallbackInterface_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalCallbackInterface(const Optional<RefPtr<TestCallbackInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalCallbackInterface", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (arg.Value()) {
        argv[0].setObjectOrNull(GetCallbackFromCallbackObject(cx, arg.Value()));
        if (!MaybeWrapObjectOrNullValue(cx, argv[0])) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
        break;
      } else {
        argv[0].setNull();
        break;
      }
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalCallbackInterface_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNonNullCallbackInterface(const Optional<OwningNonNull<TestCallbackInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNonNullCallbackInterface", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      argv[0].setObjectOrNull(GetCallbackFromCallbackObject(cx, arg.Value()));
      if (!MaybeWrapObjectValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNonNullCallbackInterface_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalCallbackInterfaceWithDefault(TestCallbackInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalCallbackInterfaceWithDefault", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg) {
      argv[0].setObjectOrNull(GetCallbackFromCallbackObject(cx, arg));
      if (!MaybeWrapObjectOrNullValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else {
      argv[0].setNull();
      break;
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalCallbackInterfaceWithDefault_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveSequence(nsTArray<int32_t>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<int32_t> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<int32_t> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      int32_t& slot = *slotPtr;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of return value of TestJSImplInterface.receiveSequence", &slot)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::ReceiveNullableSequence(Nullable<nsTArray<int32_t>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Nullable<Sequence<int32_t>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNullableSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<int32_t> &arr = rvalDecl.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      int32_t& slot = *slotPtr;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of return value of TestJSImplInterface.receiveNullableSequence", &slot)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNullableSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  if (rvalDecl.IsNull()) {
    aRetVal.SetNull();
  } else {
    aRetVal.SetValue() = std::move(rvalDecl.Value());
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveSequenceOfNullableInts(nsTArray<Nullable<int32_t>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveSequenceOfNullableInts", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveSequenceOfNullableInts_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<Nullable<int32_t>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveSequenceOfNullableInts");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<Nullable<int32_t>> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      Nullable<int32_t>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      Nullable<int32_t>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of return value of TestJSImplInterface.receiveSequenceOfNullableInts", &slot.SetValue())) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveSequenceOfNullableInts");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::ReceiveNullableSequenceOfNullableInts(Nullable<nsTArray<Nullable<int32_t>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableSequenceOfNullableInts", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableSequenceOfNullableInts_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Nullable<Sequence<Nullable<int32_t>>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNullableSequenceOfNullableInts");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<Nullable<int32_t>> &arr = rvalDecl.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      Nullable<int32_t>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      Nullable<int32_t>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of return value of TestJSImplInterface.receiveNullableSequenceOfNullableInts", &slot.SetValue())) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNullableSequenceOfNullableInts");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  if (rvalDecl.IsNull()) {
    aRetVal.SetNull();
  } else {
    aRetVal.SetValue() = std::move(rvalDecl.Value());
  }
}

void
TestJSImplInterfaceJSImpl::PassSequence(const Sequence<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.setInt32(int32_t(arg[sequenceIdx0]));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableSequence(const Nullable<Sequence<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }

    uint32_t length = arg.Value().Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.setInt32(int32_t(arg.Value()[sequenceIdx0]));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassSequenceOfNullableInts(const Sequence<Nullable<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passSequenceOfNullableInts", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (arg[sequenceIdx0].IsNull()) {
            tmp.setNull();
            break;
          }
          tmp.setInt32(int32_t(arg[sequenceIdx0].Value()));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passSequenceOfNullableInts_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalSequenceOfNullableInts(const Optional<Sequence<Nullable<int32_t>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalSequenceOfNullableInts", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {

      uint32_t length = arg.Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (arg.Value()[sequenceIdx0].IsNull()) {
              tmp.setNull();
              break;
            }
            tmp.setInt32(int32_t(arg.Value()[sequenceIdx0].Value()));
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[0].setObject(*returnArray);
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalSequenceOfNullableInts_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableSequenceOfNullableInts(const Optional<Nullable<Sequence<Nullable<int32_t>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableSequenceOfNullableInts", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {

      if (arg.Value().IsNull()) {
        argv[0].setNull();
        break;
      }

      uint32_t length = arg.Value().Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (arg.Value().Value()[sequenceIdx0].IsNull()) {
              tmp.setNull();
              break;
            }
            tmp.setInt32(int32_t(arg.Value().Value()[sequenceIdx0].Value()));
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[0].setObject(*returnArray);
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableSequenceOfNullableInts_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveCastableObjectSequence(nsTArray<RefPtr<TestJSImplInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveCastableObjectSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveCastableObjectSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<RefPtr<mozilla::dom::TestJSImplInterface>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveCastableObjectSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<mozilla::dom::TestJSImplInterface>> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestJSImplInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<mozilla::dom::TestJSImplInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            // Be careful to not wrap random DOM objects here, even if
            // they're wrapped in opaque security wrappers for some reason.
            // XXXbz Wish we could check for a JS-implemented object
            // that already has a content reflection...
            if (!IsDOMObject(js::UncheckedUnwrap(&temp.toObject()))) {
              nsCOMPtr<nsIGlobalObject> contentGlobal;
              JS::Rooted<JSObject*> callback(cx, CallbackOrNull());
              if (!callback ||
                  !GetContentGlobalForJSImplementedObject(cx, callback, getter_AddRefs(contentGlobal))) {
                aRv.Throw(NS_ERROR_UNEXPECTED);
                return;
              }
              JS::Rooted<JSObject*> jsImplSourceObj(cx, &temp.toObject());
              MOZ_RELEASE_ASSERT(!js::IsWrapper(jsImplSourceObj),
                                 "Don't return JS implementations from other compartments");
              JS::Rooted<JSObject*> jsImplSourceGlobal(cx, JS::GetNonCCWObjectGlobal(jsImplSourceObj));
              slot = new mozilla::dom::TestJSImplInterface(jsImplSourceObj, jsImplSourceGlobal, contentGlobal);
            } else {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of return value of TestJSImplInterface.receiveCastableObjectSequence", "TestJSImplInterface");
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestJSImplInterface.receiveCastableObjectSequence");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveCastableObjectSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::ReceiveCallbackObjectSequence(nsTArray<RefPtr<TestCallbackInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveCallbackObjectSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveCallbackObjectSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<RefPtr<TestCallbackInterface>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveCallbackObjectSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<TestCallbackInterface>> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<TestCallbackInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<TestCallbackInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        { // scope for tempRoot and tempGlobalRoot if needed
          JS::Rooted<JSObject*> tempRoot(cx, &temp.toObject());
          JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
          slot = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestJSImplInterface.receiveCallbackObjectSequence");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveCallbackObjectSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::ReceiveNullableCastableObjectSequence(nsTArray<RefPtr<TestJSImplInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableCastableObjectSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableCastableObjectSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<RefPtr<mozilla::dom::TestJSImplInterface>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNullableCastableObjectSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<mozilla::dom::TestJSImplInterface>> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestJSImplInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<mozilla::dom::TestJSImplInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            // Be careful to not wrap random DOM objects here, even if
            // they're wrapped in opaque security wrappers for some reason.
            // XXXbz Wish we could check for a JS-implemented object
            // that already has a content reflection...
            if (!IsDOMObject(js::UncheckedUnwrap(&temp.toObject()))) {
              nsCOMPtr<nsIGlobalObject> contentGlobal;
              JS::Rooted<JSObject*> callback(cx, CallbackOrNull());
              if (!callback ||
                  !GetContentGlobalForJSImplementedObject(cx, callback, getter_AddRefs(contentGlobal))) {
                aRv.Throw(NS_ERROR_UNEXPECTED);
                return;
              }
              JS::Rooted<JSObject*> jsImplSourceObj(cx, &temp.toObject());
              MOZ_RELEASE_ASSERT(!js::IsWrapper(jsImplSourceObj),
                                 "Don't return JS implementations from other compartments");
              JS::Rooted<JSObject*> jsImplSourceGlobal(cx, JS::GetNonCCWObjectGlobal(jsImplSourceObj));
              slot = new mozilla::dom::TestJSImplInterface(jsImplSourceObj, jsImplSourceGlobal, contentGlobal);
            } else {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of return value of TestJSImplInterface.receiveNullableCastableObjectSequence", "TestJSImplInterface");
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestJSImplInterface.receiveNullableCastableObjectSequence");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNullableCastableObjectSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::ReceiveNullableCallbackObjectSequence(nsTArray<RefPtr<TestCallbackInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableCallbackObjectSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableCallbackObjectSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<RefPtr<TestCallbackInterface>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNullableCallbackObjectSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<TestCallbackInterface>> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<TestCallbackInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<TestCallbackInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        { // scope for tempRoot and tempGlobalRoot if needed
          JS::Rooted<JSObject*> tempRoot(cx, &temp.toObject());
          JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
          slot = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestJSImplInterface.receiveNullableCallbackObjectSequence");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNullableCallbackObjectSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::ReceiveCastableObjectNullableSequence(Nullable<nsTArray<RefPtr<TestJSImplInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveCastableObjectNullableSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveCastableObjectNullableSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Nullable<Sequence<RefPtr<mozilla::dom::TestJSImplInterface>>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveCastableObjectNullableSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<mozilla::dom::TestJSImplInterface>> &arr = rvalDecl.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestJSImplInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<mozilla::dom::TestJSImplInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            // Be careful to not wrap random DOM objects here, even if
            // they're wrapped in opaque security wrappers for some reason.
            // XXXbz Wish we could check for a JS-implemented object
            // that already has a content reflection...
            if (!IsDOMObject(js::UncheckedUnwrap(&temp.toObject()))) {
              nsCOMPtr<nsIGlobalObject> contentGlobal;
              JS::Rooted<JSObject*> callback(cx, CallbackOrNull());
              if (!callback ||
                  !GetContentGlobalForJSImplementedObject(cx, callback, getter_AddRefs(contentGlobal))) {
                aRv.Throw(NS_ERROR_UNEXPECTED);
                return;
              }
              JS::Rooted<JSObject*> jsImplSourceObj(cx, &temp.toObject());
              MOZ_RELEASE_ASSERT(!js::IsWrapper(jsImplSourceObj),
                                 "Don't return JS implementations from other compartments");
              JS::Rooted<JSObject*> jsImplSourceGlobal(cx, JS::GetNonCCWObjectGlobal(jsImplSourceObj));
              slot = new mozilla::dom::TestJSImplInterface(jsImplSourceObj, jsImplSourceGlobal, contentGlobal);
            } else {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of return value of TestJSImplInterface.receiveCastableObjectNullableSequence", "TestJSImplInterface");
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestJSImplInterface.receiveCastableObjectNullableSequence");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveCastableObjectNullableSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  if (rvalDecl.IsNull()) {
    aRetVal.SetNull();
  } else {
    aRetVal.SetValue() = std::move(rvalDecl.Value());
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveNullableCastableObjectNullableSequence(Nullable<nsTArray<RefPtr<TestJSImplInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableCastableObjectNullableSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableCastableObjectNullableSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Nullable<Sequence<RefPtr<mozilla::dom::TestJSImplInterface>>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNullableCastableObjectNullableSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<mozilla::dom::TestJSImplInterface>> &arr = rvalDecl.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestJSImplInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<mozilla::dom::TestJSImplInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            // Be careful to not wrap random DOM objects here, even if
            // they're wrapped in opaque security wrappers for some reason.
            // XXXbz Wish we could check for a JS-implemented object
            // that already has a content reflection...
            if (!IsDOMObject(js::UncheckedUnwrap(&temp.toObject()))) {
              nsCOMPtr<nsIGlobalObject> contentGlobal;
              JS::Rooted<JSObject*> callback(cx, CallbackOrNull());
              if (!callback ||
                  !GetContentGlobalForJSImplementedObject(cx, callback, getter_AddRefs(contentGlobal))) {
                aRv.Throw(NS_ERROR_UNEXPECTED);
                return;
              }
              JS::Rooted<JSObject*> jsImplSourceObj(cx, &temp.toObject());
              MOZ_RELEASE_ASSERT(!js::IsWrapper(jsImplSourceObj),
                                 "Don't return JS implementations from other compartments");
              JS::Rooted<JSObject*> jsImplSourceGlobal(cx, JS::GetNonCCWObjectGlobal(jsImplSourceObj));
              slot = new mozilla::dom::TestJSImplInterface(jsImplSourceObj, jsImplSourceGlobal, contentGlobal);
            } else {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of return value of TestJSImplInterface.receiveNullableCastableObjectNullableSequence", "TestJSImplInterface");
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestJSImplInterface.receiveNullableCastableObjectNullableSequence");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNullableCastableObjectNullableSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  if (rvalDecl.IsNull()) {
    aRetVal.SetNull();
  } else {
    aRetVal.SetValue() = std::move(rvalDecl.Value());
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveWeakCastableObjectSequence(nsTArray<RefPtr<TestJSImplInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveWeakCastableObjectSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveWeakCastableObjectSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<RefPtr<mozilla::dom::TestJSImplInterface>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveWeakCastableObjectSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<mozilla::dom::TestJSImplInterface>> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestJSImplInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<mozilla::dom::TestJSImplInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            // Be careful to not wrap random DOM objects here, even if
            // they're wrapped in opaque security wrappers for some reason.
            // XXXbz Wish we could check for a JS-implemented object
            // that already has a content reflection...
            if (!IsDOMObject(js::UncheckedUnwrap(&temp.toObject()))) {
              nsCOMPtr<nsIGlobalObject> contentGlobal;
              JS::Rooted<JSObject*> callback(cx, CallbackOrNull());
              if (!callback ||
                  !GetContentGlobalForJSImplementedObject(cx, callback, getter_AddRefs(contentGlobal))) {
                aRv.Throw(NS_ERROR_UNEXPECTED);
                return;
              }
              JS::Rooted<JSObject*> jsImplSourceObj(cx, &temp.toObject());
              MOZ_RELEASE_ASSERT(!js::IsWrapper(jsImplSourceObj),
                                 "Don't return JS implementations from other compartments");
              JS::Rooted<JSObject*> jsImplSourceGlobal(cx, JS::GetNonCCWObjectGlobal(jsImplSourceObj));
              slot = new mozilla::dom::TestJSImplInterface(jsImplSourceObj, jsImplSourceGlobal, contentGlobal);
            } else {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of return value of TestJSImplInterface.receiveWeakCastableObjectSequence", "TestJSImplInterface");
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestJSImplInterface.receiveWeakCastableObjectSequence");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveWeakCastableObjectSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::ReceiveWeakNullableCastableObjectSequence(nsTArray<RefPtr<TestJSImplInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveWeakNullableCastableObjectSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveWeakNullableCastableObjectSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<RefPtr<mozilla::dom::TestJSImplInterface>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveWeakNullableCastableObjectSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<mozilla::dom::TestJSImplInterface>> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestJSImplInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<mozilla::dom::TestJSImplInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            // Be careful to not wrap random DOM objects here, even if
            // they're wrapped in opaque security wrappers for some reason.
            // XXXbz Wish we could check for a JS-implemented object
            // that already has a content reflection...
            if (!IsDOMObject(js::UncheckedUnwrap(&temp.toObject()))) {
              nsCOMPtr<nsIGlobalObject> contentGlobal;
              JS::Rooted<JSObject*> callback(cx, CallbackOrNull());
              if (!callback ||
                  !GetContentGlobalForJSImplementedObject(cx, callback, getter_AddRefs(contentGlobal))) {
                aRv.Throw(NS_ERROR_UNEXPECTED);
                return;
              }
              JS::Rooted<JSObject*> jsImplSourceObj(cx, &temp.toObject());
              MOZ_RELEASE_ASSERT(!js::IsWrapper(jsImplSourceObj),
                                 "Don't return JS implementations from other compartments");
              JS::Rooted<JSObject*> jsImplSourceGlobal(cx, JS::GetNonCCWObjectGlobal(jsImplSourceObj));
              slot = new mozilla::dom::TestJSImplInterface(jsImplSourceObj, jsImplSourceGlobal, contentGlobal);
            } else {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of return value of TestJSImplInterface.receiveWeakNullableCastableObjectSequence", "TestJSImplInterface");
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestJSImplInterface.receiveWeakNullableCastableObjectSequence");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveWeakNullableCastableObjectSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::ReceiveWeakCastableObjectNullableSequence(Nullable<nsTArray<RefPtr<TestJSImplInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveWeakCastableObjectNullableSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveWeakCastableObjectNullableSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Nullable<Sequence<RefPtr<mozilla::dom::TestJSImplInterface>>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveWeakCastableObjectNullableSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<mozilla::dom::TestJSImplInterface>> &arr = rvalDecl.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestJSImplInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<mozilla::dom::TestJSImplInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            // Be careful to not wrap random DOM objects here, even if
            // they're wrapped in opaque security wrappers for some reason.
            // XXXbz Wish we could check for a JS-implemented object
            // that already has a content reflection...
            if (!IsDOMObject(js::UncheckedUnwrap(&temp.toObject()))) {
              nsCOMPtr<nsIGlobalObject> contentGlobal;
              JS::Rooted<JSObject*> callback(cx, CallbackOrNull());
              if (!callback ||
                  !GetContentGlobalForJSImplementedObject(cx, callback, getter_AddRefs(contentGlobal))) {
                aRv.Throw(NS_ERROR_UNEXPECTED);
                return;
              }
              JS::Rooted<JSObject*> jsImplSourceObj(cx, &temp.toObject());
              MOZ_RELEASE_ASSERT(!js::IsWrapper(jsImplSourceObj),
                                 "Don't return JS implementations from other compartments");
              JS::Rooted<JSObject*> jsImplSourceGlobal(cx, JS::GetNonCCWObjectGlobal(jsImplSourceObj));
              slot = new mozilla::dom::TestJSImplInterface(jsImplSourceObj, jsImplSourceGlobal, contentGlobal);
            } else {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of return value of TestJSImplInterface.receiveWeakCastableObjectNullableSequence", "TestJSImplInterface");
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestJSImplInterface.receiveWeakCastableObjectNullableSequence");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveWeakCastableObjectNullableSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  if (rvalDecl.IsNull()) {
    aRetVal.SetNull();
  } else {
    aRetVal.SetValue() = std::move(rvalDecl.Value());
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveWeakNullableCastableObjectNullableSequence(Nullable<nsTArray<RefPtr<TestJSImplInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveWeakNullableCastableObjectNullableSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveWeakNullableCastableObjectNullableSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Nullable<Sequence<RefPtr<mozilla::dom::TestJSImplInterface>>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveWeakNullableCastableObjectNullableSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<mozilla::dom::TestJSImplInterface>> &arr = rvalDecl.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestJSImplInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<mozilla::dom::TestJSImplInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            // Be careful to not wrap random DOM objects here, even if
            // they're wrapped in opaque security wrappers for some reason.
            // XXXbz Wish we could check for a JS-implemented object
            // that already has a content reflection...
            if (!IsDOMObject(js::UncheckedUnwrap(&temp.toObject()))) {
              nsCOMPtr<nsIGlobalObject> contentGlobal;
              JS::Rooted<JSObject*> callback(cx, CallbackOrNull());
              if (!callback ||
                  !GetContentGlobalForJSImplementedObject(cx, callback, getter_AddRefs(contentGlobal))) {
                aRv.Throw(NS_ERROR_UNEXPECTED);
                return;
              }
              JS::Rooted<JSObject*> jsImplSourceObj(cx, &temp.toObject());
              MOZ_RELEASE_ASSERT(!js::IsWrapper(jsImplSourceObj),
                                 "Don't return JS implementations from other compartments");
              JS::Rooted<JSObject*> jsImplSourceGlobal(cx, JS::GetNonCCWObjectGlobal(jsImplSourceObj));
              slot = new mozilla::dom::TestJSImplInterface(jsImplSourceObj, jsImplSourceGlobal, contentGlobal);
            } else {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of return value of TestJSImplInterface.receiveWeakNullableCastableObjectNullableSequence", "TestJSImplInterface");
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestJSImplInterface.receiveWeakNullableCastableObjectNullableSequence");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveWeakNullableCastableObjectNullableSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  if (rvalDecl.IsNull()) {
    aRetVal.SetNull();
  } else {
    aRetVal.SetValue() = std::move(rvalDecl.Value());
  }
}

void
TestJSImplInterfaceJSImpl::PassCastableObjectSequence(const Sequence<OwningNonNull<TestJSImplInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passCastableObjectSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!GetOrCreateDOMReflector(cx, arg[sequenceIdx0], &tmp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passCastableObjectSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableCastableObjectSequence(const Sequence<RefPtr<TestJSImplInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableCastableObjectSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!arg[sequenceIdx0]) {
            tmp.setNull();
            break;
          }
          if (!GetOrCreateDOMReflector(cx, arg[sequenceIdx0], &tmp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableCastableObjectSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassCastableObjectNullableSequence(const Nullable<Sequence<OwningNonNull<TestJSImplInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passCastableObjectNullableSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }

    uint32_t length = arg.Value().Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!GetOrCreateDOMReflector(cx, arg.Value()[sequenceIdx0], &tmp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passCastableObjectNullableSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableCastableObjectNullableSequence(const Nullable<Sequence<RefPtr<TestJSImplInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableCastableObjectNullableSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }

    uint32_t length = arg.Value().Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!arg.Value()[sequenceIdx0]) {
            tmp.setNull();
            break;
          }
          if (!GetOrCreateDOMReflector(cx, arg.Value()[sequenceIdx0], &tmp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableCastableObjectNullableSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalSequence(const Optional<Sequence<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {

      uint32_t length = arg.Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            tmp.setInt32(int32_t(arg.Value()[sequenceIdx0]));
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[0].setObject(*returnArray);
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalSequenceWithDefaultValue(const Sequence<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalSequenceWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.setInt32(int32_t(arg[sequenceIdx0]));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalSequenceWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableSequence(const Optional<Nullable<Sequence<int32_t>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {

      if (arg.Value().IsNull()) {
        argv[0].setNull();
        break;
      }

      uint32_t length = arg.Value().Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            tmp.setInt32(int32_t(arg.Value().Value()[sequenceIdx0]));
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[0].setObject(*returnArray);
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableSequenceWithDefaultValue(const Nullable<Sequence<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableSequenceWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }

    uint32_t length = arg.Value().Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.setInt32(int32_t(arg.Value()[sequenceIdx0]));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableSequenceWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableSequenceWithDefaultValue2(const Nullable<Sequence<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableSequenceWithDefaultValue2", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }

    uint32_t length = arg.Value().Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.setInt32(int32_t(arg.Value()[sequenceIdx0]));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableSequenceWithDefaultValue2_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalObjectSequence(const Optional<Sequence<OwningNonNull<TestJSImplInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalObjectSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {

      uint32_t length = arg.Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (!GetOrCreateDOMReflector(cx, arg.Value()[sequenceIdx0], &tmp)) {
              MOZ_ASSERT(JS_IsExceptionPending(cx));
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[0].setObject(*returnArray);
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalObjectSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassExternalInterfaceSequence(const Sequence<RefPtr<TestExternalInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passExternalInterfaceSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!WrapObject(cx, arg[sequenceIdx0], &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passExternalInterfaceSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableExternalInterfaceSequence(const Sequence<RefPtr<TestExternalInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableExternalInterfaceSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!arg[sequenceIdx0]) {
            tmp.setNull();
            break;
          }
          if (!WrapObject(cx, arg[sequenceIdx0], &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableExternalInterfaceSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveStringSequence(nsTArray<nsString>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveStringSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveStringSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<nsString> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveStringSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<nsString> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      nsString* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      nsString& slot = *slotPtr;
      if (!ConvertJSValueToString(cx, temp, eStringify, eStringify, slot)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveStringSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::ReceiveByteStringSequence(nsTArray<nsCString>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveByteStringSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveByteStringSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<nsCString> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveByteStringSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<nsCString> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      nsCString* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      nsCString& slot = *slotPtr;
      if (!ConvertJSValueToByteString(cx, temp, false, "element of return value of TestJSImplInterface.receiveByteStringSequence", slot)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveByteStringSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::ReceiveUTF8StringSequence(nsTArray<nsCString>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveUTF8StringSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveUTF8StringSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<nsCString> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveUTF8StringSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<nsCString> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      nsCString* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      nsCString& slot = *slotPtr;
      if (!ConvertJSValueToString(cx, temp, eStringify, eStringify, slot)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveUTF8StringSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::ReceiveAnySequence(nsTArray<JS::Value>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveAnySequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveAnySequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<JS::Value> rvalDecl;
  SequenceRooter<JS::Value> rvalHolder(cx, &rvalDecl);
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveAnySequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<JS::Value> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      JS::Value& slot = *slotPtr;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
      if ((false) && !CallerSubsumes(temp)) {
        cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of return value of TestJSImplInterface.receiveAnySequence");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
      slot = temp;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveAnySequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::ReceiveNullableAnySequence(Nullable<nsTArray<JS::Value>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableAnySequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableAnySequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Nullable<Sequence<JS::Value>> rvalDecl;
  SequenceRooter<JS::Value> rvalHolder(cx, &rvalDecl.SetValue());
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNullableAnySequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<JS::Value> &arr = rvalDecl.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      JS::Value& slot = *slotPtr;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
      if ((false) && !CallerSubsumes(temp)) {
        cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of return value of TestJSImplInterface.receiveNullableAnySequence");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
      slot = temp;
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNullableAnySequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  if (rvalDecl.IsNull()) {
    aRetVal.SetNull();
  } else {
    aRetVal.SetValue() = std::move(rvalDecl.Value());
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveObjectSequence(nsTArray<JSObject*>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveObjectSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveObjectSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<JSObject*> rvalDecl;
  SequenceRooter<JSObject*> rvalHolder(cx, &rvalDecl);
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveObjectSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<JSObject*> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      JSObject** slotPtr = arr.AppendElement(nullptr, mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      JSObject*& slot = *slotPtr;
      if (temp.isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
        if ((false) && !CallerSubsumes(temp)) {
          cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of return value of TestJSImplInterface.receiveObjectSequence");
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
        slot = &temp.toObject();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestJSImplInterface.receiveObjectSequence");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveObjectSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::ReceiveNullableObjectSequence(nsTArray<JSObject*>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableObjectSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableObjectSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<JSObject*> rvalDecl;
  SequenceRooter<JSObject*> rvalHolder(cx, &rvalDecl);
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNullableObjectSequence");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<JSObject*> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      JSObject** slotPtr = arr.AppendElement(nullptr, mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      JSObject*& slot = *slotPtr;
      if (temp.isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
        if ((false) && !CallerSubsumes(temp)) {
          cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("element of return value of TestJSImplInterface.receiveNullableObjectSequence");
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
        slot = &temp.toObject();
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of return value of TestJSImplInterface.receiveNullableObjectSequence");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Return value of TestJSImplInterface.receiveNullableObjectSequence");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = std::move(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::PassSequenceOfSequences(const Sequence<Sequence<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passSequenceOfSequences", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {

          uint32_t length = arg[sequenceIdx0].Length();
          JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
          if (!returnArray) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          // Scope for 'tmp'
          {
            JS::Rooted<JS::Value> tmp(cx);
            for (uint32_t sequenceIdx1 = 0; sequenceIdx1 < length; ++sequenceIdx1) {
              // Control block to let us common up the JS_DefineElement calls when there
              // are different ways to succeed at wrapping the object.
              do {
                tmp.setInt32(int32_t(arg[sequenceIdx0][sequenceIdx1]));
                break;
              } while (false);
              if (!JS_DefineElement(cx, returnArray, sequenceIdx1, tmp,
                                    JSPROP_ENUMERATE)) {
                aRv.Throw(NS_ERROR_UNEXPECTED);
                return;
              }
            }
          }
          tmp.setObject(*returnArray);
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passSequenceOfSequences_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassSequenceOfSequencesOfSequences(const Sequence<Sequence<Sequence<int32_t>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passSequenceOfSequencesOfSequences", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {

          uint32_t length = arg[sequenceIdx0].Length();
          JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
          if (!returnArray) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          // Scope for 'tmp'
          {
            JS::Rooted<JS::Value> tmp(cx);
            for (uint32_t sequenceIdx1 = 0; sequenceIdx1 < length; ++sequenceIdx1) {
              // Control block to let us common up the JS_DefineElement calls when there
              // are different ways to succeed at wrapping the object.
              do {

                uint32_t length = arg[sequenceIdx0][sequenceIdx1].Length();
                JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
                if (!returnArray) {
                  aRv.Throw(NS_ERROR_UNEXPECTED);
                  return;
                }
                // Scope for 'tmp'
                {
                  JS::Rooted<JS::Value> tmp(cx);
                  for (uint32_t sequenceIdx2 = 0; sequenceIdx2 < length; ++sequenceIdx2) {
                    // Control block to let us common up the JS_DefineElement calls when there
                    // are different ways to succeed at wrapping the object.
                    do {
                      tmp.setInt32(int32_t(arg[sequenceIdx0][sequenceIdx1][sequenceIdx2]));
                      break;
                    } while (false);
                    if (!JS_DefineElement(cx, returnArray, sequenceIdx2, tmp,
                                          JSPROP_ENUMERATE)) {
                      aRv.Throw(NS_ERROR_UNEXPECTED);
                      return;
                    }
                  }
                }
                tmp.setObject(*returnArray);
                break;
              } while (false);
              if (!JS_DefineElement(cx, returnArray, sequenceIdx1, tmp,
                                    JSPROP_ENUMERATE)) {
                aRv.Throw(NS_ERROR_UNEXPECTED);
                return;
              }
            }
          }
          tmp.setObject(*returnArray);
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passSequenceOfSequencesOfSequences_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassRecord(const Record<nsString, int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passRecord", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          tmp.setInt32(int32_t(recordValue0));
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passRecord_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableRecord(const Nullable<Record<nsString, int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableRecord", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Value().Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          tmp.setInt32(int32_t(recordValue0));
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableRecord_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassRecordOfNullableInts(const Record<nsString, Nullable<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passRecordOfNullableInts", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          if (recordValue0.IsNull()) {
            tmp.setNull();
            break;
          }
          tmp.setInt32(int32_t(recordValue0.Value()));
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passRecordOfNullableInts_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalRecordOfNullableInts(const Optional<Record<nsString, Nullable<int32_t>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalRecordOfNullableInts", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {

      JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
      if (!returnObj) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (auto& entry : arg.Value().Entries()) {
          auto& recordValue0 = entry.mValue;
          // Control block to let us common up the JS_DefineUCProperty calls when there
          // are different ways to succeed at wrapping the value.
          do {
            if (recordValue0.IsNull()) {
              tmp.setNull();
              break;
            }
            tmp.setInt32(int32_t(recordValue0.Value()));
            break;
          } while (false);
          if (!JS_DefineUCProperty(cx, returnObj,
                                   entry.mKey.BeginReading(),
                                   entry.mKey.Length(), tmp,
                                   JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[0].setObject(*returnObj);
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalRecordOfNullableInts_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableRecordOfNullableInts(const Optional<Nullable<Record<nsString, Nullable<int32_t>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableRecordOfNullableInts", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {

      if (arg.Value().IsNull()) {
        argv[0].setNull();
        break;
      }

      JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
      if (!returnObj) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (auto& entry : arg.Value().Value().Entries()) {
          auto& recordValue0 = entry.mValue;
          // Control block to let us common up the JS_DefineUCProperty calls when there
          // are different ways to succeed at wrapping the value.
          do {
            if (recordValue0.IsNull()) {
              tmp.setNull();
              break;
            }
            tmp.setInt32(int32_t(recordValue0.Value()));
            break;
          } while (false);
          if (!JS_DefineUCProperty(cx, returnObj,
                                   entry.mKey.BeginReading(),
                                   entry.mKey.Length(), tmp,
                                   JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[0].setObject(*returnObj);
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableRecordOfNullableInts_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassCastableObjectRecord(const Record<nsString, OwningNonNull<TestInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passCastableObjectRecord", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          if (!GetOrCreateDOMReflector(cx, recordValue0, &tmp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passCastableObjectRecord_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableCastableObjectRecord(const Record<nsString, RefPtr<TestInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableCastableObjectRecord", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          if (!recordValue0) {
            tmp.setNull();
            break;
          }
          if (!GetOrCreateDOMReflector(cx, recordValue0, &tmp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableCastableObjectRecord_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassCastableObjectNullableRecord(const Nullable<Record<nsString, OwningNonNull<TestInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passCastableObjectNullableRecord", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Value().Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          if (!GetOrCreateDOMReflector(cx, recordValue0, &tmp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passCastableObjectNullableRecord_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableCastableObjectNullableRecord(const Nullable<Record<nsString, RefPtr<TestInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableCastableObjectNullableRecord", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Value().Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          if (!recordValue0) {
            tmp.setNull();
            break;
          }
          if (!GetOrCreateDOMReflector(cx, recordValue0, &tmp)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableCastableObjectNullableRecord_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalRecord(const Optional<Record<nsString, int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalRecord", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {

      JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
      if (!returnObj) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (auto& entry : arg.Value().Entries()) {
          auto& recordValue0 = entry.mValue;
          // Control block to let us common up the JS_DefineUCProperty calls when there
          // are different ways to succeed at wrapping the value.
          do {
            tmp.setInt32(int32_t(recordValue0));
            break;
          } while (false);
          if (!JS_DefineUCProperty(cx, returnObj,
                                   entry.mKey.BeginReading(),
                                   entry.mKey.Length(), tmp,
                                   JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[0].setObject(*returnObj);
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalRecord_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableRecord(const Optional<Nullable<Record<nsString, int32_t>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableRecord", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {

      if (arg.Value().IsNull()) {
        argv[0].setNull();
        break;
      }

      JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
      if (!returnObj) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (auto& entry : arg.Value().Value().Entries()) {
          auto& recordValue0 = entry.mValue;
          // Control block to let us common up the JS_DefineUCProperty calls when there
          // are different ways to succeed at wrapping the value.
          do {
            tmp.setInt32(int32_t(recordValue0));
            break;
          } while (false);
          if (!JS_DefineUCProperty(cx, returnObj,
                                   entry.mKey.BeginReading(),
                                   entry.mKey.Length(), tmp,
                                   JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[0].setObject(*returnObj);
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableRecord_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableRecordWithDefaultValue(const Nullable<Record<nsString, int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableRecordWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Value().Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          tmp.setInt32(int32_t(recordValue0));
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableRecordWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalObjectRecord(const Optional<Record<nsString, OwningNonNull<TestInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalObjectRecord", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {

      JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
      if (!returnObj) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (auto& entry : arg.Value().Entries()) {
          auto& recordValue0 = entry.mValue;
          // Control block to let us common up the JS_DefineUCProperty calls when there
          // are different ways to succeed at wrapping the value.
          do {
            if (!GetOrCreateDOMReflector(cx, recordValue0, &tmp)) {
              MOZ_ASSERT(JS_IsExceptionPending(cx));
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
            break;
          } while (false);
          if (!JS_DefineUCProperty(cx, returnObj,
                                   entry.mKey.BeginReading(),
                                   entry.mKey.Length(), tmp,
                                   JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[0].setObject(*returnObj);
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalObjectRecord_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassExternalInterfaceRecord(const Record<nsString, RefPtr<TestExternalInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passExternalInterfaceRecord", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          if (!WrapObject(cx, recordValue0, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passExternalInterfaceRecord_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableExternalInterfaceRecord(const Record<nsString, RefPtr<TestExternalInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableExternalInterfaceRecord", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          if (!recordValue0) {
            tmp.setNull();
            break;
          }
          if (!WrapObject(cx, recordValue0, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableExternalInterfaceRecord_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassStringRecord(const Record<nsString, nsString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passStringRecord", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          if (!xpc::NonVoidStringToJsval(cx, recordValue0, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passStringRecord_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassByteStringRecord(const Record<nsString, nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passByteStringRecord", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          if (!NonVoidByteStringToJsval(cx, recordValue0, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passByteStringRecord_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUTF8StringRecord(const Record<nsString, nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUTF8StringRecord", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          if (!NonVoidUTF8StringToJsval(cx, recordValue0, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUTF8StringRecord_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassRecordOfRecords(const Record<nsString, Record<nsString, int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passRecordOfRecords", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {

          JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
          if (!returnObj) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          // Scope for 'tmp'
          {
            JS::Rooted<JS::Value> tmp(cx);
            for (auto& entry : recordValue0.Entries()) {
              auto& recordValue1 = entry.mValue;
              // Control block to let us common up the JS_DefineUCProperty calls when there
              // are different ways to succeed at wrapping the value.
              do {
                tmp.setInt32(int32_t(recordValue1));
                break;
              } while (false);
              if (!JS_DefineUCProperty(cx, returnObj,
                                       entry.mKey.BeginReading(),
                                       entry.mKey.Length(), tmp,
                                       JSPROP_ENUMERATE)) {
                aRv.Throw(NS_ERROR_UNEXPECTED);
                return;
              }
            }
          }
          tmp.setObject(*returnObj);
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passRecordOfRecords_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveRecord(Record<nsString, int32_t>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveRecord", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveRecord_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Record<nsString, int32_t>& rvalDecl(aRetVal);
  if (rval.isObject()) {
    auto& recordEntries = rvalDecl.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &rval.toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of return value of TestJSImplInterface.receiveRecord", propName)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }

      Record<nsString, int32_t>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      int32_t& slot = entry->mValue;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in return value of TestJSImplInterface.receiveRecord", &slot)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveRecord");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveNullableRecord(Nullable<Record<nsString, int32_t>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableRecord", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableRecord_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Nullable<Record<nsString, int32_t>>& rvalDecl(aRetVal);
  if (rval.isObject()) {
    auto& recordEntries = rvalDecl.SetValue().Entries();

    JS::Rooted<JSObject*> recordObj(cx, &rval.toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of return value of TestJSImplInterface.receiveNullableRecord", propName)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }

      Record<nsString, int32_t>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      int32_t& slot = entry->mValue;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in return value of TestJSImplInterface.receiveNullableRecord", &slot)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveNullableRecord");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveRecordOfNullableInts(Record<nsString, Nullable<int32_t>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveRecordOfNullableInts", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveRecordOfNullableInts_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Record<nsString, Nullable<int32_t>>& rvalDecl(aRetVal);
  if (rval.isObject()) {
    auto& recordEntries = rvalDecl.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &rval.toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of return value of TestJSImplInterface.receiveRecordOfNullableInts", propName)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }

      Record<nsString, Nullable<int32_t>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Nullable<int32_t>& slot = entry->mValue;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in return value of TestJSImplInterface.receiveRecordOfNullableInts", &slot.SetValue())) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveRecordOfNullableInts");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveNullableRecordOfNullableInts(Nullable<Record<nsString, Nullable<int32_t>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableRecordOfNullableInts", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableRecordOfNullableInts_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Nullable<Record<nsString, Nullable<int32_t>>>& rvalDecl(aRetVal);
  if (rval.isObject()) {
    auto& recordEntries = rvalDecl.SetValue().Entries();

    JS::Rooted<JSObject*> recordObj(cx, &rval.toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of return value of TestJSImplInterface.receiveNullableRecordOfNullableInts", propName)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }

      Record<nsString, Nullable<int32_t>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Nullable<int32_t>& slot = entry->mValue;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in return value of TestJSImplInterface.receiveNullableRecordOfNullableInts", &slot.SetValue())) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveNullableRecordOfNullableInts");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveAnyRecord(Record<nsString, JS::Value>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveAnyRecord", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveAnyRecord_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Record<nsString, JS::Value>& rvalDecl(aRetVal);
  if (rval.isObject()) {
    auto& recordEntries = rvalDecl.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &rval.toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of return value of TestJSImplInterface.receiveAnyRecord", propName)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }

      Record<nsString, JS::Value>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      JS::Value& slot = entry->mValue;
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
      if ((false) && !CallerSubsumes(temp)) {
        cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("value in return value of TestJSImplInterface.receiveAnyRecord");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
      slot = temp;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveAnyRecord");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassArrayBuffer(const ArrayBuffer& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passArrayBuffer", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setObject(*arg.Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passArrayBuffer_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableArrayBuffer(const Nullable<ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableArrayBuffer", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    argv[0].setObject(*arg.Value().Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableArrayBuffer_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalArrayBuffer(const Optional<ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalArrayBuffer", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      argv[0].setObject(*arg.Value().Obj());
      if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalArrayBuffer_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableArrayBuffer(const Optional<Nullable<ArrayBuffer>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableArrayBuffer", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (arg.Value().IsNull()) {
        argv[0].setNull();
        break;
      }
      argv[0].setObject(*arg.Value().Value().Obj());
      if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableArrayBuffer_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableArrayBufferWithDefaultValue(const Nullable<ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableArrayBufferWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    argv[0].setObject(*arg.Value().Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableArrayBufferWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassArrayBufferView(const ArrayBufferView& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passArrayBufferView", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setObject(*arg.Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passArrayBufferView_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassInt8Array(const Int8Array& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passInt8Array", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setObject(*arg.Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passInt8Array_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassInt16Array(const Int16Array& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passInt16Array", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setObject(*arg.Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passInt16Array_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassInt32Array(const Int32Array& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passInt32Array", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setObject(*arg.Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passInt32Array_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUint8Array(const Uint8Array& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUint8Array", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setObject(*arg.Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUint8Array_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUint16Array(const Uint16Array& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUint16Array", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setObject(*arg.Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUint16Array_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUint32Array(const Uint32Array& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUint32Array", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setObject(*arg.Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUint32Array_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUint8ClampedArray(const Uint8ClampedArray& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUint8ClampedArray", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setObject(*arg.Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUint8ClampedArray_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassFloat32Array(const Float32Array& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passFloat32Array", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setObject(*arg.Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passFloat32Array_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassFloat64Array(const Float64Array& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passFloat64Array", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setObject(*arg.Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passFloat64Array_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassSequenceOfArrayBuffers(const Sequence<ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passSequenceOfArrayBuffers", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.setObject(*arg[sequenceIdx0].Obj());
          if (!MaybeWrapNonDOMObjectValue(cx, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passSequenceOfArrayBuffers_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassSequenceOfNullableArrayBuffers(const Sequence<Nullable<ArrayBuffer>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passSequenceOfNullableArrayBuffers", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (arg[sequenceIdx0].IsNull()) {
            tmp.setNull();
            break;
          }
          tmp.setObject(*arg[sequenceIdx0].Value().Obj());
          if (!MaybeWrapNonDOMObjectValue(cx, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passSequenceOfNullableArrayBuffers_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassRecordOfArrayBuffers(const Record<nsString, ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passRecordOfArrayBuffers", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          tmp.setObject(*recordValue0.Obj());
          if (!MaybeWrapNonDOMObjectValue(cx, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passRecordOfArrayBuffers_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassRecordOfNullableArrayBuffers(const Record<nsString, Nullable<ArrayBuffer>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passRecordOfNullableArrayBuffers", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          if (recordValue0.IsNull()) {
            tmp.setNull();
            break;
          }
          tmp.setObject(*recordValue0.Value().Obj());
          if (!MaybeWrapNonDOMObjectValue(cx, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passRecordOfNullableArrayBuffers_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassVariadicTypedArray(const nsTArray<Float32Array>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passVariadicTypedArray", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize((1 - 1) + arg.Length())) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = (1 - 1) + arg.Length();

  do {
    for (uint32_t idx = 0; idx < arg.Length(); ++idx) {
      argv[0 + idx].setObject(*arg[idx].Obj());
      if (!MaybeWrapNonDOMObjectValue(cx, argv[0 + idx])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      continue;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passVariadicTypedArray_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassVariadicNullableTypedArray(const nsTArray<Nullable<Float32Array>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passVariadicNullableTypedArray", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize((1 - 1) + arg.Length())) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = (1 - 1) + arg.Length();

  do {
    for (uint32_t idx = 0; idx < arg.Length(); ++idx) {
      if (arg[idx].IsNull()) {
        argv[0 + idx].setNull();
        continue;
      }
      argv[0 + idx].setObject(*arg[idx].Value().Obj());
      if (!MaybeWrapNonDOMObjectValue(cx, argv[0 + idx])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      continue;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passVariadicNullableTypedArray_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveUint8Array(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveUint8Array", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveUint8Array_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  RootedSpiderMonkeyInterface<Uint8Array> rvalDecl(cx);
  if (rval.isObject()) {
    if (!rvalDecl.Init(&rval.toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.receiveUint8Array", "Uint8Array");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (JS::IsArrayBufferViewShared(rvalDecl.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Return value of TestJSImplInterface.receiveUint8Array");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (JS::IsLargeArrayBufferView(rvalDecl.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Return value of TestJSImplInterface.receiveUint8Array");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveUint8Array");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.set(rvalDecl.Obj());
}

void
TestJSImplInterfaceJSImpl::PassString(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passString", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    nsString mutableStr(arg);
    if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passString_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableString(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableString", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    nsString mutableStr(arg);
    if (!xpc::StringToJsval(cx, mutableStr, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableString_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalString(const Optional<nsAString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalString", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      nsString mutableStr(arg.Value());
      if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalString_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalStringWithDefaultValue(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalStringWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    nsString mutableStr(arg);
    if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalStringWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableString(const Optional<nsAString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableString", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      nsString mutableStr(arg.Value());
      if (!xpc::StringToJsval(cx, mutableStr, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableString_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableStringWithDefaultValue(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableStringWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    nsString mutableStr(arg);
    if (!xpc::StringToJsval(cx, mutableStr, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableStringWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassVariadicString(const nsTArray<nsString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passVariadicString", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize((1 - 1) + arg.Length())) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = (1 - 1) + arg.Length();

  do {
    for (uint32_t idx = 0; idx < arg.Length(); ++idx) {
      nsString mutableStr(arg[idx]);
      if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[0 + idx])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      continue;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passVariadicString_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassByteString(const nsCString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passByteString", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!NonVoidByteStringToJsval(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passByteString_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableByteString(const nsCString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableByteString", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!ByteStringToJsval(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableByteString_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalByteString(const Optional<nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalByteString", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (!NonVoidByteStringToJsval(cx, arg.Value(), argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalByteString_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalByteStringWithDefaultValue(const nsCString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalByteStringWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!NonVoidByteStringToJsval(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalByteStringWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableByteString(const Optional<nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableByteString", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (!ByteStringToJsval(cx, arg.Value(), argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableByteString_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableByteStringWithDefaultValue(const nsCString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableByteStringWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!ByteStringToJsval(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableByteStringWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassVariadicByteString(const nsTArray<nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passVariadicByteString", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize((1 - 1) + arg.Length())) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = (1 - 1) + arg.Length();

  do {
    for (uint32_t idx = 0; idx < arg.Length(); ++idx) {
      if (!NonVoidByteStringToJsval(cx, arg[idx], argv[0 + idx])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      continue;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passVariadicByteString_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionByteString(const ByteStringOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionByteString", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionByteString_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalUnionByteString(const Optional<ByteStringOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalUnionByteString", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
      if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalUnionByteString_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalUnionByteStringWithDefaultValue(const ByteStringOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalUnionByteStringWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalUnionByteStringWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUTF8String(const nsACString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUTF8String", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!NonVoidUTF8StringToJsval(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUTF8String_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUTF8String(const nsACString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUTF8String", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!UTF8StringToJsval(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUTF8String_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalUTF8String(const Optional<nsACString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalUTF8String", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (!NonVoidUTF8StringToJsval(cx, arg.Value(), argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalUTF8String_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalUTF8StringWithDefaultValue(const nsACString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalUTF8StringWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!NonVoidUTF8StringToJsval(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalUTF8StringWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableUTF8String(const Optional<nsACString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableUTF8String", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (!UTF8StringToJsval(cx, arg.Value(), argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableUTF8String_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableUTF8StringWithDefaultValue(const nsACString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableUTF8StringWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!UTF8StringToJsval(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableUTF8StringWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassVariadicUTF8String(const nsTArray<nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passVariadicUTF8String", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize((1 - 1) + arg.Length())) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = (1 - 1) + arg.Length();

  do {
    for (uint32_t idx = 0; idx < arg.Length(); ++idx) {
      if (!NonVoidUTF8StringToJsval(cx, arg[idx], argv[0 + idx])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      continue;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passVariadicUTF8String_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionUTF8String(const UTF8StringOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionUTF8String", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionUTF8String_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalUnionUTF8String(const Optional<UTF8StringOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalUnionUTF8String", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
      if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalUnionUTF8String_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalUnionUTF8StringWithDefaultValue(const UTF8StringOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalUnionUTF8StringWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalUnionUTF8StringWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassSVS(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passSVS", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!xpc::NonVoidStringToJsval(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passSVS_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableSVS(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableSVS", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!xpc::StringToJsval(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableSVS_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalSVS(const Optional<nsAString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalSVS", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (!xpc::NonVoidStringToJsval(cx, arg.Value(), argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalSVS_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalSVSWithDefaultValue(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalSVSWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!xpc::NonVoidStringToJsval(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalSVSWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableSVS(const Optional<nsAString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableSVS", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (!xpc::StringToJsval(cx, arg.Value(), argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableSVS_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableSVSWithDefaultValue(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableSVSWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!xpc::StringToJsval(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableSVSWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassVariadicSVS(const nsTArray<nsString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passVariadicSVS", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize((1 - 1) + arg.Length())) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = (1 - 1) + arg.Length();

  do {
    for (uint32_t idx = 0; idx < arg.Length(); ++idx) {
      if (!xpc::NonVoidStringToJsval(cx, arg[idx], argv[0 + idx])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      continue;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passVariadicSVS_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveSVS(nsString& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveSVS", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveSVS_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  binding_detail::FakeString<char16_t> rvalDecl;
  if (!ConvertJSValueToString(cx, rval, eStringify, eStringify, rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  if (!NormalizeUSVString(rvalDecl)) {
    JS_ReportOutOfMemory(cx);
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = rvalDecl;
}

void
TestJSImplInterfaceJSImpl::PassJSString(JS::Handle<JSString*> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passJSString", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setString(arg);
    if (!MaybeWrapStringValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passJSString_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalJSStringWithDefaultValue(JS::Handle<JSString*> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalJSStringWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setString(arg);
    if (!MaybeWrapStringValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalJSStringWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveJSString(JS::MutableHandle<JSString*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveJSString", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveJSString_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  JS::Rooted<JSString*> rvalDecl(cx);
  if (!(rvalDecl = ConvertJSValueToJSString(cx, rval))) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.set(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::PassEnum(MyTestEnum arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passEnum", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!ToJSValue(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passEnum_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableEnum(const Nullable<MyTestEnum>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableEnum", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    } else {
      if (!ToJSValue(cx, arg.Value(), argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableEnum_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalEnum(const Optional<MyTestEnum>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalEnum", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (!ToJSValue(cx, arg.Value(), argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalEnum_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassEnumWithDefault(MyTestEnum arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passEnumWithDefault", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!ToJSValue(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passEnumWithDefault_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableEnum(const Optional<Nullable<MyTestEnum>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableEnum", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (arg.Value().IsNull()) {
        argv[0].setNull();
        break;
      } else {
        if (!ToJSValue(cx, arg.Value().Value(), argv[0])) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
        break;
      }
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableEnum_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableEnumWithDefaultValue(const Nullable<MyTestEnum>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableEnumWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    } else {
      if (!ToJSValue(cx, arg.Value(), argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableEnumWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableEnumWithDefaultValue2(const Nullable<MyTestEnum>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableEnumWithDefaultValue2", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    } else {
      if (!ToJSValue(cx, arg.Value(), argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableEnumWithDefaultValue2_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

MyTestEnum
TestJSImplInterfaceJSImpl::ReceiveEnum(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveEnum", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return MyTestEnum(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveEnum_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return MyTestEnum(0);
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return MyTestEnum(0);
  }
  MyTestEnum rvalDecl;
  {
    int index;
    if (!FindEnumStringIndex<true>(cx, rval, MyTestEnumValues::strings, "MyTestEnum", "return value of TestJSImplInterface.receiveEnum", &index)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return MyTestEnum(0);
    }
    MOZ_ASSERT(index >= 0);
    rvalDecl = static_cast<MyTestEnum>(index);
  }
  return rvalDecl;
}

Nullable<MyTestEnum>
TestJSImplInterfaceJSImpl::ReceiveNullableEnum(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableEnum", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return Nullable<MyTestEnum>();
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableEnum_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return Nullable<MyTestEnum>();
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return Nullable<MyTestEnum>();
  }
  Nullable<MyTestEnum> rvalDecl;
  if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    {
      int index;
      if (!FindEnumStringIndex<true>(cx, rval, MyTestEnumValues::strings, "MyTestEnum", "return value of TestJSImplInterface.receiveNullableEnum", &index)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return Nullable<MyTestEnum>();
      }
      MOZ_ASSERT(index >= 0);
      rvalDecl.SetValue() = static_cast<MyTestEnum>(index);
    }
  }
  return rvalDecl;
}

void
TestJSImplInterfaceJSImpl::PassCallback(MyTestCallback& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passCallback", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setObjectOrNull(GetCallbackFromCallbackObject(cx, arg));
    if (!MaybeWrapObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passCallback_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableCallback(MyTestCallback* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableCallback", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg) {
      argv[0].setObjectOrNull(GetCallbackFromCallbackObject(cx, arg));
      if (!MaybeWrapObjectOrNullValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else {
      argv[0].setNull();
      break;
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableCallback_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalCallback(const Optional<OwningNonNull<MyTestCallback>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalCallback", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      argv[0].setObjectOrNull(GetCallbackFromCallbackObject(cx, arg.Value()));
      if (!MaybeWrapObjectValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalCallback_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableCallback(const Optional<RefPtr<MyTestCallback>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableCallback", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (arg.Value()) {
        argv[0].setObjectOrNull(GetCallbackFromCallbackObject(cx, arg.Value()));
        if (!MaybeWrapObjectOrNullValue(cx, argv[0])) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
        break;
      } else {
        argv[0].setNull();
        break;
      }
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableCallback_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableCallbackWithDefaultValue(MyTestCallback* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableCallbackWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg) {
      argv[0].setObjectOrNull(GetCallbackFromCallbackObject(cx, arg));
      if (!MaybeWrapObjectOrNullValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else {
      argv[0].setNull();
      break;
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableCallbackWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

already_AddRefed<MyTestCallback>
TestJSImplInterfaceJSImpl::ReceiveCallback(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveCallback", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveCallback_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<MyTestCallback> rvalDecl;
  if (rval.isObject()) {
    if (JS::IsCallable(&rval.toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
      JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
      rvalDecl = new MyTestCallback(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Return value of TestJSImplInterface.receiveCallback");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveCallback");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<MyTestCallback>
TestJSImplInterfaceJSImpl::ReceiveNullableCallback(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableCallback", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableCallback_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<MyTestCallback> rvalDecl;
  if (rval.isObject()) {
    if (JS::IsCallable(&rval.toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
      JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
      rvalDecl = new MyTestCallback(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Return value of TestJSImplInterface.receiveNullableCallback");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveNullableCallback");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableTreatAsNullCallbackWithDefaultValue(TestTreatAsNullCallback* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableTreatAsNullCallbackWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg) {
      argv[0].setObjectOrNull(GetCallbackFromCallbackObject(cx, arg));
      if (!MaybeWrapObjectOrNullValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else {
      argv[0].setNull();
      break;
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableTreatAsNullCallbackWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassAny(JS::Handle<JS::Value> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::ExposeValueToActiveJS(arg);
    argv[0].set(arg);
    if (!MaybeWrapValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassVariadicAny(const nsTArray<JS::Value>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passVariadicAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize((1 - 1) + arg.Length())) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = (1 - 1) + arg.Length();

  do {
    for (uint32_t idx = 0; idx < arg.Length(); ++idx) {
      JS::ExposeValueToActiveJS(arg[idx]);
      argv[0 + idx].set(arg[idx]);
      if (!MaybeWrapValue(cx, argv[0 + idx])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      continue;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passVariadicAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalAny(JS::Handle<JS::Value> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::ExposeValueToActiveJS(arg);
    argv[0].set(arg);
    if (!MaybeWrapValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassAnyDefaultNull(JS::Handle<JS::Value> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passAnyDefaultNull", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::ExposeValueToActiveJS(arg);
    argv[0].set(arg);
    if (!MaybeWrapValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passAnyDefaultNull_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassSequenceOfAny(const Sequence<JS::Value>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passSequenceOfAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          JS::ExposeValueToActiveJS(arg[sequenceIdx0]);
          tmp.set(arg[sequenceIdx0]);
          if (!MaybeWrapValue(cx, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passSequenceOfAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableSequenceOfAny(const Nullable<Sequence<JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableSequenceOfAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }

    uint32_t length = arg.Value().Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          JS::ExposeValueToActiveJS(arg.Value()[sequenceIdx0]);
          tmp.set(arg.Value()[sequenceIdx0]);
          if (!MaybeWrapValue(cx, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableSequenceOfAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalSequenceOfAny(const Optional<Sequence<JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalSequenceOfAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {

      uint32_t length = arg.Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            JS::ExposeValueToActiveJS(arg.Value()[sequenceIdx0]);
            tmp.set(arg.Value()[sequenceIdx0]);
            if (!MaybeWrapValue(cx, &tmp)) {
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[0].setObject(*returnArray);
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalSequenceOfAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableSequenceOfAny(const Optional<Nullable<Sequence<JS::Value>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableSequenceOfAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {

      if (arg.Value().IsNull()) {
        argv[0].setNull();
        break;
      }

      uint32_t length = arg.Value().Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            JS::ExposeValueToActiveJS(arg.Value().Value()[sequenceIdx0]);
            tmp.set(arg.Value().Value()[sequenceIdx0]);
            if (!MaybeWrapValue(cx, &tmp)) {
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[0].setObject(*returnArray);
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableSequenceOfAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalSequenceOfAnyWithDefaultValue(const Nullable<Sequence<JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalSequenceOfAnyWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }

    uint32_t length = arg.Value().Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          JS::ExposeValueToActiveJS(arg.Value()[sequenceIdx0]);
          tmp.set(arg.Value()[sequenceIdx0]);
          if (!MaybeWrapValue(cx, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalSequenceOfAnyWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassSequenceOfSequenceOfAny(const Sequence<Sequence<JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passSequenceOfSequenceOfAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {

          uint32_t length = arg[sequenceIdx0].Length();
          JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
          if (!returnArray) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          // Scope for 'tmp'
          {
            JS::Rooted<JS::Value> tmp(cx);
            for (uint32_t sequenceIdx1 = 0; sequenceIdx1 < length; ++sequenceIdx1) {
              // Control block to let us common up the JS_DefineElement calls when there
              // are different ways to succeed at wrapping the object.
              do {
                JS::ExposeValueToActiveJS(arg[sequenceIdx0][sequenceIdx1]);
                tmp.set(arg[sequenceIdx0][sequenceIdx1]);
                if (!MaybeWrapValue(cx, &tmp)) {
                  aRv.Throw(NS_ERROR_UNEXPECTED);
                  return;
                }
                break;
              } while (false);
              if (!JS_DefineElement(cx, returnArray, sequenceIdx1, tmp,
                                    JSPROP_ENUMERATE)) {
                aRv.Throw(NS_ERROR_UNEXPECTED);
                return;
              }
            }
          }
          tmp.setObject(*returnArray);
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passSequenceOfSequenceOfAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassSequenceOfNullableSequenceOfAny(const Sequence<Nullable<Sequence<JS::Value>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passSequenceOfNullableSequenceOfAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {

          if (arg[sequenceIdx0].IsNull()) {
            tmp.setNull();
            break;
          }

          uint32_t length = arg[sequenceIdx0].Value().Length();
          JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
          if (!returnArray) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          // Scope for 'tmp'
          {
            JS::Rooted<JS::Value> tmp(cx);
            for (uint32_t sequenceIdx1 = 0; sequenceIdx1 < length; ++sequenceIdx1) {
              // Control block to let us common up the JS_DefineElement calls when there
              // are different ways to succeed at wrapping the object.
              do {
                JS::ExposeValueToActiveJS(arg[sequenceIdx0].Value()[sequenceIdx1]);
                tmp.set(arg[sequenceIdx0].Value()[sequenceIdx1]);
                if (!MaybeWrapValue(cx, &tmp)) {
                  aRv.Throw(NS_ERROR_UNEXPECTED);
                  return;
                }
                break;
              } while (false);
              if (!JS_DefineElement(cx, returnArray, sequenceIdx1, tmp,
                                    JSPROP_ENUMERATE)) {
                aRv.Throw(NS_ERROR_UNEXPECTED);
                return;
              }
            }
          }
          tmp.setObject(*returnArray);
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passSequenceOfNullableSequenceOfAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableSequenceOfNullableSequenceOfAny(const Nullable<Sequence<Nullable<Sequence<JS::Value>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableSequenceOfNullableSequenceOfAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }

    uint32_t length = arg.Value().Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {

          if (arg.Value()[sequenceIdx0].IsNull()) {
            tmp.setNull();
            break;
          }

          uint32_t length = arg.Value()[sequenceIdx0].Value().Length();
          JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
          if (!returnArray) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          // Scope for 'tmp'
          {
            JS::Rooted<JS::Value> tmp(cx);
            for (uint32_t sequenceIdx1 = 0; sequenceIdx1 < length; ++sequenceIdx1) {
              // Control block to let us common up the JS_DefineElement calls when there
              // are different ways to succeed at wrapping the object.
              do {
                JS::ExposeValueToActiveJS(arg.Value()[sequenceIdx0].Value()[sequenceIdx1]);
                tmp.set(arg.Value()[sequenceIdx0].Value()[sequenceIdx1]);
                if (!MaybeWrapValue(cx, &tmp)) {
                  aRv.Throw(NS_ERROR_UNEXPECTED);
                  return;
                }
                break;
              } while (false);
              if (!JS_DefineElement(cx, returnArray, sequenceIdx1, tmp,
                                    JSPROP_ENUMERATE)) {
                aRv.Throw(NS_ERROR_UNEXPECTED);
                return;
              }
            }
          }
          tmp.setObject(*returnArray);
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableSequenceOfNullableSequenceOfAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableSequenceOfNullableSequenceOfAny(const Optional<Nullable<Sequence<Nullable<Sequence<JS::Value>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableSequenceOfNullableSequenceOfAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {

      if (arg.Value().IsNull()) {
        argv[0].setNull();
        break;
      }

      uint32_t length = arg.Value().Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {

            if (arg.Value().Value()[sequenceIdx0].IsNull()) {
              tmp.setNull();
              break;
            }

            uint32_t length = arg.Value().Value()[sequenceIdx0].Value().Length();
            JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
            if (!returnArray) {
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
            // Scope for 'tmp'
            {
              JS::Rooted<JS::Value> tmp(cx);
              for (uint32_t sequenceIdx1 = 0; sequenceIdx1 < length; ++sequenceIdx1) {
                // Control block to let us common up the JS_DefineElement calls when there
                // are different ways to succeed at wrapping the object.
                do {
                  JS::ExposeValueToActiveJS(arg.Value().Value()[sequenceIdx0].Value()[sequenceIdx1]);
                  tmp.set(arg.Value().Value()[sequenceIdx0].Value()[sequenceIdx1]);
                  if (!MaybeWrapValue(cx, &tmp)) {
                    aRv.Throw(NS_ERROR_UNEXPECTED);
                    return;
                  }
                  break;
                } while (false);
                if (!JS_DefineElement(cx, returnArray, sequenceIdx1, tmp,
                                      JSPROP_ENUMERATE)) {
                  aRv.Throw(NS_ERROR_UNEXPECTED);
                  return;
                }
              }
            }
            tmp.setObject(*returnArray);
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[0].setObject(*returnArray);
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableSequenceOfNullableSequenceOfAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassRecordOfAny(const Record<nsString, JS::Value>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passRecordOfAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          JS::ExposeValueToActiveJS(recordValue0);
          tmp.set(recordValue0);
          if (!MaybeWrapValue(cx, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passRecordOfAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableRecordOfAny(const Nullable<Record<nsString, JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableRecordOfAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Value().Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          JS::ExposeValueToActiveJS(recordValue0);
          tmp.set(recordValue0);
          if (!MaybeWrapValue(cx, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableRecordOfAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalRecordOfAny(const Optional<Record<nsString, JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalRecordOfAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {

      JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
      if (!returnObj) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (auto& entry : arg.Value().Entries()) {
          auto& recordValue0 = entry.mValue;
          // Control block to let us common up the JS_DefineUCProperty calls when there
          // are different ways to succeed at wrapping the value.
          do {
            JS::ExposeValueToActiveJS(recordValue0);
            tmp.set(recordValue0);
            if (!MaybeWrapValue(cx, &tmp)) {
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
            break;
          } while (false);
          if (!JS_DefineUCProperty(cx, returnObj,
                                   entry.mKey.BeginReading(),
                                   entry.mKey.Length(), tmp,
                                   JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[0].setObject(*returnObj);
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalRecordOfAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableRecordOfAny(const Optional<Nullable<Record<nsString, JS::Value>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableRecordOfAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {

      if (arg.Value().IsNull()) {
        argv[0].setNull();
        break;
      }

      JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
      if (!returnObj) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (auto& entry : arg.Value().Value().Entries()) {
          auto& recordValue0 = entry.mValue;
          // Control block to let us common up the JS_DefineUCProperty calls when there
          // are different ways to succeed at wrapping the value.
          do {
            JS::ExposeValueToActiveJS(recordValue0);
            tmp.set(recordValue0);
            if (!MaybeWrapValue(cx, &tmp)) {
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
            break;
          } while (false);
          if (!JS_DefineUCProperty(cx, returnObj,
                                   entry.mKey.BeginReading(),
                                   entry.mKey.Length(), tmp,
                                   JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[0].setObject(*returnObj);
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableRecordOfAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalRecordOfAnyWithDefaultValue(const Nullable<Record<nsString, JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalRecordOfAnyWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Value().Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          JS::ExposeValueToActiveJS(recordValue0);
          tmp.set(recordValue0);
          if (!MaybeWrapValue(cx, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalRecordOfAnyWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassRecordOfRecordOfAny(const Record<nsString, Record<nsString, JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passRecordOfRecordOfAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {

          JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
          if (!returnObj) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          // Scope for 'tmp'
          {
            JS::Rooted<JS::Value> tmp(cx);
            for (auto& entry : recordValue0.Entries()) {
              auto& recordValue1 = entry.mValue;
              // Control block to let us common up the JS_DefineUCProperty calls when there
              // are different ways to succeed at wrapping the value.
              do {
                JS::ExposeValueToActiveJS(recordValue1);
                tmp.set(recordValue1);
                if (!MaybeWrapValue(cx, &tmp)) {
                  aRv.Throw(NS_ERROR_UNEXPECTED);
                  return;
                }
                break;
              } while (false);
              if (!JS_DefineUCProperty(cx, returnObj,
                                       entry.mKey.BeginReading(),
                                       entry.mKey.Length(), tmp,
                                       JSPROP_ENUMERATE)) {
                aRv.Throw(NS_ERROR_UNEXPECTED);
                return;
              }
            }
          }
          tmp.setObject(*returnObj);
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passRecordOfRecordOfAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassRecordOfNullableRecordOfAny(const Record<nsString, Nullable<Record<nsString, JS::Value>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passRecordOfNullableRecordOfAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {

          if (recordValue0.IsNull()) {
            tmp.setNull();
            break;
          }

          JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
          if (!returnObj) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          // Scope for 'tmp'
          {
            JS::Rooted<JS::Value> tmp(cx);
            for (auto& entry : recordValue0.Value().Entries()) {
              auto& recordValue1 = entry.mValue;
              // Control block to let us common up the JS_DefineUCProperty calls when there
              // are different ways to succeed at wrapping the value.
              do {
                JS::ExposeValueToActiveJS(recordValue1);
                tmp.set(recordValue1);
                if (!MaybeWrapValue(cx, &tmp)) {
                  aRv.Throw(NS_ERROR_UNEXPECTED);
                  return;
                }
                break;
              } while (false);
              if (!JS_DefineUCProperty(cx, returnObj,
                                       entry.mKey.BeginReading(),
                                       entry.mKey.Length(), tmp,
                                       JSPROP_ENUMERATE)) {
                aRv.Throw(NS_ERROR_UNEXPECTED);
                return;
              }
            }
          }
          tmp.setObject(*returnObj);
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passRecordOfNullableRecordOfAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableRecordOfNullableRecordOfAny(const Nullable<Record<nsString, Nullable<Record<nsString, JS::Value>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableRecordOfNullableRecordOfAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Value().Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {

          if (recordValue0.IsNull()) {
            tmp.setNull();
            break;
          }

          JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
          if (!returnObj) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          // Scope for 'tmp'
          {
            JS::Rooted<JS::Value> tmp(cx);
            for (auto& entry : recordValue0.Value().Entries()) {
              auto& recordValue1 = entry.mValue;
              // Control block to let us common up the JS_DefineUCProperty calls when there
              // are different ways to succeed at wrapping the value.
              do {
                JS::ExposeValueToActiveJS(recordValue1);
                tmp.set(recordValue1);
                if (!MaybeWrapValue(cx, &tmp)) {
                  aRv.Throw(NS_ERROR_UNEXPECTED);
                  return;
                }
                break;
              } while (false);
              if (!JS_DefineUCProperty(cx, returnObj,
                                       entry.mKey.BeginReading(),
                                       entry.mKey.Length(), tmp,
                                       JSPROP_ENUMERATE)) {
                aRv.Throw(NS_ERROR_UNEXPECTED);
                return;
              }
            }
          }
          tmp.setObject(*returnObj);
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableRecordOfNullableRecordOfAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableRecordOfNullableRecordOfAny(const Optional<Nullable<Record<nsString, Nullable<Record<nsString, JS::Value>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableRecordOfNullableRecordOfAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {

      if (arg.Value().IsNull()) {
        argv[0].setNull();
        break;
      }

      JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
      if (!returnObj) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (auto& entry : arg.Value().Value().Entries()) {
          auto& recordValue0 = entry.mValue;
          // Control block to let us common up the JS_DefineUCProperty calls when there
          // are different ways to succeed at wrapping the value.
          do {

            if (recordValue0.IsNull()) {
              tmp.setNull();
              break;
            }

            JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
            if (!returnObj) {
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
            // Scope for 'tmp'
            {
              JS::Rooted<JS::Value> tmp(cx);
              for (auto& entry : recordValue0.Value().Entries()) {
                auto& recordValue1 = entry.mValue;
                // Control block to let us common up the JS_DefineUCProperty calls when there
                // are different ways to succeed at wrapping the value.
                do {
                  JS::ExposeValueToActiveJS(recordValue1);
                  tmp.set(recordValue1);
                  if (!MaybeWrapValue(cx, &tmp)) {
                    aRv.Throw(NS_ERROR_UNEXPECTED);
                    return;
                  }
                  break;
                } while (false);
                if (!JS_DefineUCProperty(cx, returnObj,
                                         entry.mKey.BeginReading(),
                                         entry.mKey.Length(), tmp,
                                         JSPROP_ENUMERATE)) {
                  aRv.Throw(NS_ERROR_UNEXPECTED);
                  return;
                }
              }
            }
            tmp.setObject(*returnObj);
            break;
          } while (false);
          if (!JS_DefineUCProperty(cx, returnObj,
                                   entry.mKey.BeginReading(),
                                   entry.mKey.Length(), tmp,
                                   JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[0].setObject(*returnObj);
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableRecordOfNullableRecordOfAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableRecordOfNullableSequenceOfAny(const Optional<Nullable<Record<nsString, Nullable<Sequence<JS::Value>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableRecordOfNullableSequenceOfAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {

      if (arg.Value().IsNull()) {
        argv[0].setNull();
        break;
      }

      JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
      if (!returnObj) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (auto& entry : arg.Value().Value().Entries()) {
          auto& recordValue0 = entry.mValue;
          // Control block to let us common up the JS_DefineUCProperty calls when there
          // are different ways to succeed at wrapping the value.
          do {

            if (recordValue0.IsNull()) {
              tmp.setNull();
              break;
            }

            uint32_t length = recordValue0.Value().Length();
            JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
            if (!returnArray) {
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
            // Scope for 'tmp'
            {
              JS::Rooted<JS::Value> tmp(cx);
              for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
                // Control block to let us common up the JS_DefineElement calls when there
                // are different ways to succeed at wrapping the object.
                do {
                  JS::ExposeValueToActiveJS(recordValue0.Value()[sequenceIdx0]);
                  tmp.set(recordValue0.Value()[sequenceIdx0]);
                  if (!MaybeWrapValue(cx, &tmp)) {
                    aRv.Throw(NS_ERROR_UNEXPECTED);
                    return;
                  }
                  break;
                } while (false);
                if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                      JSPROP_ENUMERATE)) {
                  aRv.Throw(NS_ERROR_UNEXPECTED);
                  return;
                }
              }
            }
            tmp.setObject(*returnArray);
            break;
          } while (false);
          if (!JS_DefineUCProperty(cx, returnObj,
                                   entry.mKey.BeginReading(),
                                   entry.mKey.Length(), tmp,
                                   JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[0].setObject(*returnObj);
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableRecordOfNullableSequenceOfAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableSequenceOfNullableRecordOfAny(const Optional<Nullable<Sequence<Nullable<Record<nsString, JS::Value>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableSequenceOfNullableRecordOfAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {

      if (arg.Value().IsNull()) {
        argv[0].setNull();
        break;
      }

      uint32_t length = arg.Value().Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {

            if (arg.Value().Value()[sequenceIdx0].IsNull()) {
              tmp.setNull();
              break;
            }

            JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
            if (!returnObj) {
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
            // Scope for 'tmp'
            {
              JS::Rooted<JS::Value> tmp(cx);
              for (auto& entry : arg.Value().Value()[sequenceIdx0].Value().Entries()) {
                auto& recordValue0 = entry.mValue;
                // Control block to let us common up the JS_DefineUCProperty calls when there
                // are different ways to succeed at wrapping the value.
                do {
                  JS::ExposeValueToActiveJS(recordValue0);
                  tmp.set(recordValue0);
                  if (!MaybeWrapValue(cx, &tmp)) {
                    aRv.Throw(NS_ERROR_UNEXPECTED);
                    return;
                  }
                  break;
                } while (false);
                if (!JS_DefineUCProperty(cx, returnObj,
                                         entry.mKey.BeginReading(),
                                         entry.mKey.Length(), tmp,
                                         JSPROP_ENUMERATE)) {
                  aRv.Throw(NS_ERROR_UNEXPECTED);
                  return;
                }
              }
            }
            tmp.setObject(*returnObj);
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[0].setObject(*returnArray);
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableSequenceOfNullableRecordOfAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveAny(JS::MutableHandle<JS::Value> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveAny", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveAny_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  JS::Rooted<JS::Value> rvalDecl(cx);
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
  if ((false) && !CallerSubsumes(rval)) {
    cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("return value of TestJSImplInterface.receiveAny");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
  rvalDecl = rval;
  aRetVal.set(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::PassObject(JS::Handle<JSObject*> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passObject", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::ExposeObjectToActiveJS(arg);
    argv[0].setObject(*arg);
    if (!MaybeWrapObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passObject_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassVariadicObject(const nsTArray<JSObject*>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passVariadicObject", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize((1 - 1) + arg.Length())) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = (1 - 1) + arg.Length();

  do {
    for (uint32_t idx = 0; idx < arg.Length(); ++idx) {
      JS::ExposeObjectToActiveJS(arg[idx]);
      argv[0 + idx].setObject(*arg[idx]);
      if (!MaybeWrapObjectValue(cx, argv[0 + idx])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      continue;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passVariadicObject_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableObject(JS::Handle<JSObject*> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableObject", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg) {
                  JS::ExposeObjectToActiveJS(arg);
                }
                argv[0].setObjectOrNull(arg);
    if (!MaybeWrapObjectOrNullValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableObject_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassVariadicNullableObject(const nsTArray<JSObject*>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passVariadicNullableObject", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize((1 - 1) + arg.Length())) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = (1 - 1) + arg.Length();

  do {
    for (uint32_t idx = 0; idx < arg.Length(); ++idx) {
      JS::ExposeObjectToActiveJS(arg[idx]);
      argv[0 + idx].setObject(*arg[idx]);
      if (!MaybeWrapObjectValue(cx, argv[0 + idx])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      continue;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passVariadicNullableObject_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalObject(const Optional<JS::Handle<JSObject*>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalObject", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      JS::ExposeObjectToActiveJS(arg.Value());
      argv[0].setObject(*arg.Value());
      if (!MaybeWrapObjectValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalObject_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableObject(const Optional<JS::Handle<JSObject*>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableObject", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (arg.Value()) {
                    JS::ExposeObjectToActiveJS(arg.Value());
                  }
                  argv[0].setObjectOrNull(arg.Value());
      if (!MaybeWrapObjectOrNullValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableObject_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableObjectWithDefaultValue(JS::Handle<JSObject*> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableObjectWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg) {
                  JS::ExposeObjectToActiveJS(arg);
                }
                argv[0].setObjectOrNull(arg);
    if (!MaybeWrapObjectOrNullValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableObjectWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassSequenceOfObject(const Sequence<JSObject*>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passSequenceOfObject", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          JS::ExposeObjectToActiveJS(arg[sequenceIdx0]);
          tmp.setObject(*arg[sequenceIdx0]);
          if (!MaybeWrapObjectValue(cx, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passSequenceOfObject_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassSequenceOfNullableObject(const Sequence<JSObject*>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passSequenceOfNullableObject", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (arg[sequenceIdx0]) {
                        JS::ExposeObjectToActiveJS(arg[sequenceIdx0]);
                      }
                      tmp.setObjectOrNull(arg[sequenceIdx0]);
          if (!MaybeWrapObjectOrNullValue(cx, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passSequenceOfNullableObject_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableSequenceOfObject(const Nullable<Sequence<JSObject*>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableSequenceOfObject", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }

    uint32_t length = arg.Value().Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          JS::ExposeObjectToActiveJS(arg.Value()[sequenceIdx0]);
          tmp.setObject(*arg.Value()[sequenceIdx0]);
          if (!MaybeWrapObjectValue(cx, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableSequenceOfObject_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableSequenceOfNullableSequenceOfObject(const Optional<Nullable<Sequence<Nullable<Sequence<JSObject*>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableSequenceOfNullableSequenceOfObject", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {

      if (arg.Value().IsNull()) {
        argv[0].setNull();
        break;
      }

      uint32_t length = arg.Value().Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {

            if (arg.Value().Value()[sequenceIdx0].IsNull()) {
              tmp.setNull();
              break;
            }

            uint32_t length = arg.Value().Value()[sequenceIdx0].Value().Length();
            JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
            if (!returnArray) {
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
            // Scope for 'tmp'
            {
              JS::Rooted<JS::Value> tmp(cx);
              for (uint32_t sequenceIdx1 = 0; sequenceIdx1 < length; ++sequenceIdx1) {
                // Control block to let us common up the JS_DefineElement calls when there
                // are different ways to succeed at wrapping the object.
                do {
                  JS::ExposeObjectToActiveJS(arg.Value().Value()[sequenceIdx0].Value()[sequenceIdx1]);
                  tmp.setObject(*arg.Value().Value()[sequenceIdx0].Value()[sequenceIdx1]);
                  if (!MaybeWrapObjectValue(cx, &tmp)) {
                    aRv.Throw(NS_ERROR_UNEXPECTED);
                    return;
                  }
                  break;
                } while (false);
                if (!JS_DefineElement(cx, returnArray, sequenceIdx1, tmp,
                                      JSPROP_ENUMERATE)) {
                  aRv.Throw(NS_ERROR_UNEXPECTED);
                  return;
                }
              }
            }
            tmp.setObject(*returnArray);
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[0].setObject(*returnArray);
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableSequenceOfNullableSequenceOfObject_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableSequenceOfNullableSequenceOfNullableObject(const Optional<Nullable<Sequence<Nullable<Sequence<JSObject*>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableSequenceOfNullableSequenceOfNullableObject", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {

      if (arg.Value().IsNull()) {
        argv[0].setNull();
        break;
      }

      uint32_t length = arg.Value().Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {

            if (arg.Value().Value()[sequenceIdx0].IsNull()) {
              tmp.setNull();
              break;
            }

            uint32_t length = arg.Value().Value()[sequenceIdx0].Value().Length();
            JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
            if (!returnArray) {
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
            // Scope for 'tmp'
            {
              JS::Rooted<JS::Value> tmp(cx);
              for (uint32_t sequenceIdx1 = 0; sequenceIdx1 < length; ++sequenceIdx1) {
                // Control block to let us common up the JS_DefineElement calls when there
                // are different ways to succeed at wrapping the object.
                do {
                  if (arg.Value().Value()[sequenceIdx0].Value()[sequenceIdx1]) {
                                JS::ExposeObjectToActiveJS(arg.Value().Value()[sequenceIdx0].Value()[sequenceIdx1]);
                              }
                              tmp.setObjectOrNull(arg.Value().Value()[sequenceIdx0].Value()[sequenceIdx1]);
                  if (!MaybeWrapObjectOrNullValue(cx, &tmp)) {
                    aRv.Throw(NS_ERROR_UNEXPECTED);
                    return;
                  }
                  break;
                } while (false);
                if (!JS_DefineElement(cx, returnArray, sequenceIdx1, tmp,
                                      JSPROP_ENUMERATE)) {
                  aRv.Throw(NS_ERROR_UNEXPECTED);
                  return;
                }
              }
            }
            tmp.setObject(*returnArray);
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      }
      argv[0].setObject(*returnArray);
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableSequenceOfNullableSequenceOfNullableObject_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassRecordOfObject(const Record<nsString, JSObject*>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passRecordOfObject", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          JS::ExposeObjectToActiveJS(recordValue0);
          tmp.setObject(*recordValue0);
          if (!MaybeWrapObjectValue(cx, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passRecordOfObject_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveObject(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveObject", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveObject_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  JS::Rooted<JSObject*> rvalDecl(cx);
  if (rval.isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
    if ((false) && !CallerSubsumes(rval)) {
      cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("return value of TestJSImplInterface.receiveObject");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
    rvalDecl = &rval.toObject();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveObject");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.set(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::ReceiveNullableObject(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableObject", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableObject_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  JS::Rooted<JSObject*> rvalDecl(cx);
  if (rval.isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
    if ((false) && !CallerSubsumes(rval)) {
      cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("return value of TestJSImplInterface.receiveNullableObject");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
    rvalDecl = &rval.toObject();
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.receiveNullableObject");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.set(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::PassUnion(const ObjectOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnion", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnion_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithNullable(const ObjectOrNullOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithNullable", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithNullable_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnion(const Nullable<ObjectOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnion", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnion_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalUnion(const Optional<ObjectOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalUnion", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
      if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalUnion_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableUnion(const Optional<Nullable<ObjectOrLong>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableUnion", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
      if (arg.Value().IsNull()) {
        argv[0].setNull();
        break;
      }
      if (!arg.Value().Value().ToJSVal(cx, callbackObj, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableUnion_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalNullableUnionWithDefaultValue(const Nullable<ObjectOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalNullableUnionWithDefaultValue", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalNullableUnionWithDefaultValue_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithArrayBuffer(const ArrayBufferOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithArrayBuffer", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithArrayBuffer_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithString(const StringOrObject& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithString", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithString_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithEnum(const SupportedTypeOrObject& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithEnum", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithEnum_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithObject(const ObjectOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithObject", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithObject_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue1(const DoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue1", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue1_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue2(const DoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue2", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue2_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue3(const DoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue3", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue3_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue4(const FloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue4", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue4_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue5(const FloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue5", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue5_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue6(const FloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue6", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue6_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue7(const UnrestrictedDoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue7", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue7_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue8(const UnrestrictedDoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue8", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue8_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue9(const UnrestrictedDoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue9", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue9_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue10(const UnrestrictedDoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue10", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue10_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue11(const UnrestrictedFloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue11", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue11_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue12(const UnrestrictedFloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue12", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue12_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue13(const UnrestrictedFloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue13", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue13_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue14(const DoubleOrByteString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue14", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue14_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue15(const DoubleOrByteString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue15", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue15_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue16(const DoubleOrByteString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue16", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue16_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue17(const DoubleOrSupportedType& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue17", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue17_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue18(const DoubleOrSupportedType& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue18", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue18_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue19(const DoubleOrSupportedType& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue19", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue19_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue20(const DoubleOrUSVString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue20", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue20_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue21(const DoubleOrUSVString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue21", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue21_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue22(const DoubleOrUSVString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue22", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue22_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue23(const DoubleOrUTF8String& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue23", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue23_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue24(const DoubleOrUTF8String& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue24", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue24_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionWithDefaultValue25(const DoubleOrUTF8String& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionWithDefaultValue25", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionWithDefaultValue25_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue1(const Nullable<DoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue1", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue1_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue2(const Nullable<DoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue2", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue2_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue3(const Nullable<DoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue3", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue3_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue4(const Nullable<FloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue4", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue4_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue5(const Nullable<FloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue5", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue5_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue6(const Nullable<FloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue6", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue6_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue7(const Nullable<UnrestrictedDoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue7", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue7_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue8(const Nullable<UnrestrictedDoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue8", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue8_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue9(const Nullable<UnrestrictedDoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue9", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue9_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue10(const Nullable<UnrestrictedFloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue10", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue10_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue11(const Nullable<UnrestrictedFloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue11", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue11_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue12(const Nullable<UnrestrictedFloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue12", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue12_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue13(const Nullable<DoubleOrByteString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue13", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue13_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue14(const Nullable<DoubleOrByteString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue14", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue14_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue15(const Nullable<DoubleOrByteString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue15", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue15_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue16(const Nullable<DoubleOrByteString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue16", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue16_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue17(const Nullable<DoubleOrSupportedType>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue17", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue17_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue18(const Nullable<DoubleOrSupportedType>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue18", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue18_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue19(const Nullable<DoubleOrSupportedType>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue19", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue19_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue20(const Nullable<DoubleOrSupportedType>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue20", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue20_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue21(const Nullable<DoubleOrUSVString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue21", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue21_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue22(const Nullable<DoubleOrUSVString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue22", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue22_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue23(const Nullable<DoubleOrUSVString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue23", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue23_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue24(const Nullable<DoubleOrUSVString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue24", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue24_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue25(const Nullable<DoubleOrUTF8String>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue25", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue25_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue26(const Nullable<DoubleOrUTF8String>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue26", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue26_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue27(const Nullable<DoubleOrUTF8String>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue27", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue27_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassNullableUnionWithDefaultValue28(const Nullable<DoubleOrUTF8String>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passNullableUnionWithDefaultValue28", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passNullableUnionWithDefaultValue28_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassSequenceOfUnions(const Sequence<OwningCanvasPatternOrCanvasGradient>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passSequenceOfUnions", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!arg[sequenceIdx0].ToJSVal(cx, returnArray, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passSequenceOfUnions_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassSequenceOfUnions2(const Sequence<OwningObjectOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passSequenceOfUnions2", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!arg[sequenceIdx0].ToJSVal(cx, returnArray, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passSequenceOfUnions2_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassVariadicUnion(const nsTArray<OwningCanvasPatternOrCanvasGradient>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passVariadicUnion", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize((1 - 1) + arg.Length())) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = (1 - 1) + arg.Length();

  do {
    for (uint32_t idx = 0; idx < arg.Length(); ++idx) {
      JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
      if (!arg[idx].ToJSVal(cx, callbackObj, argv[0 + idx])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      continue;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passVariadicUnion_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassSequenceOfNullableUnions(const Sequence<Nullable<OwningCanvasPatternOrCanvasGradient>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passSequenceOfNullableUnions", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (arg[sequenceIdx0].IsNull()) {
            tmp.setNull();
            break;
          }
          if (!arg[sequenceIdx0].Value().ToJSVal(cx, returnArray, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passSequenceOfNullableUnions_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassVariadicNullableUnion(const nsTArray<Nullable<OwningCanvasPatternOrCanvasGradient>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passVariadicNullableUnion", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize((1 - 1) + arg.Length())) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = (1 - 1) + arg.Length();

  do {
    for (uint32_t idx = 0; idx < arg.Length(); ++idx) {
      JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
      if (arg[idx].IsNull()) {
        argv[0 + idx].setNull();
        continue;
      }
      if (!arg[idx].Value().ToJSVal(cx, callbackObj, argv[0 + idx])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      continue;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passVariadicNullableUnion_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassRecordOfUnions(const Record<nsString, OwningCanvasPatternOrCanvasGradient>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passRecordOfUnions", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          if (!recordValue0.ToJSVal(cx, returnObj, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passRecordOfUnions_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveUnion(OwningCanvasPatternOrCanvasGradient& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveUnion", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveUnion_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  OwningCanvasPatternOrCanvasGradient& rvalDecl(aRetVal);
  {
    bool done = false, failed = false, tryNext;
    if (rval.isObject()) {
      done = (failed = !rvalDecl.TrySetToCanvasPattern(cx, rval, tryNext, false)) || !tryNext ||
             (failed = !rvalDecl.TrySetToCanvasGradient(cx, rval, tryNext, false)) || !tryNext;

    }
    if (failed) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Return value of TestJSImplInterface.receiveUnion", "CanvasPattern, CanvasGradient");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveUnion2(OwningObjectOrLong& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveUnion2", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveUnion2_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  OwningObjectOrLong& rvalDecl(aRetVal);
  {
    bool done = false, failed = false, tryNext;
    if (rval.isObject()) {
      if (!rvalDecl.SetToObject(cx, &rval.toObject(), false)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      done = true;
    } else {
      do {
        done = (failed = !rvalDecl.TrySetToLong(cx, rval, tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Return value of TestJSImplInterface.receiveUnion2", "object");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveUnionContainingNull(OwningCanvasPatternOrNullOrCanvasGradient& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveUnionContainingNull", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveUnionContainingNull_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  OwningCanvasPatternOrNullOrCanvasGradient& rvalDecl(aRetVal);
  if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    {
      bool done = false, failed = false, tryNext;
      if (rval.isObject()) {
        done = (failed = !rvalDecl.TrySetToCanvasPattern(cx, rval, tryNext, false)) || !tryNext ||
               (failed = !rvalDecl.TrySetToCanvasGradient(cx, rval, tryNext, false)) || !tryNext;

      }
      if (failed) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Return value of TestJSImplInterface.receiveUnionContainingNull", "CanvasPattern, CanvasGradient");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveNullableUnion(Nullable<OwningCanvasPatternOrCanvasGradient>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableUnion", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableUnion_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Nullable<OwningCanvasPatternOrCanvasGradient >& rvalDecl(aRetVal);
  if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    {
      bool done = false, failed = false, tryNext;
      if (rval.isObject()) {
        done = (failed = !rvalDecl.SetValue().TrySetToCanvasPattern(cx, rval, tryNext, false)) || !tryNext ||
               (failed = !rvalDecl.SetValue().TrySetToCanvasGradient(cx, rval, tryNext, false)) || !tryNext;

      }
      if (failed) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Return value of TestJSImplInterface.receiveNullableUnion", "CanvasPattern, CanvasGradient");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveNullableUnion2(Nullable<OwningObjectOrLong>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableUnion2", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableUnion2_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Nullable<OwningObjectOrLong >& rvalDecl(aRetVal);
  if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    {
      bool done = false, failed = false, tryNext;
      if (rval.isObject()) {
        if (!rvalDecl.SetValue().SetToObject(cx, &rval.toObject(), false)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
        done = true;
      } else {
        do {
          done = (failed = !rvalDecl.SetValue().TrySetToLong(cx, rval, tryNext)) || !tryNext;
          break;
        } while (false);
      }
      if (failed) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Return value of TestJSImplInterface.receiveNullableUnion2", "object");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  }
}

void
TestJSImplInterfaceJSImpl::PassPromise(Promise& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passPromise", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!ToJSValue(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passPromise_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassOptionalPromise(const Optional<OwningNonNull<Promise>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOptionalPromise", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (!ToJSValue(cx, arg.Value(), argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOptionalPromise_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassPromiseSequence(const Sequence<OwningNonNull<Promise>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passPromiseSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!ToJSValue(cx, arg[sequenceIdx0], &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passPromiseSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

already_AddRefed<Promise>
TestJSImplInterfaceJSImpl::ReceivePromise(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receivePromise", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receivePromise_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<Promise> rvalDecl;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoRealm,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx);
    if (!rval.isObject()) {
      aRv.ThrowTypeError<MSG_NOT_OBJECT>("return value of TestJSImplInterface.receivePromise");
      return nullptr;
    }
    JSObject* unwrappedVal = js::CheckedUnwrapStatic(&rval.toObject());
    if (!unwrappedVal) {
      // A slight lie, but not much of one, for a dead object wrapper.
      aRv.ThrowTypeError<MSG_NOT_OBJECT>("return value of TestJSImplInterface.receivePromise");
      return nullptr;
    }
    globalObj = JS::GetNonCCWObjectGlobal(unwrappedVal);
    JSAutoRealm ar(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, rval);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      MOZ_ALWAYS_TRUE(promiseRv.MaybeSetPendingException(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  }
  return rvalDecl.forget();
}

already_AddRefed<Promise>
TestJSImplInterfaceJSImpl::ReceiveAddrefedPromise(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveAddrefedPromise", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveAddrefedPromise_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<Promise> rvalDecl;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoRealm,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx);
    if (!rval.isObject()) {
      aRv.ThrowTypeError<MSG_NOT_OBJECT>("return value of TestJSImplInterface.receiveAddrefedPromise");
      return nullptr;
    }
    JSObject* unwrappedVal = js::CheckedUnwrapStatic(&rval.toObject());
    if (!unwrappedVal) {
      // A slight lie, but not much of one, for a dead object wrapper.
      aRv.ThrowTypeError<MSG_NOT_OBJECT>("return value of TestJSImplInterface.receiveAddrefedPromise");
      return nullptr;
    }
    globalObj = JS::GetNonCCWObjectGlobal(unwrappedVal);
    JSAutoRealm ar(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, rval);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      MOZ_ALWAYS_TRUE(promiseRv.MaybeSetPendingException(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  }
  return rvalDecl.forget();
}

void
TestJSImplInterfaceJSImpl::MethodRenamedTo(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.methodRenamedFrom", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->methodRenamedTo_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::MethodRenamedTo(int8_t argument, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.methodRenamedFrom", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(argument));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->methodRenamedTo_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassDictionary(const Dict& x, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passDictionary", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!x.ToObjectInternal(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passDictionary_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassDictionary2(const Dict& x, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passDictionary2", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!x.ToObjectInternal(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passDictionary2_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveDictionary(Dict& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveDictionary", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveDictionary_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Dict& rvalDecl(aRetVal);
  if (!rvalDecl.Init(cx, rval, "Return value of TestJSImplInterface.receiveDictionary", false)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveNullableDictionary(Nullable<Dict>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveNullableDictionary", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveNullableDictionary_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Nullable<Dict>& rvalDecl(aRetVal);
  if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    if (!rvalDecl.SetValue().Init(cx, rval, "Return value of TestJSImplInterface.receiveNullableDictionary", false)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
  }
}

void
TestJSImplInterfaceJSImpl::PassOtherDictionary(const GrandparentDict& x, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passOtherDictionary", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!x.ToObjectInternal(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passOtherDictionary_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassSequenceOfDictionaries(const Sequence<Dict>& x, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passSequenceOfDictionaries", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = x.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!x[sequenceIdx0].ToObjectInternal(cx, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passSequenceOfDictionaries_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassRecordOfDictionaries(const Record<nsString, GrandparentDict>& x, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passRecordOfDictionaries", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : x.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          if (!recordValue0.ToObjectInternal(cx, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passRecordOfDictionaries_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassDictionaryOrLong(const Dict& x, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passDictionaryOrLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!x.ToObjectInternal(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passDictionaryOrLong_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassDictionaryOrLong(int32_t x, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passDictionaryOrLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(x));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passDictionaryOrLong_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassDictContainingDict(const DictContainingDict& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passDictContainingDict", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!arg.ToObjectInternal(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passDictContainingDict_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassDictContainingSequence(const DictContainingSequence& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passDictContainingSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!arg.ToObjectInternal(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passDictContainingSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ReceiveDictContainingSequence(DictContainingSequence& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.receiveDictContainingSequence", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->receiveDictContainingSequence_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  DictContainingSequence& rvalDecl(aRetVal);
  if (!rvalDecl.Init(cx, rval, "Return value of TestJSImplInterface.receiveDictContainingSequence", false)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassVariadicDictionary(const nsTArray<Dict>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passVariadicDictionary", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize((1 - 1) + arg.Length())) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = (1 - 1) + arg.Length();

  do {
    for (uint32_t idx = 0; idx < arg.Length(); ++idx) {
      if (!arg[idx].ToObjectInternal(cx, argv[0 + idx])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      continue;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passVariadicDictionary_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::DontEnforceRangeOrClamp(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.dontEnforceRangeOrClamp", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->dontEnforceRangeOrClamp_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::DoEnforceRange(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.doEnforceRange", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->doEnforceRange_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::DoEnforceRangeNullable(const Nullable<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.doEnforceRangeNullable", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    argv[0].setInt32(int32_t(arg.Value()));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->doEnforceRangeNullable_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::DoClamp(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.doClamp", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->doClamp_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::DoClampNullable(const Nullable<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.doClampNullable", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    argv[0].setInt32(int32_t(arg.Value()));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->doClampNullable_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ExerciseTypedefInterfaces1(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.exerciseTypedefInterfaces1", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!GetOrCreateDOMReflector(cx, arg, argv[0])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->exerciseTypedefInterfaces1_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

already_AddRefed<TestJSImplInterface>
TestJSImplInterfaceJSImpl::ExerciseTypedefInterfaces2(TestJSImplInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.exerciseTypedefInterfaces2", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return nullptr;
  }
  unsigned argc = 1;

  do {
    if (!arg) {
      argv[0].setNull();
      break;
    }
    if (!GetOrCreateDOMReflector(cx, arg, argv[0])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->exerciseTypedefInterfaces2_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestJSImplInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(rval, rvalDecl, cx);
      if (NS_FAILED(rv)) {
        // Be careful to not wrap random DOM objects here, even if
        // they're wrapped in opaque security wrappers for some reason.
        // XXXbz Wish we could check for a JS-implemented object
        // that already has a content reflection...
        if (!IsDOMObject(js::UncheckedUnwrap(&rval.toObject()))) {
          nsCOMPtr<nsIGlobalObject> contentGlobal;
          JS::Rooted<JSObject*> callback(cx, CallbackOrNull());
          if (!callback ||
              !GetContentGlobalForJSImplementedObject(cx, callback, getter_AddRefs(contentGlobal))) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return nullptr;
          }
          JS::Rooted<JSObject*> jsImplSourceObj(cx, &rval.toObject());
          MOZ_RELEASE_ASSERT(!js::IsWrapper(jsImplSourceObj),
                             "Don't return JS implementations from other compartments");
          JS::Rooted<JSObject*> jsImplSourceGlobal(cx, JS::GetNonCCWObjectGlobal(jsImplSourceObj));
          rvalDecl = new mozilla::dom::TestJSImplInterface(jsImplSourceObj, jsImplSourceGlobal, contentGlobal);
        } else {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.exerciseTypedefInterfaces2", "TestJSImplInterface");
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return nullptr;
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.exerciseTypedefInterfaces2");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

void
TestJSImplInterfaceJSImpl::ExerciseTypedefInterfaces3(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.exerciseTypedefInterfaces3", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!GetOrCreateDOMReflector(cx, arg, argv[0])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->exerciseTypedefInterfaces3_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

int8_t
TestJSImplInterfaceJSImpl::DeprecatedMethod(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.deprecatedMethod", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->deprecatedMethod_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return int8_t(0);
  }
  int8_t rvalDecl;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.deprecatedMethod", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  return rvalDecl;
}

void
TestJSImplInterfaceJSImpl::DeprecatedMethodWithContext(JS::Handle<JS::Value> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.deprecatedMethodWithContext", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::ExposeValueToActiveJS(arg);
    argv[0].set(arg);
    if (!MaybeWrapValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->deprecatedMethodWithContext_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

bool
TestJSImplInterfaceJSImpl::Overload1(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload1", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return bool(0);
  }
  unsigned argc = 1;

  do {
    if (!GetOrCreateDOMReflector(cx, arg, argv[0])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return bool(0);
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload1_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.overload1", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

already_AddRefed<TestJSImplInterface>
TestJSImplInterfaceJSImpl::Overload1(const nsAString& strs, TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload1", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(2)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return nullptr;
  }
  unsigned argc = 2;

  do {
    if (!GetOrCreateDOMReflector(cx, arg, argv[1])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (false);

  do {
    nsString mutableStr(strs);
    if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload1_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestJSImplInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(rval, rvalDecl, cx);
      if (NS_FAILED(rv)) {
        // Be careful to not wrap random DOM objects here, even if
        // they're wrapped in opaque security wrappers for some reason.
        // XXXbz Wish we could check for a JS-implemented object
        // that already has a content reflection...
        if (!IsDOMObject(js::UncheckedUnwrap(&rval.toObject()))) {
          nsCOMPtr<nsIGlobalObject> contentGlobal;
          JS::Rooted<JSObject*> callback(cx, CallbackOrNull());
          if (!callback ||
              !GetContentGlobalForJSImplementedObject(cx, callback, getter_AddRefs(contentGlobal))) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return nullptr;
          }
          JS::Rooted<JSObject*> jsImplSourceObj(cx, &rval.toObject());
          MOZ_RELEASE_ASSERT(!js::IsWrapper(jsImplSourceObj),
                             "Don't return JS implementations from other compartments");
          JS::Rooted<JSObject*> jsImplSourceGlobal(cx, JS::GetNonCCWObjectGlobal(jsImplSourceObj));
          rvalDecl = new mozilla::dom::TestJSImplInterface(jsImplSourceObj, jsImplSourceGlobal, contentGlobal);
        } else {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.overload1", "TestJSImplInterface");
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return nullptr;
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.overload1");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

void
TestJSImplInterfaceJSImpl::Overload2(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload2", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!GetOrCreateDOMReflector(cx, arg, argv[0])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload2_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload2(const Dict& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload2", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!arg.ToObjectInternal(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload2_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload2(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload2", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setBoolean(arg);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload2_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload2(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload2", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    nsString mutableStr(arg);
    if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload2_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload3(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload3", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!GetOrCreateDOMReflector(cx, arg, argv[0])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload3_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload3(MyTestCallback& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload3", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setObjectOrNull(GetCallbackFromCallbackObject(cx, arg));
    if (!MaybeWrapObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload3_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload3(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload3", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setBoolean(arg);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload3_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload4(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload4", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!GetOrCreateDOMReflector(cx, arg, argv[0])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload4_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload4(TestCallbackInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload4", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setObjectOrNull(GetCallbackFromCallbackObject(cx, arg));
    if (!MaybeWrapObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload4_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload4(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload4", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    nsString mutableStr(arg);
    if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload4_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload5(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload5", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload5_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload5(MyTestEnum arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload5", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!ToJSValue(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload5_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload6(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload6", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload6_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload6(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload6", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setBoolean(arg);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload6_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload7(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload7", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload7_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload7(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload7", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setBoolean(arg);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload7_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload7(const nsCString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload7", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!NonVoidByteStringToJsval(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload7_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload8(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload8", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload8_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload8(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload8", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!GetOrCreateDOMReflector(cx, arg, argv[0])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload8_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload9(const Nullable<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload9", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    argv[0].setInt32(int32_t(arg.Value()));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload9_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload9(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload9", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    nsString mutableStr(arg);
    if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload9_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload10(const Nullable<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload10", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    argv[0].setInt32(int32_t(arg.Value()));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload10_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload10(JS::Handle<JSObject*> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload10", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::ExposeObjectToActiveJS(arg);
    argv[0].setObject(*arg);
    if (!MaybeWrapObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload10_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload11(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload11", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload11_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload11(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload11", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    nsString mutableStr(arg);
    if (!xpc::StringToJsval(cx, mutableStr, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload11_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload12(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload12", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload12_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload12(const Nullable<bool>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload12", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    argv[0].setBoolean(arg.Value());
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload12_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload13(const Nullable<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload13", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    argv[0].setInt32(int32_t(arg.Value()));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload13_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload13(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload13", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setBoolean(arg);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload13_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload14(const Optional<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload14", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      argv[0].setInt32(int32_t(arg.Value()));
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload14_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload14(TestInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload14", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!GetOrCreateDOMReflector(cx, arg, argv[0])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload14_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload15(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload15", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload15_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload15(const Optional<NonNull<TestInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload15", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (!GetOrCreateDOMReflector(cx, arg.Value(), argv[0])) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload15_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload16(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload16", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload16_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload16(const Optional<TestInterface*>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload16", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (arg.WasPassed()) {
      if (!arg.Value()) {
        argv[0].setNull();
        break;
      }
      if (!GetOrCreateDOMReflector(cx, arg.Value(), argv[0])) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload16_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload17(const Sequence<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload17", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.setInt32(int32_t(arg[sequenceIdx0]));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload17_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload17(const Record<nsString, int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload17", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          tmp.setInt32(int32_t(recordValue0));
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload17_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload18(const Record<nsString, nsString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload18", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
    if (!returnObj) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (auto& entry : arg.Entries()) {
        auto& recordValue0 = entry.mValue;
        // Control block to let us common up the JS_DefineUCProperty calls when there
        // are different ways to succeed at wrapping the value.
        do {
          if (!xpc::NonVoidStringToJsval(cx, recordValue0, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineUCProperty(cx, returnObj,
                                 entry.mKey.BeginReading(),
                                 entry.mKey.Length(), tmp,
                                 JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnObj);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload18_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload18(const Sequence<nsString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload18", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!xpc::NonVoidStringToJsval(cx, arg[sequenceIdx0], &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload18_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload19(const Sequence<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload19", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.setInt32(int32_t(arg[sequenceIdx0]));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload19_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload19(const Dict& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload19", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!arg.ToObjectInternal(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload19_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload20(const Dict& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload20", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!arg.ToObjectInternal(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload20_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Overload20(const Sequence<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.overload20", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {

    uint32_t length = arg.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          tmp.setInt32(int32_t(arg[sequenceIdx0]));
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[0].setObject(*returnArray);
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->overload20_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassVariadicThirdArg(const nsAString& arg1, int32_t arg2, const nsTArray<OwningNonNull<TestJSImplInterface>>& arg3, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passVariadicThirdArg", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize((3 - 1) + arg3.Length())) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = (3 - 1) + arg3.Length();

  do {
    for (uint32_t idx = 0; idx < arg3.Length(); ++idx) {
      if (!GetOrCreateDOMReflector(cx, arg3[idx], argv[2 + idx])) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      continue;
    }
    break;
  } while (false);

  do {
    argv[1].setInt32(int32_t(arg2));
    break;
  } while (false);

  do {
    nsString mutableStr(arg1);
    if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passVariadicThirdArg_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Prefable10(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.prefable10", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->prefable10_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Prefable11(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.prefable11", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->prefable11_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Prefable13(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.prefable13", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->prefable13_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Prefable17(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.prefable17", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->prefable17_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Prefable18(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.prefable18", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->prefable18_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Prefable19(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.prefable19", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->prefable19_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::Prefable20(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.prefable20", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->prefable20_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ConditionalOnSecureContext5(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.conditionalOnSecureContext5", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->conditionalOnSecureContext5_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ConditionalOnSecureContext6(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.conditionalOnSecureContext6", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->conditionalOnSecureContext6_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ConditionalOnSecureContext7(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.conditionalOnSecureContext7", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->conditionalOnSecureContext7_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ConditionalOnSecureContext8(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.conditionalOnSecureContext8", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->conditionalOnSecureContext8_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassRenamedInterface(nsRenamedInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passRenamedInterface", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (!GetOrCreateDOMReflector(cx, arg, argv[0])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passRenamedInterface_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ThrowingMethod(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.throwingMethod", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->throwingMethod_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::CanOOMMethod(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.canOOMMethod", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->canOOMMethod_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::CeReactionsMethod(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.ceReactionsMethod", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->ceReactionsMethod_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::CeReactionsMethodOverload(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.ceReactionsMethodOverload", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->ceReactionsMethodOverload_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::CeReactionsMethodOverload(const nsAString& bar, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.ceReactionsMethodOverload", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    nsString mutableStr(bar);
    if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->ceReactionsMethodOverload_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassArgsWithDefaults(const Optional<int32_t>& arg1, TestInterface* arg2, const Dict& arg3, double arg4, const Optional<float>& arg5, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passArgsWithDefaults", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(5)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 5;

  do {
    if (arg5.WasPassed()) {
      argv[4].set(JS_NumberValue(double(arg5.Value())));
      break;
    } else if (argc == 5) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[4].setUndefined();
    }
  } while (false);

  do {
    argv[3].set(JS_NumberValue(double(arg4)));
    break;
  } while (false);

  do {
    if (!arg3.ToObjectInternal(cx, argv[2])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  do {
    if (!arg2) {
      argv[1].setNull();
      break;
    }
    if (!GetOrCreateDOMReflector(cx, arg2, argv[1])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  do {
    if (arg1.WasPassed()) {
      argv[0].setInt32(int32_t(arg1.Value()));
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passArgsWithDefaults_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::ToJSON(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.toJSON", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->toJSON_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  JS::Rooted<JSObject*> rvalDecl(cx);
  if (rval.isObject()) {
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
    if ((false) && !CallerSubsumes(rval)) {
      cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("return value of TestJSImplInterface.toJSON");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
    rvalDecl = &rval.toObject();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.toJSON");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.set(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::Dashed_method(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.dashed-method", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->dashed_method_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::NonEnumerableMethod(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.nonEnumerableMethod", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->nonEnumerableMethod_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassAllowSharedArrayBufferViewTypedef(const ArrayBufferView& foo, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passAllowSharedArrayBufferViewTypedef", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setObject(*foo.Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passAllowSharedArrayBufferViewTypedef_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassAllowSharedArrayBufferView(const ArrayBufferView& foo, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passAllowSharedArrayBufferView", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setObject(*foo.Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passAllowSharedArrayBufferView_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassAllowSharedNullableArrayBufferView(const Nullable<ArrayBufferView>& foo, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passAllowSharedNullableArrayBufferView", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (foo.IsNull()) {
      argv[0].setNull();
      break;
    }
    argv[0].setObject(*foo.Value().Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passAllowSharedNullableArrayBufferView_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassAllowSharedArrayBuffer(const ArrayBuffer& foo, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passAllowSharedArrayBuffer", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    argv[0].setObject(*foo.Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passAllowSharedArrayBuffer_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassAllowSharedNullableArrayBuffer(const Nullable<ArrayBuffer>& foo, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passAllowSharedNullableArrayBuffer", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    if (foo.IsNull()) {
      argv[0].setNull();
      break;
    }
    argv[0].setObject(*foo.Value().Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passAllowSharedNullableArrayBuffer_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionArrayBuffer(const StringOrArrayBuffer& foo, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionArrayBuffer", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!foo.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionArrayBuffer_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::PassUnionAllowSharedArrayBuffer(const StringOrMaybeSharedArrayBuffer& foo, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.passUnionAllowSharedArrayBuffer", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 1;

  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!foo.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->passUnionAllowSharedArrayBuffer_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::__Init(const nsAString& str, uint32_t num, const Nullable<bool>& boolArg, TestInterface* iface, int32_t arg1, const DictForConstructor& dict, JS::Handle<JS::Value> any1, JS::Handle<JSObject*> obj1, JS::Handle<JSObject*> obj2, const Sequence<Dict>& seq, JS::Handle<JS::Value> any2, const Optional<JS::Handle<JSObject*>>& obj3, const Optional<JS::Handle<JSObject*>>& obj4, const Uint8Array& typedArr, const ArrayBuffer& arrayBuf, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "__init", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);
  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(15)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  unsigned argc = 15;

  do {
    argv[14].setObject(*arrayBuf.Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[14])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  do {
    argv[13].setObject(*typedArr.Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[13])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  do {
    if (obj4.WasPassed()) {
      if (obj4.Value()) {
                    JS::ExposeObjectToActiveJS(obj4.Value());
                  }
                  argv[12].setObjectOrNull(obj4.Value());
      if (!MaybeWrapObjectOrNullValue(cx, argv[12])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 13) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[12].setUndefined();
    }
  } while (false);

  do {
    if (obj3.WasPassed()) {
      JS::ExposeObjectToActiveJS(obj3.Value());
      argv[11].setObject(*obj3.Value());
      if (!MaybeWrapObjectValue(cx, argv[11])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 12) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[11].setUndefined();
    }
  } while (false);

  do {
    JS::ExposeValueToActiveJS(any2);
    argv[10].set(any2);
    if (!MaybeWrapValue(cx, argv[10])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  do {

    uint32_t length = seq.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!seq[sequenceIdx0].ToObjectInternal(cx, &tmp)) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return;
        }
      }
    }
    argv[9].setObject(*returnArray);
    break;
  } while (false);

  do {
    if (obj2) {
                  JS::ExposeObjectToActiveJS(obj2);
                }
                argv[8].setObjectOrNull(obj2);
    if (!MaybeWrapObjectOrNullValue(cx, argv[8])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  do {
    JS::ExposeObjectToActiveJS(obj1);
    argv[7].setObject(*obj1);
    if (!MaybeWrapObjectValue(cx, argv[7])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  do {
    JS::ExposeValueToActiveJS(any1);
    argv[6].set(any1);
    if (!MaybeWrapValue(cx, argv[6])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  do {
    if (!dict.ToObjectInternal(cx, argv[5])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  do {
    argv[4].setInt32(int32_t(arg1));
    break;
  } while (false);

  do {
    if (!iface) {
      argv[3].setNull();
      break;
    }
    if (!GetOrCreateDOMReflector(cx, iface, argv[3])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  do {
    if (boolArg.IsNull()) {
      argv[2].setNull();
      break;
    }
    argv[2].setBoolean(boolArg.Value());
    break;
  } while (false);

  do {
    argv[1].setNumber(num);
    break;
  } while (false);

  do {
    nsString mutableStr(str);
    if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  JS::Rooted<JS::Value> callable(cx);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->__init_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

bool
TestJSImplInterfaceJSImpl::InitIds(JSContext* cx, TestJSImplInterfaceAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->__init_id.init(cx, "__init") ||
      !atomsCache->passUnionAllowSharedArrayBuffer_id.init(cx, "passUnionAllowSharedArrayBuffer") ||
      !atomsCache->passUnionArrayBuffer_id.init(cx, "passUnionArrayBuffer") ||
      !atomsCache->passAllowSharedNullableArrayBuffer_id.init(cx, "passAllowSharedNullableArrayBuffer") ||
      !atomsCache->passAllowSharedArrayBuffer_id.init(cx, "passAllowSharedArrayBuffer") ||
      !atomsCache->passAllowSharedNullableArrayBufferView_id.init(cx, "passAllowSharedNullableArrayBufferView") ||
      !atomsCache->passAllowSharedArrayBufferView_id.init(cx, "passAllowSharedArrayBufferView") ||
      !atomsCache->passAllowSharedArrayBufferViewTypedef_id.init(cx, "passAllowSharedArrayBufferViewTypedef") ||
      !atomsCache->allowSharedNullableArrayBuffer_id.init(cx, "allowSharedNullableArrayBuffer") ||
      !atomsCache->allowSharedArrayBuffer_id.init(cx, "allowSharedArrayBuffer") ||
      !atomsCache->allowSharedNullableArrayBufferView_id.init(cx, "allowSharedNullableArrayBufferView") ||
      !atomsCache->allowSharedArrayBufferView_id.init(cx, "allowSharedArrayBufferView") ||
      !atomsCache->allowSharedArrayBufferViewTypedef_id.init(cx, "allowSharedArrayBufferViewTypedef") ||
      !atomsCache->nonEnumerableMethod_id.init(cx, "nonEnumerableMethod") ||
      !atomsCache->nonEnumerableAttr_id.init(cx, "nonEnumerableAttr") ||
      !atomsCache->dashed_method_id.init(cx, "dashed-method") ||
      !atomsCache->dashed_attribute_id.init(cx, "dashed-attribute") ||
      !atomsCache->toJSON_id.init(cx, "toJSON") ||
      !atomsCache->toJSONShouldSkipThis3_id.init(cx, "toJSONShouldSkipThis3") ||
      !atomsCache->toJSONShouldSkipThis2_id.init(cx, "toJSONShouldSkipThis2") ||
      !atomsCache->toJSONShouldSkipThis_id.init(cx, "toJSONShouldSkipThis") ||
      !atomsCache->passArgsWithDefaults_id.init(cx, "passArgsWithDefaults") ||
      !atomsCache->ceReactionsAttr_id.init(cx, "ceReactionsAttr") ||
      !atomsCache->ceReactionsMethodOverload_id.init(cx, "ceReactionsMethodOverload") ||
      !atomsCache->ceReactionsMethod_id.init(cx, "ceReactionsMethod") ||
      !atomsCache->canOOMSetterAttr_id.init(cx, "canOOMSetterAttr") ||
      !atomsCache->canOOMGetterAttr_id.init(cx, "canOOMGetterAttr") ||
      !atomsCache->canOOMAttr_id.init(cx, "canOOMAttr") ||
      !atomsCache->canOOMMethod_id.init(cx, "canOOMMethod") ||
      !atomsCache->throwingSetterAttr_id.init(cx, "throwingSetterAttr") ||
      !atomsCache->throwingGetterAttr_id.init(cx, "throwingGetterAttr") ||
      !atomsCache->throwingAttr_id.init(cx, "throwingAttr") ||
      !atomsCache->throwingMethod_id.init(cx, "throwingMethod") ||
      !atomsCache->putForwardsAttr3_id.init(cx, "putForwardsAttr3") ||
      !atomsCache->putForwardsAttr2_id.init(cx, "putForwardsAttr2") ||
      !atomsCache->putForwardsAttr_id.init(cx, "putForwardsAttr") ||
      !atomsCache->passRenamedInterface_id.init(cx, "passRenamedInterface") ||
      !atomsCache->attrWithLenientThis_id.init(cx, "attrWithLenientThis") ||
      !atomsCache->conditionalOnSecureContext8_id.init(cx, "conditionalOnSecureContext8") ||
      !atomsCache->conditionalOnSecureContext7_id.init(cx, "conditionalOnSecureContext7") ||
      !atomsCache->conditionalOnSecureContext6_id.init(cx, "conditionalOnSecureContext6") ||
      !atomsCache->conditionalOnSecureContext5_id.init(cx, "conditionalOnSecureContext5") ||
      !atomsCache->conditionalOnSecureContext4_id.init(cx, "conditionalOnSecureContext4") ||
      !atomsCache->conditionalOnSecureContext3_id.init(cx, "conditionalOnSecureContext3") ||
      !atomsCache->conditionalOnSecureContext2_id.init(cx, "conditionalOnSecureContext2") ||
      !atomsCache->conditionalOnSecureContext1_id.init(cx, "conditionalOnSecureContext1") ||
      !atomsCache->prefable20_id.init(cx, "prefable20") ||
      !atomsCache->prefable19_id.init(cx, "prefable19") ||
      !atomsCache->prefable18_id.init(cx, "prefable18") ||
      !atomsCache->prefable17_id.init(cx, "prefable17") ||
      !atomsCache->prefable16_id.init(cx, "prefable16") ||
      !atomsCache->prefable15_id.init(cx, "prefable15") ||
      !atomsCache->prefable14_id.init(cx, "prefable14") ||
      !atomsCache->prefable13_id.init(cx, "prefable13") ||
      !atomsCache->prefable12_id.init(cx, "prefable12") ||
      !atomsCache->prefable11_id.init(cx, "prefable11") ||
      !atomsCache->prefable10_id.init(cx, "prefable10") ||
      !atomsCache->prefable9_id.init(cx, "prefable9") ||
      !atomsCache->prefable8_id.init(cx, "prefable8") ||
      !atomsCache->prefable7_id.init(cx, "prefable7") ||
      !atomsCache->prefable6_id.init(cx, "prefable6") ||
      !atomsCache->prefable5_id.init(cx, "prefable5") ||
      !atomsCache->prefable4_id.init(cx, "prefable4") ||
      !atomsCache->prefable3_id.init(cx, "prefable3") ||
      !atomsCache->prefable2_id.init(cx, "prefable2") ||
      !atomsCache->prefable1_id.init(cx, "prefable1") ||
      !atomsCache->passVariadicThirdArg_id.init(cx, "passVariadicThirdArg") ||
      !atomsCache->overload20_id.init(cx, "overload20") ||
      !atomsCache->overload19_id.init(cx, "overload19") ||
      !atomsCache->overload18_id.init(cx, "overload18") ||
      !atomsCache->overload17_id.init(cx, "overload17") ||
      !atomsCache->overload16_id.init(cx, "overload16") ||
      !atomsCache->overload15_id.init(cx, "overload15") ||
      !atomsCache->overload14_id.init(cx, "overload14") ||
      !atomsCache->overload13_id.init(cx, "overload13") ||
      !atomsCache->overload12_id.init(cx, "overload12") ||
      !atomsCache->overload11_id.init(cx, "overload11") ||
      !atomsCache->overload10_id.init(cx, "overload10") ||
      !atomsCache->overload9_id.init(cx, "overload9") ||
      !atomsCache->overload8_id.init(cx, "overload8") ||
      !atomsCache->overload7_id.init(cx, "overload7") ||
      !atomsCache->overload6_id.init(cx, "overload6") ||
      !atomsCache->overload5_id.init(cx, "overload5") ||
      !atomsCache->overload4_id.init(cx, "overload4") ||
      !atomsCache->overload3_id.init(cx, "overload3") ||
      !atomsCache->overload2_id.init(cx, "overload2") ||
      !atomsCache->overload1_id.init(cx, "overload1") ||
      !atomsCache->deprecatedMethodWithContext_id.init(cx, "deprecatedMethodWithContext") ||
      !atomsCache->deprecatedMethod_id.init(cx, "deprecatedMethod") ||
      !atomsCache->deprecatedAttribute_id.init(cx, "deprecatedAttribute") ||
      !atomsCache->exerciseTypedefInterfaces3_id.init(cx, "exerciseTypedefInterfaces3") ||
      !atomsCache->exerciseTypedefInterfaces2_id.init(cx, "exerciseTypedefInterfaces2") ||
      !atomsCache->exerciseTypedefInterfaces1_id.init(cx, "exerciseTypedefInterfaces1") ||
      !atomsCache->clampedByteNullable_id.init(cx, "clampedByteNullable") ||
      !atomsCache->clampedByte_id.init(cx, "clampedByte") ||
      !atomsCache->enforcedByteNullable_id.init(cx, "enforcedByteNullable") ||
      !atomsCache->enforcedByte_id.init(cx, "enforcedByte") ||
      !atomsCache->doClampNullable_id.init(cx, "doClampNullable") ||
      !atomsCache->doClamp_id.init(cx, "doClamp") ||
      !atomsCache->doEnforceRangeNullable_id.init(cx, "doEnforceRangeNullable") ||
      !atomsCache->doEnforceRange_id.init(cx, "doEnforceRange") ||
      !atomsCache->dontEnforceRangeOrClamp_id.init(cx, "dontEnforceRangeOrClamp") ||
      !atomsCache->passVariadicDictionary_id.init(cx, "passVariadicDictionary") ||
      !atomsCache->receiveDictContainingSequence_id.init(cx, "receiveDictContainingSequence") ||
      !atomsCache->passDictContainingSequence_id.init(cx, "passDictContainingSequence") ||
      !atomsCache->passDictContainingDict_id.init(cx, "passDictContainingDict") ||
      !atomsCache->passDictionaryOrLong_id.init(cx, "passDictionaryOrLong") ||
      !atomsCache->passRecordOfDictionaries_id.init(cx, "passRecordOfDictionaries") ||
      !atomsCache->passSequenceOfDictionaries_id.init(cx, "passSequenceOfDictionaries") ||
      !atomsCache->passOtherDictionary_id.init(cx, "passOtherDictionary") ||
      !atomsCache->receiveNullableDictionary_id.init(cx, "receiveNullableDictionary") ||
      !atomsCache->receiveDictionary_id.init(cx, "receiveDictionary") ||
      !atomsCache->passDictionary2_id.init(cx, "passDictionary2") ||
      !atomsCache->passDictionary_id.init(cx, "passDictionary") ||
      !atomsCache->attributeRenamedTo_id.init(cx, "attributeRenamedTo") ||
      !atomsCache->attributeGetterRenamedTo_id.init(cx, "attributeGetterRenamedTo") ||
      !atomsCache->methodRenamedTo_id.init(cx, "methodRenamedTo") ||
      !atomsCache->receiveAddrefedPromise_id.init(cx, "receiveAddrefedPromise") ||
      !atomsCache->receivePromise_id.init(cx, "receivePromise") ||
      !atomsCache->passPromiseSequence_id.init(cx, "passPromiseSequence") ||
      !atomsCache->passOptionalPromise_id.init(cx, "passOptionalPromise") ||
      !atomsCache->passPromise_id.init(cx, "passPromise") ||
      !atomsCache->writableNullableUnion_id.init(cx, "writableNullableUnion") ||
      !atomsCache->writableUnionContainingNull_id.init(cx, "writableUnionContainingNull") ||
      !atomsCache->writableUnion_id.init(cx, "writableUnion") ||
      !atomsCache->receiveNullableUnion2_id.init(cx, "receiveNullableUnion2") ||
      !atomsCache->receiveNullableUnion_id.init(cx, "receiveNullableUnion") ||
      !atomsCache->receiveUnionContainingNull_id.init(cx, "receiveUnionContainingNull") ||
      !atomsCache->receiveUnion2_id.init(cx, "receiveUnion2") ||
      !atomsCache->receiveUnion_id.init(cx, "receiveUnion") ||
      !atomsCache->passRecordOfUnions_id.init(cx, "passRecordOfUnions") ||
      !atomsCache->passVariadicNullableUnion_id.init(cx, "passVariadicNullableUnion") ||
      !atomsCache->passSequenceOfNullableUnions_id.init(cx, "passSequenceOfNullableUnions") ||
      !atomsCache->passVariadicUnion_id.init(cx, "passVariadicUnion") ||
      !atomsCache->passSequenceOfUnions2_id.init(cx, "passSequenceOfUnions2") ||
      !atomsCache->passSequenceOfUnions_id.init(cx, "passSequenceOfUnions") ||
      !atomsCache->passNullableUnionWithDefaultValue28_id.init(cx, "passNullableUnionWithDefaultValue28") ||
      !atomsCache->passNullableUnionWithDefaultValue27_id.init(cx, "passNullableUnionWithDefaultValue27") ||
      !atomsCache->passNullableUnionWithDefaultValue26_id.init(cx, "passNullableUnionWithDefaultValue26") ||
      !atomsCache->passNullableUnionWithDefaultValue25_id.init(cx, "passNullableUnionWithDefaultValue25") ||
      !atomsCache->passNullableUnionWithDefaultValue24_id.init(cx, "passNullableUnionWithDefaultValue24") ||
      !atomsCache->passNullableUnionWithDefaultValue23_id.init(cx, "passNullableUnionWithDefaultValue23") ||
      !atomsCache->passNullableUnionWithDefaultValue22_id.init(cx, "passNullableUnionWithDefaultValue22") ||
      !atomsCache->passNullableUnionWithDefaultValue21_id.init(cx, "passNullableUnionWithDefaultValue21") ||
      !atomsCache->passNullableUnionWithDefaultValue20_id.init(cx, "passNullableUnionWithDefaultValue20") ||
      !atomsCache->passNullableUnionWithDefaultValue19_id.init(cx, "passNullableUnionWithDefaultValue19") ||
      !atomsCache->passNullableUnionWithDefaultValue18_id.init(cx, "passNullableUnionWithDefaultValue18") ||
      !atomsCache->passNullableUnionWithDefaultValue17_id.init(cx, "passNullableUnionWithDefaultValue17") ||
      !atomsCache->passNullableUnionWithDefaultValue16_id.init(cx, "passNullableUnionWithDefaultValue16") ||
      !atomsCache->passNullableUnionWithDefaultValue15_id.init(cx, "passNullableUnionWithDefaultValue15") ||
      !atomsCache->passNullableUnionWithDefaultValue14_id.init(cx, "passNullableUnionWithDefaultValue14") ||
      !atomsCache->passNullableUnionWithDefaultValue13_id.init(cx, "passNullableUnionWithDefaultValue13") ||
      !atomsCache->passNullableUnionWithDefaultValue12_id.init(cx, "passNullableUnionWithDefaultValue12") ||
      !atomsCache->passNullableUnionWithDefaultValue11_id.init(cx, "passNullableUnionWithDefaultValue11") ||
      !atomsCache->passNullableUnionWithDefaultValue10_id.init(cx, "passNullableUnionWithDefaultValue10") ||
      !atomsCache->passNullableUnionWithDefaultValue9_id.init(cx, "passNullableUnionWithDefaultValue9") ||
      !atomsCache->passNullableUnionWithDefaultValue8_id.init(cx, "passNullableUnionWithDefaultValue8") ||
      !atomsCache->passNullableUnionWithDefaultValue7_id.init(cx, "passNullableUnionWithDefaultValue7") ||
      !atomsCache->passNullableUnionWithDefaultValue6_id.init(cx, "passNullableUnionWithDefaultValue6") ||
      !atomsCache->passNullableUnionWithDefaultValue5_id.init(cx, "passNullableUnionWithDefaultValue5") ||
      !atomsCache->passNullableUnionWithDefaultValue4_id.init(cx, "passNullableUnionWithDefaultValue4") ||
      !atomsCache->passNullableUnionWithDefaultValue3_id.init(cx, "passNullableUnionWithDefaultValue3") ||
      !atomsCache->passNullableUnionWithDefaultValue2_id.init(cx, "passNullableUnionWithDefaultValue2") ||
      !atomsCache->passNullableUnionWithDefaultValue1_id.init(cx, "passNullableUnionWithDefaultValue1") ||
      !atomsCache->passUnionWithDefaultValue25_id.init(cx, "passUnionWithDefaultValue25") ||
      !atomsCache->passUnionWithDefaultValue24_id.init(cx, "passUnionWithDefaultValue24") ||
      !atomsCache->passUnionWithDefaultValue23_id.init(cx, "passUnionWithDefaultValue23") ||
      !atomsCache->passUnionWithDefaultValue22_id.init(cx, "passUnionWithDefaultValue22") ||
      !atomsCache->passUnionWithDefaultValue21_id.init(cx, "passUnionWithDefaultValue21") ||
      !atomsCache->passUnionWithDefaultValue20_id.init(cx, "passUnionWithDefaultValue20") ||
      !atomsCache->passUnionWithDefaultValue19_id.init(cx, "passUnionWithDefaultValue19") ||
      !atomsCache->passUnionWithDefaultValue18_id.init(cx, "passUnionWithDefaultValue18") ||
      !atomsCache->passUnionWithDefaultValue17_id.init(cx, "passUnionWithDefaultValue17") ||
      !atomsCache->passUnionWithDefaultValue16_id.init(cx, "passUnionWithDefaultValue16") ||
      !atomsCache->passUnionWithDefaultValue15_id.init(cx, "passUnionWithDefaultValue15") ||
      !atomsCache->passUnionWithDefaultValue14_id.init(cx, "passUnionWithDefaultValue14") ||
      !atomsCache->passUnionWithDefaultValue13_id.init(cx, "passUnionWithDefaultValue13") ||
      !atomsCache->passUnionWithDefaultValue12_id.init(cx, "passUnionWithDefaultValue12") ||
      !atomsCache->passUnionWithDefaultValue11_id.init(cx, "passUnionWithDefaultValue11") ||
      !atomsCache->passUnionWithDefaultValue10_id.init(cx, "passUnionWithDefaultValue10") ||
      !atomsCache->passUnionWithDefaultValue9_id.init(cx, "passUnionWithDefaultValue9") ||
      !atomsCache->passUnionWithDefaultValue8_id.init(cx, "passUnionWithDefaultValue8") ||
      !atomsCache->passUnionWithDefaultValue7_id.init(cx, "passUnionWithDefaultValue7") ||
      !atomsCache->passUnionWithDefaultValue6_id.init(cx, "passUnionWithDefaultValue6") ||
      !atomsCache->passUnionWithDefaultValue5_id.init(cx, "passUnionWithDefaultValue5") ||
      !atomsCache->passUnionWithDefaultValue4_id.init(cx, "passUnionWithDefaultValue4") ||
      !atomsCache->passUnionWithDefaultValue3_id.init(cx, "passUnionWithDefaultValue3") ||
      !atomsCache->passUnionWithDefaultValue2_id.init(cx, "passUnionWithDefaultValue2") ||
      !atomsCache->passUnionWithDefaultValue1_id.init(cx, "passUnionWithDefaultValue1") ||
      !atomsCache->passUnionWithObject_id.init(cx, "passUnionWithObject") ||
      !atomsCache->passUnionWithEnum_id.init(cx, "passUnionWithEnum") ||
      !atomsCache->passUnionWithString_id.init(cx, "passUnionWithString") ||
      !atomsCache->passUnionWithArrayBuffer_id.init(cx, "passUnionWithArrayBuffer") ||
      !atomsCache->passOptionalNullableUnionWithDefaultValue_id.init(cx, "passOptionalNullableUnionWithDefaultValue") ||
      !atomsCache->passOptionalNullableUnion_id.init(cx, "passOptionalNullableUnion") ||
      !atomsCache->passOptionalUnion_id.init(cx, "passOptionalUnion") ||
      !atomsCache->passNullableUnion_id.init(cx, "passNullableUnion") ||
      !atomsCache->passUnionWithNullable_id.init(cx, "passUnionWithNullable") ||
      !atomsCache->passUnion_id.init(cx, "passUnion") ||
      !atomsCache->receiveNullableObject_id.init(cx, "receiveNullableObject") ||
      !atomsCache->receiveObject_id.init(cx, "receiveObject") ||
      !atomsCache->passRecordOfObject_id.init(cx, "passRecordOfObject") ||
      !atomsCache->passOptionalNullableSequenceOfNullableSequenceOfNullableObject_id.init(cx, "passOptionalNullableSequenceOfNullableSequenceOfNullableObject") ||
      !atomsCache->passOptionalNullableSequenceOfNullableSequenceOfObject_id.init(cx, "passOptionalNullableSequenceOfNullableSequenceOfObject") ||
      !atomsCache->passNullableSequenceOfObject_id.init(cx, "passNullableSequenceOfObject") ||
      !atomsCache->passSequenceOfNullableObject_id.init(cx, "passSequenceOfNullableObject") ||
      !atomsCache->passSequenceOfObject_id.init(cx, "passSequenceOfObject") ||
      !atomsCache->passOptionalNullableObjectWithDefaultValue_id.init(cx, "passOptionalNullableObjectWithDefaultValue") ||
      !atomsCache->passOptionalNullableObject_id.init(cx, "passOptionalNullableObject") ||
      !atomsCache->passOptionalObject_id.init(cx, "passOptionalObject") ||
      !atomsCache->passVariadicNullableObject_id.init(cx, "passVariadicNullableObject") ||
      !atomsCache->passNullableObject_id.init(cx, "passNullableObject") ||
      !atomsCache->passVariadicObject_id.init(cx, "passVariadicObject") ||
      !atomsCache->passObject_id.init(cx, "passObject") ||
      !atomsCache->receiveAny_id.init(cx, "receiveAny") ||
      !atomsCache->passOptionalNullableSequenceOfNullableRecordOfAny_id.init(cx, "passOptionalNullableSequenceOfNullableRecordOfAny") ||
      !atomsCache->passOptionalNullableRecordOfNullableSequenceOfAny_id.init(cx, "passOptionalNullableRecordOfNullableSequenceOfAny") ||
      !atomsCache->passOptionalNullableRecordOfNullableRecordOfAny_id.init(cx, "passOptionalNullableRecordOfNullableRecordOfAny") ||
      !atomsCache->passNullableRecordOfNullableRecordOfAny_id.init(cx, "passNullableRecordOfNullableRecordOfAny") ||
      !atomsCache->passRecordOfNullableRecordOfAny_id.init(cx, "passRecordOfNullableRecordOfAny") ||
      !atomsCache->passRecordOfRecordOfAny_id.init(cx, "passRecordOfRecordOfAny") ||
      !atomsCache->passOptionalRecordOfAnyWithDefaultValue_id.init(cx, "passOptionalRecordOfAnyWithDefaultValue") ||
      !atomsCache->passOptionalNullableRecordOfAny_id.init(cx, "passOptionalNullableRecordOfAny") ||
      !atomsCache->passOptionalRecordOfAny_id.init(cx, "passOptionalRecordOfAny") ||
      !atomsCache->passNullableRecordOfAny_id.init(cx, "passNullableRecordOfAny") ||
      !atomsCache->passRecordOfAny_id.init(cx, "passRecordOfAny") ||
      !atomsCache->passOptionalNullableSequenceOfNullableSequenceOfAny_id.init(cx, "passOptionalNullableSequenceOfNullableSequenceOfAny") ||
      !atomsCache->passNullableSequenceOfNullableSequenceOfAny_id.init(cx, "passNullableSequenceOfNullableSequenceOfAny") ||
      !atomsCache->passSequenceOfNullableSequenceOfAny_id.init(cx, "passSequenceOfNullableSequenceOfAny") ||
      !atomsCache->passSequenceOfSequenceOfAny_id.init(cx, "passSequenceOfSequenceOfAny") ||
      !atomsCache->passOptionalSequenceOfAnyWithDefaultValue_id.init(cx, "passOptionalSequenceOfAnyWithDefaultValue") ||
      !atomsCache->passOptionalNullableSequenceOfAny_id.init(cx, "passOptionalNullableSequenceOfAny") ||
      !atomsCache->passOptionalSequenceOfAny_id.init(cx, "passOptionalSequenceOfAny") ||
      !atomsCache->passNullableSequenceOfAny_id.init(cx, "passNullableSequenceOfAny") ||
      !atomsCache->passSequenceOfAny_id.init(cx, "passSequenceOfAny") ||
      !atomsCache->passAnyDefaultNull_id.init(cx, "passAnyDefaultNull") ||
      !atomsCache->passOptionalAny_id.init(cx, "passOptionalAny") ||
      !atomsCache->passVariadicAny_id.init(cx, "passVariadicAny") ||
      !atomsCache->passAny_id.init(cx, "passAny") ||
      !atomsCache->passOptionalNullableTreatAsNullCallbackWithDefaultValue_id.init(cx, "passOptionalNullableTreatAsNullCallbackWithDefaultValue") ||
      !atomsCache->receiveNullableCallback_id.init(cx, "receiveNullableCallback") ||
      !atomsCache->receiveCallback_id.init(cx, "receiveCallback") ||
      !atomsCache->passOptionalNullableCallbackWithDefaultValue_id.init(cx, "passOptionalNullableCallbackWithDefaultValue") ||
      !atomsCache->passOptionalNullableCallback_id.init(cx, "passOptionalNullableCallback") ||
      !atomsCache->passOptionalCallback_id.init(cx, "passOptionalCallback") ||
      !atomsCache->passNullableCallback_id.init(cx, "passNullableCallback") ||
      !atomsCache->passCallback_id.init(cx, "passCallback") ||
      !atomsCache->readonlyEnumAttribute_id.init(cx, "readonlyEnumAttribute") ||
      !atomsCache->enumAttribute_id.init(cx, "enumAttribute") ||
      !atomsCache->receiveNullableEnum_id.init(cx, "receiveNullableEnum") ||
      !atomsCache->receiveEnum_id.init(cx, "receiveEnum") ||
      !atomsCache->passOptionalNullableEnumWithDefaultValue2_id.init(cx, "passOptionalNullableEnumWithDefaultValue2") ||
      !atomsCache->passOptionalNullableEnumWithDefaultValue_id.init(cx, "passOptionalNullableEnumWithDefaultValue") ||
      !atomsCache->passOptionalNullableEnum_id.init(cx, "passOptionalNullableEnum") ||
      !atomsCache->passEnumWithDefault_id.init(cx, "passEnumWithDefault") ||
      !atomsCache->passOptionalEnum_id.init(cx, "passOptionalEnum") ||
      !atomsCache->passNullableEnum_id.init(cx, "passNullableEnum") ||
      !atomsCache->passEnum_id.init(cx, "passEnum") ||
      !atomsCache->jsStringAttr_id.init(cx, "jsStringAttr") ||
      !atomsCache->readonlyJSStringAttr_id.init(cx, "readonlyJSStringAttr") ||
      !atomsCache->receiveJSString_id.init(cx, "receiveJSString") ||
      !atomsCache->passOptionalJSStringWithDefaultValue_id.init(cx, "passOptionalJSStringWithDefaultValue") ||
      !atomsCache->passJSString_id.init(cx, "passJSString") ||
      !atomsCache->receiveSVS_id.init(cx, "receiveSVS") ||
      !atomsCache->passVariadicSVS_id.init(cx, "passVariadicSVS") ||
      !atomsCache->passOptionalNullableSVSWithDefaultValue_id.init(cx, "passOptionalNullableSVSWithDefaultValue") ||
      !atomsCache->passOptionalNullableSVS_id.init(cx, "passOptionalNullableSVS") ||
      !atomsCache->passOptionalSVSWithDefaultValue_id.init(cx, "passOptionalSVSWithDefaultValue") ||
      !atomsCache->passOptionalSVS_id.init(cx, "passOptionalSVS") ||
      !atomsCache->passNullableSVS_id.init(cx, "passNullableSVS") ||
      !atomsCache->passSVS_id.init(cx, "passSVS") ||
      !atomsCache->passOptionalUnionUTF8StringWithDefaultValue_id.init(cx, "passOptionalUnionUTF8StringWithDefaultValue") ||
      !atomsCache->passOptionalUnionUTF8String_id.init(cx, "passOptionalUnionUTF8String") ||
      !atomsCache->passUnionUTF8String_id.init(cx, "passUnionUTF8String") ||
      !atomsCache->passVariadicUTF8String_id.init(cx, "passVariadicUTF8String") ||
      !atomsCache->passOptionalNullableUTF8StringWithDefaultValue_id.init(cx, "passOptionalNullableUTF8StringWithDefaultValue") ||
      !atomsCache->passOptionalNullableUTF8String_id.init(cx, "passOptionalNullableUTF8String") ||
      !atomsCache->passOptionalUTF8StringWithDefaultValue_id.init(cx, "passOptionalUTF8StringWithDefaultValue") ||
      !atomsCache->passOptionalUTF8String_id.init(cx, "passOptionalUTF8String") ||
      !atomsCache->passNullableUTF8String_id.init(cx, "passNullableUTF8String") ||
      !atomsCache->passUTF8String_id.init(cx, "passUTF8String") ||
      !atomsCache->passOptionalUnionByteStringWithDefaultValue_id.init(cx, "passOptionalUnionByteStringWithDefaultValue") ||
      !atomsCache->passOptionalUnionByteString_id.init(cx, "passOptionalUnionByteString") ||
      !atomsCache->passUnionByteString_id.init(cx, "passUnionByteString") ||
      !atomsCache->passVariadicByteString_id.init(cx, "passVariadicByteString") ||
      !atomsCache->passOptionalNullableByteStringWithDefaultValue_id.init(cx, "passOptionalNullableByteStringWithDefaultValue") ||
      !atomsCache->passOptionalNullableByteString_id.init(cx, "passOptionalNullableByteString") ||
      !atomsCache->passOptionalByteStringWithDefaultValue_id.init(cx, "passOptionalByteStringWithDefaultValue") ||
      !atomsCache->passOptionalByteString_id.init(cx, "passOptionalByteString") ||
      !atomsCache->passNullableByteString_id.init(cx, "passNullableByteString") ||
      !atomsCache->passByteString_id.init(cx, "passByteString") ||
      !atomsCache->passVariadicString_id.init(cx, "passVariadicString") ||
      !atomsCache->passOptionalNullableStringWithDefaultValue_id.init(cx, "passOptionalNullableStringWithDefaultValue") ||
      !atomsCache->passOptionalNullableString_id.init(cx, "passOptionalNullableString") ||
      !atomsCache->passOptionalStringWithDefaultValue_id.init(cx, "passOptionalStringWithDefaultValue") ||
      !atomsCache->passOptionalString_id.init(cx, "passOptionalString") ||
      !atomsCache->passNullableString_id.init(cx, "passNullableString") ||
      !atomsCache->passString_id.init(cx, "passString") ||
      !atomsCache->uint8ArrayAttr_id.init(cx, "uint8ArrayAttr") ||
      !atomsCache->receiveUint8Array_id.init(cx, "receiveUint8Array") ||
      !atomsCache->passVariadicNullableTypedArray_id.init(cx, "passVariadicNullableTypedArray") ||
      !atomsCache->passVariadicTypedArray_id.init(cx, "passVariadicTypedArray") ||
      !atomsCache->passRecordOfNullableArrayBuffers_id.init(cx, "passRecordOfNullableArrayBuffers") ||
      !atomsCache->passRecordOfArrayBuffers_id.init(cx, "passRecordOfArrayBuffers") ||
      !atomsCache->passSequenceOfNullableArrayBuffers_id.init(cx, "passSequenceOfNullableArrayBuffers") ||
      !atomsCache->passSequenceOfArrayBuffers_id.init(cx, "passSequenceOfArrayBuffers") ||
      !atomsCache->passFloat64Array_id.init(cx, "passFloat64Array") ||
      !atomsCache->passFloat32Array_id.init(cx, "passFloat32Array") ||
      !atomsCache->passUint8ClampedArray_id.init(cx, "passUint8ClampedArray") ||
      !atomsCache->passUint32Array_id.init(cx, "passUint32Array") ||
      !atomsCache->passUint16Array_id.init(cx, "passUint16Array") ||
      !atomsCache->passUint8Array_id.init(cx, "passUint8Array") ||
      !atomsCache->passInt32Array_id.init(cx, "passInt32Array") ||
      !atomsCache->passInt16Array_id.init(cx, "passInt16Array") ||
      !atomsCache->passInt8Array_id.init(cx, "passInt8Array") ||
      !atomsCache->passArrayBufferView_id.init(cx, "passArrayBufferView") ||
      !atomsCache->passOptionalNullableArrayBufferWithDefaultValue_id.init(cx, "passOptionalNullableArrayBufferWithDefaultValue") ||
      !atomsCache->passOptionalNullableArrayBuffer_id.init(cx, "passOptionalNullableArrayBuffer") ||
      !atomsCache->passOptionalArrayBuffer_id.init(cx, "passOptionalArrayBuffer") ||
      !atomsCache->passNullableArrayBuffer_id.init(cx, "passNullableArrayBuffer") ||
      !atomsCache->passArrayBuffer_id.init(cx, "passArrayBuffer") ||
      !atomsCache->receiveAnyRecord_id.init(cx, "receiveAnyRecord") ||
      !atomsCache->receiveNullableRecordOfNullableInts_id.init(cx, "receiveNullableRecordOfNullableInts") ||
      !atomsCache->receiveRecordOfNullableInts_id.init(cx, "receiveRecordOfNullableInts") ||
      !atomsCache->receiveNullableRecord_id.init(cx, "receiveNullableRecord") ||
      !atomsCache->receiveRecord_id.init(cx, "receiveRecord") ||
      !atomsCache->passRecordOfRecords_id.init(cx, "passRecordOfRecords") ||
      !atomsCache->passUTF8StringRecord_id.init(cx, "passUTF8StringRecord") ||
      !atomsCache->passByteStringRecord_id.init(cx, "passByteStringRecord") ||
      !atomsCache->passStringRecord_id.init(cx, "passStringRecord") ||
      !atomsCache->passNullableExternalInterfaceRecord_id.init(cx, "passNullableExternalInterfaceRecord") ||
      !atomsCache->passExternalInterfaceRecord_id.init(cx, "passExternalInterfaceRecord") ||
      !atomsCache->passOptionalObjectRecord_id.init(cx, "passOptionalObjectRecord") ||
      !atomsCache->passOptionalNullableRecordWithDefaultValue_id.init(cx, "passOptionalNullableRecordWithDefaultValue") ||
      !atomsCache->passOptionalNullableRecord_id.init(cx, "passOptionalNullableRecord") ||
      !atomsCache->passOptionalRecord_id.init(cx, "passOptionalRecord") ||
      !atomsCache->passNullableCastableObjectNullableRecord_id.init(cx, "passNullableCastableObjectNullableRecord") ||
      !atomsCache->passCastableObjectNullableRecord_id.init(cx, "passCastableObjectNullableRecord") ||
      !atomsCache->passNullableCastableObjectRecord_id.init(cx, "passNullableCastableObjectRecord") ||
      !atomsCache->passCastableObjectRecord_id.init(cx, "passCastableObjectRecord") ||
      !atomsCache->passOptionalNullableRecordOfNullableInts_id.init(cx, "passOptionalNullableRecordOfNullableInts") ||
      !atomsCache->passOptionalRecordOfNullableInts_id.init(cx, "passOptionalRecordOfNullableInts") ||
      !atomsCache->passRecordOfNullableInts_id.init(cx, "passRecordOfNullableInts") ||
      !atomsCache->passNullableRecord_id.init(cx, "passNullableRecord") ||
      !atomsCache->passRecord_id.init(cx, "passRecord") ||
      !atomsCache->passSequenceOfSequencesOfSequences_id.init(cx, "passSequenceOfSequencesOfSequences") ||
      !atomsCache->passSequenceOfSequences_id.init(cx, "passSequenceOfSequences") ||
      !atomsCache->receiveNullableObjectSequence_id.init(cx, "receiveNullableObjectSequence") ||
      !atomsCache->receiveObjectSequence_id.init(cx, "receiveObjectSequence") ||
      !atomsCache->receiveNullableAnySequence_id.init(cx, "receiveNullableAnySequence") ||
      !atomsCache->receiveAnySequence_id.init(cx, "receiveAnySequence") ||
      !atomsCache->receiveUTF8StringSequence_id.init(cx, "receiveUTF8StringSequence") ||
      !atomsCache->receiveByteStringSequence_id.init(cx, "receiveByteStringSequence") ||
      !atomsCache->receiveStringSequence_id.init(cx, "receiveStringSequence") ||
      !atomsCache->passNullableExternalInterfaceSequence_id.init(cx, "passNullableExternalInterfaceSequence") ||
      !atomsCache->passExternalInterfaceSequence_id.init(cx, "passExternalInterfaceSequence") ||
      !atomsCache->passOptionalObjectSequence_id.init(cx, "passOptionalObjectSequence") ||
      !atomsCache->passOptionalNullableSequenceWithDefaultValue2_id.init(cx, "passOptionalNullableSequenceWithDefaultValue2") ||
      !atomsCache->passOptionalNullableSequenceWithDefaultValue_id.init(cx, "passOptionalNullableSequenceWithDefaultValue") ||
      !atomsCache->passOptionalNullableSequence_id.init(cx, "passOptionalNullableSequence") ||
      !atomsCache->passOptionalSequenceWithDefaultValue_id.init(cx, "passOptionalSequenceWithDefaultValue") ||
      !atomsCache->passOptionalSequence_id.init(cx, "passOptionalSequence") ||
      !atomsCache->passNullableCastableObjectNullableSequence_id.init(cx, "passNullableCastableObjectNullableSequence") ||
      !atomsCache->passCastableObjectNullableSequence_id.init(cx, "passCastableObjectNullableSequence") ||
      !atomsCache->passNullableCastableObjectSequence_id.init(cx, "passNullableCastableObjectSequence") ||
      !atomsCache->passCastableObjectSequence_id.init(cx, "passCastableObjectSequence") ||
      !atomsCache->receiveWeakNullableCastableObjectNullableSequence_id.init(cx, "receiveWeakNullableCastableObjectNullableSequence") ||
      !atomsCache->receiveWeakCastableObjectNullableSequence_id.init(cx, "receiveWeakCastableObjectNullableSequence") ||
      !atomsCache->receiveWeakNullableCastableObjectSequence_id.init(cx, "receiveWeakNullableCastableObjectSequence") ||
      !atomsCache->receiveWeakCastableObjectSequence_id.init(cx, "receiveWeakCastableObjectSequence") ||
      !atomsCache->receiveNullableCastableObjectNullableSequence_id.init(cx, "receiveNullableCastableObjectNullableSequence") ||
      !atomsCache->receiveCastableObjectNullableSequence_id.init(cx, "receiveCastableObjectNullableSequence") ||
      !atomsCache->receiveNullableCallbackObjectSequence_id.init(cx, "receiveNullableCallbackObjectSequence") ||
      !atomsCache->receiveNullableCastableObjectSequence_id.init(cx, "receiveNullableCastableObjectSequence") ||
      !atomsCache->receiveCallbackObjectSequence_id.init(cx, "receiveCallbackObjectSequence") ||
      !atomsCache->receiveCastableObjectSequence_id.init(cx, "receiveCastableObjectSequence") ||
      !atomsCache->passOptionalNullableSequenceOfNullableInts_id.init(cx, "passOptionalNullableSequenceOfNullableInts") ||
      !atomsCache->passOptionalSequenceOfNullableInts_id.init(cx, "passOptionalSequenceOfNullableInts") ||
      !atomsCache->passSequenceOfNullableInts_id.init(cx, "passSequenceOfNullableInts") ||
      !atomsCache->passNullableSequence_id.init(cx, "passNullableSequence") ||
      !atomsCache->passSequence_id.init(cx, "passSequence") ||
      !atomsCache->receiveNullableSequenceOfNullableInts_id.init(cx, "receiveNullableSequenceOfNullableInts") ||
      !atomsCache->receiveSequenceOfNullableInts_id.init(cx, "receiveSequenceOfNullableInts") ||
      !atomsCache->receiveNullableSequence_id.init(cx, "receiveNullableSequence") ||
      !atomsCache->receiveSequence_id.init(cx, "receiveSequence") ||
      !atomsCache->passOptionalCallbackInterfaceWithDefault_id.init(cx, "passOptionalCallbackInterfaceWithDefault") ||
      !atomsCache->passOptionalNonNullCallbackInterface_id.init(cx, "passOptionalNonNullCallbackInterface") ||
      !atomsCache->passOptionalCallbackInterface_id.init(cx, "passOptionalCallbackInterface") ||
      !atomsCache->nullableCallbackInterface_id.init(cx, "nullableCallbackInterface") ||
      !atomsCache->nonNullCallbackInterface_id.init(cx, "nonNullCallbackInterface") ||
      !atomsCache->passNullableCallbackInterface_id.init(cx, "passNullableCallbackInterface") ||
      !atomsCache->passCallbackInterface_id.init(cx, "passCallbackInterface") ||
      !atomsCache->receiveWeakNullableCallbackInterface_id.init(cx, "receiveWeakNullableCallbackInterface") ||
      !atomsCache->receiveWeakCallbackInterface_id.init(cx, "receiveWeakCallbackInterface") ||
      !atomsCache->receiveNullableCallbackInterface_id.init(cx, "receiveNullableCallbackInterface") ||
      !atomsCache->receiveCallbackInterface_id.init(cx, "receiveCallbackInterface") ||
      !atomsCache->passOptionalExternalWithDefault_id.init(cx, "passOptionalExternalWithDefault") ||
      !atomsCache->passOptionalNonNullExternal_id.init(cx, "passOptionalNonNullExternal") ||
      !atomsCache->passOptionalExternal_id.init(cx, "passOptionalExternal") ||
      !atomsCache->nullableExternal_id.init(cx, "nullableExternal") ||
      !atomsCache->nonNullExternal_id.init(cx, "nonNullExternal") ||
      !atomsCache->passNullableExternal_id.init(cx, "passNullableExternal") ||
      !atomsCache->passExternal_id.init(cx, "passExternal") ||
      !atomsCache->receiveWeakNullableExternal_id.init(cx, "receiveWeakNullableExternal") ||
      !atomsCache->receiveWeakExternal_id.init(cx, "receiveWeakExternal") ||
      !atomsCache->receiveNullableExternal_id.init(cx, "receiveNullableExternal") ||
      !atomsCache->receiveExternal_id.init(cx, "receiveExternal") ||
      !atomsCache->receiveNullableNonWrapperCacheInterfaceNullableSequence_id.init(cx, "receiveNullableNonWrapperCacheInterfaceNullableSequence") ||
      !atomsCache->receiveNonWrapperCacheInterfaceNullableSequence_id.init(cx, "receiveNonWrapperCacheInterfaceNullableSequence") ||
      !atomsCache->receiveNullableNonWrapperCacheInterfaceSequence_id.init(cx, "receiveNullableNonWrapperCacheInterfaceSequence") ||
      !atomsCache->receiveNonWrapperCacheInterfaceSequence_id.init(cx, "receiveNonWrapperCacheInterfaceSequence") ||
      !atomsCache->receiveNullableNonWrapperCacheInterface_id.init(cx, "receiveNullableNonWrapperCacheInterface") ||
      !atomsCache->receiveNonWrapperCacheInterface_id.init(cx, "receiveNonWrapperCacheInterface") ||
      !atomsCache->passOptionalSelfWithDefault_id.init(cx, "passOptionalSelfWithDefault") ||
      !atomsCache->passOptionalNonNullSelf_id.init(cx, "passOptionalNonNullSelf") ||
      !atomsCache->passOptionalSelf_id.init(cx, "passOptionalSelf") ||
      !atomsCache->nullableSelf_id.init(cx, "nullableSelf") ||
      !atomsCache->nonNullSelf_id.init(cx, "nonNullSelf") ||
      !atomsCache->passNullableSelf_id.init(cx, "passNullableSelf") ||
      !atomsCache->passSelf_id.init(cx, "passSelf") ||
      !atomsCache->receiveWeakNullableSelf_id.init(cx, "receiveWeakNullableSelf") ||
      !atomsCache->receiveWeakSelf_id.init(cx, "receiveWeakSelf") ||
      !atomsCache->receiveNullableSelf_id.init(cx, "receiveNullableSelf") ||
      !atomsCache->receiveSelf_id.init(cx, "receiveSelf") ||
      !atomsCache->lenientDoubleAttr_id.init(cx, "lenientDoubleAttr") ||
      !atomsCache->lenientFloatAttr_id.init(cx, "lenientFloatAttr") ||
      !atomsCache->passLenientFloat_id.init(cx, "passLenientFloat") ||
      !atomsCache->passFloat_id.init(cx, "passFloat") ||
      !atomsCache->writableNullableUnrestrictedDouble_id.init(cx, "writableNullableUnrestrictedDouble") ||
      !atomsCache->writableNullableDouble_id.init(cx, "writableNullableDouble") ||
      !atomsCache->writableUnrestrictedDouble_id.init(cx, "writableUnrestrictedDouble") ||
      !atomsCache->writableDouble_id.init(cx, "writableDouble") ||
      !atomsCache->writableNullableUnrestrictedFloat_id.init(cx, "writableNullableUnrestrictedFloat") ||
      !atomsCache->writableNullableFloat_id.init(cx, "writableNullableFloat") ||
      !atomsCache->writableUnrestrictedFloat_id.init(cx, "writableUnrestrictedFloat") ||
      !atomsCache->writableFloat_id.init(cx, "writableFloat") ||
      !atomsCache->passOptionalUnsignedLongLongWithDefault_id.init(cx, "passOptionalUnsignedLongLongWithDefault") ||
      !atomsCache->passOptionalUnsignedLongLong_id.init(cx, "passOptionalUnsignedLongLong") ||
      !atomsCache->receiveUnsignedLongLong_id.init(cx, "receiveUnsignedLongLong") ||
      !atomsCache->passUnsignedLongLong_id.init(cx, "passUnsignedLongLong") ||
      !atomsCache->writableUnsignedLongLong_id.init(cx, "writableUnsignedLongLong") ||
      !atomsCache->readonlyUnsignedLongLong_id.init(cx, "readonlyUnsignedLongLong") ||
      !atomsCache->passOptionalUnsignedLongWithDefault_id.init(cx, "passOptionalUnsignedLongWithDefault") ||
      !atomsCache->passOptionalUnsignedLong_id.init(cx, "passOptionalUnsignedLong") ||
      !atomsCache->receiveUnsignedLong_id.init(cx, "receiveUnsignedLong") ||
      !atomsCache->passUnsignedLong_id.init(cx, "passUnsignedLong") ||
      !atomsCache->writableUnsignedLong_id.init(cx, "writableUnsignedLong") ||
      !atomsCache->readonlyUnsignedLong_id.init(cx, "readonlyUnsignedLong") ||
      !atomsCache->passOptionalUnsignedShortWithDefault_id.init(cx, "passOptionalUnsignedShortWithDefault") ||
      !atomsCache->passOptionalUnsignedShort_id.init(cx, "passOptionalUnsignedShort") ||
      !atomsCache->receiveUnsignedShort_id.init(cx, "receiveUnsignedShort") ||
      !atomsCache->passUnsignedShort_id.init(cx, "passUnsignedShort") ||
      !atomsCache->writableUnsignedShort_id.init(cx, "writableUnsignedShort") ||
      !atomsCache->readonlyUnsignedShort_id.init(cx, "readonlyUnsignedShort") ||
      !atomsCache->passOptionalOctetWithDefault_id.init(cx, "passOptionalOctetWithDefault") ||
      !atomsCache->passOptionalOctet_id.init(cx, "passOptionalOctet") ||
      !atomsCache->receiveOctet_id.init(cx, "receiveOctet") ||
      !atomsCache->passOctet_id.init(cx, "passOctet") ||
      !atomsCache->writableOctet_id.init(cx, "writableOctet") ||
      !atomsCache->readonlyOctet_id.init(cx, "readonlyOctet") ||
      !atomsCache->passOptionalLongLongWithDefault_id.init(cx, "passOptionalLongLongWithDefault") ||
      !atomsCache->passOptionalLongLong_id.init(cx, "passOptionalLongLong") ||
      !atomsCache->receiveLongLong_id.init(cx, "receiveLongLong") ||
      !atomsCache->passLongLong_id.init(cx, "passLongLong") ||
      !atomsCache->writableLongLong_id.init(cx, "writableLongLong") ||
      !atomsCache->readonlyLongLong_id.init(cx, "readonlyLongLong") ||
      !atomsCache->passOptionalLongWithDefault_id.init(cx, "passOptionalLongWithDefault") ||
      !atomsCache->passOptionalLong_id.init(cx, "passOptionalLong") ||
      !atomsCache->receiveLong_id.init(cx, "receiveLong") ||
      !atomsCache->passLong_id.init(cx, "passLong") ||
      !atomsCache->writableLong_id.init(cx, "writableLong") ||
      !atomsCache->readonlyLong_id.init(cx, "readonlyLong") ||
      !atomsCache->passOptionalShortWithDefault_id.init(cx, "passOptionalShortWithDefault") ||
      !atomsCache->passOptionalShort_id.init(cx, "passOptionalShort") ||
      !atomsCache->receiveShort_id.init(cx, "receiveShort") ||
      !atomsCache->passShort_id.init(cx, "passShort") ||
      !atomsCache->writableShort_id.init(cx, "writableShort") ||
      !atomsCache->readonlyShort_id.init(cx, "readonlyShort") ||
      !atomsCache->returnDeviceStateDependentByte_id.init(cx, "returnDeviceStateDependentByte") ||
      !atomsCache->returnConstantByte_id.init(cx, "returnConstantByte") ||
      !atomsCache->returnDOMDependentByte_id.init(cx, "returnDOMDependentByte") ||
      !atomsCache->returnByteSideEffectFree_id.init(cx, "returnByteSideEffectFree") ||
      !atomsCache->deviceStateDependentByte_id.init(cx, "deviceStateDependentByte") ||
      !atomsCache->constantByte_id.init(cx, "constantByte") ||
      !atomsCache->domDependentByte_id.init(cx, "domDependentByte") ||
      !atomsCache->sideEffectFreeByte_id.init(cx, "sideEffectFreeByte") ||
      !atomsCache->passVariadicByte_id.init(cx, "passVariadicByte") ||
      !atomsCache->passOptionalNullableByte_id.init(cx, "passOptionalNullableByte") ||
      !atomsCache->passNullableByte_id.init(cx, "passNullableByte") ||
      !atomsCache->passOptionalByteWithDefaultBeforeRequired_id.init(cx, "passOptionalByteWithDefaultBeforeRequired") ||
      !atomsCache->passOptionalByteWithDefault_id.init(cx, "passOptionalByteWithDefault") ||
      !atomsCache->passOptionalByteBeforeRequired_id.init(cx, "passOptionalByteBeforeRequired") ||
      !atomsCache->passOptionalByte_id.init(cx, "passOptionalByte") ||
      !atomsCache->receiveByte_id.init(cx, "receiveByte") ||
      !atomsCache->passByte_id.init(cx, "passByte") ||
      !atomsCache->writableByte_id.init(cx, "writableByte") ||
      !atomsCache->readonlyByte_id.init(cx, "readonlyByte")) {
    return false;
  }
  return true;
}


int8_t
TestJSImplInterfaceJSImpl::GetReadonlyByte(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.readonlyByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->readonlyByte_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  int8_t rvalDecl;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.readonlyByte", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  return rvalDecl;
}

int8_t
TestJSImplInterfaceJSImpl::GetWritableByte(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->writableByte_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  int8_t rvalDecl;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.writableByte", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  return rvalDecl;
}

int8_t
TestJSImplInterfaceJSImpl::GetSideEffectFreeByte(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.sideEffectFreeByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->sideEffectFreeByte_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  int8_t rvalDecl;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.sideEffectFreeByte", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  return rvalDecl;
}

int8_t
TestJSImplInterfaceJSImpl::GetDomDependentByte(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.domDependentByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->domDependentByte_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  int8_t rvalDecl;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.domDependentByte", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  return rvalDecl;
}

int8_t
TestJSImplInterfaceJSImpl::GetConstantByte(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.constantByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->constantByte_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  int8_t rvalDecl;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.constantByte", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  return rvalDecl;
}

int8_t
TestJSImplInterfaceJSImpl::GetDeviceStateDependentByte(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.deviceStateDependentByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->deviceStateDependentByte_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  int8_t rvalDecl;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.deviceStateDependentByte", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  return rvalDecl;
}

int16_t
TestJSImplInterfaceJSImpl::GetReadonlyShort(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.readonlyShort", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int16_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->readonlyShort_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int16_t(0);
  }
  int16_t rvalDecl;
  if (!ValueToPrimitive<int16_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.readonlyShort", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int16_t(0);
  }
  return rvalDecl;
}

int16_t
TestJSImplInterfaceJSImpl::GetWritableShort(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableShort", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int16_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->writableShort_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int16_t(0);
  }
  int16_t rvalDecl;
  if (!ValueToPrimitive<int16_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.writableShort", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int16_t(0);
  }
  return rvalDecl;
}

int32_t
TestJSImplInterfaceJSImpl::GetReadonlyLong(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.readonlyLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int32_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->readonlyLong_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int32_t(0);
  }
  int32_t rvalDecl;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.readonlyLong", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int32_t(0);
  }
  return rvalDecl;
}

int32_t
TestJSImplInterfaceJSImpl::GetWritableLong(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int32_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->writableLong_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int32_t(0);
  }
  int32_t rvalDecl;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.writableLong", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int32_t(0);
  }
  return rvalDecl;
}

int64_t
TestJSImplInterfaceJSImpl::GetReadonlyLongLong(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.readonlyLongLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int64_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->readonlyLongLong_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int64_t(0);
  }
  int64_t rvalDecl;
  if (!ValueToPrimitive<int64_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.readonlyLongLong", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int64_t(0);
  }
  return rvalDecl;
}

int64_t
TestJSImplInterfaceJSImpl::GetWritableLongLong(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableLongLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int64_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->writableLongLong_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int64_t(0);
  }
  int64_t rvalDecl;
  if (!ValueToPrimitive<int64_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.writableLongLong", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int64_t(0);
  }
  return rvalDecl;
}

uint8_t
TestJSImplInterfaceJSImpl::GetReadonlyOctet(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.readonlyOctet", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return uint8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->readonlyOctet_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint8_t(0);
  }
  uint8_t rvalDecl;
  if (!ValueToPrimitive<uint8_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.readonlyOctet", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint8_t(0);
  }
  return rvalDecl;
}

uint8_t
TestJSImplInterfaceJSImpl::GetWritableOctet(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableOctet", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return uint8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->writableOctet_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint8_t(0);
  }
  uint8_t rvalDecl;
  if (!ValueToPrimitive<uint8_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.writableOctet", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint8_t(0);
  }
  return rvalDecl;
}

uint16_t
TestJSImplInterfaceJSImpl::GetReadonlyUnsignedShort(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.readonlyUnsignedShort", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return uint16_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->readonlyUnsignedShort_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint16_t(0);
  }
  uint16_t rvalDecl;
  if (!ValueToPrimitive<uint16_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.readonlyUnsignedShort", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint16_t(0);
  }
  return rvalDecl;
}

uint16_t
TestJSImplInterfaceJSImpl::GetWritableUnsignedShort(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableUnsignedShort", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return uint16_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->writableUnsignedShort_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint16_t(0);
  }
  uint16_t rvalDecl;
  if (!ValueToPrimitive<uint16_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.writableUnsignedShort", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint16_t(0);
  }
  return rvalDecl;
}

uint32_t
TestJSImplInterfaceJSImpl::GetReadonlyUnsignedLong(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.readonlyUnsignedLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return uint32_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->readonlyUnsignedLong_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint32_t(0);
  }
  uint32_t rvalDecl;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.readonlyUnsignedLong", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint32_t(0);
  }
  return rvalDecl;
}

uint32_t
TestJSImplInterfaceJSImpl::GetWritableUnsignedLong(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableUnsignedLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return uint32_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->writableUnsignedLong_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint32_t(0);
  }
  uint32_t rvalDecl;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.writableUnsignedLong", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint32_t(0);
  }
  return rvalDecl;
}

uint64_t
TestJSImplInterfaceJSImpl::GetReadonlyUnsignedLongLong(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.readonlyUnsignedLongLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return uint64_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->readonlyUnsignedLongLong_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint64_t(0);
  }
  uint64_t rvalDecl;
  if (!ValueToPrimitive<uint64_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.readonlyUnsignedLongLong", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint64_t(0);
  }
  return rvalDecl;
}

uint64_t
TestJSImplInterfaceJSImpl::GetWritableUnsignedLongLong(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableUnsignedLongLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return uint64_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->writableUnsignedLongLong_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint64_t(0);
  }
  uint64_t rvalDecl;
  if (!ValueToPrimitive<uint64_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.writableUnsignedLongLong", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return uint64_t(0);
  }
  return rvalDecl;
}

float
TestJSImplInterfaceJSImpl::GetWritableFloat(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableFloat", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return float(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->writableFloat_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return float(0);
  }
  float rvalDecl;
  if (!ValueToPrimitive<float, eDefault>(cx, rval, "Return value of TestJSImplInterface.writableFloat", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return float(0);
  } else if (!mozilla::IsFinite(rvalDecl)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Return value of TestJSImplInterface.writableFloat");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return float(0);
  }
  return rvalDecl;
}

float
TestJSImplInterfaceJSImpl::GetWritableUnrestrictedFloat(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableUnrestrictedFloat", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return float(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->writableUnrestrictedFloat_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return float(0);
  }
  float rvalDecl;
  if (!ValueToPrimitive<float, eDefault>(cx, rval, "Return value of TestJSImplInterface.writableUnrestrictedFloat", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return float(0);
  }
  return rvalDecl;
}

Nullable<float>
TestJSImplInterfaceJSImpl::GetWritableNullableFloat(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableNullableFloat", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return Nullable<float>();
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->writableNullableFloat_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return Nullable<float>();
  }
  Nullable<float> rvalDecl;
  if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, rval, "Return value of TestJSImplInterface.writableNullableFloat", &rvalDecl.SetValue())) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return Nullable<float>();
  } else if (!mozilla::IsFinite(rvalDecl.Value())) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Return value of TestJSImplInterface.writableNullableFloat");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return Nullable<float>();
  }
  return rvalDecl;
}

Nullable<float>
TestJSImplInterfaceJSImpl::GetWritableNullableUnrestrictedFloat(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableNullableUnrestrictedFloat", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return Nullable<float>();
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->writableNullableUnrestrictedFloat_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return Nullable<float>();
  }
  Nullable<float> rvalDecl;
  if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, rval, "Return value of TestJSImplInterface.writableNullableUnrestrictedFloat", &rvalDecl.SetValue())) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return Nullable<float>();
  }
  return rvalDecl;
}

double
TestJSImplInterfaceJSImpl::GetWritableDouble(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableDouble", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return double(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->writableDouble_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return double(0);
  }
  double rvalDecl;
  if (!ValueToPrimitive<double, eDefault>(cx, rval, "Return value of TestJSImplInterface.writableDouble", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return double(0);
  } else if (!mozilla::IsFinite(rvalDecl)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Return value of TestJSImplInterface.writableDouble");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return double(0);
  }
  return rvalDecl;
}

double
TestJSImplInterfaceJSImpl::GetWritableUnrestrictedDouble(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableUnrestrictedDouble", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return double(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->writableUnrestrictedDouble_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return double(0);
  }
  double rvalDecl;
  if (!ValueToPrimitive<double, eDefault>(cx, rval, "Return value of TestJSImplInterface.writableUnrestrictedDouble", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return double(0);
  }
  return rvalDecl;
}

Nullable<double>
TestJSImplInterfaceJSImpl::GetWritableNullableDouble(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableNullableDouble", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return Nullable<double>();
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->writableNullableDouble_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return Nullable<double>();
  }
  Nullable<double> rvalDecl;
  if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, rval, "Return value of TestJSImplInterface.writableNullableDouble", &rvalDecl.SetValue())) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return Nullable<double>();
  } else if (!mozilla::IsFinite(rvalDecl.Value())) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Return value of TestJSImplInterface.writableNullableDouble");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return Nullable<double>();
  }
  return rvalDecl;
}

Nullable<double>
TestJSImplInterfaceJSImpl::GetWritableNullableUnrestrictedDouble(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableNullableUnrestrictedDouble", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return Nullable<double>();
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->writableNullableUnrestrictedDouble_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return Nullable<double>();
  }
  Nullable<double> rvalDecl;
  if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, rval, "Return value of TestJSImplInterface.writableNullableUnrestrictedDouble", &rvalDecl.SetValue())) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return Nullable<double>();
  }
  return rvalDecl;
}

float
TestJSImplInterfaceJSImpl::GetLenientFloatAttr(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.lenientFloatAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return float(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->lenientFloatAttr_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return float(0);
  }
  float rvalDecl;
  if (!ValueToPrimitive<float, eDefault>(cx, rval, "Return value of TestJSImplInterface.lenientFloatAttr", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return float(0);
  } else if (!mozilla::IsFinite(rvalDecl)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Return value of TestJSImplInterface.lenientFloatAttr");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return float(0);
  }
  return rvalDecl;
}

double
TestJSImplInterfaceJSImpl::GetLenientDoubleAttr(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.lenientDoubleAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return double(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->lenientDoubleAttr_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return double(0);
  }
  double rvalDecl;
  if (!ValueToPrimitive<double, eDefault>(cx, rval, "Return value of TestJSImplInterface.lenientDoubleAttr", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return double(0);
  } else if (!mozilla::IsFinite(rvalDecl)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Return value of TestJSImplInterface.lenientDoubleAttr");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return double(0);
  }
  return rvalDecl;
}

already_AddRefed<TestJSImplInterface>
TestJSImplInterfaceJSImpl::GetNonNullSelf(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.nonNullSelf", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->nonNullSelf_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestJSImplInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(rval, rvalDecl, cx);
      if (NS_FAILED(rv)) {
        // Be careful to not wrap random DOM objects here, even if
        // they're wrapped in opaque security wrappers for some reason.
        // XXXbz Wish we could check for a JS-implemented object
        // that already has a content reflection...
        if (!IsDOMObject(js::UncheckedUnwrap(&rval.toObject()))) {
          nsCOMPtr<nsIGlobalObject> contentGlobal;
          JS::Rooted<JSObject*> callback(cx, CallbackOrNull());
          if (!callback ||
              !GetContentGlobalForJSImplementedObject(cx, callback, getter_AddRefs(contentGlobal))) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return nullptr;
          }
          JS::Rooted<JSObject*> jsImplSourceObj(cx, &rval.toObject());
          MOZ_RELEASE_ASSERT(!js::IsWrapper(jsImplSourceObj),
                             "Don't return JS implementations from other compartments");
          JS::Rooted<JSObject*> jsImplSourceGlobal(cx, JS::GetNonCCWObjectGlobal(jsImplSourceObj));
          rvalDecl = new mozilla::dom::TestJSImplInterface(jsImplSourceObj, jsImplSourceGlobal, contentGlobal);
        } else {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.nonNullSelf", "TestJSImplInterface");
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return nullptr;
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.nonNullSelf");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<TestJSImplInterface>
TestJSImplInterfaceJSImpl::GetNullableSelf(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.nullableSelf", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->nullableSelf_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestJSImplInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(rval, rvalDecl, cx);
      if (NS_FAILED(rv)) {
        // Be careful to not wrap random DOM objects here, even if
        // they're wrapped in opaque security wrappers for some reason.
        // XXXbz Wish we could check for a JS-implemented object
        // that already has a content reflection...
        if (!IsDOMObject(js::UncheckedUnwrap(&rval.toObject()))) {
          nsCOMPtr<nsIGlobalObject> contentGlobal;
          JS::Rooted<JSObject*> callback(cx, CallbackOrNull());
          if (!callback ||
              !GetContentGlobalForJSImplementedObject(cx, callback, getter_AddRefs(contentGlobal))) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return nullptr;
          }
          JS::Rooted<JSObject*> jsImplSourceObj(cx, &rval.toObject());
          MOZ_RELEASE_ASSERT(!js::IsWrapper(jsImplSourceObj),
                             "Don't return JS implementations from other compartments");
          JS::Rooted<JSObject*> jsImplSourceGlobal(cx, JS::GetNonCCWObjectGlobal(jsImplSourceObj));
          rvalDecl = new mozilla::dom::TestJSImplInterface(jsImplSourceObj, jsImplSourceGlobal, contentGlobal);
        } else {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.nullableSelf", "TestJSImplInterface");
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return nullptr;
        }
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.nullableSelf");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<TestExternalInterface>
TestJSImplInterfaceJSImpl::GetNonNullExternal(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.nonNullExternal", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->nonNullExternal_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestExternalInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
    RefPtr<mozilla::dom::TestExternalInterface> rvalHolder;
    JS::Rooted<JSObject*> source(cx, &rval.toObject());
    if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(rvalHolder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.nonNullExternal", "TestExternalInterface");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    MOZ_ASSERT(rvalHolder);
    rvalDecl = rvalHolder;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.nonNullExternal");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<TestExternalInterface>
TestJSImplInterfaceJSImpl::GetNullableExternal(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.nullableExternal", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->nullableExternal_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestExternalInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
    RefPtr<mozilla::dom::TestExternalInterface> rvalHolder;
    JS::Rooted<JSObject*> source(cx, &rval.toObject());
    if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(rvalHolder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.nullableExternal", "TestExternalInterface");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    MOZ_ASSERT(rvalHolder);
    rvalDecl = rvalHolder;
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.nullableExternal");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<TestCallbackInterface>
TestJSImplInterfaceJSImpl::GetNonNullCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.nonNullCallbackInterface", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->nonNullCallbackInterface_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<TestCallbackInterface> rvalDecl;
  if (rval.isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
      JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
      rvalDecl = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.nonNullCallbackInterface");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<TestCallbackInterface>
TestJSImplInterfaceJSImpl::GetNullableCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.nullableCallbackInterface", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->nullableCallbackInterface_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<TestCallbackInterface> rvalDecl;
  if (rval.isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
      JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
      rvalDecl = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.nullableCallbackInterface");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

void
TestJSImplInterfaceJSImpl::GetUint8ArrayAttr(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.uint8ArrayAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->uint8ArrayAttr_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  RootedSpiderMonkeyInterface<Uint8Array> rvalDecl(cx);
  if (rval.isObject()) {
    if (!rvalDecl.Init(&rval.toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.uint8ArrayAttr", "Uint8Array");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (JS::IsArrayBufferViewShared(rvalDecl.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Return value of TestJSImplInterface.uint8ArrayAttr");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (JS::IsLargeArrayBufferView(rvalDecl.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Return value of TestJSImplInterface.uint8ArrayAttr");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.uint8ArrayAttr");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.set(rvalDecl.Obj());
}

void
TestJSImplInterfaceJSImpl::GetReadonlyJSStringAttr(JS::MutableHandle<JSString*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.readonlyJSStringAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->readonlyJSStringAttr_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JSString*> rvalDecl(cx);
  if (!(rvalDecl = ConvertJSValueToJSString(cx, rval))) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.set(rvalDecl);
}

void
TestJSImplInterfaceJSImpl::GetJsStringAttr(JS::MutableHandle<JSString*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.jsStringAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->jsStringAttr_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JSString*> rvalDecl(cx);
  if (!(rvalDecl = ConvertJSValueToJSString(cx, rval))) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.set(rvalDecl);
}

MyTestEnum
TestJSImplInterfaceJSImpl::GetEnumAttribute(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.enumAttribute", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return MyTestEnum(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->enumAttribute_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return MyTestEnum(0);
  }
  MyTestEnum rvalDecl;
  {
    int index;
    if (!FindEnumStringIndex<true>(cx, rval, MyTestEnumValues::strings, "MyTestEnum", "return value of TestJSImplInterface.enumAttribute", &index)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return MyTestEnum(0);
    }
    MOZ_ASSERT(index >= 0);
    rvalDecl = static_cast<MyTestEnum>(index);
  }
  return rvalDecl;
}

MyTestEnum
TestJSImplInterfaceJSImpl::GetReadonlyEnumAttribute(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.readonlyEnumAttribute", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return MyTestEnum(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->readonlyEnumAttribute_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return MyTestEnum(0);
  }
  MyTestEnum rvalDecl;
  {
    int index;
    if (!FindEnumStringIndex<true>(cx, rval, MyTestEnumValues::strings, "MyTestEnum", "return value of TestJSImplInterface.readonlyEnumAttribute", &index)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return MyTestEnum(0);
    }
    MOZ_ASSERT(index >= 0);
    rvalDecl = static_cast<MyTestEnum>(index);
  }
  return rvalDecl;
}

void
TestJSImplInterfaceJSImpl::GetWritableUnion(OwningCanvasPatternOrCanvasGradient& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableUnion", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->writableUnion_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  OwningCanvasPatternOrCanvasGradient& rvalDecl(aRetVal);
  {
    bool done = false, failed = false, tryNext;
    if (rval.isObject()) {
      done = (failed = !rvalDecl.TrySetToCanvasPattern(cx, rval, tryNext, false)) || !tryNext ||
             (failed = !rvalDecl.TrySetToCanvasGradient(cx, rval, tryNext, false)) || !tryNext;

    }
    if (failed) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Return value of TestJSImplInterface.writableUnion", "CanvasPattern, CanvasGradient");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
  }
}

void
TestJSImplInterfaceJSImpl::GetWritableUnionContainingNull(OwningCanvasPatternOrNullOrCanvasGradient& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableUnionContainingNull", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->writableUnionContainingNull_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  OwningCanvasPatternOrNullOrCanvasGradient& rvalDecl(aRetVal);
  if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    {
      bool done = false, failed = false, tryNext;
      if (rval.isObject()) {
        done = (failed = !rvalDecl.TrySetToCanvasPattern(cx, rval, tryNext, false)) || !tryNext ||
               (failed = !rvalDecl.TrySetToCanvasGradient(cx, rval, tryNext, false)) || !tryNext;

      }
      if (failed) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Return value of TestJSImplInterface.writableUnionContainingNull", "CanvasPattern, CanvasGradient");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  }
}

void
TestJSImplInterfaceJSImpl::GetWritableNullableUnion(Nullable<OwningCanvasPatternOrCanvasGradient>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableNullableUnion", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->writableNullableUnion_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  Nullable<OwningCanvasPatternOrCanvasGradient >& rvalDecl(aRetVal);
  if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    {
      bool done = false, failed = false, tryNext;
      if (rval.isObject()) {
        done = (failed = !rvalDecl.SetValue().TrySetToCanvasPattern(cx, rval, tryNext, false)) || !tryNext ||
               (failed = !rvalDecl.SetValue().TrySetToCanvasGradient(cx, rval, tryNext, false)) || !tryNext;

      }
      if (failed) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Return value of TestJSImplInterface.writableNullableUnion", "CanvasPattern, CanvasGradient");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  }
}

int8_t
TestJSImplInterfaceJSImpl::GetAttributeGetterRenamedTo(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.attributeGetterRenamedFrom", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->attributeGetterRenamedTo_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  int8_t rvalDecl;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.attributeGetterRenamedFrom", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  return rvalDecl;
}

int8_t
TestJSImplInterfaceJSImpl::GetAttributeRenamedTo(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.attributeRenamedFrom", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->attributeRenamedTo_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  int8_t rvalDecl;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.attributeRenamedFrom", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  return rvalDecl;
}

int8_t
TestJSImplInterfaceJSImpl::GetEnforcedByte(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.enforcedByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->enforcedByte_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  int8_t rvalDecl;
  if (!ValueToPrimitive<int8_t, eEnforceRange>(cx, rval, "Return value of TestJSImplInterface.enforcedByte", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  return rvalDecl;
}

Nullable<int8_t>
TestJSImplInterfaceJSImpl::GetEnforcedByteNullable(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.enforcedByteNullable", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return Nullable<int8_t>();
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->enforcedByteNullable_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return Nullable<int8_t>();
  }
  Nullable<int8_t> rvalDecl;
  if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else if (!ValueToPrimitive<int8_t, eEnforceRange>(cx, rval, "Return value of TestJSImplInterface.enforcedByteNullable", &rvalDecl.SetValue())) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return Nullable<int8_t>();
  }
  return rvalDecl;
}

int8_t
TestJSImplInterfaceJSImpl::GetClampedByte(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.clampedByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->clampedByte_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  int8_t rvalDecl;
  if (!ValueToPrimitive<int8_t, eClamp>(cx, rval, "Return value of TestJSImplInterface.clampedByte", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  return rvalDecl;
}

Nullable<int8_t>
TestJSImplInterfaceJSImpl::GetClampedByteNullable(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.clampedByteNullable", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return Nullable<int8_t>();
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->clampedByteNullable_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return Nullable<int8_t>();
  }
  Nullable<int8_t> rvalDecl;
  if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else if (!ValueToPrimitive<int8_t, eClamp>(cx, rval, "Return value of TestJSImplInterface.clampedByteNullable", &rvalDecl.SetValue())) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return Nullable<int8_t>();
  }
  return rvalDecl;
}

int8_t
TestJSImplInterfaceJSImpl::GetDeprecatedAttribute(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.deprecatedAttribute", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->deprecatedAttribute_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  int8_t rvalDecl;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.deprecatedAttribute", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetPrefable1(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.prefable1", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->prefable1_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.prefable1", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetPrefable2(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.prefable2", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->prefable2_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.prefable2", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetPrefable3(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.prefable3", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->prefable3_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.prefable3", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetPrefable4(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.prefable4", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->prefable4_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.prefable4", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetPrefable5(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.prefable5", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->prefable5_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.prefable5", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetPrefable6(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.prefable6", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->prefable6_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.prefable6", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetPrefable7(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.prefable7", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->prefable7_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.prefable7", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetPrefable8(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.prefable8", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->prefable8_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.prefable8", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetPrefable9(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.prefable9", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->prefable9_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.prefable9", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetPrefable12(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.prefable12", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->prefable12_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.prefable12", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetPrefable14(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.prefable14", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->prefable14_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.prefable14", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetPrefable15(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.prefable15", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->prefable15_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.prefable15", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetPrefable16(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.prefable16", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->prefable16_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.prefable16", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetConditionalOnSecureContext1(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.conditionalOnSecureContext1", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->conditionalOnSecureContext1_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.conditionalOnSecureContext1", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetConditionalOnSecureContext2(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.conditionalOnSecureContext2", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->conditionalOnSecureContext2_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.conditionalOnSecureContext2", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetConditionalOnSecureContext3(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.conditionalOnSecureContext3", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->conditionalOnSecureContext3_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.conditionalOnSecureContext3", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetConditionalOnSecureContext4(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.conditionalOnSecureContext4", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->conditionalOnSecureContext4_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.conditionalOnSecureContext4", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

int32_t
TestJSImplInterfaceJSImpl::GetAttrWithLenientThis(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.attrWithLenientThis", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int32_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->attrWithLenientThis_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int32_t(0);
  }
  int32_t rvalDecl;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.attrWithLenientThis", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int32_t(0);
  }
  return rvalDecl;
}

already_AddRefed<TestJSImplInterface>
TestJSImplInterfaceJSImpl::GetPutForwardsAttr(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.putForwardsAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->putForwardsAttr_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestJSImplInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(rval, rvalDecl, cx);
      if (NS_FAILED(rv)) {
        // Be careful to not wrap random DOM objects here, even if
        // they're wrapped in opaque security wrappers for some reason.
        // XXXbz Wish we could check for a JS-implemented object
        // that already has a content reflection...
        if (!IsDOMObject(js::UncheckedUnwrap(&rval.toObject()))) {
          nsCOMPtr<nsIGlobalObject> contentGlobal;
          JS::Rooted<JSObject*> callback(cx, CallbackOrNull());
          if (!callback ||
              !GetContentGlobalForJSImplementedObject(cx, callback, getter_AddRefs(contentGlobal))) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return nullptr;
          }
          JS::Rooted<JSObject*> jsImplSourceObj(cx, &rval.toObject());
          MOZ_RELEASE_ASSERT(!js::IsWrapper(jsImplSourceObj),
                             "Don't return JS implementations from other compartments");
          JS::Rooted<JSObject*> jsImplSourceGlobal(cx, JS::GetNonCCWObjectGlobal(jsImplSourceObj));
          rvalDecl = new mozilla::dom::TestJSImplInterface(jsImplSourceObj, jsImplSourceGlobal, contentGlobal);
        } else {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.putForwardsAttr", "TestJSImplInterface");
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return nullptr;
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.putForwardsAttr");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<TestJSImplInterface>
TestJSImplInterfaceJSImpl::GetPutForwardsAttr2(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.putForwardsAttr2", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->putForwardsAttr2_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestJSImplInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(rval, rvalDecl, cx);
      if (NS_FAILED(rv)) {
        // Be careful to not wrap random DOM objects here, even if
        // they're wrapped in opaque security wrappers for some reason.
        // XXXbz Wish we could check for a JS-implemented object
        // that already has a content reflection...
        if (!IsDOMObject(js::UncheckedUnwrap(&rval.toObject()))) {
          nsCOMPtr<nsIGlobalObject> contentGlobal;
          JS::Rooted<JSObject*> callback(cx, CallbackOrNull());
          if (!callback ||
              !GetContentGlobalForJSImplementedObject(cx, callback, getter_AddRefs(contentGlobal))) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return nullptr;
          }
          JS::Rooted<JSObject*> jsImplSourceObj(cx, &rval.toObject());
          MOZ_RELEASE_ASSERT(!js::IsWrapper(jsImplSourceObj),
                             "Don't return JS implementations from other compartments");
          JS::Rooted<JSObject*> jsImplSourceGlobal(cx, JS::GetNonCCWObjectGlobal(jsImplSourceObj));
          rvalDecl = new mozilla::dom::TestJSImplInterface(jsImplSourceObj, jsImplSourceGlobal, contentGlobal);
        } else {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.putForwardsAttr2", "TestJSImplInterface");
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return nullptr;
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.putForwardsAttr2");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<TestJSImplInterface>
TestJSImplInterfaceJSImpl::GetPutForwardsAttr3(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.putForwardsAttr3", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->putForwardsAttr3_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestJSImplInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestJSImplInterface>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestJSImplInterface, mozilla::dom::TestJSImplInterface>(rval, rvalDecl, cx);
      if (NS_FAILED(rv)) {
        // Be careful to not wrap random DOM objects here, even if
        // they're wrapped in opaque security wrappers for some reason.
        // XXXbz Wish we could check for a JS-implemented object
        // that already has a content reflection...
        if (!IsDOMObject(js::UncheckedUnwrap(&rval.toObject()))) {
          nsCOMPtr<nsIGlobalObject> contentGlobal;
          JS::Rooted<JSObject*> callback(cx, CallbackOrNull());
          if (!callback ||
              !GetContentGlobalForJSImplementedObject(cx, callback, getter_AddRefs(contentGlobal))) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return nullptr;
          }
          JS::Rooted<JSObject*> jsImplSourceObj(cx, &rval.toObject());
          MOZ_RELEASE_ASSERT(!js::IsWrapper(jsImplSourceObj),
                             "Don't return JS implementations from other compartments");
          JS::Rooted<JSObject*> jsImplSourceGlobal(cx, JS::GetNonCCWObjectGlobal(jsImplSourceObj));
          rvalDecl = new mozilla::dom::TestJSImplInterface(jsImplSourceObj, jsImplSourceGlobal, contentGlobal);
        } else {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.putForwardsAttr3", "TestJSImplInterface");
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return nullptr;
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.putForwardsAttr3");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

bool
TestJSImplInterfaceJSImpl::GetThrowingAttr(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.throwingAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->throwingAttr_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.throwingAttr", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetThrowingGetterAttr(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.throwingGetterAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->throwingGetterAttr_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.throwingGetterAttr", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetThrowingSetterAttr(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.throwingSetterAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->throwingSetterAttr_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.throwingSetterAttr", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetCanOOMAttr(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.canOOMAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->canOOMAttr_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.canOOMAttr", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetCanOOMGetterAttr(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.canOOMGetterAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->canOOMGetterAttr_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.canOOMGetterAttr", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetCanOOMSetterAttr(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.canOOMSetterAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->canOOMSetterAttr_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.canOOMSetterAttr", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetCeReactionsAttr(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.ceReactionsAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->ceReactionsAttr_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.ceReactionsAttr", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

void
TestJSImplInterfaceJSImpl::GetToJSONShouldSkipThis(JS::MutableHandle<JS::Value> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.toJSONShouldSkipThis", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->toJSONShouldSkipThis_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> rvalDecl(cx);
#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunreachable-code-return"
#endif // __clang__
  if ((false) && !CallerSubsumes(rval)) {
    cx.ThrowErrorMessage<MSG_PERMISSION_DENIED_TO_PASS_ARG>("return value of TestJSImplInterface.toJSONShouldSkipThis");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__
  rvalDecl = rval;
  aRetVal.set(rvalDecl);
}

already_AddRefed<TestParentInterface>
TestJSImplInterfaceJSImpl::GetToJSONShouldSkipThis2(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.toJSONShouldSkipThis2", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->toJSONShouldSkipThis2_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<mozilla::dom::TestParentInterface> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::TestParentInterface>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestParentInterface, mozilla::dom::TestParentInterface>(rval, rvalDecl, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.toJSONShouldSkipThis2", "TestParentInterface");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return nullptr;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.toJSONShouldSkipThis2");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<TestCallbackInterface>
TestJSImplInterfaceJSImpl::GetToJSONShouldSkipThis3(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.toJSONShouldSkipThis3", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return nullptr;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->toJSONShouldSkipThis3_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<TestCallbackInterface> rvalDecl;
  if (rval.isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
      JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
      rvalDecl = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.toJSONShouldSkipThis3");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

int8_t
TestJSImplInterfaceJSImpl::GetDashed_attribute(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.dashed-attribute", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return int8_t(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->dashed_attribute_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  int8_t rvalDecl;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, rval, "Return value of TestJSImplInterface.dashed-attribute", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return int8_t(0);
  }
  return rvalDecl;
}

bool
TestJSImplInterfaceJSImpl::GetNonEnumerableAttr(ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.nonEnumerableAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return bool(0);
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->nonEnumerableAttr_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  bool rvalDecl;
  if (!ValueToPrimitive<bool, eDefault>(cx, rval, "Return value of TestJSImplInterface.nonEnumerableAttr", &rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return bool(0);
  }
  return rvalDecl;
}

void
TestJSImplInterfaceJSImpl::GetAllowSharedArrayBufferViewTypedef(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.allowSharedArrayBufferViewTypedef", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->allowSharedArrayBufferViewTypedef_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  RootedSpiderMonkeyInterface<ArrayBufferView> rvalDecl(cx);
  if (rval.isObject()) {
    if (!rvalDecl.Init(&rval.toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.allowSharedArrayBufferViewTypedef", "ArrayBufferView");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (JS::IsLargeArrayBufferView(rvalDecl.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Return value of TestJSImplInterface.allowSharedArrayBufferViewTypedef");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.allowSharedArrayBufferViewTypedef");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.set(rvalDecl.Obj());
}

void
TestJSImplInterfaceJSImpl::GetAllowSharedArrayBufferView(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.allowSharedArrayBufferView", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->allowSharedArrayBufferView_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  RootedSpiderMonkeyInterface<ArrayBufferView> rvalDecl(cx);
  if (rval.isObject()) {
    if (!rvalDecl.Init(&rval.toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.allowSharedArrayBufferView", "ArrayBufferView");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (JS::IsLargeArrayBufferView(rvalDecl.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Return value of TestJSImplInterface.allowSharedArrayBufferView");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.allowSharedArrayBufferView");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.set(rvalDecl.Obj());
}

void
TestJSImplInterfaceJSImpl::GetAllowSharedNullableArrayBufferView(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.allowSharedNullableArrayBufferView", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->allowSharedNullableArrayBufferView_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  RootedSpiderMonkeyInterface<Nullable<ArrayBufferView>> rvalDecl(cx);
  if (rval.isObject()) {
    if (!rvalDecl.SetValue().Init(&rval.toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.allowSharedNullableArrayBufferView", "ArrayBufferViewOrNull");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (JS::IsLargeArrayBufferView(rvalDecl.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Return value of TestJSImplInterface.allowSharedNullableArrayBufferView");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.allowSharedNullableArrayBufferView");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.set(rvalDecl.IsNull() ? nullptr : rvalDecl.Value().Obj());
}

void
TestJSImplInterfaceJSImpl::GetAllowSharedArrayBuffer(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.allowSharedArrayBuffer", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->allowSharedArrayBuffer_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  RootedSpiderMonkeyInterface<ArrayBuffer> rvalDecl(cx);
  if (rval.isObject()) {
    if (!rvalDecl.Init(&rval.toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.allowSharedArrayBuffer", "ArrayBuffer");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (JS::IsLargeArrayBufferMaybeShared(rvalDecl.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Return value of TestJSImplInterface.allowSharedArrayBuffer");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.allowSharedArrayBuffer");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.set(rvalDecl.Obj());
}

void
TestJSImplInterfaceJSImpl::GetAllowSharedNullableArrayBuffer(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.allowSharedNullableArrayBuffer", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::Rooted<JS::Value> rval(cx);

  JS::Rooted<JSObject *> callback(cx, mCallback);
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache))
       && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->allowSharedNullableArrayBuffer_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  RootedSpiderMonkeyInterface<Nullable<ArrayBuffer>> rvalDecl(cx);
  if (rval.isObject()) {
    if (!rvalDecl.SetValue().Init(&rval.toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Return value of TestJSImplInterface.allowSharedNullableArrayBuffer", "ArrayBufferOrNull");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (JS::IsLargeArrayBufferMaybeShared(rvalDecl.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Return value of TestJSImplInterface.allowSharedNullableArrayBuffer");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Return value of TestJSImplInterface.allowSharedNullableArrayBuffer");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.set(rvalDecl.IsNull() ? nullptr : rvalDecl.Value().Obj());
}

void
TestJSImplInterfaceJSImpl::SetWritableByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->writableByte_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetSideEffectFreeByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.sideEffectFreeByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->sideEffectFreeByte_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetDomDependentByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.domDependentByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->domDependentByte_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetWritableShort(int16_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableShort", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->writableShort_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetWritableLong(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->writableLong_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetWritableLongLong(int64_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableLongLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].set(JS_NumberValue(double(arg)));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->writableLongLong_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetWritableOctet(uint8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableOctet", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->writableOctet_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetWritableUnsignedShort(uint16_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableUnsignedShort", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->writableUnsignedShort_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetWritableUnsignedLong(uint32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableUnsignedLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setNumber(arg);
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->writableUnsignedLong_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetWritableUnsignedLongLong(uint64_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableUnsignedLongLong", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].set(JS_NumberValue(double(arg)));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->writableUnsignedLongLong_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetWritableFloat(float arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableFloat", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].set(JS_NumberValue(double(arg)));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->writableFloat_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetWritableUnrestrictedFloat(float arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableUnrestrictedFloat", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].set(JS_NumberValue(double(arg)));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->writableUnrestrictedFloat_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetWritableNullableFloat(const Nullable<float>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableNullableFloat", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    argv[0].set(JS_NumberValue(double(arg.Value())));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->writableNullableFloat_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetWritableNullableUnrestrictedFloat(const Nullable<float>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableNullableUnrestrictedFloat", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    argv[0].set(JS_NumberValue(double(arg.Value())));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->writableNullableUnrestrictedFloat_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetWritableDouble(double arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableDouble", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].set(JS_NumberValue(double(arg)));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->writableDouble_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetWritableUnrestrictedDouble(double arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableUnrestrictedDouble", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].set(JS_NumberValue(double(arg)));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->writableUnrestrictedDouble_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetWritableNullableDouble(const Nullable<double>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableNullableDouble", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    argv[0].set(JS_NumberValue(double(arg.Value())));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->writableNullableDouble_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetWritableNullableUnrestrictedDouble(const Nullable<double>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableNullableUnrestrictedDouble", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    argv[0].set(JS_NumberValue(double(arg.Value())));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->writableNullableUnrestrictedDouble_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetLenientFloatAttr(float arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.lenientFloatAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].set(JS_NumberValue(double(arg)));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->lenientFloatAttr_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetLenientDoubleAttr(double arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.lenientDoubleAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].set(JS_NumberValue(double(arg)));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->lenientDoubleAttr_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetNonNullSelf(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.nonNullSelf", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    if (!GetOrCreateDOMReflector(cx, arg, argv[0])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->nonNullSelf_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetNullableSelf(TestJSImplInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.nullableSelf", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    if (!arg) {
      argv[0].setNull();
      break;
    }
    if (!GetOrCreateDOMReflector(cx, arg, argv[0])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->nullableSelf_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetNonNullExternal(TestExternalInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.nonNullExternal", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    if (!WrapObject(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->nonNullExternal_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetNullableExternal(TestExternalInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.nullableExternal", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    if (!arg) {
      argv[0].setNull();
      break;
    }
    if (!WrapObject(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->nullableExternal_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetNonNullCallbackInterface(TestCallbackInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.nonNullCallbackInterface", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setObjectOrNull(GetCallbackFromCallbackObject(cx, arg));
    if (!MaybeWrapObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->nonNullCallbackInterface_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetNullableCallbackInterface(TestCallbackInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.nullableCallbackInterface", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    if (arg) {
      argv[0].setObjectOrNull(GetCallbackFromCallbackObject(cx, arg));
      if (!MaybeWrapObjectOrNullValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else {
      argv[0].setNull();
      break;
    }
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->nullableCallbackInterface_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetUint8ArrayAttr(const Uint8Array& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.uint8ArrayAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setObject(*arg.Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->uint8ArrayAttr_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetJsStringAttr(JS::Handle<JSString*> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.jsStringAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setString(arg);
    if (!MaybeWrapStringValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->jsStringAttr_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetEnumAttribute(MyTestEnum arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.enumAttribute", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    if (!ToJSValue(cx, arg, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->enumAttribute_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetWritableUnion(const CanvasPatternOrCanvasGradient& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableUnion", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->writableUnion_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetWritableUnionContainingNull(const CanvasPatternOrNullOrCanvasGradient& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableUnionContainingNull", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (!arg.ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->writableUnionContainingNull_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetWritableNullableUnion(const Nullable<CanvasPatternOrCanvasGradient>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.writableNullableUnion", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    JS::Rooted<JSObject*> callbackObj(cx, CallbackKnownNotGray());
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    if (!arg.Value().ToJSVal(cx, callbackObj, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->writableNullableUnion_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetAttributeRenamedTo(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.attributeRenamedFrom", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->attributeRenamedTo_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetEnforcedByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.enforcedByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->enforcedByte_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetEnforcedByteNullable(const Nullable<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.enforcedByteNullable", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    argv[0].setInt32(int32_t(arg.Value()));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->enforcedByteNullable_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetClampedByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.clampedByte", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->clampedByte_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetClampedByteNullable(const Nullable<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.clampedByteNullable", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    argv[0].setInt32(int32_t(arg.Value()));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->clampedByteNullable_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetDeprecatedAttribute(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.deprecatedAttribute", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->deprecatedAttribute_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetAttrWithLenientThis(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.attrWithLenientThis", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->attrWithLenientThis_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetThrowingAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.throwingAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setBoolean(arg);
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->throwingAttr_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetThrowingGetterAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.throwingGetterAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setBoolean(arg);
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->throwingGetterAttr_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetThrowingSetterAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.throwingSetterAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setBoolean(arg);
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->throwingSetterAttr_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetCanOOMAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.canOOMAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setBoolean(arg);
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->canOOMAttr_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetCanOOMGetterAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.canOOMGetterAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setBoolean(arg);
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->canOOMGetterAttr_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetCanOOMSetterAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.canOOMSetterAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setBoolean(arg);
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->canOOMSetterAttr_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetCeReactionsAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.ceReactionsAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setBoolean(arg);
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->ceReactionsAttr_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetToJSONShouldSkipThis(JS::Handle<JS::Value> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.toJSONShouldSkipThis", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    JS::ExposeValueToActiveJS(arg);
    argv[0].set(arg);
    if (!MaybeWrapValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->toJSONShouldSkipThis_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetToJSONShouldSkipThis2(TestParentInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.toJSONShouldSkipThis2", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    if (!GetOrCreateDOMReflector(cx, arg, argv[0])) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->toJSONShouldSkipThis2_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetToJSONShouldSkipThis3(TestCallbackInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.toJSONShouldSkipThis3", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setObjectOrNull(GetCallbackFromCallbackObject(cx, arg));
    if (!MaybeWrapObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->toJSONShouldSkipThis3_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetDashed_attribute(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.dashed-attribute", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setInt32(int32_t(arg));
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->dashed_attribute_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetNonEnumerableAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.nonEnumerableAttr", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setBoolean(arg);
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->nonEnumerableAttr_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetAllowSharedArrayBufferViewTypedef(const ArrayBufferView& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.allowSharedArrayBufferViewTypedef", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setObject(*arg.Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->allowSharedArrayBufferViewTypedef_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetAllowSharedArrayBufferView(const ArrayBufferView& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.allowSharedArrayBufferView", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setObject(*arg.Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->allowSharedArrayBufferView_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetAllowSharedNullableArrayBufferView(const Nullable<ArrayBufferView>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.allowSharedNullableArrayBufferView", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    argv[0].setObject(*arg.Value().Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->allowSharedNullableArrayBufferView_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetAllowSharedArrayBuffer(const ArrayBuffer& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.allowSharedArrayBuffer", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    argv[0].setObject(*arg.Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->allowSharedArrayBuffer_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
TestJSImplInterfaceJSImpl::SetAllowSharedNullableArrayBuffer(const Nullable<ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  CallSetup s(this, aRv, "TestJSImplInterface.allowSharedNullableArrayBuffer", eRethrowContentExceptions, aRealm, /* aIsJSImplementedWebIDL = */ true);
  if (aRv.Failed()) {
    return;
  }
  MOZ_ASSERT(s.GetContext());
  BindingCallContext& cx = s.GetCallContext();

  JS::RootedVector<JS::Value> argv(cx);
  if (!argv.resize(1)) {
    // That threw an exception on the JSContext, and our CallSetup will do
    // the right thing with that.
    return;
  }
  do {
    if (arg.IsNull()) {
      argv[0].setNull();
      break;
    }
    argv[0].setObject(*arg.Value().Obj());
    if (!MaybeWrapNonDOMObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (false);

  MOZ_ASSERT(argv.length() == 1);
  JS::Rooted<JSObject*> callback(cx, CallbackKnownNotGray());
  TestJSImplInterfaceAtoms* atomsCache = GetAtomCache<TestJSImplInterfaceAtoms>(cx);
  if ((JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
       !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, callback, atomsCache->allowSharedNullableArrayBuffer_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}


NS_IMPL_CYCLE_COLLECTION_CLASS(TestJSImplInterface)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(TestJSImplInterface)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mImpl)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mParent)
  NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
  tmp->ClearWeakReferences();
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(TestJSImplInterface)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mImpl)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mParent)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_WRAPPERCACHE(TestJSImplInterface)
NS_IMPL_CYCLE_COLLECTING_ADDREF(TestJSImplInterface)
NS_IMPL_CYCLE_COLLECTING_RELEASE(TestJSImplInterface)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(TestJSImplInterface)
  NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
  NS_INTERFACE_MAP_ENTRY(nsISupports)
  NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
NS_INTERFACE_MAP_END

TestJSImplInterface::TestJSImplInterface(JS::Handle<JSObject*> aJSImplObject, JS::Handle<JSObject*> aJSImplGlobal, nsIGlobalObject* aParent)
  : mImpl(new TestJSImplInterfaceJSImpl(nullptr, aJSImplObject, aJSImplGlobal, /* aIncumbentGlobal = */ nullptr)),
    mParent(aParent)
{
}


TestJSImplInterface::~TestJSImplInterface()
{
}

nsISupports*
TestJSImplInterface::GetParentObject() const
{
  return mParent;
}

DocGroup*
TestJSImplInterface::GetDocGroup() const
{
  nsCOMPtr<nsPIDOMWindowInner> window = do_QueryInterface(mParent);
  if (!window) {
    return nullptr;
  }
  return window->GetDocGroup();
}

JSObject*
TestJSImplInterface::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
{
  JS::Rooted<JSObject*> obj(aCx, TestJSImplInterface_Binding::Wrap(aCx, this, aGivenProto));
  if (!obj) {
    return nullptr;
  }

  // Now define it on our chrome object
  JSAutoRealm ar(aCx, mImpl->CallbackGlobalOrNull());
  if (!JS_WrapObject(aCx, &obj)) {
    return nullptr;
  }
  JS::Rooted<JSObject*> callback(aCx, mImpl->CallbackOrNull());
  if (!JS_DefineProperty(aCx, callback, "__DOM_IMPL__", obj, 0)) {
    return nullptr;
  }
  return obj;
}

already_AddRefed<TestJSImplInterface>
TestJSImplInterface::Constructor(const GlobalObject& global, JSContext* cx, const nsAString& str, uint32_t num, const Nullable<bool>& boolArg, TestInterface* iface, int32_t arg1, const DictForConstructor& dict, JS::Handle<JS::Value> any1, JS::Handle<JSObject*> obj1, JS::Handle<JSObject*> obj2, const Sequence<Dict>& seq, JS::Handle<JS::Value> any2, const Optional<JS::Handle<JSObject*>>& obj3, const Optional<JS::Handle<JSObject*>>& obj4, const Uint8Array& typedArr, const ArrayBuffer& arrayBuf, ErrorResult& aRv, JS::Handle<JSObject*> aGivenProto)
{
  RefPtr<TestJSImplInterface> impl =
    ConstructJSImplementation<TestJSImplInterface>("@mozilla.org/test-js-impl-interface;1", global, aRv);
  if (aRv.Failed()) {
    return nullptr;
  }
  // Wrap the object before calling __Init so that __DOM_IMPL__ is available.
  JS::Rooted<JSObject*> scopeObj(cx, global.Get());
  MOZ_ASSERT(js::IsObjectInContextCompartment(scopeObj, cx));
  JS::Rooted<JS::Value> wrappedVal(cx);
  if (!GetOrCreateDOMReflector(cx, impl, &wrappedVal, aGivenProto)) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  // Initialize the object with the constructor arguments.
  impl->mImpl->__Init(str, num, boolArg, iface, arg1, dict, any1, obj1, obj2, seq, any2, obj3, obj4, typedArr, arrayBuf, aRv, js::GetNonCCWObjectRealm(scopeObj));
  if (aRv.Failed()) {
    return nullptr;
  }
  return impl.forget();
}

int8_t
TestJSImplInterface::GetReadonlyByte(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetReadonlyByte(aRv, aRealm);
}

int8_t
TestJSImplInterface::GetWritableByte(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetWritableByte(aRv, aRealm);
}

void
TestJSImplInterface::SetWritableByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetWritableByte(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassByte(arg, aRv, aRealm);
}

int8_t
TestJSImplInterface::ReceiveByte(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveByte(aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalByte(const Optional<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalByte(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalByteBeforeRequired(const Optional<int8_t>& arg1, int8_t arg2, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalByteBeforeRequired(arg1, arg2, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalByteWithDefault(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalByteWithDefault(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalByteWithDefaultBeforeRequired(int8_t arg1, int8_t arg2, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalByteWithDefaultBeforeRequired(arg1, arg2, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableByte(const Nullable<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableByte(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableByte(const Optional<Nullable<int8_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableByte(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassVariadicByte(const Sequence<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassVariadicByte(arg, aRv, aRealm);
}

int8_t
TestJSImplInterface::GetSideEffectFreeByte(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetSideEffectFreeByte(aRv, aRealm);
}

void
TestJSImplInterface::SetSideEffectFreeByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetSideEffectFreeByte(arg, aRv, aRealm);
}

int8_t
TestJSImplInterface::GetDomDependentByte(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetDomDependentByte(aRv, aRealm);
}

void
TestJSImplInterface::SetDomDependentByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetDomDependentByte(arg, aRv, aRealm);
}

int8_t
TestJSImplInterface::GetConstantByte(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetConstantByte(aRv, aRealm);
}

int8_t
TestJSImplInterface::GetDeviceStateDependentByte(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetDeviceStateDependentByte(aRv, aRealm);
}

int8_t
TestJSImplInterface::ReturnByteSideEffectFree(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReturnByteSideEffectFree(aRv, aRealm);
}

int8_t
TestJSImplInterface::ReturnDOMDependentByte(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReturnDOMDependentByte(aRv, aRealm);
}

int8_t
TestJSImplInterface::ReturnConstantByte(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReturnConstantByte(aRv, aRealm);
}

int8_t
TestJSImplInterface::ReturnDeviceStateDependentByte(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReturnDeviceStateDependentByte(aRv, aRealm);
}

int16_t
TestJSImplInterface::GetReadonlyShort(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetReadonlyShort(aRv, aRealm);
}

int16_t
TestJSImplInterface::GetWritableShort(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetWritableShort(aRv, aRealm);
}

void
TestJSImplInterface::SetWritableShort(int16_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetWritableShort(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassShort(int16_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassShort(arg, aRv, aRealm);
}

int16_t
TestJSImplInterface::ReceiveShort(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveShort(aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalShort(const Optional<int16_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalShort(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalShortWithDefault(int16_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalShortWithDefault(arg, aRv, aRealm);
}

int32_t
TestJSImplInterface::GetReadonlyLong(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetReadonlyLong(aRv, aRealm);
}

int32_t
TestJSImplInterface::GetWritableLong(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetWritableLong(aRv, aRealm);
}

void
TestJSImplInterface::SetWritableLong(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetWritableLong(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassLong(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassLong(arg, aRv, aRealm);
}

int32_t
TestJSImplInterface::ReceiveLong(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveLong(aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalLong(const Optional<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalLong(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalLongWithDefault(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalLongWithDefault(arg, aRv, aRealm);
}

int64_t
TestJSImplInterface::GetReadonlyLongLong(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetReadonlyLongLong(aRv, aRealm);
}

int64_t
TestJSImplInterface::GetWritableLongLong(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetWritableLongLong(aRv, aRealm);
}

void
TestJSImplInterface::SetWritableLongLong(int64_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetWritableLongLong(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassLongLong(int64_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassLongLong(arg, aRv, aRealm);
}

int64_t
TestJSImplInterface::ReceiveLongLong(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveLongLong(aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalLongLong(const Optional<int64_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalLongLong(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalLongLongWithDefault(int64_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalLongLongWithDefault(arg, aRv, aRealm);
}

uint8_t
TestJSImplInterface::GetReadonlyOctet(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetReadonlyOctet(aRv, aRealm);
}

uint8_t
TestJSImplInterface::GetWritableOctet(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetWritableOctet(aRv, aRealm);
}

void
TestJSImplInterface::SetWritableOctet(uint8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetWritableOctet(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOctet(uint8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOctet(arg, aRv, aRealm);
}

uint8_t
TestJSImplInterface::ReceiveOctet(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveOctet(aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalOctet(const Optional<uint8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalOctet(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalOctetWithDefault(uint8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalOctetWithDefault(arg, aRv, aRealm);
}

uint16_t
TestJSImplInterface::GetReadonlyUnsignedShort(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetReadonlyUnsignedShort(aRv, aRealm);
}

uint16_t
TestJSImplInterface::GetWritableUnsignedShort(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetWritableUnsignedShort(aRv, aRealm);
}

void
TestJSImplInterface::SetWritableUnsignedShort(uint16_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetWritableUnsignedShort(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnsignedShort(uint16_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnsignedShort(arg, aRv, aRealm);
}

uint16_t
TestJSImplInterface::ReceiveUnsignedShort(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveUnsignedShort(aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalUnsignedShort(const Optional<uint16_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalUnsignedShort(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalUnsignedShortWithDefault(uint16_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalUnsignedShortWithDefault(arg, aRv, aRealm);
}

uint32_t
TestJSImplInterface::GetReadonlyUnsignedLong(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetReadonlyUnsignedLong(aRv, aRealm);
}

uint32_t
TestJSImplInterface::GetWritableUnsignedLong(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetWritableUnsignedLong(aRv, aRealm);
}

void
TestJSImplInterface::SetWritableUnsignedLong(uint32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetWritableUnsignedLong(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnsignedLong(uint32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnsignedLong(arg, aRv, aRealm);
}

uint32_t
TestJSImplInterface::ReceiveUnsignedLong(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveUnsignedLong(aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalUnsignedLong(const Optional<uint32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalUnsignedLong(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalUnsignedLongWithDefault(uint32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalUnsignedLongWithDefault(arg, aRv, aRealm);
}

uint64_t
TestJSImplInterface::GetReadonlyUnsignedLongLong(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetReadonlyUnsignedLongLong(aRv, aRealm);
}

uint64_t
TestJSImplInterface::GetWritableUnsignedLongLong(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetWritableUnsignedLongLong(aRv, aRealm);
}

void
TestJSImplInterface::SetWritableUnsignedLongLong(uint64_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetWritableUnsignedLongLong(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnsignedLongLong(uint64_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnsignedLongLong(arg, aRv, aRealm);
}

uint64_t
TestJSImplInterface::ReceiveUnsignedLongLong(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveUnsignedLongLong(aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalUnsignedLongLong(const Optional<uint64_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalUnsignedLongLong(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalUnsignedLongLongWithDefault(uint64_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalUnsignedLongLongWithDefault(arg, aRv, aRealm);
}

float
TestJSImplInterface::GetWritableFloat(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetWritableFloat(aRv, aRealm);
}

void
TestJSImplInterface::SetWritableFloat(float arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetWritableFloat(arg, aRv, aRealm);
}

float
TestJSImplInterface::GetWritableUnrestrictedFloat(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetWritableUnrestrictedFloat(aRv, aRealm);
}

void
TestJSImplInterface::SetWritableUnrestrictedFloat(float arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetWritableUnrestrictedFloat(arg, aRv, aRealm);
}

Nullable<float>
TestJSImplInterface::GetWritableNullableFloat(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetWritableNullableFloat(aRv, aRealm);
}

void
TestJSImplInterface::SetWritableNullableFloat(const Nullable<float>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetWritableNullableFloat(arg, aRv, aRealm);
}

Nullable<float>
TestJSImplInterface::GetWritableNullableUnrestrictedFloat(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetWritableNullableUnrestrictedFloat(aRv, aRealm);
}

void
TestJSImplInterface::SetWritableNullableUnrestrictedFloat(const Nullable<float>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetWritableNullableUnrestrictedFloat(arg, aRv, aRealm);
}

double
TestJSImplInterface::GetWritableDouble(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetWritableDouble(aRv, aRealm);
}

void
TestJSImplInterface::SetWritableDouble(double arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetWritableDouble(arg, aRv, aRealm);
}

double
TestJSImplInterface::GetWritableUnrestrictedDouble(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetWritableUnrestrictedDouble(aRv, aRealm);
}

void
TestJSImplInterface::SetWritableUnrestrictedDouble(double arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetWritableUnrestrictedDouble(arg, aRv, aRealm);
}

Nullable<double>
TestJSImplInterface::GetWritableNullableDouble(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetWritableNullableDouble(aRv, aRealm);
}

void
TestJSImplInterface::SetWritableNullableDouble(const Nullable<double>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetWritableNullableDouble(arg, aRv, aRealm);
}

Nullable<double>
TestJSImplInterface::GetWritableNullableUnrestrictedDouble(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetWritableNullableUnrestrictedDouble(aRv, aRealm);
}

void
TestJSImplInterface::SetWritableNullableUnrestrictedDouble(const Nullable<double>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetWritableNullableUnrestrictedDouble(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassFloat(float arg1, float arg2, const Nullable<float>& arg3, const Nullable<float>& arg4, double arg5, double arg6, const Nullable<double>& arg7, const Nullable<double>& arg8, const Sequence<float>& arg9, const Sequence<float>& arg10, const Sequence<Nullable<float>>& arg11, const Sequence<Nullable<float>>& arg12, const Sequence<double>& arg13, const Sequence<double>& arg14, const Sequence<Nullable<double>>& arg15, const Sequence<Nullable<double>>& arg16, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassFloat(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, aRv, aRealm);
}

void
TestJSImplInterface::PassLenientFloat(float arg1, float arg2, const Nullable<float>& arg3, const Nullable<float>& arg4, double arg5, double arg6, const Nullable<double>& arg7, const Nullable<double>& arg8, const Sequence<float>& arg9, const Sequence<float>& arg10, const Sequence<Nullable<float>>& arg11, const Sequence<Nullable<float>>& arg12, const Sequence<double>& arg13, const Sequence<double>& arg14, const Sequence<Nullable<double>>& arg15, const Sequence<Nullable<double>>& arg16, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassLenientFloat(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14, arg15, arg16, aRv, aRealm);
}

float
TestJSImplInterface::GetLenientFloatAttr(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetLenientFloatAttr(aRv, aRealm);
}

void
TestJSImplInterface::SetLenientFloatAttr(float arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetLenientFloatAttr(arg, aRv, aRealm);
}

double
TestJSImplInterface::GetLenientDoubleAttr(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetLenientDoubleAttr(aRv, aRealm);
}

void
TestJSImplInterface::SetLenientDoubleAttr(double arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetLenientDoubleAttr(arg, aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestJSImplInterface>
TestJSImplInterface::ReceiveSelf(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveSelf(aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestJSImplInterface>
TestJSImplInterface::ReceiveNullableSelf(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableSelf(aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestJSImplInterface>
TestJSImplInterface::ReceiveWeakSelf(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveWeakSelf(aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestJSImplInterface>
TestJSImplInterface::ReceiveWeakNullableSelf(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveWeakNullableSelf(aRv, aRealm);
}

void
TestJSImplInterface::PassSelf(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassSelf(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableSelf(TestJSImplInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableSelf(arg, aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestJSImplInterface>
TestJSImplInterface::GetNonNullSelf(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetNonNullSelf(aRv, aRealm);
}

void
TestJSImplInterface::SetNonNullSelf(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetNonNullSelf(arg, aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestJSImplInterface>
TestJSImplInterface::GetNullableSelf(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetNullableSelf(aRv, aRealm);
}

void
TestJSImplInterface::SetNullableSelf(TestJSImplInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetNullableSelf(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalSelf(const Optional<TestJSImplInterface*>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalSelf(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNonNullSelf(const Optional<NonNull<TestJSImplInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNonNullSelf(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalSelfWithDefault(TestJSImplInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalSelfWithDefault(arg, aRv, aRealm);
}

already_AddRefed<TestNonWrapperCacheInterface>
TestJSImplInterface::ReceiveNonWrapperCacheInterface(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNonWrapperCacheInterface(aRv, aRealm);
}

already_AddRefed<TestNonWrapperCacheInterface>
TestJSImplInterface::ReceiveNullableNonWrapperCacheInterface(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableNonWrapperCacheInterface(aRv, aRealm);
}

void
TestJSImplInterface::ReceiveNonWrapperCacheInterfaceSequence(nsTArray<RefPtr<TestNonWrapperCacheInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNonWrapperCacheInterfaceSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveNullableNonWrapperCacheInterfaceSequence(nsTArray<RefPtr<TestNonWrapperCacheInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableNonWrapperCacheInterfaceSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveNonWrapperCacheInterfaceNullableSequence(Nullable<nsTArray<RefPtr<TestNonWrapperCacheInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNonWrapperCacheInterfaceNullableSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveNullableNonWrapperCacheInterfaceNullableSequence(Nullable<nsTArray<RefPtr<TestNonWrapperCacheInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableNonWrapperCacheInterfaceNullableSequence(aRetVal, aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestExternalInterface>
TestJSImplInterface::ReceiveExternal(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveExternal(aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestExternalInterface>
TestJSImplInterface::ReceiveNullableExternal(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableExternal(aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestExternalInterface>
TestJSImplInterface::ReceiveWeakExternal(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveWeakExternal(aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestExternalInterface>
TestJSImplInterface::ReceiveWeakNullableExternal(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveWeakNullableExternal(aRv, aRealm);
}

void
TestJSImplInterface::PassExternal(TestExternalInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassExternal(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableExternal(TestExternalInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableExternal(arg, aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestExternalInterface>
TestJSImplInterface::GetNonNullExternal(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetNonNullExternal(aRv, aRealm);
}

void
TestJSImplInterface::SetNonNullExternal(TestExternalInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetNonNullExternal(arg, aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestExternalInterface>
TestJSImplInterface::GetNullableExternal(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetNullableExternal(aRv, aRealm);
}

void
TestJSImplInterface::SetNullableExternal(TestExternalInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetNullableExternal(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalExternal(const Optional<TestExternalInterface*>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalExternal(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNonNullExternal(const Optional<TestExternalInterface*>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNonNullExternal(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalExternalWithDefault(TestExternalInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalExternalWithDefault(arg, aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestCallbackInterface>
TestJSImplInterface::ReceiveCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveCallbackInterface(aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestCallbackInterface>
TestJSImplInterface::ReceiveNullableCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableCallbackInterface(aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestCallbackInterface>
TestJSImplInterface::ReceiveWeakCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveWeakCallbackInterface(aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestCallbackInterface>
TestJSImplInterface::ReceiveWeakNullableCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveWeakNullableCallbackInterface(aRv, aRealm);
}

void
TestJSImplInterface::PassCallbackInterface(TestCallbackInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassCallbackInterface(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableCallbackInterface(TestCallbackInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableCallbackInterface(arg, aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestCallbackInterface>
TestJSImplInterface::GetNonNullCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetNonNullCallbackInterface(aRv, aRealm);
}

void
TestJSImplInterface::SetNonNullCallbackInterface(TestCallbackInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetNonNullCallbackInterface(arg, aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestCallbackInterface>
TestJSImplInterface::GetNullableCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetNullableCallbackInterface(aRv, aRealm);
}

void
TestJSImplInterface::SetNullableCallbackInterface(TestCallbackInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetNullableCallbackInterface(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalCallbackInterface(const Optional<RefPtr<TestCallbackInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalCallbackInterface(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNonNullCallbackInterface(const Optional<OwningNonNull<TestCallbackInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNonNullCallbackInterface(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalCallbackInterfaceWithDefault(TestCallbackInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalCallbackInterfaceWithDefault(arg, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveSequence(nsTArray<int32_t>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveNullableSequence(Nullable<nsTArray<int32_t>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveSequenceOfNullableInts(nsTArray<Nullable<int32_t>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveSequenceOfNullableInts(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveNullableSequenceOfNullableInts(Nullable<nsTArray<Nullable<int32_t>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableSequenceOfNullableInts(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::PassSequence(const Sequence<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassSequence(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableSequence(const Nullable<Sequence<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableSequence(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassSequenceOfNullableInts(const Sequence<Nullable<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassSequenceOfNullableInts(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalSequenceOfNullableInts(const Optional<Sequence<Nullable<int32_t>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalSequenceOfNullableInts(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableSequenceOfNullableInts(const Optional<Nullable<Sequence<Nullable<int32_t>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableSequenceOfNullableInts(arg, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveCastableObjectSequence(nsTArray<RefPtr<TestJSImplInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveCastableObjectSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveCallbackObjectSequence(nsTArray<RefPtr<TestCallbackInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveCallbackObjectSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveNullableCastableObjectSequence(nsTArray<RefPtr<TestJSImplInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableCastableObjectSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveNullableCallbackObjectSequence(nsTArray<RefPtr<TestCallbackInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableCallbackObjectSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveCastableObjectNullableSequence(Nullable<nsTArray<RefPtr<TestJSImplInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveCastableObjectNullableSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveNullableCastableObjectNullableSequence(Nullable<nsTArray<RefPtr<TestJSImplInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableCastableObjectNullableSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveWeakCastableObjectSequence(nsTArray<RefPtr<TestJSImplInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveWeakCastableObjectSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveWeakNullableCastableObjectSequence(nsTArray<RefPtr<TestJSImplInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveWeakNullableCastableObjectSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveWeakCastableObjectNullableSequence(Nullable<nsTArray<RefPtr<TestJSImplInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveWeakCastableObjectNullableSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveWeakNullableCastableObjectNullableSequence(Nullable<nsTArray<RefPtr<TestJSImplInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveWeakNullableCastableObjectNullableSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::PassCastableObjectSequence(const Sequence<OwningNonNull<TestJSImplInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassCastableObjectSequence(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableCastableObjectSequence(const Sequence<RefPtr<TestJSImplInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableCastableObjectSequence(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassCastableObjectNullableSequence(const Nullable<Sequence<OwningNonNull<TestJSImplInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassCastableObjectNullableSequence(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableCastableObjectNullableSequence(const Nullable<Sequence<RefPtr<TestJSImplInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableCastableObjectNullableSequence(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalSequence(const Optional<Sequence<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalSequence(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalSequenceWithDefaultValue(const Sequence<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalSequenceWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableSequence(const Optional<Nullable<Sequence<int32_t>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableSequence(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableSequenceWithDefaultValue(const Nullable<Sequence<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableSequenceWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableSequenceWithDefaultValue2(const Nullable<Sequence<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableSequenceWithDefaultValue2(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalObjectSequence(const Optional<Sequence<OwningNonNull<TestJSImplInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalObjectSequence(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassExternalInterfaceSequence(const Sequence<RefPtr<TestExternalInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassExternalInterfaceSequence(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableExternalInterfaceSequence(const Sequence<RefPtr<TestExternalInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableExternalInterfaceSequence(arg, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveStringSequence(nsTArray<nsString>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveStringSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveByteStringSequence(nsTArray<nsCString>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveByteStringSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveUTF8StringSequence(nsTArray<nsCString>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveUTF8StringSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveAnySequence(nsTArray<JS::Value>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveAnySequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveNullableAnySequence(Nullable<nsTArray<JS::Value>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableAnySequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveObjectSequence(nsTArray<JSObject*>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveObjectSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveNullableObjectSequence(nsTArray<JSObject*>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableObjectSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::PassSequenceOfSequences(const Sequence<Sequence<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassSequenceOfSequences(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassSequenceOfSequencesOfSequences(const Sequence<Sequence<Sequence<int32_t>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassSequenceOfSequencesOfSequences(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassRecord(const Record<nsString, int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassRecord(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableRecord(const Nullable<Record<nsString, int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableRecord(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassRecordOfNullableInts(const Record<nsString, Nullable<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassRecordOfNullableInts(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalRecordOfNullableInts(const Optional<Record<nsString, Nullable<int32_t>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalRecordOfNullableInts(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableRecordOfNullableInts(const Optional<Nullable<Record<nsString, Nullable<int32_t>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableRecordOfNullableInts(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassCastableObjectRecord(const Record<nsString, OwningNonNull<TestInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassCastableObjectRecord(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableCastableObjectRecord(const Record<nsString, RefPtr<TestInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableCastableObjectRecord(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassCastableObjectNullableRecord(const Nullable<Record<nsString, OwningNonNull<TestInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassCastableObjectNullableRecord(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableCastableObjectNullableRecord(const Nullable<Record<nsString, RefPtr<TestInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableCastableObjectNullableRecord(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalRecord(const Optional<Record<nsString, int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalRecord(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableRecord(const Optional<Nullable<Record<nsString, int32_t>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableRecord(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableRecordWithDefaultValue(const Nullable<Record<nsString, int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableRecordWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalObjectRecord(const Optional<Record<nsString, OwningNonNull<TestInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalObjectRecord(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassExternalInterfaceRecord(const Record<nsString, RefPtr<TestExternalInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassExternalInterfaceRecord(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableExternalInterfaceRecord(const Record<nsString, RefPtr<TestExternalInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableExternalInterfaceRecord(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassStringRecord(const Record<nsString, nsString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassStringRecord(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassByteStringRecord(const Record<nsString, nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassByteStringRecord(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUTF8StringRecord(const Record<nsString, nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUTF8StringRecord(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassRecordOfRecords(const Record<nsString, Record<nsString, int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassRecordOfRecords(arg, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveRecord(Record<nsString, int32_t>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveRecord(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveNullableRecord(Nullable<Record<nsString, int32_t>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableRecord(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveRecordOfNullableInts(Record<nsString, Nullable<int32_t>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveRecordOfNullableInts(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveNullableRecordOfNullableInts(Nullable<Record<nsString, Nullable<int32_t>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableRecordOfNullableInts(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveAnyRecord(Record<nsString, JS::Value>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveAnyRecord(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::PassArrayBuffer(const ArrayBuffer& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassArrayBuffer(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableArrayBuffer(const Nullable<ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableArrayBuffer(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalArrayBuffer(const Optional<ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalArrayBuffer(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableArrayBuffer(const Optional<Nullable<ArrayBuffer>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableArrayBuffer(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableArrayBufferWithDefaultValue(const Nullable<ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableArrayBufferWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassArrayBufferView(const ArrayBufferView& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassArrayBufferView(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassInt8Array(const Int8Array& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassInt8Array(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassInt16Array(const Int16Array& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassInt16Array(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassInt32Array(const Int32Array& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassInt32Array(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUint8Array(const Uint8Array& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUint8Array(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUint16Array(const Uint16Array& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUint16Array(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUint32Array(const Uint32Array& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUint32Array(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUint8ClampedArray(const Uint8ClampedArray& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUint8ClampedArray(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassFloat32Array(const Float32Array& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassFloat32Array(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassFloat64Array(const Float64Array& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassFloat64Array(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassSequenceOfArrayBuffers(const Sequence<ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassSequenceOfArrayBuffers(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassSequenceOfNullableArrayBuffers(const Sequence<Nullable<ArrayBuffer>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassSequenceOfNullableArrayBuffers(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassRecordOfArrayBuffers(const Record<nsString, ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassRecordOfArrayBuffers(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassRecordOfNullableArrayBuffers(const Record<nsString, Nullable<ArrayBuffer>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassRecordOfNullableArrayBuffers(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassVariadicTypedArray(const Sequence<Float32Array>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassVariadicTypedArray(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassVariadicNullableTypedArray(const Sequence<Nullable<Float32Array>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassVariadicNullableTypedArray(arg, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveUint8Array(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveUint8Array(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::GetUint8ArrayAttr(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetUint8ArrayAttr(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::SetUint8ArrayAttr(const Uint8Array& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetUint8ArrayAttr(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassString(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassString(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableString(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableString(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalString(const Optional<nsAString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalString(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalStringWithDefaultValue(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalStringWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableString(const Optional<nsAString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableString(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableStringWithDefaultValue(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableStringWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassVariadicString(const Sequence<nsString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassVariadicString(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassByteString(const nsCString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassByteString(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableByteString(const nsCString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableByteString(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalByteString(const Optional<nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalByteString(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalByteStringWithDefaultValue(const nsCString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalByteStringWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableByteString(const Optional<nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableByteString(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableByteStringWithDefaultValue(const nsCString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableByteStringWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassVariadicByteString(const Sequence<nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassVariadicByteString(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionByteString(const ByteStringOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionByteString(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalUnionByteString(const Optional<ByteStringOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalUnionByteString(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalUnionByteStringWithDefaultValue(const ByteStringOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalUnionByteStringWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUTF8String(const nsACString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUTF8String(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUTF8String(const nsACString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUTF8String(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalUTF8String(const Optional<nsACString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalUTF8String(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalUTF8StringWithDefaultValue(const nsACString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalUTF8StringWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableUTF8String(const Optional<nsACString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableUTF8String(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableUTF8StringWithDefaultValue(const nsACString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableUTF8StringWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassVariadicUTF8String(const Sequence<nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassVariadicUTF8String(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionUTF8String(const UTF8StringOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionUTF8String(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalUnionUTF8String(const Optional<UTF8StringOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalUnionUTF8String(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalUnionUTF8StringWithDefaultValue(const UTF8StringOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalUnionUTF8StringWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassSVS(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassSVS(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableSVS(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableSVS(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalSVS(const Optional<nsAString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalSVS(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalSVSWithDefaultValue(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalSVSWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableSVS(const Optional<nsAString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableSVS(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableSVSWithDefaultValue(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableSVSWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassVariadicSVS(const Sequence<nsString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassVariadicSVS(arg, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveSVS(nsString& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveSVS(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::PassJSString(JS::Handle<JSString*> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassJSString(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalJSStringWithDefaultValue(JS::Handle<JSString*> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalJSStringWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveJSString(JS::MutableHandle<JSString*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveJSString(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::GetReadonlyJSStringAttr(JS::MutableHandle<JSString*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetReadonlyJSStringAttr(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::GetJsStringAttr(JS::MutableHandle<JSString*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetJsStringAttr(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::SetJsStringAttr(JS::Handle<JSString*> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetJsStringAttr(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassEnum(MyTestEnum arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassEnum(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableEnum(const Nullable<MyTestEnum>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableEnum(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalEnum(const Optional<MyTestEnum>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalEnum(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassEnumWithDefault(MyTestEnum arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassEnumWithDefault(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableEnum(const Optional<Nullable<MyTestEnum>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableEnum(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableEnumWithDefaultValue(const Nullable<MyTestEnum>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableEnumWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableEnumWithDefaultValue2(const Nullable<MyTestEnum>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableEnumWithDefaultValue2(arg, aRv, aRealm);
}

MyTestEnum
TestJSImplInterface::ReceiveEnum(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveEnum(aRv, aRealm);
}

Nullable<MyTestEnum>
TestJSImplInterface::ReceiveNullableEnum(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableEnum(aRv, aRealm);
}

MyTestEnum
TestJSImplInterface::GetEnumAttribute(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetEnumAttribute(aRv, aRealm);
}

void
TestJSImplInterface::SetEnumAttribute(MyTestEnum arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetEnumAttribute(arg, aRv, aRealm);
}

MyTestEnum
TestJSImplInterface::GetReadonlyEnumAttribute(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetReadonlyEnumAttribute(aRv, aRealm);
}

void
TestJSImplInterface::PassCallback(MyTestCallback& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassCallback(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableCallback(MyTestCallback* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableCallback(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalCallback(const Optional<OwningNonNull<MyTestCallback>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalCallback(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableCallback(const Optional<RefPtr<MyTestCallback>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableCallback(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableCallbackWithDefaultValue(MyTestCallback* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableCallbackWithDefaultValue(arg, aRv, aRealm);
}

already_AddRefed<MyTestCallback>
TestJSImplInterface::ReceiveCallback(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveCallback(aRv, aRealm);
}

already_AddRefed<MyTestCallback>
TestJSImplInterface::ReceiveNullableCallback(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableCallback(aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableTreatAsNullCallbackWithDefaultValue(TestTreatAsNullCallback* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableTreatAsNullCallbackWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassAny(JS::Handle<JS::Value> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassVariadicAny(const Sequence<JS::Value>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassVariadicAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalAny(JS::Handle<JS::Value> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassAnyDefaultNull(JS::Handle<JS::Value> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassAnyDefaultNull(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassSequenceOfAny(const Sequence<JS::Value>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassSequenceOfAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableSequenceOfAny(const Nullable<Sequence<JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableSequenceOfAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalSequenceOfAny(const Optional<Sequence<JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalSequenceOfAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableSequenceOfAny(const Optional<Nullable<Sequence<JS::Value>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableSequenceOfAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalSequenceOfAnyWithDefaultValue(const Nullable<Sequence<JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalSequenceOfAnyWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassSequenceOfSequenceOfAny(const Sequence<Sequence<JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassSequenceOfSequenceOfAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassSequenceOfNullableSequenceOfAny(const Sequence<Nullable<Sequence<JS::Value>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassSequenceOfNullableSequenceOfAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableSequenceOfNullableSequenceOfAny(const Nullable<Sequence<Nullable<Sequence<JS::Value>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableSequenceOfNullableSequenceOfAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableSequenceOfNullableSequenceOfAny(const Optional<Nullable<Sequence<Nullable<Sequence<JS::Value>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableSequenceOfNullableSequenceOfAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassRecordOfAny(const Record<nsString, JS::Value>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassRecordOfAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableRecordOfAny(const Nullable<Record<nsString, JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableRecordOfAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalRecordOfAny(const Optional<Record<nsString, JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalRecordOfAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableRecordOfAny(const Optional<Nullable<Record<nsString, JS::Value>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableRecordOfAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalRecordOfAnyWithDefaultValue(const Nullable<Record<nsString, JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalRecordOfAnyWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassRecordOfRecordOfAny(const Record<nsString, Record<nsString, JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassRecordOfRecordOfAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassRecordOfNullableRecordOfAny(const Record<nsString, Nullable<Record<nsString, JS::Value>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassRecordOfNullableRecordOfAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableRecordOfNullableRecordOfAny(const Nullable<Record<nsString, Nullable<Record<nsString, JS::Value>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableRecordOfNullableRecordOfAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableRecordOfNullableRecordOfAny(const Optional<Nullable<Record<nsString, Nullable<Record<nsString, JS::Value>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableRecordOfNullableRecordOfAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableRecordOfNullableSequenceOfAny(const Optional<Nullable<Record<nsString, Nullable<Sequence<JS::Value>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableRecordOfNullableSequenceOfAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableSequenceOfNullableRecordOfAny(const Optional<Nullable<Sequence<Nullable<Record<nsString, JS::Value>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableSequenceOfNullableRecordOfAny(arg, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveAny(JS::MutableHandle<JS::Value> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveAny(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::PassObject(JS::Handle<JSObject*> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassObject(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassVariadicObject(const Sequence<JSObject*>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassVariadicObject(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableObject(JS::Handle<JSObject*> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableObject(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassVariadicNullableObject(const Sequence<JSObject*>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassVariadicNullableObject(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalObject(const Optional<JS::Handle<JSObject*>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalObject(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableObject(const Optional<JS::Handle<JSObject*>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableObject(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableObjectWithDefaultValue(JS::Handle<JSObject*> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableObjectWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassSequenceOfObject(const Sequence<JSObject*>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassSequenceOfObject(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassSequenceOfNullableObject(const Sequence<JSObject*>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassSequenceOfNullableObject(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableSequenceOfObject(const Nullable<Sequence<JSObject*>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableSequenceOfObject(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableSequenceOfNullableSequenceOfObject(const Optional<Nullable<Sequence<Nullable<Sequence<JSObject*>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableSequenceOfNullableSequenceOfObject(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableSequenceOfNullableSequenceOfNullableObject(const Optional<Nullable<Sequence<Nullable<Sequence<JSObject*>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableSequenceOfNullableSequenceOfNullableObject(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassRecordOfObject(const Record<nsString, JSObject*>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassRecordOfObject(arg, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveObject(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveObject(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveNullableObject(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableObject(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::PassUnion(const ObjectOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnion(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithNullable(const ObjectOrNullOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithNullable(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnion(const Nullable<ObjectOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnion(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalUnion(const Optional<ObjectOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalUnion(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableUnion(const Optional<Nullable<ObjectOrLong>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableUnion(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalNullableUnionWithDefaultValue(const Nullable<ObjectOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalNullableUnionWithDefaultValue(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithArrayBuffer(const ArrayBufferOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithArrayBuffer(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithString(const StringOrObject& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithString(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithEnum(const SupportedTypeOrObject& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithEnum(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithObject(const ObjectOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithObject(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue1(const DoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue1(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue2(const DoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue2(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue3(const DoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue3(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue4(const FloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue4(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue5(const FloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue5(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue6(const FloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue6(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue7(const UnrestrictedDoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue7(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue8(const UnrestrictedDoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue8(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue9(const UnrestrictedDoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue9(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue10(const UnrestrictedDoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue10(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue11(const UnrestrictedFloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue11(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue12(const UnrestrictedFloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue12(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue13(const UnrestrictedFloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue13(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue14(const DoubleOrByteString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue14(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue15(const DoubleOrByteString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue15(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue16(const DoubleOrByteString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue16(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue17(const DoubleOrSupportedType& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue17(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue18(const DoubleOrSupportedType& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue18(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue19(const DoubleOrSupportedType& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue19(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue20(const DoubleOrUSVString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue20(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue21(const DoubleOrUSVString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue21(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue22(const DoubleOrUSVString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue22(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue23(const DoubleOrUTF8String& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue23(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue24(const DoubleOrUTF8String& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue24(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionWithDefaultValue25(const DoubleOrUTF8String& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionWithDefaultValue25(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue1(const Nullable<DoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue1(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue2(const Nullable<DoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue2(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue3(const Nullable<DoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue3(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue4(const Nullable<FloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue4(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue5(const Nullable<FloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue5(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue6(const Nullable<FloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue6(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue7(const Nullable<UnrestrictedDoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue7(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue8(const Nullable<UnrestrictedDoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue8(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue9(const Nullable<UnrestrictedDoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue9(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue10(const Nullable<UnrestrictedFloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue10(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue11(const Nullable<UnrestrictedFloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue11(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue12(const Nullable<UnrestrictedFloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue12(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue13(const Nullable<DoubleOrByteString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue13(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue14(const Nullable<DoubleOrByteString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue14(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue15(const Nullable<DoubleOrByteString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue15(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue16(const Nullable<DoubleOrByteString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue16(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue17(const Nullable<DoubleOrSupportedType>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue17(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue18(const Nullable<DoubleOrSupportedType>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue18(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue19(const Nullable<DoubleOrSupportedType>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue19(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue20(const Nullable<DoubleOrSupportedType>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue20(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue21(const Nullable<DoubleOrUSVString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue21(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue22(const Nullable<DoubleOrUSVString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue22(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue23(const Nullable<DoubleOrUSVString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue23(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue24(const Nullable<DoubleOrUSVString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue24(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue25(const Nullable<DoubleOrUTF8String>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue25(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue26(const Nullable<DoubleOrUTF8String>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue26(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue27(const Nullable<DoubleOrUTF8String>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue27(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassNullableUnionWithDefaultValue28(const Nullable<DoubleOrUTF8String>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassNullableUnionWithDefaultValue28(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassSequenceOfUnions(const Sequence<OwningCanvasPatternOrCanvasGradient>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassSequenceOfUnions(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassSequenceOfUnions2(const Sequence<OwningObjectOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassSequenceOfUnions2(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassVariadicUnion(const Sequence<OwningCanvasPatternOrCanvasGradient>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassVariadicUnion(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassSequenceOfNullableUnions(const Sequence<Nullable<OwningCanvasPatternOrCanvasGradient>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassSequenceOfNullableUnions(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassVariadicNullableUnion(const Sequence<Nullable<OwningCanvasPatternOrCanvasGradient>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassVariadicNullableUnion(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassRecordOfUnions(const Record<nsString, OwningCanvasPatternOrCanvasGradient>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassRecordOfUnions(arg, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveUnion(OwningCanvasPatternOrCanvasGradient& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveUnion(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveUnion2(OwningObjectOrLong& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveUnion2(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveUnionContainingNull(OwningCanvasPatternOrNullOrCanvasGradient& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveUnionContainingNull(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveNullableUnion(Nullable<OwningCanvasPatternOrCanvasGradient>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableUnion(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveNullableUnion2(Nullable<OwningObjectOrLong>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableUnion2(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::GetWritableUnion(OwningCanvasPatternOrCanvasGradient& aRetVal, ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetWritableUnion(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::SetWritableUnion(const CanvasPatternOrCanvasGradient& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetWritableUnion(arg, aRv, aRealm);
}

void
TestJSImplInterface::GetWritableUnionContainingNull(OwningCanvasPatternOrNullOrCanvasGradient& aRetVal, ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetWritableUnionContainingNull(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::SetWritableUnionContainingNull(const CanvasPatternOrNullOrCanvasGradient& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetWritableUnionContainingNull(arg, aRv, aRealm);
}

void
TestJSImplInterface::GetWritableNullableUnion(Nullable<OwningCanvasPatternOrCanvasGradient>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetWritableNullableUnion(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::SetWritableNullableUnion(const Nullable<CanvasPatternOrCanvasGradient>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetWritableNullableUnion(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassPromise(Promise& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassPromise(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassOptionalPromise(const Optional<OwningNonNull<Promise>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOptionalPromise(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassPromiseSequence(const Sequence<OwningNonNull<Promise>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassPromiseSequence(arg, aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<Promise>
TestJSImplInterface::ReceivePromise(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceivePromise(aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<Promise>
TestJSImplInterface::ReceiveAddrefedPromise(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveAddrefedPromise(aRv, aRealm);
}

void
TestJSImplInterface::MethodRenamedTo(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->MethodRenamedTo(aRv, aRealm);
}

void
TestJSImplInterface::MethodRenamedTo(int8_t argument, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->MethodRenamedTo(argument, aRv, aRealm);
}

int8_t
TestJSImplInterface::GetAttributeGetterRenamedTo(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetAttributeGetterRenamedTo(aRv, aRealm);
}

int8_t
TestJSImplInterface::GetAttributeRenamedTo(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetAttributeRenamedTo(aRv, aRealm);
}

void
TestJSImplInterface::SetAttributeRenamedTo(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetAttributeRenamedTo(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassDictionary(const Dict& x, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassDictionary(x, aRv, aRealm);
}

void
TestJSImplInterface::PassDictionary2(const Dict& x, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassDictionary2(x, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveDictionary(Dict& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveDictionary(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveNullableDictionary(Nullable<Dict>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveNullableDictionary(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::PassOtherDictionary(const GrandparentDict& x, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassOtherDictionary(x, aRv, aRealm);
}

void
TestJSImplInterface::PassSequenceOfDictionaries(const Sequence<Dict>& x, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassSequenceOfDictionaries(x, aRv, aRealm);
}

void
TestJSImplInterface::PassRecordOfDictionaries(const Record<nsString, GrandparentDict>& x, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassRecordOfDictionaries(x, aRv, aRealm);
}

void
TestJSImplInterface::PassDictionaryOrLong(const Dict& x, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassDictionaryOrLong(x, aRv, aRealm);
}

void
TestJSImplInterface::PassDictionaryOrLong(int32_t x, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassDictionaryOrLong(x, aRv, aRealm);
}

void
TestJSImplInterface::PassDictContainingDict(const DictContainingDict& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassDictContainingDict(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassDictContainingSequence(const DictContainingSequence& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassDictContainingSequence(arg, aRv, aRealm);
}

void
TestJSImplInterface::ReceiveDictContainingSequence(DictContainingSequence& aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ReceiveDictContainingSequence(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::PassVariadicDictionary(const Sequence<Dict>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassVariadicDictionary(arg, aRv, aRealm);
}

void
TestJSImplInterface::DontEnforceRangeOrClamp(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->DontEnforceRangeOrClamp(arg, aRv, aRealm);
}

void
TestJSImplInterface::DoEnforceRange(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->DoEnforceRange(arg, aRv, aRealm);
}

void
TestJSImplInterface::DoEnforceRangeNullable(const Nullable<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->DoEnforceRangeNullable(arg, aRv, aRealm);
}

void
TestJSImplInterface::DoClamp(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->DoClamp(arg, aRv, aRealm);
}

void
TestJSImplInterface::DoClampNullable(const Nullable<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->DoClampNullable(arg, aRv, aRealm);
}

int8_t
TestJSImplInterface::GetEnforcedByte(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetEnforcedByte(aRv, aRealm);
}

void
TestJSImplInterface::SetEnforcedByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetEnforcedByte(arg, aRv, aRealm);
}

Nullable<int8_t>
TestJSImplInterface::GetEnforcedByteNullable(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetEnforcedByteNullable(aRv, aRealm);
}

void
TestJSImplInterface::SetEnforcedByteNullable(const Nullable<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetEnforcedByteNullable(arg, aRv, aRealm);
}

int8_t
TestJSImplInterface::GetClampedByte(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetClampedByte(aRv, aRealm);
}

void
TestJSImplInterface::SetClampedByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetClampedByte(arg, aRv, aRealm);
}

Nullable<int8_t>
TestJSImplInterface::GetClampedByteNullable(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetClampedByteNullable(aRv, aRealm);
}

void
TestJSImplInterface::SetClampedByteNullable(const Nullable<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetClampedByteNullable(arg, aRv, aRealm);
}

void
TestJSImplInterface::ExerciseTypedefInterfaces1(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ExerciseTypedefInterfaces1(arg, aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestJSImplInterface>
TestJSImplInterface::ExerciseTypedefInterfaces2(TestJSImplInterface* arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ExerciseTypedefInterfaces2(arg, aRv, aRealm);
}

void
TestJSImplInterface::ExerciseTypedefInterfaces3(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ExerciseTypedefInterfaces3(arg, aRv, aRealm);
}

int8_t
TestJSImplInterface::GetDeprecatedAttribute(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetDeprecatedAttribute(aRv, aRealm);
}

void
TestJSImplInterface::SetDeprecatedAttribute(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetDeprecatedAttribute(arg, aRv, aRealm);
}

int8_t
TestJSImplInterface::DeprecatedMethod(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->DeprecatedMethod(aRv, aRealm);
}

void
TestJSImplInterface::DeprecatedMethodWithContext(JS::Handle<JS::Value> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->DeprecatedMethodWithContext(arg, aRv, aRealm);
}

bool
TestJSImplInterface::Overload1(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload1(arg, aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestJSImplInterface>
TestJSImplInterface::Overload1(const nsAString& strs, TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload1(strs, arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload2(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload2(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload2(const Dict& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload2(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload2(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload2(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload2(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload2(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload3(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload3(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload3(MyTestCallback& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload3(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload3(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload3(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload4(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload4(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload4(TestCallbackInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload4(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload4(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload4(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload5(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload5(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload5(MyTestEnum arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload5(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload6(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload6(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload6(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload6(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload7(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload7(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload7(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload7(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload7(const nsCString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload7(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload8(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload8(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload8(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload8(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload9(const Nullable<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload9(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload9(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload9(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload10(const Nullable<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload10(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload10(JS::Handle<JSObject*> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload10(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload11(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload11(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload11(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload11(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload12(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload12(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload12(const Nullable<bool>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload12(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload13(const Nullable<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload13(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload13(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload13(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload14(const Optional<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload14(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload14(TestInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload14(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload15(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload15(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload15(const Optional<NonNull<TestInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload15(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload16(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload16(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload16(const Optional<TestInterface*>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload16(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload17(const Sequence<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload17(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload17(const Record<nsString, int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload17(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload18(const Record<nsString, nsString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload18(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload18(const Sequence<nsString>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload18(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload19(const Sequence<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload19(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload19(const Dict& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload19(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload20(const Dict& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload20(arg, aRv, aRealm);
}

void
TestJSImplInterface::Overload20(const Sequence<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Overload20(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassVariadicThirdArg(const nsAString& arg1, int32_t arg2, const Sequence<OwningNonNull<TestJSImplInterface>>& arg3, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassVariadicThirdArg(arg1, arg2, arg3, aRv, aRealm);
}

bool
TestJSImplInterface::GetPrefable1(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetPrefable1(aRv, aRealm);
}

bool
TestJSImplInterface::GetPrefable2(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetPrefable2(aRv, aRealm);
}

bool
TestJSImplInterface::GetPrefable3(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetPrefable3(aRv, aRealm);
}

bool
TestJSImplInterface::GetPrefable4(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetPrefable4(aRv, aRealm);
}

bool
TestJSImplInterface::GetPrefable5(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetPrefable5(aRv, aRealm);
}

bool
TestJSImplInterface::GetPrefable6(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetPrefable6(aRv, aRealm);
}

bool
TestJSImplInterface::GetPrefable7(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetPrefable7(aRv, aRealm);
}

bool
TestJSImplInterface::GetPrefable8(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetPrefable8(aRv, aRealm);
}

bool
TestJSImplInterface::GetPrefable9(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetPrefable9(aRv, aRealm);
}

void
TestJSImplInterface::Prefable10(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Prefable10(aRv, aRealm);
}

void
TestJSImplInterface::Prefable11(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Prefable11(aRv, aRealm);
}

bool
TestJSImplInterface::GetPrefable12(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetPrefable12(aRv, aRealm);
}

void
TestJSImplInterface::Prefable13(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Prefable13(aRv, aRealm);
}

bool
TestJSImplInterface::GetPrefable14(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetPrefable14(aRv, aRealm);
}

bool
TestJSImplInterface::GetPrefable15(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetPrefable15(aRv, aRealm);
}

bool
TestJSImplInterface::GetPrefable16(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetPrefable16(aRv, aRealm);
}

void
TestJSImplInterface::Prefable17(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Prefable17(aRv, aRealm);
}

void
TestJSImplInterface::Prefable18(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Prefable18(aRv, aRealm);
}

void
TestJSImplInterface::Prefable19(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Prefable19(aRv, aRealm);
}

void
TestJSImplInterface::Prefable20(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Prefable20(aRv, aRealm);
}

bool
TestJSImplInterface::GetConditionalOnSecureContext1(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetConditionalOnSecureContext1(aRv, aRealm);
}

bool
TestJSImplInterface::GetConditionalOnSecureContext2(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetConditionalOnSecureContext2(aRv, aRealm);
}

bool
TestJSImplInterface::GetConditionalOnSecureContext3(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetConditionalOnSecureContext3(aRv, aRealm);
}

bool
TestJSImplInterface::GetConditionalOnSecureContext4(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetConditionalOnSecureContext4(aRv, aRealm);
}

void
TestJSImplInterface::ConditionalOnSecureContext5(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ConditionalOnSecureContext5(aRv, aRealm);
}

void
TestJSImplInterface::ConditionalOnSecureContext6(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ConditionalOnSecureContext6(aRv, aRealm);
}

void
TestJSImplInterface::ConditionalOnSecureContext7(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ConditionalOnSecureContext7(aRv, aRealm);
}

void
TestJSImplInterface::ConditionalOnSecureContext8(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ConditionalOnSecureContext8(aRv, aRealm);
}

int32_t
TestJSImplInterface::GetAttrWithLenientThis(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetAttrWithLenientThis(aRv, aRealm);
}

void
TestJSImplInterface::SetAttrWithLenientThis(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetAttrWithLenientThis(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassRenamedInterface(nsRenamedInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassRenamedInterface(arg, aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestJSImplInterface>
TestJSImplInterface::GetPutForwardsAttr(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetPutForwardsAttr(aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestJSImplInterface>
TestJSImplInterface::GetPutForwardsAttr2(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetPutForwardsAttr2(aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestJSImplInterface>
TestJSImplInterface::GetPutForwardsAttr3(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetPutForwardsAttr3(aRv, aRealm);
}

void
TestJSImplInterface::ThrowingMethod(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ThrowingMethod(aRv, aRealm);
}

bool
TestJSImplInterface::GetThrowingAttr(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetThrowingAttr(aRv, aRealm);
}

void
TestJSImplInterface::SetThrowingAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetThrowingAttr(arg, aRv, aRealm);
}

bool
TestJSImplInterface::GetThrowingGetterAttr(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetThrowingGetterAttr(aRv, aRealm);
}

void
TestJSImplInterface::SetThrowingGetterAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetThrowingGetterAttr(arg, aRv, aRealm);
}

bool
TestJSImplInterface::GetThrowingSetterAttr(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetThrowingSetterAttr(aRv, aRealm);
}

void
TestJSImplInterface::SetThrowingSetterAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetThrowingSetterAttr(arg, aRv, aRealm);
}

void
TestJSImplInterface::CanOOMMethod(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->CanOOMMethod(aRv, aRealm);
}

bool
TestJSImplInterface::GetCanOOMAttr(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetCanOOMAttr(aRv, aRealm);
}

void
TestJSImplInterface::SetCanOOMAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetCanOOMAttr(arg, aRv, aRealm);
}

bool
TestJSImplInterface::GetCanOOMGetterAttr(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetCanOOMGetterAttr(aRv, aRealm);
}

void
TestJSImplInterface::SetCanOOMGetterAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetCanOOMGetterAttr(arg, aRv, aRealm);
}

bool
TestJSImplInterface::GetCanOOMSetterAttr(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetCanOOMSetterAttr(aRv, aRealm);
}

void
TestJSImplInterface::SetCanOOMSetterAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetCanOOMSetterAttr(arg, aRv, aRealm);
}

void
TestJSImplInterface::CeReactionsMethod(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->CeReactionsMethod(aRv, aRealm);
}

void
TestJSImplInterface::CeReactionsMethodOverload(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->CeReactionsMethodOverload(aRv, aRealm);
}

void
TestJSImplInterface::CeReactionsMethodOverload(const nsAString& bar, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->CeReactionsMethodOverload(bar, aRv, aRealm);
}

bool
TestJSImplInterface::GetCeReactionsAttr(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetCeReactionsAttr(aRv, aRealm);
}

void
TestJSImplInterface::SetCeReactionsAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetCeReactionsAttr(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassArgsWithDefaults(const Optional<int32_t>& arg1, TestInterface* arg2, const Dict& arg3, double arg4, const Optional<float>& arg5, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassArgsWithDefaults(arg1, arg2, arg3, arg4, arg5, aRv, aRealm);
}

void
TestJSImplInterface::GetToJSONShouldSkipThis(JS::MutableHandle<JS::Value> aRetVal, ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetToJSONShouldSkipThis(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::SetToJSONShouldSkipThis(JS::Handle<JS::Value> arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetToJSONShouldSkipThis(arg, aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestParentInterface>
TestJSImplInterface::GetToJSONShouldSkipThis2(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetToJSONShouldSkipThis2(aRv, aRealm);
}

void
TestJSImplInterface::SetToJSONShouldSkipThis2(TestParentInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetToJSONShouldSkipThis2(arg, aRv, aRealm);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<TestCallbackInterface>
TestJSImplInterface::GetToJSONShouldSkipThis3(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetToJSONShouldSkipThis3(aRv, aRealm);
}

void
TestJSImplInterface::SetToJSONShouldSkipThis3(TestCallbackInterface& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetToJSONShouldSkipThis3(arg, aRv, aRealm);
}

void
TestJSImplInterface::ToJSON(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->ToJSON(aRetVal, aRv, aRealm);
}

int8_t
TestJSImplInterface::GetDashed_attribute(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetDashed_attribute(aRv, aRealm);
}

void
TestJSImplInterface::SetDashed_attribute(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetDashed_attribute(arg, aRv, aRealm);
}

void
TestJSImplInterface::Dashed_method(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->Dashed_method(aRv, aRealm);
}

bool
TestJSImplInterface::GetNonEnumerableAttr(ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetNonEnumerableAttr(aRv, aRealm);
}

void
TestJSImplInterface::SetNonEnumerableAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetNonEnumerableAttr(arg, aRv, aRealm);
}

void
TestJSImplInterface::NonEnumerableMethod(ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->NonEnumerableMethod(aRv, aRealm);
}

void
TestJSImplInterface::GetAllowSharedArrayBufferViewTypedef(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetAllowSharedArrayBufferViewTypedef(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::SetAllowSharedArrayBufferViewTypedef(const ArrayBufferView& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetAllowSharedArrayBufferViewTypedef(arg, aRv, aRealm);
}

void
TestJSImplInterface::GetAllowSharedArrayBufferView(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetAllowSharedArrayBufferView(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::SetAllowSharedArrayBufferView(const ArrayBufferView& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetAllowSharedArrayBufferView(arg, aRv, aRealm);
}

void
TestJSImplInterface::GetAllowSharedNullableArrayBufferView(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetAllowSharedNullableArrayBufferView(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::SetAllowSharedNullableArrayBufferView(const Nullable<ArrayBufferView>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetAllowSharedNullableArrayBufferView(arg, aRv, aRealm);
}

void
TestJSImplInterface::GetAllowSharedArrayBuffer(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetAllowSharedArrayBuffer(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::SetAllowSharedArrayBuffer(const ArrayBuffer& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetAllowSharedArrayBuffer(arg, aRv, aRealm);
}

void
TestJSImplInterface::GetAllowSharedNullableArrayBuffer(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm) const
{
  return mImpl->GetAllowSharedNullableArrayBuffer(aRetVal, aRv, aRealm);
}

void
TestJSImplInterface::SetAllowSharedNullableArrayBuffer(const Nullable<ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm)
{
  mImpl->SetAllowSharedNullableArrayBuffer(arg, aRv, aRealm);
}

void
TestJSImplInterface::PassAllowSharedArrayBufferViewTypedef(const ArrayBufferView& foo, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassAllowSharedArrayBufferViewTypedef(foo, aRv, aRealm);
}

void
TestJSImplInterface::PassAllowSharedArrayBufferView(const ArrayBufferView& foo, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassAllowSharedArrayBufferView(foo, aRv, aRealm);
}

void
TestJSImplInterface::PassAllowSharedNullableArrayBufferView(const Nullable<ArrayBufferView>& foo, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassAllowSharedNullableArrayBufferView(foo, aRv, aRealm);
}

void
TestJSImplInterface::PassAllowSharedArrayBuffer(const ArrayBuffer& foo, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassAllowSharedArrayBuffer(foo, aRv, aRealm);
}

void
TestJSImplInterface::PassAllowSharedNullableArrayBuffer(const Nullable<ArrayBuffer>& foo, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassAllowSharedNullableArrayBuffer(foo, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionArrayBuffer(const StringOrArrayBuffer& foo, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionArrayBuffer(foo, aRv, aRealm);
}

void
TestJSImplInterface::PassUnionAllowSharedArrayBuffer(const StringOrMaybeSharedArrayBuffer& foo, ErrorResult& aRv, JS::Realm* aRealm)
{
  return mImpl->PassUnionAllowSharedArrayBuffer(foo, aRv, aRealm);
}

bool
TestJSImplInterface::_Create(JSContext* cx, unsigned argc, JS::Value* vp)
{
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  if (!args.requireAtLeast(cx, "TestJSImplInterface._create", 2)) {
    return false;
  }
  BindingCallContext callCx(cx, "TestJSImplInterface._create");
  if (!args[0].isObject()) {
    return callCx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
  }
  if (!args[1].isObject()) {
    return callCx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 2");
  }

  // GlobalObject will go through wrappers as needed for us, and
  // is simpler than the right UnwrapArg incantation.
  GlobalObject global(cx, &args[0].toObject());
  if (global.Failed()) {
    return false;
  }
  nsCOMPtr<nsIGlobalObject> globalHolder = do_QueryInterface(global.GetAsSupports());
  MOZ_ASSERT(globalHolder);
  JS::Rooted<JSObject*> arg(cx, &args[1].toObject());
  JS::Rooted<JSObject*> argGlobal(cx, JS::CurrentGlobalOrNull(cx));
  RefPtr<TestJSImplInterface> impl = new TestJSImplInterface(arg, argGlobal, globalHolder);
  MOZ_ASSERT(js::IsObjectInContextCompartment(arg, cx));
  return GetOrCreateDOMReflector(cx, impl, args.rval());
}


NS_IMPL_CYCLE_COLLECTION_CLASS(TestJSImplNoInterfaceObject)
NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(TestJSImplNoInterfaceObject)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mImpl)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mParent)
  NS_IMPL_CYCLE_COLLECTION_UNLINK_PRESERVED_WRAPPER
  tmp->ClearWeakReferences();
NS_IMPL_CYCLE_COLLECTION_UNLINK_END
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(TestJSImplNoInterfaceObject)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mImpl)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mParent)
NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
NS_IMPL_CYCLE_COLLECTION_TRACE_WRAPPERCACHE(TestJSImplNoInterfaceObject)
NS_IMPL_CYCLE_COLLECTING_ADDREF(TestJSImplNoInterfaceObject)
NS_IMPL_CYCLE_COLLECTING_RELEASE(TestJSImplNoInterfaceObject)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(TestJSImplNoInterfaceObject)
  NS_WRAPPERCACHE_INTERFACE_MAP_ENTRY
  NS_INTERFACE_MAP_ENTRY(nsISupports)
  NS_INTERFACE_MAP_ENTRY(nsISupportsWeakReference)
NS_INTERFACE_MAP_END

TestJSImplNoInterfaceObject::TestJSImplNoInterfaceObject(JS::Handle<JSObject*> aJSImplObject, JS::Handle<JSObject*> aJSImplGlobal, nsIGlobalObject* aParent)
  : mImpl(new TestJSImplNoInterfaceObjectJSImpl(nullptr, aJSImplObject, aJSImplGlobal, /* aIncumbentGlobal = */ nullptr)),
    mParent(aParent)
{
}


TestJSImplNoInterfaceObject::~TestJSImplNoInterfaceObject()
{
}

nsISupports*
TestJSImplNoInterfaceObject::GetParentObject() const
{
  return mParent;
}

JSObject*
TestJSImplNoInterfaceObject::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
{
  JS::Rooted<JSObject*> obj(aCx, TestJSImplNoInterfaceObject_Binding::Wrap(aCx, this, aGivenProto));
  if (!obj) {
    return nullptr;
  }

  // Now define it on our chrome object
  JSAutoRealm ar(aCx, mImpl->CallbackGlobalOrNull());
  if (!JS_WrapObject(aCx, &obj)) {
    return nullptr;
  }
  JS::Rooted<JSObject*> callback(aCx, mImpl->CallbackOrNull());
  if (!JS_DefineProperty(aCx, callback, "__DOM_IMPL__", obj, 0)) {
    return nullptr;
  }
  return obj;
}

bool
TestJSImplNoInterfaceObject::_Create(JSContext* cx, unsigned argc, JS::Value* vp)
{
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  if (!args.requireAtLeast(cx, "TestJSImplNoInterfaceObject._create", 2)) {
    return false;
  }
  BindingCallContext callCx(cx, "TestJSImplNoInterfaceObject._create");
  if (!args[0].isObject()) {
    return callCx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
  }
  if (!args[1].isObject()) {
    return callCx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 2");
  }

  // GlobalObject will go through wrappers as needed for us, and
  // is simpler than the right UnwrapArg incantation.
  GlobalObject global(cx, &args[0].toObject());
  if (global.Failed()) {
    return false;
  }
  nsCOMPtr<nsIGlobalObject> globalHolder = do_QueryInterface(global.GetAsSupports());
  MOZ_ASSERT(globalHolder);
  JS::Rooted<JSObject*> arg(cx, &args[1].toObject());
  JS::Rooted<JSObject*> argGlobal(cx, JS::CurrentGlobalOrNull(cx));
  RefPtr<TestJSImplNoInterfaceObject> impl = new TestJSImplNoInterfaceObject(arg, argGlobal, globalHolder);
  MOZ_ASSERT(js::IsObjectInContextCompartment(arg, cx));
  return GetOrCreateDOMReflector(cx, impl, args.rval());
}


} // namespace dom
} // namespace mozilla
