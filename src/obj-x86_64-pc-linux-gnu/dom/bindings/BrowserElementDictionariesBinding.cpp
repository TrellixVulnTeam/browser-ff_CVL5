/* THIS FILE IS AUTOGENERATED FROM BrowserElementDictionaries.webidl BY Codegen.py - DO NOT EDIT */

#include <type_traits>
#include "AtomList.h"
#include "BrowserElementDictionariesBinding.h"
#include "GeckoProfiler.h"
#include "js/Object.h"
#include "js/experimental/JitInfo.h"
#include "mozilla/OwningNonNull.h"
#include "mozilla/dom/BindingCallContext.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/PrimitiveConversions.h"
#include "mozilla/dom/ScriptSettings.h"
#include "mozilla/dom/SimpleGlobalObject.h"

namespace mozilla {
namespace dom {

namespace binding_detail {}; // Just to make sure it's known as a namespace
using namespace mozilla::dom::binding_detail;



DOMWindowResizeEventDetail::DOMWindowResizeEventDetail()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
DOMWindowResizeEventDetail::InitIds(JSContext* cx, DOMWindowResizeEventDetailAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->width_id.init(cx, "width") ||
      !atomsCache->height_id.init(cx, "height")) {
    return false;
  }
  return true;
}

bool
DOMWindowResizeEventDetail::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mHeight = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mWidth = 0;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
DOMWindowResizeEventDetail::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  DOMWindowResizeEventDetailAtoms* atomsCache = GetAtomCache<DOMWindowResizeEventDetailAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mHeight;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->height_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mWidth;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->width_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
DOMWindowResizeEventDetail::TraceDictionary(JSTracer* trc)
{
}

DOMWindowResizeEventDetail&
DOMWindowResizeEventDetail::operator=(const DOMWindowResizeEventDetail& aOther)
{
  DictionaryBase::operator=(aOther);
  mHeight = aOther.mHeight;
  mWidth = aOther.mWidth;
  return *this;
}

bool
DOMWindowResizeEventDetail::operator==(const DOMWindowResizeEventDetail& aOther) const
{
  if (mHeight != aOther.mHeight) {
      return false;
  }
  if (mWidth != aOther.mWidth) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



OpenWindowEventDetail::OpenWindowEventDetail()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
OpenWindowEventDetail::InitIds(JSContext* cx, OpenWindowEventDetailAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->url_id.init(cx, "url") ||
      !atomsCache->name_id.init(cx, "name") ||
      !atomsCache->frameElement_id.init(cx, "frameElement") ||
      !atomsCache->forceNoReferrer_id.init(cx, "forceNoReferrer") ||
      !atomsCache->features_id.init(cx, "features")) {
    return false;
  }
  return true;
}

bool
OpenWindowEventDetail::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mFeatures.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mForceNoReferrer = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mFrameElement = nullptr;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mName.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mUrl.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
OpenWindowEventDetail::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  OpenWindowEventDetailAtoms* atomsCache = GetAtomCache<OpenWindowEventDetailAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mFeatures;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->features_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mForceNoReferrer;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->forceNoReferrer_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    RefPtr<nsINode> const & currentValue = mFrameElement;
    if (!currentValue) {
      temp.setNull();
      if (!JS_DefinePropertyById(cx, obj, atomsCache->frameElement_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    }
    if (!GetOrCreateDOMReflector(cx, currentValue, &temp)) {
      MOZ_ASSERT(JS_IsExceptionPending(cx));
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->frameElement_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mName;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->name_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mUrl;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->url_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
OpenWindowEventDetail::TraceDictionary(JSTracer* trc)
{
}



OpenWindowEventDetail&
OpenWindowEventDetail::operator=(const OpenWindowEventDetail& aOther)
{
  DictionaryBase::operator=(aOther);
  mFeatures = aOther.mFeatures;
  mForceNoReferrer = aOther.mForceNoReferrer;
  mFrameElement = aOther.mFrameElement;
  mName = aOther.mName;
  mUrl = aOther.mUrl;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail


} // namespace dom
} // namespace mozilla
