/* THIS FILE IS AUTOGENERATED FROM TestExampleGen.webidl BY Codegen.py - DO NOT EDIT */

#include <type_traits>
#include "GeckoProfiler.h"
#include "TestBindingHeader.h"
#include "TestCodeGenBinding.h"
#include "TestDictionaryBinding.h"
#include "TestExampleGenBinding.h"
#include "TestExampleInterface-example.h"
#include "TestExampleProxyInterface-example.h"
#include "TestExampleThrowingConstructorInterface-example.h"
#include "TestExampleWorkerInterface-example.h"
#include "WrapperFactory.h"
#include "XrayWrapper.h"
#include "js/Array.h"
#include "js/ForOfIterator.h"
#include "js/Object.h"
#include "js/experimental/JitInfo.h"
#include "js/shadow/Object.h"
#include "jsfriendapi.h"
#include "mozilla/Atomics.h"
#include "mozilla/FloatingPoint.h"
#include "mozilla/OwningNonNull.h"
#include "mozilla/dom/BindingCallContext.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/CustomElementRegistry.h"
#include "mozilla/dom/DOMJSClass.h"
#include "mozilla/dom/DOMJSProxyHandler.h"
#include "mozilla/dom/DocGroup.h"
#include "mozilla/dom/Document.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/PrimitiveConversions.h"
#include "mozilla/dom/Promise.h"
#include "mozilla/dom/Record.h"
#include "mozilla/dom/RootedDictionary.h"
#include "mozilla/dom/ToJSValue.h"
#include "mozilla/dom/TypedArray.h"
#include "mozilla/dom/UnionConversions.h"
#include "mozilla/dom/UnionTypes.h"
#include "mozilla/dom/WebIDLPrefs.h"
#include "mozilla/dom/XrayExpandoClass.h"
#include "nsContentUtils.h"
#include "nsJSUtils.h"

namespace mozilla {
namespace dom {

namespace binding_detail {}; // Just to make sure it's known as a namespace
using namespace mozilla::dom::binding_detail;


namespace TestExampleInterface_Binding {

static bool
_Example(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "Example constructor");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "Example", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "Example");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestExampleInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      GlobalObject global(cx, obj);
      if (global.Failed()) {
        return false;
      }

      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      Maybe<JSAutoRealm> ar;
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        obj = js::CheckedUnwrapStatic(obj);
        if (!obj) {
          return false;
        }
        ar.emplace(cx, obj);
        if (!JS_WrapObject(cx, &desiredProto)) {
          return false;
        }
      }
      FastErrorResult rv;
      auto result(StrongOrRawPtr<mozilla::dom::TestExampleInterface>(mozilla::dom::TestExampleInterface::Example(global, rv)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "Example constructor"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case 1: {
      GlobalObject global(cx, obj);
      if (global.Failed()) {
        return false;
      }

      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      Maybe<JSAutoRealm> ar;
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        obj = js::CheckedUnwrapStatic(obj);
        if (!obj) {
          return false;
        }
        ar.emplace(cx, obj);
        if (!JS_WrapObject(cx, &desiredProto)) {
          return false;
        }
      }
      FastErrorResult rv;
      auto result(StrongOrRawPtr<mozilla::dom::TestExampleInterface>(mozilla::dom::TestExampleInterface::Example(global, NonNullHelper(Constify(arg0)), rv)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "Example constructor"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static bool
_Example2(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "Example2 constructor");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "Example2", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "Example2");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestExampleInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  unsigned argcount = std::min(args.length(), 8u);
  switch (argcount) {
    case 1: {
      GlobalObject global(cx, obj);
      if (global.Failed()) {
        return false;
      }

      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      LongOrStringAnyRecord arg0;
      LongOrStringAnyRecordArgument arg0_holder(arg0);
      {
        bool done = false, failed = false, tryNext;
        if (args[0].isObject()) {
          if (!done) {
            done = (failed = !arg0_holder.TrySetToStringAnyRecord(cx, args[0], tryNext, false)) || !tryNext;
          }
        }
        if (!done) {
          do {
            done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
            break;
          } while (false);
        }
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "record<DOMString, any>");
          return false;
        }
      }
      Maybe<JSAutoRealm> ar;
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        obj = js::CheckedUnwrapStatic(obj);
        if (!obj) {
          return false;
        }
        ar.emplace(cx, obj);
        if (!JS_WrapObject(cx, &desiredProto)) {
          return false;
        }
        if (arg0.IsStringAnyRecord()) {
          for (auto& mapEntry0 : arg0.GetAsStringAnyRecord().Entries()) {
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&mapEntry0.mValue))) {
              return false;
            }
          }
        }
      }
      FastErrorResult rv;
      auto result(StrongOrRawPtr<mozilla::dom::TestExampleInterface>(mozilla::dom::TestExampleInterface::Example2(global, Constify(arg0), rv)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "Example2 constructor"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case 5: {
      [[fallthrough]];
    }
    case 6: {
      [[fallthrough]];
    }
    case 7: {
      [[fallthrough]];
    }
    case 8: {
      GlobalObject global(cx, obj);
      if (global.Failed()) {
        return false;
      }

      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      RootedDictionary<binding_detail::FastDictForConstructor> arg0(cx);
      if (!arg0.Init(cx, args[0], "Argument 1", false)) {
        return false;
      }
      JS::Rooted<JS::Value> arg1(cx);
      arg1 = args[1];
      JS::Rooted<JSObject*> arg2(cx);
      if (args[2].isObject()) {
        arg2 = &args[2].toObject();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 3");
        return false;
      }
      JS::Rooted<JSObject*> arg3(cx);
      if (args[3].isObject()) {
        arg3 = &args[3].toObject();
      } else if (args[3].isNullOrUndefined()) {
        arg3 = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 4");
        return false;
      }
      binding_detail::AutoSequence<Dict> arg4;
      SequenceRooter<Dict> arg4_holder(cx, &arg4);
      if (args[4].isObject()) {
        JS::ForOfIterator iter(cx);
        if (!iter.init(args[4], JS::ForOfIterator::AllowNonIterable)) {
          return false;
        }
        if (!iter.valueIsIterable()) {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 5");
          return false;
        }
        binding_detail::AutoSequence<Dict> &arr = arg4;
        JS::Rooted<JS::Value> temp(cx);
        while (true) {
          bool done;
          if (!iter.next(&temp, &done)) {
            return false;
          }
          if (done) {
            break;
          }
          Dict* slotPtr = arr.AppendElement(mozilla::fallible);
          if (!slotPtr) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          Dict& slot = *slotPtr;
          if (!slot.Init(cx, temp, "Element of argument 5", false)) {
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 5");
        return false;
      }
      JS::Rooted<JS::Value> arg5(cx);
      if (args.hasDefined(5)) {
        arg5 = args[5];
      } else {
        arg5 = JS::UndefinedValue();
      }
      Optional<JS::Handle<JSObject*>> arg6;
      if (args.hasDefined(6)) {
        arg6.Construct(cx);
        if (args[6].isObject()) {
          arg6.Value() = &args[6].toObject();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 7");
          return false;
        }
      }
      Optional<JS::Handle<JSObject*>> arg7;
      if (args.hasDefined(7)) {
        arg7.Construct(cx);
        if (args[7].isObject()) {
          arg7.Value() = &args[7].toObject();
        } else if (args[7].isNullOrUndefined()) {
          arg7.Value() = nullptr;
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 8");
          return false;
        }
      }
      Maybe<JSAutoRealm> ar;
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        obj = js::CheckedUnwrapStatic(obj);
        if (!obj) {
          return false;
        }
        ar.emplace(cx, obj);
        if (!JS_WrapObject(cx, &desiredProto)) {
          return false;
        }
        if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mAny1))) {
          return false;
        }
        if (arg0.mDict.WasPassed()) {
          if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mDict.Value().mAnotherAny))) {
            return false;
          }
          if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mDict.Value().mAnotherObj))) {
            return false;
          }
          if (arg0.mDict.Value().mArrayBuffer.WasPassed()) {
            if (!arg0.mDict.Value().mArrayBuffer.Value().WrapIntoNewCompartment(cx)) {
              return false;
            }
          }
          if (arg0.mDict.Value().mCustomEventInit.WasPassed()) {
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mDict.Value().mCustomEventInit.Value().mDetail))) {
              return false;
            }
          }
          if (arg0.mDict.Value().mDictionaryTypedef.WasPassed()) {
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mDict.Value().mDictionaryTypedef.Value().mDetail))) {
              return false;
            }
          }
          if (!arg0.mDict.Value().mFloat64Array.IsNull()) {
            if (!arg0.mDict.Value().mFloat64Array.Value().WrapIntoNewCompartment(cx)) {
              return false;
            }
          }
          if (arg0.mDict.Value().mNullableArrayBuffer.WasPassed()) {
            if (!arg0.mDict.Value().mNullableArrayBuffer.Value().IsNull()) {
              if (!arg0.mDict.Value().mNullableArrayBuffer.Value().Value().WrapIntoNewCompartment(cx)) {
                return false;
              }
            }
          }
          if (arg0.mDict.Value().mObjectOrLong.WasPassed()) {
            if (arg0.mDict.Value().mObjectOrLong.Value().IsObject()) {
              if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mDict.Value().mObjectOrLong.Value().GetAsObject()))) {
                return false;
              }
            }
          }
          if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mDict.Value().mRequiredObject))) {
            return false;
          }
          if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mDict.Value().mSomeAny))) {
            return false;
          }
          if (arg0.mDict.Value().mSomeObj.WasPassed()) {
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mDict.Value().mSomeObj.Value()))) {
              return false;
            }
          }
          if (arg0.mDict.Value().mUint8Array.WasPassed()) {
            if (!arg0.mDict.Value().mUint8Array.Value().WrapIntoNewCompartment(cx)) {
              return false;
            }
          }
          if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mDict.Value().mParentAny))) {
            return false;
          }
        }
        if (arg0.mDict2.WasPassed()) {
          if (arg0.mDict2.Value().mMemberDict.WasPassed()) {
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mDict2.Value().mMemberDict.Value().mAnotherAny))) {
              return false;
            }
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mDict2.Value().mMemberDict.Value().mAnotherObj))) {
              return false;
            }
            if (arg0.mDict2.Value().mMemberDict.Value().mArrayBuffer.WasPassed()) {
              if (!arg0.mDict2.Value().mMemberDict.Value().mArrayBuffer.Value().WrapIntoNewCompartment(cx)) {
                return false;
              }
            }
            if (arg0.mDict2.Value().mMemberDict.Value().mCustomEventInit.WasPassed()) {
              if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mDict2.Value().mMemberDict.Value().mCustomEventInit.Value().mDetail))) {
                return false;
              }
            }
            if (arg0.mDict2.Value().mMemberDict.Value().mDictionaryTypedef.WasPassed()) {
              if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mDict2.Value().mMemberDict.Value().mDictionaryTypedef.Value().mDetail))) {
                return false;
              }
            }
            if (!arg0.mDict2.Value().mMemberDict.Value().mFloat64Array.IsNull()) {
              if (!arg0.mDict2.Value().mMemberDict.Value().mFloat64Array.Value().WrapIntoNewCompartment(cx)) {
                return false;
              }
            }
            if (arg0.mDict2.Value().mMemberDict.Value().mNullableArrayBuffer.WasPassed()) {
              if (!arg0.mDict2.Value().mMemberDict.Value().mNullableArrayBuffer.Value().IsNull()) {
                if (!arg0.mDict2.Value().mMemberDict.Value().mNullableArrayBuffer.Value().Value().WrapIntoNewCompartment(cx)) {
                  return false;
                }
              }
            }
            if (arg0.mDict2.Value().mMemberDict.Value().mObjectOrLong.WasPassed()) {
              if (arg0.mDict2.Value().mMemberDict.Value().mObjectOrLong.Value().IsObject()) {
                if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mDict2.Value().mMemberDict.Value().mObjectOrLong.Value().GetAsObject()))) {
                  return false;
                }
              }
            }
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mDict2.Value().mMemberDict.Value().mRequiredObject))) {
              return false;
            }
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mDict2.Value().mMemberDict.Value().mSomeAny))) {
              return false;
            }
            if (arg0.mDict2.Value().mMemberDict.Value().mSomeObj.WasPassed()) {
              if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mDict2.Value().mMemberDict.Value().mSomeObj.Value()))) {
                return false;
              }
            }
            if (arg0.mDict2.Value().mMemberDict.Value().mUint8Array.WasPassed()) {
              if (!arg0.mDict2.Value().mMemberDict.Value().mUint8Array.Value().WrapIntoNewCompartment(cx)) {
                return false;
              }
            }
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mDict2.Value().mMemberDict.Value().mParentAny))) {
              return false;
            }
          }
        }
        if (arg0.mObj1.WasPassed()) {
          if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mObj1.Value()))) {
            return false;
          }
        }
        if (arg0.mObj2.WasPassed()) {
          if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mObj2.Value()))) {
            return false;
          }
        }
        if (arg0.mSeq1.WasPassed()) {
          for (uint32_t indexName0 = 0; indexName0 < arg0.mSeq1.Value().Length(); ++indexName0) {
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq1.Value()[indexName0].mAnotherAny))) {
              return false;
            }
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq1.Value()[indexName0].mAnotherObj))) {
              return false;
            }
            if (arg0.mSeq1.Value()[indexName0].mArrayBuffer.WasPassed()) {
              if (!arg0.mSeq1.Value()[indexName0].mArrayBuffer.Value().WrapIntoNewCompartment(cx)) {
                return false;
              }
            }
            if (arg0.mSeq1.Value()[indexName0].mCustomEventInit.WasPassed()) {
              if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq1.Value()[indexName0].mCustomEventInit.Value().mDetail))) {
                return false;
              }
            }
            if (arg0.mSeq1.Value()[indexName0].mDictionaryTypedef.WasPassed()) {
              if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq1.Value()[indexName0].mDictionaryTypedef.Value().mDetail))) {
                return false;
              }
            }
            if (!arg0.mSeq1.Value()[indexName0].mFloat64Array.IsNull()) {
              if (!arg0.mSeq1.Value()[indexName0].mFloat64Array.Value().WrapIntoNewCompartment(cx)) {
                return false;
              }
            }
            if (arg0.mSeq1.Value()[indexName0].mNullableArrayBuffer.WasPassed()) {
              if (!arg0.mSeq1.Value()[indexName0].mNullableArrayBuffer.Value().IsNull()) {
                if (!arg0.mSeq1.Value()[indexName0].mNullableArrayBuffer.Value().Value().WrapIntoNewCompartment(cx)) {
                  return false;
                }
              }
            }
            if (arg0.mSeq1.Value()[indexName0].mObjectOrLong.WasPassed()) {
              if (arg0.mSeq1.Value()[indexName0].mObjectOrLong.Value().IsObject()) {
                if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq1.Value()[indexName0].mObjectOrLong.Value().GetAsObject()))) {
                  return false;
                }
              }
            }
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq1.Value()[indexName0].mRequiredObject))) {
              return false;
            }
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq1.Value()[indexName0].mSomeAny))) {
              return false;
            }
            if (arg0.mSeq1.Value()[indexName0].mSomeObj.WasPassed()) {
              if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq1.Value()[indexName0].mSomeObj.Value()))) {
                return false;
              }
            }
            if (arg0.mSeq1.Value()[indexName0].mUint8Array.WasPassed()) {
              if (!arg0.mSeq1.Value()[indexName0].mUint8Array.Value().WrapIntoNewCompartment(cx)) {
                return false;
              }
            }
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq1.Value()[indexName0].mParentAny))) {
              return false;
            }
          }
        }
        if (arg0.mSeq2.WasPassed()) {
          if (!arg0.mSeq2.Value().IsNull()) {
            for (uint32_t indexName0 = 0; indexName0 < arg0.mSeq2.Value().Value().Length(); ++indexName0) {
              for (uint32_t indexName1 = 0; indexName1 < arg0.mSeq2.Value().Value()[indexName0].Length(); ++indexName1) {
                if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq2.Value().Value()[indexName0][indexName1].mAnotherAny))) {
                  return false;
                }
                if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq2.Value().Value()[indexName0][indexName1].mAnotherObj))) {
                  return false;
                }
                if (arg0.mSeq2.Value().Value()[indexName0][indexName1].mArrayBuffer.WasPassed()) {
                  if (!arg0.mSeq2.Value().Value()[indexName0][indexName1].mArrayBuffer.Value().WrapIntoNewCompartment(cx)) {
                    return false;
                  }
                }
                if (arg0.mSeq2.Value().Value()[indexName0][indexName1].mCustomEventInit.WasPassed()) {
                  if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq2.Value().Value()[indexName0][indexName1].mCustomEventInit.Value().mDetail))) {
                    return false;
                  }
                }
                if (arg0.mSeq2.Value().Value()[indexName0][indexName1].mDictionaryTypedef.WasPassed()) {
                  if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq2.Value().Value()[indexName0][indexName1].mDictionaryTypedef.Value().mDetail))) {
                    return false;
                  }
                }
                if (!arg0.mSeq2.Value().Value()[indexName0][indexName1].mFloat64Array.IsNull()) {
                  if (!arg0.mSeq2.Value().Value()[indexName0][indexName1].mFloat64Array.Value().WrapIntoNewCompartment(cx)) {
                    return false;
                  }
                }
                if (arg0.mSeq2.Value().Value()[indexName0][indexName1].mNullableArrayBuffer.WasPassed()) {
                  if (!arg0.mSeq2.Value().Value()[indexName0][indexName1].mNullableArrayBuffer.Value().IsNull()) {
                    if (!arg0.mSeq2.Value().Value()[indexName0][indexName1].mNullableArrayBuffer.Value().Value().WrapIntoNewCompartment(cx)) {
                      return false;
                    }
                  }
                }
                if (arg0.mSeq2.Value().Value()[indexName0][indexName1].mObjectOrLong.WasPassed()) {
                  if (arg0.mSeq2.Value().Value()[indexName0][indexName1].mObjectOrLong.Value().IsObject()) {
                    if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq2.Value().Value()[indexName0][indexName1].mObjectOrLong.Value().GetAsObject()))) {
                      return false;
                    }
                  }
                }
                if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq2.Value().Value()[indexName0][indexName1].mRequiredObject))) {
                  return false;
                }
                if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq2.Value().Value()[indexName0][indexName1].mSomeAny))) {
                  return false;
                }
                if (arg0.mSeq2.Value().Value()[indexName0][indexName1].mSomeObj.WasPassed()) {
                  if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq2.Value().Value()[indexName0][indexName1].mSomeObj.Value()))) {
                    return false;
                  }
                }
                if (arg0.mSeq2.Value().Value()[indexName0][indexName1].mUint8Array.WasPassed()) {
                  if (!arg0.mSeq2.Value().Value()[indexName0][indexName1].mUint8Array.Value().WrapIntoNewCompartment(cx)) {
                    return false;
                  }
                }
                if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq2.Value().Value()[indexName0][indexName1].mParentAny))) {
                  return false;
                }
              }
            }
          }
        }
        if (arg0.mSeq3.WasPassed()) {
          for (uint32_t indexName0 = 0; indexName0 < arg0.mSeq3.Value().Length(); ++indexName0) {
            if (!arg0.mSeq3.Value()[indexName0].IsNull()) {
              for (uint32_t indexName1 = 0; indexName1 < arg0.mSeq3.Value()[indexName0].Value().Length(); ++indexName1) {
                if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq3.Value()[indexName0].Value()[indexName1].mAnotherAny))) {
                  return false;
                }
                if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq3.Value()[indexName0].Value()[indexName1].mAnotherObj))) {
                  return false;
                }
                if (arg0.mSeq3.Value()[indexName0].Value()[indexName1].mArrayBuffer.WasPassed()) {
                  if (!arg0.mSeq3.Value()[indexName0].Value()[indexName1].mArrayBuffer.Value().WrapIntoNewCompartment(cx)) {
                    return false;
                  }
                }
                if (arg0.mSeq3.Value()[indexName0].Value()[indexName1].mCustomEventInit.WasPassed()) {
                  if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq3.Value()[indexName0].Value()[indexName1].mCustomEventInit.Value().mDetail))) {
                    return false;
                  }
                }
                if (arg0.mSeq3.Value()[indexName0].Value()[indexName1].mDictionaryTypedef.WasPassed()) {
                  if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq3.Value()[indexName0].Value()[indexName1].mDictionaryTypedef.Value().mDetail))) {
                    return false;
                  }
                }
                if (!arg0.mSeq3.Value()[indexName0].Value()[indexName1].mFloat64Array.IsNull()) {
                  if (!arg0.mSeq3.Value()[indexName0].Value()[indexName1].mFloat64Array.Value().WrapIntoNewCompartment(cx)) {
                    return false;
                  }
                }
                if (arg0.mSeq3.Value()[indexName0].Value()[indexName1].mNullableArrayBuffer.WasPassed()) {
                  if (!arg0.mSeq3.Value()[indexName0].Value()[indexName1].mNullableArrayBuffer.Value().IsNull()) {
                    if (!arg0.mSeq3.Value()[indexName0].Value()[indexName1].mNullableArrayBuffer.Value().Value().WrapIntoNewCompartment(cx)) {
                      return false;
                    }
                  }
                }
                if (arg0.mSeq3.Value()[indexName0].Value()[indexName1].mObjectOrLong.WasPassed()) {
                  if (arg0.mSeq3.Value()[indexName0].Value()[indexName1].mObjectOrLong.Value().IsObject()) {
                    if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq3.Value()[indexName0].Value()[indexName1].mObjectOrLong.Value().GetAsObject()))) {
                      return false;
                    }
                  }
                }
                if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq3.Value()[indexName0].Value()[indexName1].mRequiredObject))) {
                  return false;
                }
                if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq3.Value()[indexName0].Value()[indexName1].mSomeAny))) {
                  return false;
                }
                if (arg0.mSeq3.Value()[indexName0].Value()[indexName1].mSomeObj.WasPassed()) {
                  if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq3.Value()[indexName0].Value()[indexName1].mSomeObj.Value()))) {
                    return false;
                  }
                }
                if (arg0.mSeq3.Value()[indexName0].Value()[indexName1].mUint8Array.WasPassed()) {
                  if (!arg0.mSeq3.Value()[indexName0].Value()[indexName1].mUint8Array.Value().WrapIntoNewCompartment(cx)) {
                    return false;
                  }
                }
                if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq3.Value()[indexName0].Value()[indexName1].mParentAny))) {
                  return false;
                }
              }
            }
          }
        }
        if (arg0.mSeq4.WasPassed()) {
          for (uint32_t indexName0 = 0; indexName0 < arg0.mSeq4.Value().Length(); ++indexName0) {
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq4.Value()[indexName0]))) {
              return false;
            }
          }
        }
        if (arg0.mSeq5.WasPassed()) {
          for (uint32_t indexName0 = 0; indexName0 < arg0.mSeq5.Value().Length(); ++indexName0) {
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq5.Value()[indexName0]))) {
              return false;
            }
          }
        }
        if (arg0.mSeq6.WasPassed()) {
          for (uint32_t indexName0 = 0; indexName0 < arg0.mSeq6.Value().Length(); ++indexName0) {
            if (arg0.mSeq6.Value()[indexName0].mOurSequence3.WasPassed()) {
              for (uint32_t indexName1 = 0; indexName1 < arg0.mSeq6.Value()[indexName0].mOurSequence3.Value().Length(); ++indexName1) {
                if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg0.mSeq6.Value()[indexName0].mOurSequence3.Value()[indexName1]))) {
                  return false;
                }
              }
            }
            if (arg0.mSeq6.Value()[indexName0].mOurSequence4.WasPassed()) {
              for (uint32_t indexName1 = 0; indexName1 < arg0.mSeq6.Value()[indexName0].mOurSequence4.Value().Length(); ++indexName1) {
                if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq6.Value()[indexName0].mOurSequence4.Value()[indexName1]))) {
                  return false;
                }
              }
            }
            if (arg0.mSeq6.Value()[indexName0].mOurSequence5.WasPassed()) {
              for (uint32_t indexName1 = 0; indexName1 < arg0.mSeq6.Value()[indexName0].mOurSequence5.Value().Length(); ++indexName1) {
                if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq6.Value()[indexName0].mOurSequence5.Value()[indexName1]))) {
                  return false;
                }
              }
            }
            if (arg0.mSeq6.Value()[indexName0].mOurSequence6.WasPassed()) {
              if (!arg0.mSeq6.Value()[indexName0].mOurSequence6.Value().IsNull()) {
                for (uint32_t indexName1 = 0; indexName1 < arg0.mSeq6.Value()[indexName0].mOurSequence6.Value().Value().Length(); ++indexName1) {
                  if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq6.Value()[indexName0].mOurSequence6.Value().Value()[indexName1]))) {
                    return false;
                  }
                }
              }
            }
            if (arg0.mSeq6.Value()[indexName0].mOurSequence7.WasPassed()) {
              if (!arg0.mSeq6.Value()[indexName0].mOurSequence7.Value().IsNull()) {
                for (uint32_t indexName1 = 0; indexName1 < arg0.mSeq6.Value()[indexName0].mOurSequence7.Value().Value().Length(); ++indexName1) {
                  if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq6.Value()[indexName0].mOurSequence7.Value().Value()[indexName1]))) {
                    return false;
                  }
                }
              }
            }
            if (!arg0.mSeq6.Value()[indexName0].mOurSequence8.IsNull()) {
              for (uint32_t indexName1 = 0; indexName1 < arg0.mSeq6.Value()[indexName0].mOurSequence8.Value().Length(); ++indexName1) {
                if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq6.Value()[indexName0].mOurSequence8.Value()[indexName1]))) {
                  return false;
                }
              }
            }
            if (!arg0.mSeq6.Value()[indexName0].mOurSequence9.IsNull()) {
              for (uint32_t indexName1 = 0; indexName1 < arg0.mSeq6.Value()[indexName0].mOurSequence9.Value().Length(); ++indexName1) {
                if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg0.mSeq6.Value()[indexName0].mOurSequence9.Value()[indexName1]))) {
                  return false;
                }
              }
            }
          }
        }
        if (!JS_WrapValue(cx, &arg1)) {
          return false;
        }
        if (!JS_WrapObject(cx, &arg2)) {
          return false;
        }
        if (!JS_WrapObject(cx, &arg3)) {
          return false;
        }
        for (uint32_t indexName0 = 0; indexName0 < arg4.Length(); ++indexName0) {
          if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg4[indexName0].mAnotherAny))) {
            return false;
          }
          if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg4[indexName0].mAnotherObj))) {
            return false;
          }
          if (arg4[indexName0].mArrayBuffer.WasPassed()) {
            if (!arg4[indexName0].mArrayBuffer.Value().WrapIntoNewCompartment(cx)) {
              return false;
            }
          }
          if (arg4[indexName0].mCustomEventInit.WasPassed()) {
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg4[indexName0].mCustomEventInit.Value().mDetail))) {
              return false;
            }
          }
          if (arg4[indexName0].mDictionaryTypedef.WasPassed()) {
            if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg4[indexName0].mDictionaryTypedef.Value().mDetail))) {
              return false;
            }
          }
          if (!arg4[indexName0].mFloat64Array.IsNull()) {
            if (!arg4[indexName0].mFloat64Array.Value().WrapIntoNewCompartment(cx)) {
              return false;
            }
          }
          if (arg4[indexName0].mNullableArrayBuffer.WasPassed()) {
            if (!arg4[indexName0].mNullableArrayBuffer.Value().IsNull()) {
              if (!arg4[indexName0].mNullableArrayBuffer.Value().Value().WrapIntoNewCompartment(cx)) {
                return false;
              }
            }
          }
          if (arg4[indexName0].mObjectOrLong.WasPassed()) {
            if (arg4[indexName0].mObjectOrLong.Value().IsObject()) {
              if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg4[indexName0].mObjectOrLong.Value().GetAsObject()))) {
                return false;
              }
            }
          }
          if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg4[indexName0].mRequiredObject))) {
            return false;
          }
          if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg4[indexName0].mSomeAny))) {
            return false;
          }
          if (arg4[indexName0].mSomeObj.WasPassed()) {
            if (!JS_WrapObject(cx, JS::MutableHandle<JSObject*>::fromMarkedLocation(&arg4[indexName0].mSomeObj.Value()))) {
              return false;
            }
          }
          if (arg4[indexName0].mUint8Array.WasPassed()) {
            if (!arg4[indexName0].mUint8Array.Value().WrapIntoNewCompartment(cx)) {
              return false;
            }
          }
          if (!JS_WrapValue(cx, JS::MutableHandle<JS::Value>::fromMarkedLocation(&arg4[indexName0].mParentAny))) {
            return false;
          }
        }
        if (!JS_WrapValue(cx, &arg5)) {
          return false;
        }
        if (arg6.WasPassed()) {
          if (!JS_WrapObject(cx, &arg6.Value())) {
            return false;
          }
        }
        if (arg7.WasPassed()) {
          if (!JS_WrapObject(cx, &arg7.Value())) {
            return false;
          }
        }
      }
      FastErrorResult rv;
      auto result(StrongOrRawPtr<mozilla::dom::TestExampleInterface>(mozilla::dom::TestExampleInterface::Example2(global, Constify(arg0), arg1, arg2, arg3, Constify(arg4), arg5, Constify(arg6), Constify(arg7), rv)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "Example2 constructor"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "readonlyByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->ReadonlyByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo readonlyByte_getterinfo = {
  { get_readonlyByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->WritableByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableByte(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableByte(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableByte_getterinfo = {
  { get_writableByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableByte_setterinfo = {
  { (JSJitGetterOp)set_writableByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passByte", 1)) {
    return false;
  }
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassByte(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassByte(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passByte_methodinfo = {
  { (JSJitGetterOp)passByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->ReceiveByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo receiveByte_methodinfo = {
  { (JSJitGetterOp)receiveByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<int8_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalByte(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalByte(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalByte_methodinfo = {
  { (JSJitGetterOp)passOptionalByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalByteBeforeRequired(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalByteBeforeRequired", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passOptionalByteBeforeRequired", 2)) {
    return false;
  }
  Optional<int8_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  int8_t arg1;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalByteBeforeRequired(Constify(arg0), arg1))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalByteBeforeRequired(Constify(arg0), arg1);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalByteBeforeRequired_methodinfo = {
  { (JSJitGetterOp)passOptionalByteBeforeRequired },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalByteWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalByteWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 0;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalByteWithDefault(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalByteWithDefault(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalByteWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalByteWithDefault },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalByteWithDefaultBeforeRequired(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalByteWithDefaultBeforeRequired", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passOptionalByteWithDefaultBeforeRequired", 2)) {
    return false;
  }
  int8_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 0;
  }
  int8_t arg1;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalByteWithDefaultBeforeRequired(arg0, arg1))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalByteWithDefaultBeforeRequired(arg0, arg1);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalByteWithDefaultBeforeRequired_methodinfo = {
  { (JSJitGetterOp)passOptionalByteWithDefaultBeforeRequired },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableByte", 1)) {
    return false;
  }
  Nullable<int8_t> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableByte(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableByte(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableByte_methodinfo = {
  { (JSJitGetterOp)passNullableByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Nullable<int8_t>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value().SetValue())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableByte(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableByte(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableByte_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passVariadicByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  AutoSequence<int8_t> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      int8_t& slot = *arg0.AppendElement();
      if (!ValueToPrimitive<int8_t, eDefault>(cx, args[variadicArg], "Argument 1", &slot)) {
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicByte(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicByte(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicByte_methodinfo = {
  { (JSJitGetterOp)passVariadicByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_cachedByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "cachedByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 0) : (DOM_INSTANCE_RESERVED_SLOTS + 0);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapValue(cx, args.rval());
    }
  }

  int8_t result(MOZ_KnownLive(self)->CachedByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      args.rval().setInt32(int32_t(result));
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapValue(cx, args.rval());
}

static const JSJitInfo cachedByte_getterinfo = {
  { get_cachedByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 0)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 0) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 0) < 16, "There is no slot for us");

static bool
get_cachedConstantByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "cachedConstantByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 1) : (DOM_INSTANCE_RESERVED_SLOTS + 1);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapValue(cx, args.rval());
    }
  }

  int8_t result(MOZ_KnownLive(self)->CachedConstantByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      args.rval().setInt32(int32_t(result));
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapValue(cx, args.rval());
}

static const JSJitInfo cachedConstantByte_getterinfo = {
  { get_cachedConstantByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasNone, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  true, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 1)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 1) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 1) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_cachedWritableByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "cachedWritableByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 2) : (DOM_INSTANCE_RESERVED_SLOTS + 2);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapValue(cx, args.rval());
    }
  }

  int8_t result(MOZ_KnownLive(self)->CachedWritableByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      args.rval().setInt32(int32_t(result));
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapValue(cx, args.rval());
}

MOZ_CAN_RUN_SCRIPT static bool
set_cachedWritableByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "cachedWritableByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetCachedWritableByte(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetCachedWritableByte(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  ClearCachedCachedWritableByteValue(self);
  return true;
}

static const JSJitInfo cachedWritableByte_getterinfo = {
  { get_cachedWritableByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 2)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 2) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 2) < 16, "There is no slot for us");
static const JSJitInfo cachedWritableByte_setterinfo = {
  { (JSJitGetterOp)set_cachedWritableByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_sideEffectFreeByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "sideEffectFreeByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->SideEffectFreeByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_sideEffectFreeByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "sideEffectFreeByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetSideEffectFreeByte(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetSideEffectFreeByte(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo sideEffectFreeByte_getterinfo = {
  { get_sideEffectFreeByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo sideEffectFreeByte_setterinfo = {
  { (JSJitGetterOp)set_sideEffectFreeByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_domDependentByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "domDependentByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->DomDependentByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_domDependentByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "domDependentByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetDomDependentByte(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetDomDependentByte(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo domDependentByte_getterinfo = {
  { get_domDependentByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo domDependentByte_setterinfo = {
  { (JSJitGetterOp)set_domDependentByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_constantByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "constantByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->ConstantByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo constantByte_getterinfo = {
  { get_constantByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasNone, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_deviceStateDependentByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "deviceStateDependentByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->DeviceStateDependentByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo deviceStateDependentByte_getterinfo = {
  { get_deviceStateDependentByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasNone, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
returnByteSideEffectFree(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "returnByteSideEffectFree", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->ReturnByteSideEffectFree());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo::ArgType returnByteSideEffectFree_methodinfo_argTypes[] = { JSJitInfo::ArgTypeListEnd };
static const JSTypedMethodJitInfo returnByteSideEffectFree_methodinfo = {
  {
    { (JSJitGetterOp)returnByteSideEffectFree },
    { prototypes::id::TestExampleInterface },
    { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
    JSJitInfo::Method,
    JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
    JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
    true,  /* isInfallible. False in setters. */
    false,  /* isMovable.  Not relevant for setters. */
    false, /* isEliminatable.  Not relevant for setters. */
    false, /* isAlwaysInSlot.  Only relevant for getters. */
    false, /* isLazilyCachedInSlot.  Only relevant for getters. */
    true,  /* isTypedMethod.  Only relevant for methods. */
    0   /* Reserved slot index, if we're stored in a slot, else 0. */
  },
  returnByteSideEffectFree_methodinfo_argTypes
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
returnDOMDependentByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "returnDOMDependentByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->ReturnDOMDependentByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo::ArgType returnDOMDependentByte_methodinfo_argTypes[] = { JSJitInfo::ArgTypeListEnd };
static const JSTypedMethodJitInfo returnDOMDependentByte_methodinfo = {
  {
    { (JSJitGetterOp)returnDOMDependentByte },
    { prototypes::id::TestExampleInterface },
    { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
    JSJitInfo::Method,
    JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
    JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
    true,  /* isInfallible. False in setters. */
    true,  /* isMovable.  Not relevant for setters. */
    true, /* isEliminatable.  Not relevant for setters. */
    false, /* isAlwaysInSlot.  Only relevant for getters. */
    false, /* isLazilyCachedInSlot.  Only relevant for getters. */
    true,  /* isTypedMethod.  Only relevant for methods. */
    0   /* Reserved slot index, if we're stored in a slot, else 0. */
  },
  returnDOMDependentByte_methodinfo_argTypes
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
returnConstantByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "returnConstantByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->ReturnConstantByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo::ArgType returnConstantByte_methodinfo_argTypes[] = { JSJitInfo::ArgTypeListEnd };
static const JSTypedMethodJitInfo returnConstantByte_methodinfo = {
  {
    { (JSJitGetterOp)returnConstantByte },
    { prototypes::id::TestExampleInterface },
    { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
    JSJitInfo::Method,
    JSJitInfo::AliasNone, /* aliasSet.  Not relevant for setters. */
    JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
    true,  /* isInfallible. False in setters. */
    true,  /* isMovable.  Not relevant for setters. */
    true, /* isEliminatable.  Not relevant for setters. */
    false, /* isAlwaysInSlot.  Only relevant for getters. */
    false, /* isLazilyCachedInSlot.  Only relevant for getters. */
    true,  /* isTypedMethod.  Only relevant for methods. */
    0   /* Reserved slot index, if we're stored in a slot, else 0. */
  },
  returnConstantByte_methodinfo_argTypes
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
returnDeviceStateDependentByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "returnDeviceStateDependentByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->ReturnDeviceStateDependentByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo::ArgType returnDeviceStateDependentByte_methodinfo_argTypes[] = { JSJitInfo::ArgTypeListEnd };
static const JSTypedMethodJitInfo returnDeviceStateDependentByte_methodinfo = {
  {
    { (JSJitGetterOp)returnDeviceStateDependentByte },
    { prototypes::id::TestExampleInterface },
    { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
    JSJitInfo::Method,
    JSJitInfo::AliasNone, /* aliasSet.  Not relevant for setters. */
    JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
    true,  /* isInfallible. False in setters. */
    false,  /* isMovable.  Not relevant for setters. */
    true, /* isEliminatable.  Not relevant for setters. */
    false, /* isAlwaysInSlot.  Only relevant for getters. */
    false, /* isLazilyCachedInSlot.  Only relevant for getters. */
    true,  /* isTypedMethod.  Only relevant for methods. */
    0   /* Reserved slot index, if we're stored in a slot, else 0. */
  },
  returnDeviceStateDependentByte_methodinfo_argTypes
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "readonlyShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int16_t result(MOZ_KnownLive(self)->ReadonlyShort());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo readonlyShort_getterinfo = {
  { get_readonlyShort },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int16_t result(MOZ_KnownLive(self)->WritableShort());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int16_t arg0;
  if (!ValueToPrimitive<int16_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableShort(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableShort(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableShort_getterinfo = {
  { get_writableShort },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableShort_setterinfo = {
  { (JSJitGetterOp)set_writableShort },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passShort", 1)) {
    return false;
  }
  int16_t arg0;
  if (!ValueToPrimitive<int16_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassShort(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassShort(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passShort_methodinfo = {
  { (JSJitGetterOp)passShort },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int16_t result(MOZ_KnownLive(self)->ReceiveShort());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo receiveShort_methodinfo = {
  { (JSJitGetterOp)receiveShort },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<int16_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<int16_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalShort(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalShort(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalShort_methodinfo = {
  { (JSJitGetterOp)passOptionalShort },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalShortWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalShortWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int16_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<int16_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 5;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalShortWithDefault(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalShortWithDefault(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalShortWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalShortWithDefault },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "readonlyLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int32_t result(MOZ_KnownLive(self)->ReadonlyLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo readonlyLong_getterinfo = {
  { get_readonlyLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int32_t result(MOZ_KnownLive(self)->WritableLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableLong(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableLong(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableLong_getterinfo = {
  { get_writableLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableLong_setterinfo = {
  { (JSJitGetterOp)set_writableLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passLong", 1)) {
    return false;
  }
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassLong(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassLong(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passLong_methodinfo = {
  { (JSJitGetterOp)passLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int32_t result(MOZ_KnownLive(self)->ReceiveLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo receiveLong_methodinfo = {
  { (JSJitGetterOp)receiveLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<int32_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalLong(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalLong(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalLong_methodinfo = {
  { (JSJitGetterOp)passOptionalLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalLongWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalLongWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int32_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 7;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalLongWithDefault(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalLongWithDefault(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalLongWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalLongWithDefault },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "readonlyLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int64_t result(MOZ_KnownLive(self)->ReadonlyLongLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo readonlyLongLong_getterinfo = {
  { get_readonlyLongLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int64_t result(MOZ_KnownLive(self)->WritableLongLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int64_t arg0;
  if (!ValueToPrimitive<int64_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableLongLong(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableLongLong(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableLongLong_getterinfo = {
  { get_writableLongLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableLongLong_setterinfo = {
  { (JSJitGetterOp)set_writableLongLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passLongLong", 1)) {
    return false;
  }
  int64_t arg0;
  if (!ValueToPrimitive<int64_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassLongLong(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassLongLong(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passLongLong_methodinfo = {
  { (JSJitGetterOp)passLongLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int64_t result(MOZ_KnownLive(self)->ReceiveLongLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo receiveLongLong_methodinfo = {
  { (JSJitGetterOp)receiveLongLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<int64_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<int64_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalLongLong(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalLongLong(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalLongLong_methodinfo = {
  { (JSJitGetterOp)passOptionalLongLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalLongLongWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalLongLongWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int64_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<int64_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = -12LL;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalLongLongWithDefault(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalLongLongWithDefault(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalLongLongWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalLongLongWithDefault },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyOctet(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "readonlyOctet", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  uint8_t result(MOZ_KnownLive(self)->ReadonlyOctet());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo readonlyOctet_getterinfo = {
  { get_readonlyOctet },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableOctet(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableOctet", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  uint8_t result(MOZ_KnownLive(self)->WritableOctet());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableOctet(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableOctet", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  uint8_t arg0;
  if (!ValueToPrimitive<uint8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableOctet(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableOctet(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableOctet_getterinfo = {
  { get_writableOctet },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableOctet_setterinfo = {
  { (JSJitGetterOp)set_writableOctet },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOctet(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOctet", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passOctet", 1)) {
    return false;
  }
  uint8_t arg0;
  if (!ValueToPrimitive<uint8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOctet(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOctet(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOctet_methodinfo = {
  { (JSJitGetterOp)passOctet },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveOctet(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveOctet", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  uint8_t result(MOZ_KnownLive(self)->ReceiveOctet());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo receiveOctet_methodinfo = {
  { (JSJitGetterOp)receiveOctet },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalOctet(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalOctet", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<uint8_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<uint8_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalOctet(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalOctet(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalOctet_methodinfo = {
  { (JSJitGetterOp)passOptionalOctet },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalOctetWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalOctetWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  uint8_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<uint8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 19;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalOctetWithDefault(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalOctetWithDefault(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalOctetWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalOctetWithDefault },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyUnsignedShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "readonlyUnsignedShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  uint16_t result(MOZ_KnownLive(self)->ReadonlyUnsignedShort());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo readonlyUnsignedShort_getterinfo = {
  { get_readonlyUnsignedShort },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnsignedShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableUnsignedShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  uint16_t result(MOZ_KnownLive(self)->WritableUnsignedShort());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnsignedShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableUnsignedShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  uint16_t arg0;
  if (!ValueToPrimitive<uint16_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnsignedShort(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnsignedShort(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnsignedShort_getterinfo = {
  { get_writableUnsignedShort },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableUnsignedShort_setterinfo = {
  { (JSJitGetterOp)set_writableUnsignedShort },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnsignedShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnsignedShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passUnsignedShort", 1)) {
    return false;
  }
  uint16_t arg0;
  if (!ValueToPrimitive<uint16_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnsignedShort(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnsignedShort(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnsignedShort_methodinfo = {
  { (JSJitGetterOp)passUnsignedShort },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUnsignedShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveUnsignedShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  uint16_t result(MOZ_KnownLive(self)->ReceiveUnsignedShort());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo receiveUnsignedShort_methodinfo = {
  { (JSJitGetterOp)receiveUnsignedShort },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnsignedShort(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalUnsignedShort", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<uint16_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<uint16_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnsignedShort(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnsignedShort(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnsignedShort_methodinfo = {
  { (JSJitGetterOp)passOptionalUnsignedShort },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnsignedShortWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalUnsignedShortWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  uint16_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<uint16_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 2;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnsignedShortWithDefault(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnsignedShortWithDefault(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnsignedShortWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalUnsignedShortWithDefault },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyUnsignedLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "readonlyUnsignedLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  uint32_t result(MOZ_KnownLive(self)->ReadonlyUnsignedLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setNumber(result);
  return true;
}

static const JSJitInfo readonlyUnsignedLong_getterinfo = {
  { get_readonlyUnsignedLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnsignedLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableUnsignedLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  uint32_t result(MOZ_KnownLive(self)->WritableUnsignedLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setNumber(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnsignedLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableUnsignedLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnsignedLong(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnsignedLong(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnsignedLong_getterinfo = {
  { get_writableUnsignedLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableUnsignedLong_setterinfo = {
  { (JSJitGetterOp)set_writableUnsignedLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnsignedLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnsignedLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passUnsignedLong", 1)) {
    return false;
  }
  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnsignedLong(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnsignedLong(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnsignedLong_methodinfo = {
  { (JSJitGetterOp)passUnsignedLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUnsignedLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveUnsignedLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  uint32_t result(MOZ_KnownLive(self)->ReceiveUnsignedLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setNumber(result);
  return true;
}

static const JSJitInfo receiveUnsignedLong_methodinfo = {
  { (JSJitGetterOp)receiveUnsignedLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnsignedLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalUnsignedLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<uint32_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnsignedLong(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnsignedLong(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnsignedLong_methodinfo = {
  { (JSJitGetterOp)passOptionalUnsignedLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnsignedLongWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalUnsignedLongWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  uint32_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 6U;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnsignedLongWithDefault(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnsignedLongWithDefault(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnsignedLongWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalUnsignedLongWithDefault },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyUnsignedLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "readonlyUnsignedLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  uint64_t result(MOZ_KnownLive(self)->ReadonlyUnsignedLongLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo readonlyUnsignedLongLong_getterinfo = {
  { get_readonlyUnsignedLongLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnsignedLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableUnsignedLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  uint64_t result(MOZ_KnownLive(self)->WritableUnsignedLongLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnsignedLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableUnsignedLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  uint64_t arg0;
  if (!ValueToPrimitive<uint64_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnsignedLongLong(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnsignedLongLong(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnsignedLongLong_getterinfo = {
  { get_writableUnsignedLongLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableUnsignedLongLong_setterinfo = {
  { (JSJitGetterOp)set_writableUnsignedLongLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnsignedLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnsignedLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passUnsignedLongLong", 1)) {
    return false;
  }
  uint64_t arg0;
  if (!ValueToPrimitive<uint64_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnsignedLongLong(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnsignedLongLong(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnsignedLongLong_methodinfo = {
  { (JSJitGetterOp)passUnsignedLongLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUnsignedLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveUnsignedLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  uint64_t result(MOZ_KnownLive(self)->ReceiveUnsignedLongLong());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo receiveUnsignedLongLong_methodinfo = {
  { (JSJitGetterOp)receiveUnsignedLongLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnsignedLongLong(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalUnsignedLongLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<uint64_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<uint64_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnsignedLongLong(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnsignedLongLong(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnsignedLongLong_methodinfo = {
  { (JSJitGetterOp)passOptionalUnsignedLongLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnsignedLongLongWithDefault(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalUnsignedLongLongWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  uint64_t arg0;
  if (args.hasDefined(0)) {
    if (!ValueToPrimitive<uint64_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
      return false;
    }
  } else {
    arg0 = 17ULL;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnsignedLongLongWithDefault(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnsignedLongLongWithDefault(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnsignedLongLongWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalUnsignedLongLongWithDefault },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableFloat(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  float result(MOZ_KnownLive(self)->WritableFloat());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableFloat(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.writableFloat setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableFloat(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableFloat(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableFloat_getterinfo = {
  { get_writableFloat },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableFloat_setterinfo = {
  { (JSJitGetterOp)set_writableFloat },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnrestrictedFloat(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableUnrestrictedFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  float result(MOZ_KnownLive(self)->WritableUnrestrictedFloat());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnrestrictedFloat(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableUnrestrictedFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnrestrictedFloat(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnrestrictedFloat(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnrestrictedFloat_getterinfo = {
  { get_writableUnrestrictedFloat },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableUnrestrictedFloat_setterinfo = {
  { (JSJitGetterOp)set_writableUnrestrictedFloat },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableNullableFloat(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableNullableFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<float> result(MOZ_KnownLive(self)->GetWritableNullableFloat());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  args.rval().set(JS_NumberValue(double(result.Value())));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableNullableFloat(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.writableNullableFloat setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableNullableFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<float> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Value being assigned", &arg0.SetValue())) {
    return false;
  } else if (!mozilla::IsFinite(arg0.Value())) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableNullableFloat(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableNullableFloat(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableNullableFloat_getterinfo = {
  { get_writableNullableFloat },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableNullableFloat_setterinfo = {
  { (JSJitGetterOp)set_writableNullableFloat },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableNullableUnrestrictedFloat(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableNullableUnrestrictedFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<float> result(MOZ_KnownLive(self)->GetWritableNullableUnrestrictedFloat());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  args.rval().set(JS_NumberValue(double(result.Value())));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableNullableUnrestrictedFloat(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableNullableUnrestrictedFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<float> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Value being assigned", &arg0.SetValue())) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableNullableUnrestrictedFloat(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableNullableUnrestrictedFloat(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableNullableUnrestrictedFloat_getterinfo = {
  { get_writableNullableUnrestrictedFloat },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableNullableUnrestrictedFloat_setterinfo = {
  { (JSJitGetterOp)set_writableNullableUnrestrictedFloat },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableDouble(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  double result(MOZ_KnownLive(self)->WritableDouble());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableDouble(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.writableDouble setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableDouble(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableDouble(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableDouble_getterinfo = {
  { get_writableDouble },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableDouble_setterinfo = {
  { (JSJitGetterOp)set_writableDouble },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnrestrictedDouble(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableUnrestrictedDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  double result(MOZ_KnownLive(self)->WritableUnrestrictedDouble());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnrestrictedDouble(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableUnrestrictedDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnrestrictedDouble(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnrestrictedDouble(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnrestrictedDouble_getterinfo = {
  { get_writableUnrestrictedDouble },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableUnrestrictedDouble_setterinfo = {
  { (JSJitGetterOp)set_writableUnrestrictedDouble },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableNullableDouble(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableNullableDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<double> result(MOZ_KnownLive(self)->GetWritableNullableDouble());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  args.rval().set(JS_NumberValue(double(result.Value())));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableNullableDouble(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.writableNullableDouble setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableNullableDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<double> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0.SetValue())) {
    return false;
  } else if (!mozilla::IsFinite(arg0.Value())) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableNullableDouble(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableNullableDouble(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableNullableDouble_getterinfo = {
  { get_writableNullableDouble },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableNullableDouble_setterinfo = {
  { (JSJitGetterOp)set_writableNullableDouble },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableNullableUnrestrictedDouble(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableNullableUnrestrictedDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<double> result(MOZ_KnownLive(self)->GetWritableNullableUnrestrictedDouble());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  args.rval().set(JS_NumberValue(double(result.Value())));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableNullableUnrestrictedDouble(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableNullableUnrestrictedDouble", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<double> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0.SetValue())) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableNullableUnrestrictedDouble(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableNullableUnrestrictedDouble(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableNullableUnrestrictedDouble_getterinfo = {
  { get_writableNullableUnrestrictedDouble },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableNullableUnrestrictedDouble_setterinfo = {
  { (JSJitGetterOp)set_writableNullableUnrestrictedDouble },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passFloat(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passFloat");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passFloat", 16)) {
    return false;
  }
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 1");
    return false;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  }
  Nullable<float> arg2;
  if (args[2].isNullOrUndefined()) {
    arg2.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, args[2], "Argument 3", &arg2.SetValue())) {
    return false;
  } else if (!mozilla::IsFinite(arg2.Value())) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 3");
    return false;
  }
  Nullable<float> arg3;
  if (args[3].isNullOrUndefined()) {
    arg3.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, args[3], "Argument 4", &arg3.SetValue())) {
    return false;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
    return false;
  } else if (!mozilla::IsFinite(arg4)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 5");
    return false;
  }
  double arg5;
  if (!ValueToPrimitive<double, eDefault>(cx, args[5], "Argument 6", &arg5)) {
    return false;
  }
  Nullable<double> arg6;
  if (args[6].isNullOrUndefined()) {
    arg6.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, args[6], "Argument 7", &arg6.SetValue())) {
    return false;
  } else if (!mozilla::IsFinite(arg6.Value())) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 7");
    return false;
  }
  Nullable<double> arg7;
  if (args[7].isNullOrUndefined()) {
    arg7.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, args[7], "Argument 8", &arg7.SetValue())) {
    return false;
  }
  binding_detail::AutoSequence<float> arg8;
  if (args[8].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[8], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 9");
      return false;
    }
    binding_detail::AutoSequence<float> &arr = arg8;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      float* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      float& slot = *slotPtr;
      if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 9", &slot)) {
        return false;
      } else if (!mozilla::IsFinite(slot)) {
        cx.ThrowErrorMessage<MSG_NOT_FINITE>("Element of argument 9");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 9");
    return false;
  }
  binding_detail::AutoSequence<float> arg9;
  if (args[9].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[9], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 10");
      return false;
    }
    binding_detail::AutoSequence<float> &arr = arg9;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      float* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      float& slot = *slotPtr;
      if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 10", &slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 10");
    return false;
  }
  binding_detail::AutoSequence<Nullable<float>> arg10;
  if (args[10].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[10], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 11");
      return false;
    }
    binding_detail::AutoSequence<Nullable<float>> &arr = arg10;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<float>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<float>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 11", &slot.SetValue())) {
        return false;
      } else if (!mozilla::IsFinite(slot.Value())) {
        cx.ThrowErrorMessage<MSG_NOT_FINITE>("Element of argument 11");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 11");
    return false;
  }
  binding_detail::AutoSequence<Nullable<float>> arg11;
  if (args[11].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[11], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 12");
      return false;
    }
    binding_detail::AutoSequence<Nullable<float>> &arr = arg11;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<float>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<float>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 12", &slot.SetValue())) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 12");
    return false;
  }
  binding_detail::AutoSequence<double> arg12;
  if (args[12].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[12], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 13");
      return false;
    }
    binding_detail::AutoSequence<double> &arr = arg12;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      double* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      double& slot = *slotPtr;
      if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 13", &slot)) {
        return false;
      } else if (!mozilla::IsFinite(slot)) {
        cx.ThrowErrorMessage<MSG_NOT_FINITE>("Element of argument 13");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 13");
    return false;
  }
  binding_detail::AutoSequence<double> arg13;
  if (args[13].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[13], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 14");
      return false;
    }
    binding_detail::AutoSequence<double> &arr = arg13;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      double* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      double& slot = *slotPtr;
      if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 14", &slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 14");
    return false;
  }
  binding_detail::AutoSequence<Nullable<double>> arg14;
  if (args[14].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[14], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 15");
      return false;
    }
    binding_detail::AutoSequence<Nullable<double>> &arr = arg14;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<double>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<double>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 15", &slot.SetValue())) {
        return false;
      } else if (!mozilla::IsFinite(slot.Value())) {
        cx.ThrowErrorMessage<MSG_NOT_FINITE>("Element of argument 15");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 15");
    return false;
  }
  binding_detail::AutoSequence<Nullable<double>> arg15;
  if (args[15].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[15], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 16");
      return false;
    }
    binding_detail::AutoSequence<Nullable<double>> &arr = arg15;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<double>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<double>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 16", &slot.SetValue())) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 16");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassFloat(arg0, arg1, Constify(arg2), Constify(arg3), arg4, arg5, Constify(arg6), Constify(arg7), Constify(arg8), Constify(arg9), Constify(arg10), Constify(arg11), Constify(arg12), Constify(arg13), Constify(arg14), Constify(arg15)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassFloat(arg0, arg1, Constify(arg2), Constify(arg3), arg4, arg5, Constify(arg6), Constify(arg7), Constify(arg8), Constify(arg9), Constify(arg10), Constify(arg11), Constify(arg12), Constify(arg13), Constify(arg14), Constify(arg15));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passFloat_methodinfo = {
  { (JSJitGetterOp)passFloat },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passLenientFloat(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passLenientFloat");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passLenientFloat", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passLenientFloat", 16)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  float arg1;
  if (!ValueToPrimitive<float, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  }
  Nullable<float> arg2;
  if (args[2].isNullOrUndefined()) {
    arg2.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, args[2], "Argument 3", &arg2.SetValue())) {
    return false;
  } else if (!mozilla::IsFinite(arg2.Value())) {
    foundNonFiniteFloat = true;
  }
  Nullable<float> arg3;
  if (args[3].isNullOrUndefined()) {
    arg3.SetNull();
  } else if (!ValueToPrimitive<float, eDefault>(cx, args[3], "Argument 4", &arg3.SetValue())) {
    return false;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
    return false;
  } else if (!mozilla::IsFinite(arg4)) {
    foundNonFiniteFloat = true;
  }
  double arg5;
  if (!ValueToPrimitive<double, eDefault>(cx, args[5], "Argument 6", &arg5)) {
    return false;
  }
  Nullable<double> arg6;
  if (args[6].isNullOrUndefined()) {
    arg6.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, args[6], "Argument 7", &arg6.SetValue())) {
    return false;
  } else if (!mozilla::IsFinite(arg6.Value())) {
    foundNonFiniteFloat = true;
  }
  Nullable<double> arg7;
  if (args[7].isNullOrUndefined()) {
    arg7.SetNull();
  } else if (!ValueToPrimitive<double, eDefault>(cx, args[7], "Argument 8", &arg7.SetValue())) {
    return false;
  }
  binding_detail::AutoSequence<float> arg8;
  if (args[8].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[8], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 9");
      return false;
    }
    binding_detail::AutoSequence<float> &arr = arg8;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      float* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      float& slot = *slotPtr;
      if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 9", &slot)) {
        return false;
      } else if (!mozilla::IsFinite(slot)) {
        foundNonFiniteFloat = true;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 9");
    return false;
  }
  binding_detail::AutoSequence<float> arg9;
  if (args[9].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[9], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 10");
      return false;
    }
    binding_detail::AutoSequence<float> &arr = arg9;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      float* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      float& slot = *slotPtr;
      if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 10", &slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 10");
    return false;
  }
  binding_detail::AutoSequence<Nullable<float>> arg10;
  if (args[10].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[10], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 11");
      return false;
    }
    binding_detail::AutoSequence<Nullable<float>> &arr = arg10;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<float>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<float>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 11", &slot.SetValue())) {
        return false;
      } else if (!mozilla::IsFinite(slot.Value())) {
        foundNonFiniteFloat = true;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 11");
    return false;
  }
  binding_detail::AutoSequence<Nullable<float>> arg11;
  if (args[11].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[11], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 12");
      return false;
    }
    binding_detail::AutoSequence<Nullable<float>> &arr = arg11;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<float>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<float>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<float, eDefault>(cx, temp, "Element of argument 12", &slot.SetValue())) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 12");
    return false;
  }
  binding_detail::AutoSequence<double> arg12;
  if (args[12].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[12], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 13");
      return false;
    }
    binding_detail::AutoSequence<double> &arr = arg12;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      double* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      double& slot = *slotPtr;
      if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 13", &slot)) {
        return false;
      } else if (!mozilla::IsFinite(slot)) {
        foundNonFiniteFloat = true;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 13");
    return false;
  }
  binding_detail::AutoSequence<double> arg13;
  if (args[13].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[13], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 14");
      return false;
    }
    binding_detail::AutoSequence<double> &arr = arg13;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      double* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      double& slot = *slotPtr;
      if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 14", &slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 14");
    return false;
  }
  binding_detail::AutoSequence<Nullable<double>> arg14;
  if (args[14].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[14], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 15");
      return false;
    }
    binding_detail::AutoSequence<Nullable<double>> &arr = arg14;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<double>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<double>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 15", &slot.SetValue())) {
        return false;
      } else if (!mozilla::IsFinite(slot.Value())) {
        foundNonFiniteFloat = true;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 15");
    return false;
  }
  binding_detail::AutoSequence<Nullable<double>> arg15;
  if (args[15].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[15], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 16");
      return false;
    }
    binding_detail::AutoSequence<Nullable<double>> &arr = arg15;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<double>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<double>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 16", &slot.SetValue())) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 16");
    return false;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassLenientFloat(arg0, arg1, Constify(arg2), Constify(arg3), arg4, arg5, Constify(arg6), Constify(arg7), Constify(arg8), Constify(arg9), Constify(arg10), Constify(arg11), Constify(arg12), Constify(arg13), Constify(arg14), Constify(arg15)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassLenientFloat(arg0, arg1, Constify(arg2), Constify(arg3), arg4, arg5, Constify(arg6), Constify(arg7), Constify(arg8), Constify(arg9), Constify(arg10), Constify(arg11), Constify(arg12), Constify(arg13), Constify(arg14), Constify(arg15));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passLenientFloat_methodinfo = {
  { (JSJitGetterOp)passLenientFloat },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_lenientFloatAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "lenientFloatAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  float result(MOZ_KnownLive(self)->LenientFloatAttr());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_lenientFloatAttr(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.lenientFloatAttr setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "lenientFloatAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool foundNonFiniteFloat = false;
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetLenientFloatAttr(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetLenientFloatAttr(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo lenientFloatAttr_getterinfo = {
  { get_lenientFloatAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo lenientFloatAttr_setterinfo = {
  { (JSJitGetterOp)set_lenientFloatAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_lenientDoubleAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "lenientDoubleAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  double result(MOZ_KnownLive(self)->LenientDoubleAttr());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_lenientDoubleAttr(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.lenientDoubleAttr setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "lenientDoubleAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetLenientDoubleAttr(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetLenientDoubleAttr(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo lenientDoubleAttr_getterinfo = {
  { get_lenientDoubleAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo lenientDoubleAttr_setterinfo = {
  { (JSJitGetterOp)set_lenientDoubleAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveSelf(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->ReceiveSelf()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo receiveSelf_methodinfo = {
  { (JSJitGetterOp)receiveSelf },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableSelf(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->ReceiveNullableSelf()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableSelf_methodinfo = {
  { (JSJitGetterOp)receiveNullableSelf },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakSelf(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveWeakSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->ReceiveWeakSelf()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo receiveWeakSelf_methodinfo = {
  { (JSJitGetterOp)receiveWeakSelf },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakNullableSelf(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveWeakNullableSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->ReceiveWeakNullableSelf()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo receiveWeakNullableSelf_methodinfo = {
  { (JSJitGetterOp)receiveWeakNullableSelf },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSelf(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passSelf");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passSelf", 1)) {
    return false;
  }
  NonNull<mozilla::dom::TestInterface> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSelf(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSelf(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSelf_methodinfo = {
  { (JSJitGetterOp)passSelf },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableSelf(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableSelf");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableSelf", 1)) {
    return false;
  }
  mozilla::dom::TestInterface* arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableSelf(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableSelf(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableSelf_methodinfo = {
  { (JSJitGetterOp)passNullableSelf },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nonNullSelf(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "nonNullSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->NonNullSelf()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_nonNullSelf(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.nonNullSelf setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "nonNullSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  NonNull<mozilla::dom::TestInterface> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "TestInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNonNullSelf(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNonNullSelf(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nonNullSelf_getterinfo = {
  { get_nonNullSelf },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo nonNullSelf_setterinfo = {
  { (JSJitGetterOp)set_nonNullSelf },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nullableSelf(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "nullableSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->GetNullableSelf()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_nullableSelf(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.nullableSelf setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "nullableSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  mozilla::dom::TestInterface* arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "TestInterface");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNullableSelf(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNullableSelf(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nullableSelf_getterinfo = {
  { get_nullableSelf },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo nullableSelf_setterinfo = {
  { (JSJitGetterOp)set_nullableSelf },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_cachedSelf(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "cachedSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  JS::Rooted<JSObject*> slotStorage(cx, js::UncheckedUnwrap(obj, /* stopAtWindowProxy = */ false));
  MOZ_ASSERT(IsDOMObject(slotStorage));
  const size_t slotIndex = (DOM_INSTANCE_RESERVED_SLOTS + 3);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapValue(cx, args.rval());
    }
  }

  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->CachedSelf()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    PreserveWrapper(self);
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapValue(cx, args.rval());
}

static const JSJitInfo cachedSelf_getterinfo = {
  { get_cachedSelf },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 3)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 3) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 3) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSelf(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalSelf");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<mozilla::dom::TestInterface*> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      {
        // Our JSContext should be in the right global to do unwrapping in.
        nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0.Value(), cx);
        if (NS_FAILED(rv)) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value() = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSelf(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSelf(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSelf_methodinfo = {
  { (JSJitGetterOp)passOptionalSelf },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNonNullSelf(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNonNullSelf");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNonNullSelf", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<NonNull<mozilla::dom::TestInterface>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      {
        // Our JSContext should be in the right global to do unwrapping in.
        nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0.Value(), cx);
        if (NS_FAILED(rv)) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNonNullSelf(MOZ_KnownLive(NonNullHelper(Constify(arg0)))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNonNullSelf(MOZ_KnownLive(NonNullHelper(Constify(arg0))));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNonNullSelf_methodinfo = {
  { (JSJitGetterOp)passOptionalNonNullSelf },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSelfWithDefault(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalSelfWithDefault");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalSelfWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  mozilla::dom::TestInterface* arg0;
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      {
        // Our JSContext should be in the right global to do unwrapping in.
        nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
        if (NS_FAILED(rv)) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSelfWithDefault(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSelfWithDefault(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSelfWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalSelfWithDefault },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNonWrapperCacheInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNonWrapperCacheInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestNonWrapperCacheInterface>(MOZ_KnownLive(self)->ReceiveNonWrapperCacheInterface()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo receiveNonWrapperCacheInterface_methodinfo = {
  { (JSJitGetterOp)receiveNonWrapperCacheInterface },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableNonWrapperCacheInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableNonWrapperCacheInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestNonWrapperCacheInterface>(MOZ_KnownLive(self)->ReceiveNullableNonWrapperCacheInterface()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableNonWrapperCacheInterface_methodinfo = {
  { (JSJitGetterOp)receiveNullableNonWrapperCacheInterface },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNonWrapperCacheInterfaceSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNonWrapperCacheInterfaceSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  nsTArray<StrongPtrForMember<mozilla::dom::TestNonWrapperCacheInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNonWrapperCacheInterfaceSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNonWrapperCacheInterfaceSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapNewBindingNonWrapperCachedObject(cx, returnArray, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNonWrapperCacheInterfaceSequence_methodinfo = {
  { (JSJitGetterOp)receiveNonWrapperCacheInterfaceSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableNonWrapperCacheInterfaceSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableNonWrapperCacheInterfaceSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  nsTArray<StrongPtrForMember<mozilla::dom::TestNonWrapperCacheInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableNonWrapperCacheInterfaceSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableNonWrapperCacheInterfaceSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result[sequenceIdx0]) {
          tmp.setNull();
          break;
        }
        if (!WrapNewBindingNonWrapperCachedObject(cx, returnArray, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableNonWrapperCacheInterfaceSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableNonWrapperCacheInterfaceSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNonWrapperCacheInterfaceNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNonWrapperCacheInterfaceNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<nsTArray<StrongPtrForMember<mozilla::dom::TestNonWrapperCacheInterface>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNonWrapperCacheInterfaceNullableSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNonWrapperCacheInterfaceNullableSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!WrapNewBindingNonWrapperCachedObject(cx, returnArray, result.Value()[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNonWrapperCacheInterfaceNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveNonWrapperCacheInterfaceNullableSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableNonWrapperCacheInterfaceNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableNonWrapperCacheInterfaceNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<nsTArray<StrongPtrForMember<mozilla::dom::TestNonWrapperCacheInterface>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableNonWrapperCacheInterfaceNullableSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableNonWrapperCacheInterfaceNullableSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result.Value()[sequenceIdx0]) {
          tmp.setNull();
          break;
        }
        if (!WrapNewBindingNonWrapperCachedObject(cx, returnArray, result.Value()[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableNonWrapperCacheInterfaceNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableNonWrapperCacheInterfaceNullableSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveExternal(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestExternalInterface>(MOZ_KnownLive(self)->ReceiveExternal()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveExternal_methodinfo = {
  { (JSJitGetterOp)receiveExternal },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableExternal(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestExternalInterface>(MOZ_KnownLive(self)->ReceiveNullableExternal()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableExternal_methodinfo = {
  { (JSJitGetterOp)receiveNullableExternal },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakExternal(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveWeakExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestExternalInterface>(MOZ_KnownLive(self)->ReceiveWeakExternal()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveWeakExternal_methodinfo = {
  { (JSJitGetterOp)receiveWeakExternal },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakNullableExternal(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveWeakNullableExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestExternalInterface>(MOZ_KnownLive(self)->ReceiveWeakNullableExternal()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveWeakNullableExternal_methodinfo = {
  { (JSJitGetterOp)receiveWeakNullableExternal },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passExternal(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passExternal");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passExternal", 1)) {
    return false;
  }
  mozilla::dom::TestExternalInterface* arg0;
  RefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  if (args[0].isObject()) {
    JS::Rooted<JSObject*> source(cx, &args[0].toObject());
    if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestExternalInterface");
      return false;
    }
    MOZ_ASSERT(arg0_holder);
    arg0 = arg0_holder;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassExternal(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassExternal(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passExternal_methodinfo = {
  { (JSJitGetterOp)passExternal },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableExternal(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableExternal");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableExternal", 1)) {
    return false;
  }
  mozilla::dom::TestExternalInterface* arg0;
  RefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  if (args[0].isObject()) {
    JS::Rooted<JSObject*> source(cx, &args[0].toObject());
    if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestExternalInterface");
      return false;
    }
    MOZ_ASSERT(arg0_holder);
    arg0 = arg0_holder;
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableExternal(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableExternal(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableExternal_methodinfo = {
  { (JSJitGetterOp)passNullableExternal },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nonNullExternal(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "nonNullExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestExternalInterface>(MOZ_KnownLive(self)->NonNullExternal()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_nonNullExternal(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.nonNullExternal setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "nonNullExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  mozilla::dom::TestExternalInterface* arg0;
  RefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  if (args[0].isObject()) {
    JS::Rooted<JSObject*> source(cx, &args[0].toObject());
    if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "TestExternalInterface");
      return false;
    }
    MOZ_ASSERT(arg0_holder);
    arg0 = arg0_holder;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNonNullExternal(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNonNullExternal(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nonNullExternal_getterinfo = {
  { get_nonNullExternal },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo nonNullExternal_setterinfo = {
  { (JSJitGetterOp)set_nonNullExternal },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nullableExternal(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "nullableExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestExternalInterface>(MOZ_KnownLive(self)->GetNullableExternal()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_nullableExternal(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.nullableExternal setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "nullableExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  mozilla::dom::TestExternalInterface* arg0;
  RefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  if (args[0].isObject()) {
    JS::Rooted<JSObject*> source(cx, &args[0].toObject());
    if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder)))) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "TestExternalInterface");
      return false;
    }
    MOZ_ASSERT(arg0_holder);
    arg0 = arg0_holder;
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNullableExternal(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNullableExternal(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nullableExternal_getterinfo = {
  { get_nullableExternal },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo nullableExternal_setterinfo = {
  { (JSJitGetterOp)set_nullableExternal },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalExternal(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalExternal");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<mozilla::dom::TestExternalInterface*> arg0;
  Maybe<RefPtr<mozilla::dom::TestExternalInterface>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace();
    if (args[0].isObject()) {
      JS::Rooted<JSObject*> source(cx, &args[0].toObject());
      if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder.ref())))) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestExternalInterface");
        return false;
      }
      MOZ_ASSERT(arg0_holder.ref());
      arg0.Value() = arg0_holder.ref();
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value() = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalExternal(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalExternal(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalExternal_methodinfo = {
  { (JSJitGetterOp)passOptionalExternal },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNonNullExternal(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNonNullExternal");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNonNullExternal", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<mozilla::dom::TestExternalInterface*> arg0;
  Maybe<RefPtr<mozilla::dom::TestExternalInterface>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace();
    if (args[0].isObject()) {
      JS::Rooted<JSObject*> source(cx, &args[0].toObject());
      if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder.ref())))) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestExternalInterface");
        return false;
      }
      MOZ_ASSERT(arg0_holder.ref());
      arg0.Value() = arg0_holder.ref();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNonNullExternal(MOZ_KnownLive(NonNullHelper(Constify(arg0)))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNonNullExternal(MOZ_KnownLive(NonNullHelper(Constify(arg0))));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNonNullExternal_methodinfo = {
  { (JSJitGetterOp)passOptionalNonNullExternal },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalExternalWithDefault(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalExternalWithDefault");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalExternalWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  mozilla::dom::TestExternalInterface* arg0;
  RefPtr<mozilla::dom::TestExternalInterface> arg0_holder;
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      JS::Rooted<JSObject*> source(cx, &args[0].toObject());
      if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(arg0_holder)))) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestExternalInterface");
        return false;
      }
      MOZ_ASSERT(arg0_holder);
      arg0 = arg0_holder;
    } else if (args[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalExternalWithDefault(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalExternalWithDefault(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalExternalWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalExternalWithDefault },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveCallbackInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->ReceiveCallbackInterface()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveCallbackInterface_methodinfo = {
  { (JSJitGetterOp)receiveCallbackInterface },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableCallbackInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->ReceiveNullableCallbackInterface()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static const JSJitInfo receiveNullableCallbackInterface_methodinfo = {
  { (JSJitGetterOp)receiveNullableCallbackInterface },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakCallbackInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveWeakCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->ReceiveWeakCallbackInterface()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveWeakCallbackInterface_methodinfo = {
  { (JSJitGetterOp)receiveWeakCallbackInterface },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakNullableCallbackInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveWeakNullableCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->ReceiveWeakNullableCallbackInterface()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static const JSJitInfo receiveWeakNullableCallbackInterface_methodinfo = {
  { (JSJitGetterOp)receiveWeakNullableCallbackInterface },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passCallbackInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passCallbackInterface");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passCallbackInterface", 1)) {
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestCallbackInterface>> arg0(cx);
  if (args[0].isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassCallbackInterface(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassCallbackInterface(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passCallbackInterface_methodinfo = {
  { (JSJitGetterOp)passCallbackInterface },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableCallbackInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableCallbackInterface");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableCallbackInterface", 1)) {
    return false;
  }
  RootedCallback<RefPtr<binding_detail::FastTestCallbackInterface>> arg0(cx);
  if (args[0].isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableCallbackInterface(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableCallbackInterface(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableCallbackInterface_methodinfo = {
  { (JSJitGetterOp)passNullableCallbackInterface },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nonNullCallbackInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "nonNullCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->NonNullCallbackInterface()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_nonNullCallbackInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.nonNullCallbackInterface setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "nonNullCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedCallback<OwningNonNull<binding_detail::FastTestCallbackInterface>> arg0(cx);
  if (args[0].isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNonNullCallbackInterface(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNonNullCallbackInterface(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nonNullCallbackInterface_getterinfo = {
  { get_nonNullCallbackInterface },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo nonNullCallbackInterface_setterinfo = {
  { (JSJitGetterOp)set_nonNullCallbackInterface },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nullableCallbackInterface(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "nullableCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->GetNullableCallbackInterface()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

MOZ_CAN_RUN_SCRIPT static bool
set_nullableCallbackInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.nullableCallbackInterface setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "nullableCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedCallback<RefPtr<binding_detail::FastTestCallbackInterface>> arg0(cx);
  if (args[0].isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNullableCallbackInterface(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNullableCallbackInterface(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nullableCallbackInterface_getterinfo = {
  { get_nullableCallbackInterface },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo nullableCallbackInterface_setterinfo = {
  { (JSJitGetterOp)set_nullableCallbackInterface },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalCallbackInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalCallbackInterface");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<RefPtr<TestCallbackInterface>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      { // scope for tempRoot and tempGlobalRoot if needed
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
        arg0.Value() = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value() = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalCallbackInterface(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalCallbackInterface(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalCallbackInterface_methodinfo = {
  { (JSJitGetterOp)passOptionalCallbackInterface },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNonNullCallbackInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNonNullCallbackInterface");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNonNullCallbackInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<OwningNonNull<TestCallbackInterface>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      { // scope for tempRoot and tempGlobalRoot if needed
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
        arg0.Value() = new TestCallbackInterface(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNonNullCallbackInterface(MOZ_KnownLive(NonNullHelper(Constify(arg0)))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNonNullCallbackInterface(MOZ_KnownLive(NonNullHelper(Constify(arg0))));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNonNullCallbackInterface_methodinfo = {
  { (JSJitGetterOp)passOptionalNonNullCallbackInterface },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalCallbackInterfaceWithDefault(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalCallbackInterfaceWithDefault");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalCallbackInterfaceWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedCallback<RefPtr<binding_detail::FastTestCallbackInterface>> arg0(cx);
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      { // scope for tempRoot and tempGlobalRoot if needed
        arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalCallbackInterfaceWithDefault(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalCallbackInterfaceWithDefault(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalCallbackInterfaceWithDefault_methodinfo = {
  { (JSJitGetterOp)passOptionalCallbackInterfaceWithDefault },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlySequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "readonlySequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 4) : (DOM_INSTANCE_RESERVED_SLOTS + 4);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectValue(cx, args.rval());
    }
  }

  nsTArray<int32_t> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlySequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlySequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping

      uint32_t length = result.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            tmp.setInt32(int32_t(result[sequenceIdx0]));
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      args.rval().setObject(*returnArray);
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectValue(cx, args.rval());
}

static const JSJitInfo readonlySequence_getterinfo = {
  { get_readonlySequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 4)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 4) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 4) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlySequenceOfDictionaries(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "readonlySequenceOfDictionaries", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 5) : (DOM_INSTANCE_RESERVED_SLOTS + 5);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectValue(cx, args.rval());
    }
  }

  nsTArray<Dict> result;
  SequenceRooter<Dict > resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlySequenceOfDictionaries(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlySequenceOfDictionaries(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping

      uint32_t length = result.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (!result[sequenceIdx0].ToObjectInternal(cx, &tmp)) {
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      args.rval().setObject(*returnArray);
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectValue(cx, args.rval());
}

static const JSJitInfo readonlySequenceOfDictionaries_getterinfo = {
  { get_readonlySequenceOfDictionaries },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 5)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 5) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 5) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyNullableSequenceOfDictionaries(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "readonlyNullableSequenceOfDictionaries", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 6) : (DOM_INSTANCE_RESERVED_SLOTS + 6);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectOrNullValue(cx, args.rval());
    }
  }

  Nullable<nsTArray<Dict>> result;
  SequenceRooter<Dict > resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlyNullableSequenceOfDictionaries(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlyNullableSequenceOfDictionaries(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping

      if (result.IsNull()) {
        args.rval().setNull();
        break;
      }

      uint32_t length = result.Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (!result.Value()[sequenceIdx0].ToObjectInternal(cx, &tmp)) {
              return false;
            }
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      args.rval().setObject(*returnArray);
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectOrNullValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectOrNullValue(cx, args.rval());
}

static const JSJitInfo readonlyNullableSequenceOfDictionaries_getterinfo = {
  { get_readonlyNullableSequenceOfDictionaries },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 6)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 6) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 6) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyFrozenSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "readonlyFrozenSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 7) : (DOM_INSTANCE_RESERVED_SLOTS + 7);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectValue(cx, args.rval());
    }
  }

  nsTArray<int32_t> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlyFrozenSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlyFrozenSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping

      uint32_t length = result.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            tmp.setInt32(int32_t(result[sequenceIdx0]));
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      args.rval().setObject(*returnArray);
      break;
    } while (false);
    JS::Rooted<JSObject*> rvalObj(cx, &args.rval().toObject());
    if (!JS_FreezeObject(cx, rvalObj)) {
      return false;
    }
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectValue(cx, args.rval());
}

static const JSJitInfo readonlyFrozenSequence_getterinfo = {
  { get_readonlyFrozenSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 7)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 7) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 7) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyFrozenNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "readonlyFrozenNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 8) : (DOM_INSTANCE_RESERVED_SLOTS + 8);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectOrNullValue(cx, args.rval());
    }
  }

  Nullable<nsTArray<int32_t>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlyFrozenNullableSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlyFrozenNullableSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping

      if (result.IsNull()) {
        args.rval().setNull();
        break;
      }

      uint32_t length = result.Value().Length();
      JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            tmp.setInt32(int32_t(result.Value()[sequenceIdx0]));
            break;
          } while (false);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      args.rval().setObject(*returnArray);
      break;
    } while (false);
    if (args.rval().isObject()) {
      JS::Rooted<JSObject*> rvalObj(cx, &args.rval().toObject());
      if (!JS_FreezeObject(cx, rvalObj)) {
        return false;
      }
    }
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectOrNullValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectOrNullValue(cx, args.rval());
}

static const JSJitInfo readonlyFrozenNullableSequence_getterinfo = {
  { get_readonlyFrozenNullableSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 8)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 8) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 8) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  nsTArray<int32_t> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        tmp.setInt32(int32_t(result[sequenceIdx0]));
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveSequence_methodinfo = {
  { (JSJitGetterOp)receiveSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<nsTArray<int32_t>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        tmp.setInt32(int32_t(result.Value()[sequenceIdx0]));
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveSequenceOfNullableInts(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveSequenceOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  nsTArray<Nullable<int32_t>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveSequenceOfNullableInts(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveSequenceOfNullableInts(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (result[sequenceIdx0].IsNull()) {
          tmp.setNull();
          break;
        }
        tmp.setInt32(int32_t(result[sequenceIdx0].Value()));
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveSequenceOfNullableInts_methodinfo = {
  { (JSJitGetterOp)receiveSequenceOfNullableInts },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableSequenceOfNullableInts(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableSequenceOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<nsTArray<Nullable<int32_t>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableSequenceOfNullableInts(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableSequenceOfNullableInts(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (result.Value()[sequenceIdx0].IsNull()) {
          tmp.setNull();
          break;
        }
        tmp.setInt32(int32_t(result.Value()[sequenceIdx0].Value()));
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableSequenceOfNullableInts_methodinfo = {
  { (JSJitGetterOp)receiveNullableSequenceOfNullableInts },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passSequence", 1)) {
    return false;
  }
  binding_detail::AutoSequence<int32_t> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<int32_t> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      int32_t& slot = *slotPtr;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequence_methodinfo = {
  { (JSJitGetterOp)passSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableSequence", 1)) {
    return false;
  }
  Nullable<Sequence<int32_t>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    Sequence<int32_t> &arr = arg0.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      int32_t& slot = *slotPtr;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableSequence_methodinfo = {
  { (JSJitGetterOp)passNullableSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfNullableInts(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passSequenceOfNullableInts");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passSequenceOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passSequenceOfNullableInts", 1)) {
    return false;
  }
  binding_detail::AutoSequence<Nullable<int32_t>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Nullable<int32_t>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<int32_t>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<int32_t>& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot.SetValue())) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfNullableInts(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfNullableInts(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfNullableInts_methodinfo = {
  { (JSJitGetterOp)passSequenceOfNullableInts },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSequenceOfNullableInts(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalSequenceOfNullableInts");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalSequenceOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Sequence<Nullable<int32_t>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<Nullable<int32_t>> &arr = arg0.Value();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Nullable<int32_t>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Nullable<int32_t>& slot = *slotPtr;
        if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot.SetValue())) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSequenceOfNullableInts(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSequenceOfNullableInts(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSequenceOfNullableInts_methodinfo = {
  { (JSJitGetterOp)passOptionalSequenceOfNullableInts },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceOfNullableInts(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableSequenceOfNullableInts");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableSequenceOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Nullable<Sequence<Nullable<int32_t>>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<Nullable<int32_t>> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Nullable<int32_t>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Nullable<int32_t>& slot = *slotPtr;
        if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot.SetValue())) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableInts(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableInts(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceOfNullableInts_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceOfNullableInts },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveCastableObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveCastableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  nsTArray<StrongPtrForMember<mozilla::dom::TestInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveCastableObjectSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveCastableObjectSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!GetOrCreateDOMReflector(cx, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveCastableObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveCastableObjectSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveCallbackObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveCallbackObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  nsTArray<StrongPtrForMember<mozilla::dom::TestCallbackInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveCallbackObjectSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveCallbackObjectSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        tmp.setObjectOrNull(GetCallbackFromCallbackObject(cx, result[sequenceIdx0]));
        if (!MaybeWrapObjectValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveCallbackObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveCallbackObjectSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableCastableObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableCastableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  nsTArray<StrongPtrForMember<mozilla::dom::TestInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableCastableObjectSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableCastableObjectSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result[sequenceIdx0]) {
          tmp.setNull();
          break;
        }
        if (!GetOrCreateDOMReflector(cx, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableCastableObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableCastableObjectSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableCallbackObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableCallbackObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  nsTArray<StrongPtrForMember<mozilla::dom::TestCallbackInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableCallbackObjectSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableCallbackObjectSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (result[sequenceIdx0]) {
          tmp.setObjectOrNull(GetCallbackFromCallbackObject(cx, result[sequenceIdx0]));
          if (!MaybeWrapObjectOrNullValue(cx, &tmp)) {
            return false;
          }
          break;
        } else {
          tmp.setNull();
          break;
        }
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableCallbackObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableCallbackObjectSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveCastableObjectNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveCastableObjectNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<nsTArray<StrongPtrForMember<mozilla::dom::TestInterface>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveCastableObjectNullableSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveCastableObjectNullableSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!GetOrCreateDOMReflector(cx, result.Value()[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveCastableObjectNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveCastableObjectNullableSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableCastableObjectNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableCastableObjectNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<nsTArray<StrongPtrForMember<mozilla::dom::TestInterface>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableCastableObjectNullableSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableCastableObjectNullableSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result.Value()[sequenceIdx0]) {
          tmp.setNull();
          break;
        }
        if (!GetOrCreateDOMReflector(cx, result.Value()[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableCastableObjectNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableCastableObjectNullableSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakCastableObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveWeakCastableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  nsTArray<StrongPtrForMember<mozilla::dom::TestInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveWeakCastableObjectSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveWeakCastableObjectSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!GetOrCreateDOMReflector(cx, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveWeakCastableObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveWeakCastableObjectSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakNullableCastableObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveWeakNullableCastableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  nsTArray<StrongPtrForMember<mozilla::dom::TestInterface>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveWeakNullableCastableObjectSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveWeakNullableCastableObjectSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result[sequenceIdx0]) {
          tmp.setNull();
          break;
        }
        if (!GetOrCreateDOMReflector(cx, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveWeakNullableCastableObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveWeakNullableCastableObjectSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakCastableObjectNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveWeakCastableObjectNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<nsTArray<StrongPtrForMember<mozilla::dom::TestInterface>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveWeakCastableObjectNullableSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveWeakCastableObjectNullableSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!GetOrCreateDOMReflector(cx, result.Value()[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveWeakCastableObjectNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveWeakCastableObjectNullableSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveWeakNullableCastableObjectNullableSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveWeakNullableCastableObjectNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<nsTArray<StrongPtrForMember<mozilla::dom::TestInterface>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveWeakNullableCastableObjectNullableSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveWeakNullableCastableObjectNullableSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!result.Value()[sequenceIdx0]) {
          tmp.setNull();
          break;
        }
        if (!GetOrCreateDOMReflector(cx, result.Value()[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveWeakNullableCastableObjectNullableSequence_methodinfo = {
  { (JSJitGetterOp)receiveWeakNullableCastableObjectNullableSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passCastableObjectSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passCastableObjectSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passCastableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passCastableObjectSequence", 1)) {
    return false;
  }
  binding_detail::AutoSequence<OwningNonNull<mozilla::dom::TestInterface>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<OwningNonNull<mozilla::dom::TestInterface>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      OwningNonNull<mozilla::dom::TestInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      OwningNonNull<mozilla::dom::TestInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassCastableObjectSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassCastableObjectSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passCastableObjectSequence_methodinfo = {
  { (JSJitGetterOp)passCastableObjectSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableCastableObjectSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableCastableObjectSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableCastableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableCastableObjectSequence", 1)) {
    return false;
  }
  binding_detail::AutoSequence<RefPtr<mozilla::dom::TestInterface>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<RefPtr<mozilla::dom::TestInterface>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      RefPtr<mozilla::dom::TestInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestInterface");
            return false;
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableCastableObjectSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableCastableObjectSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableCastableObjectSequence_methodinfo = {
  { (JSJitGetterOp)passNullableCastableObjectSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passCastableObjectNullableSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passCastableObjectNullableSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passCastableObjectNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passCastableObjectNullableSequence", 1)) {
    return false;
  }
  Nullable<Sequence<OwningNonNull<mozilla::dom::TestInterface>>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    Sequence<OwningNonNull<mozilla::dom::TestInterface>> &arr = arg0.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      OwningNonNull<mozilla::dom::TestInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      OwningNonNull<mozilla::dom::TestInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassCastableObjectNullableSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassCastableObjectNullableSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passCastableObjectNullableSequence_methodinfo = {
  { (JSJitGetterOp)passCastableObjectNullableSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableCastableObjectNullableSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableCastableObjectNullableSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableCastableObjectNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableCastableObjectNullableSequence", 1)) {
    return false;
  }
  Nullable<Sequence<RefPtr<mozilla::dom::TestInterface>>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    Sequence<RefPtr<mozilla::dom::TestInterface>> &arr = arg0.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      RefPtr<mozilla::dom::TestInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestInterface");
            return false;
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableCastableObjectNullableSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableCastableObjectNullableSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableCastableObjectNullableSequence_methodinfo = {
  { (JSJitGetterOp)passNullableCastableObjectNullableSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Sequence<int32_t>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<int32_t> &arr = arg0.Value();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSequence_methodinfo = {
  { (JSJitGetterOp)passOptionalSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSequenceWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalSequenceWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalSequenceWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  binding_detail::AutoSequence<int32_t> arg0;
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      binding_detail::AutoSequence<int32_t> &arr = arg0;
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  } else {
    /* arg0 array is already empty; nothing to do */
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSequenceWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSequenceWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSequenceWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalSequenceWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Nullable<Sequence<int32_t>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<int32_t> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequence_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableSequenceWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableSequenceWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<Sequence<int32_t>> arg0;
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<int32_t> &arr = arg0.SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  } else {
    arg0.SetNull();
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceWithDefaultValue2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableSequenceWithDefaultValue2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableSequenceWithDefaultValue2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<Sequence<int32_t>> arg0;
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<int32_t> &arr = arg0.SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        int32_t& slot = *slotPtr;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  } else {
    arg0.SetValue();
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceWithDefaultValue2(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceWithDefaultValue2(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceWithDefaultValue2_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceWithDefaultValue2 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalObjectSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalObjectSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Sequence<OwningNonNull<mozilla::dom::TestInterface>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<OwningNonNull<mozilla::dom::TestInterface>> &arr = arg0.Value();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        OwningNonNull<mozilla::dom::TestInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        OwningNonNull<mozilla::dom::TestInterface>& slot = *slotPtr;
        if (temp.isObject()) {
          static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
            if (NS_FAILED(rv)) {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestInterface");
              return false;
            }
          }
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalObjectSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalObjectSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalObjectSequence_methodinfo = {
  { (JSJitGetterOp)passOptionalObjectSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passExternalInterfaceSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passExternalInterfaceSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passExternalInterfaceSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passExternalInterfaceSequence", 1)) {
    return false;
  }
  binding_detail::AutoSequence<RefPtr<mozilla::dom::TestExternalInterface>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<RefPtr<mozilla::dom::TestExternalInterface>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestExternalInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      RefPtr<mozilla::dom::TestExternalInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
        RefPtr<mozilla::dom::TestExternalInterface> tempHolder;
        JS::Rooted<JSObject*> source(cx, &temp.toObject());
        if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(tempHolder)))) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestExternalInterface");
          return false;
        }
        MOZ_ASSERT(tempHolder);
        slot = tempHolder;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassExternalInterfaceSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassExternalInterfaceSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passExternalInterfaceSequence_methodinfo = {
  { (JSJitGetterOp)passExternalInterfaceSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableExternalInterfaceSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableExternalInterfaceSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableExternalInterfaceSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableExternalInterfaceSequence", 1)) {
    return false;
  }
  binding_detail::AutoSequence<RefPtr<mozilla::dom::TestExternalInterface>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<RefPtr<mozilla::dom::TestExternalInterface>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::TestExternalInterface>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      RefPtr<mozilla::dom::TestExternalInterface>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
        RefPtr<mozilla::dom::TestExternalInterface> tempHolder;
        JS::Rooted<JSObject*> source(cx, &temp.toObject());
        if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(tempHolder)))) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "TestExternalInterface");
          return false;
        }
        MOZ_ASSERT(tempHolder);
        slot = tempHolder;
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableExternalInterfaceSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableExternalInterfaceSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableExternalInterfaceSequence_methodinfo = {
  { (JSJitGetterOp)passNullableExternalInterfaceSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveStringSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveStringSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  nsTArray<nsString> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveStringSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveStringSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!xpc::NonVoidStringToJsval(cx, result[sequenceIdx0], &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveStringSequence_methodinfo = {
  { (JSJitGetterOp)receiveStringSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passStringSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passStringSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passStringSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passStringSequence", 1)) {
    return false;
  }
  binding_detail::AutoSequence<nsString> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<nsString> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      nsString* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      nsString& slot = *slotPtr;
      if (!ConvertJSValueToString(cx, temp, eStringify, eStringify, slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassStringSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassStringSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passStringSequence_methodinfo = {
  { (JSJitGetterOp)passStringSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveByteStringSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveByteStringSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  nsTArray<nsCString> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveByteStringSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveByteStringSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!NonVoidByteStringToJsval(cx, result[sequenceIdx0], &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveByteStringSequence_methodinfo = {
  { (JSJitGetterOp)receiveByteStringSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passByteStringSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passByteStringSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passByteStringSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passByteStringSequence", 1)) {
    return false;
  }
  binding_detail::AutoSequence<nsCString> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<nsCString> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      nsCString* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      nsCString& slot = *slotPtr;
      if (!ConvertJSValueToByteString(cx, temp, false, "element of argument 1", slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassByteStringSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassByteStringSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passByteStringSequence_methodinfo = {
  { (JSJitGetterOp)passByteStringSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUTF8StringSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveUTF8StringSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  nsTArray<nsCString> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveUTF8StringSequence(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveUTF8StringSequence(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!NonVoidUTF8StringToJsval(cx, result[sequenceIdx0], &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveUTF8StringSequence_methodinfo = {
  { (JSJitGetterOp)receiveUTF8StringSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUTF8StringSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUTF8StringSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUTF8StringSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passUTF8StringSequence", 1)) {
    return false;
  }
  binding_detail::AutoSequence<nsCString> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<nsCString> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      nsCString* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      nsCString& slot = *slotPtr;
      if (!ConvertJSValueToString(cx, temp, eStringify, eStringify, slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUTF8StringSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUTF8StringSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUTF8StringSequence_methodinfo = {
  { (JSJitGetterOp)passUTF8StringSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveAnySequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveAnySequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  nsTArray<JS::Value> result;
  SequenceRooter<JS::Value > resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveAnySequence(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveAnySequence(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        JS::ExposeValueToActiveJS(result[sequenceIdx0]);
        tmp.set(result[sequenceIdx0]);
        if (!MaybeWrapValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveAnySequence_methodinfo = {
  { (JSJitGetterOp)receiveAnySequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableAnySequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableAnySequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<nsTArray<JS::Value>> result;
  SequenceRooter<JS::Value > resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableAnySequence(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableAnySequence(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  uint32_t length = result.Value().Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        JS::ExposeValueToActiveJS(result.Value()[sequenceIdx0]);
        tmp.set(result.Value()[sequenceIdx0]);
        if (!MaybeWrapValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableAnySequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableAnySequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  nsTArray<JSObject*> result;
  SequenceRooter<JSObject* > resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveObjectSequence(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveObjectSequence(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        JS::ExposeObjectToActiveJS(result[sequenceIdx0]);
        tmp.setObject(*result[sequenceIdx0]);
        if (!MaybeWrapObjectValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveObjectSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableObjectSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableObjectSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  nsTArray<JSObject*> result;
  SequenceRooter<JSObject* > resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableObjectSequence(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableObjectSequence(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (result[sequenceIdx0]) {
                      JS::ExposeObjectToActiveJS(result[sequenceIdx0]);
                    }
                    tmp.setObjectOrNull(result[sequenceIdx0]);
        if (!MaybeWrapObjectOrNullValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo receiveNullableObjectSequence_methodinfo = {
  { (JSJitGetterOp)receiveNullableObjectSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfSequences(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passSequenceOfSequences");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passSequenceOfSequences", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passSequenceOfSequences", 1)) {
    return false;
  }
  binding_detail::AutoSequence<Sequence<int32_t>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Sequence<int32_t>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Sequence<int32_t>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Sequence<int32_t>& slot = *slotPtr;
      if (temp.isObject()) {
        JS::ForOfIterator iter1(cx);
        if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
          return false;
        }
        if (!iter1.valueIsIterable()) {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
        Sequence<int32_t> &arr1 = slot;
        JS::Rooted<JS::Value> temp1(cx);
        while (true) {
          bool done1;
          if (!iter1.next(&temp1, &done1)) {
            return false;
          }
          if (done1) {
            break;
          }
          int32_t* slotPtr1 = arr1.AppendElement(mozilla::fallible);
          if (!slotPtr1) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          int32_t& slot1 = *slotPtr1;
          if (!ValueToPrimitive<int32_t, eDefault>(cx, temp1, "Element of element of argument 1", &slot1)) {
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfSequences(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfSequences(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfSequences_methodinfo = {
  { (JSJitGetterOp)passSequenceOfSequences },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfSequencesOfSequences(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passSequenceOfSequencesOfSequences");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passSequenceOfSequencesOfSequences", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passSequenceOfSequencesOfSequences", 1)) {
    return false;
  }
  binding_detail::AutoSequence<Sequence<Sequence<int32_t>>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Sequence<Sequence<int32_t>>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Sequence<Sequence<int32_t>>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Sequence<Sequence<int32_t>>& slot = *slotPtr;
      if (temp.isObject()) {
        JS::ForOfIterator iter1(cx);
        if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
          return false;
        }
        if (!iter1.valueIsIterable()) {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
        Sequence<Sequence<int32_t>> &arr1 = slot;
        JS::Rooted<JS::Value> temp1(cx);
        while (true) {
          bool done1;
          if (!iter1.next(&temp1, &done1)) {
            return false;
          }
          if (done1) {
            break;
          }
          Sequence<int32_t>* slotPtr1 = arr1.AppendElement(mozilla::fallible);
          if (!slotPtr1) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          Sequence<int32_t>& slot1 = *slotPtr1;
          if (temp1.isObject()) {
            JS::ForOfIterator iter2(cx);
            if (!iter2.init(temp1, JS::ForOfIterator::AllowNonIterable)) {
              return false;
            }
            if (!iter2.valueIsIterable()) {
              cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of element of argument 1");
              return false;
            }
            Sequence<int32_t> &arr2 = slot1;
            JS::Rooted<JS::Value> temp2(cx);
            while (true) {
              bool done2;
              if (!iter2.next(&temp2, &done2)) {
                return false;
              }
              if (done2) {
                break;
              }
              int32_t* slotPtr2 = arr2.AppendElement(mozilla::fallible);
              if (!slotPtr2) {
                JS_ReportOutOfMemory(cx);
                return false;
              }
              int32_t& slot2 = *slotPtr2;
              if (!ValueToPrimitive<int32_t, eDefault>(cx, temp2, "Element of element of element of argument 1", &slot2)) {
                return false;
              }
            }
          } else {
            cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of element of argument 1");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfSequencesOfSequences(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfSequencesOfSequences(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfSequencesOfSequences_methodinfo = {
  { (JSJitGetterOp)passSequenceOfSequencesOfSequences },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passRecord", 1)) {
    return false;
  }
  Record<nsString, int32_t> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, int32_t>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      int32_t& slot = entry->mValue;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecord_methodinfo = {
  { (JSJitGetterOp)passRecord },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableRecord", 1)) {
    return false;
  }
  Nullable<Record<nsString, int32_t>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.SetValue().Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, int32_t>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      int32_t& slot = entry->mValue;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot)) {
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableRecord_methodinfo = {
  { (JSJitGetterOp)passNullableRecord },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfNullableInts(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passRecordOfNullableInts");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passRecordOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passRecordOfNullableInts", 1)) {
    return false;
  }
  Record<nsString, Nullable<int32_t>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, Nullable<int32_t>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Nullable<int32_t>& slot = entry->mValue;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot.SetValue())) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfNullableInts(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfNullableInts(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfNullableInts_methodinfo = {
  { (JSJitGetterOp)passRecordOfNullableInts },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalRecordOfNullableInts(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalRecordOfNullableInts");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalRecordOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Record<nsString, Nullable<int32_t>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, Nullable<int32_t>>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        Nullable<int32_t>& slot = entry->mValue;
        if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot.SetValue())) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalRecordOfNullableInts(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalRecordOfNullableInts(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalRecordOfNullableInts_methodinfo = {
  { (JSJitGetterOp)passOptionalRecordOfNullableInts },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableRecordOfNullableInts(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableRecordOfNullableInts");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableRecordOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Nullable<Record<nsString, Nullable<int32_t>>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, Nullable<int32_t>>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        Nullable<int32_t>& slot = entry->mValue;
        if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot.SetValue())) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableRecordOfNullableInts(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableRecordOfNullableInts(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableRecordOfNullableInts_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableRecordOfNullableInts },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passCastableObjectRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passCastableObjectRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passCastableObjectRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passCastableObjectRecord", 1)) {
    return false;
  }
  Record<nsString, OwningNonNull<mozilla::dom::TestInterface>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, OwningNonNull<mozilla::dom::TestInterface>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      OwningNonNull<mozilla::dom::TestInterface>& slot = entry->mValue;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassCastableObjectRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassCastableObjectRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passCastableObjectRecord_methodinfo = {
  { (JSJitGetterOp)passCastableObjectRecord },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableCastableObjectRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableCastableObjectRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableCastableObjectRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableCastableObjectRecord", 1)) {
    return false;
  }
  Record<nsString, RefPtr<mozilla::dom::TestInterface>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, RefPtr<mozilla::dom::TestInterface>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      RefPtr<mozilla::dom::TestInterface>& slot = entry->mValue;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestInterface");
            return false;
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableCastableObjectRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableCastableObjectRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableCastableObjectRecord_methodinfo = {
  { (JSJitGetterOp)passNullableCastableObjectRecord },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passCastableObjectNullableRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passCastableObjectNullableRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passCastableObjectNullableRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passCastableObjectNullableRecord", 1)) {
    return false;
  }
  Nullable<Record<nsString, OwningNonNull<mozilla::dom::TestInterface>>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.SetValue().Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, OwningNonNull<mozilla::dom::TestInterface>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      OwningNonNull<mozilla::dom::TestInterface>& slot = entry->mValue;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassCastableObjectNullableRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassCastableObjectNullableRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passCastableObjectNullableRecord_methodinfo = {
  { (JSJitGetterOp)passCastableObjectNullableRecord },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableCastableObjectNullableRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableCastableObjectNullableRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableCastableObjectNullableRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableCastableObjectNullableRecord", 1)) {
    return false;
  }
  Nullable<Record<nsString, RefPtr<mozilla::dom::TestInterface>>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.SetValue().Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, RefPtr<mozilla::dom::TestInterface>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      RefPtr<mozilla::dom::TestInterface>& slot = entry->mValue;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestInterface");
            return false;
          }
        }
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableCastableObjectNullableRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableCastableObjectNullableRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableCastableObjectNullableRecord_methodinfo = {
  { (JSJitGetterOp)passNullableCastableObjectNullableRecord },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Record<nsString, int32_t>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, int32_t>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        int32_t& slot = entry->mValue;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot)) {
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalRecord_methodinfo = {
  { (JSJitGetterOp)passOptionalRecord },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Nullable<Record<nsString, int32_t>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, int32_t>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        int32_t& slot = entry->mValue;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot)) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableRecord_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableRecord },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableRecordWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableRecordWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableRecordWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<Record<nsString, int32_t>> arg0;
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      auto& recordEntries = arg0.SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, int32_t>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        int32_t& slot = entry->mValue;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot)) {
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0.SetNull();
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableRecordWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableRecordWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableRecordWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableRecordWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalObjectRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalObjectRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalObjectRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Record<nsString, OwningNonNull<mozilla::dom::TestInterface>>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, OwningNonNull<mozilla::dom::TestInterface>>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        OwningNonNull<mozilla::dom::TestInterface>& slot = entry->mValue;
        if (temp.isObject()) {
          static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(&temp, slot, cx);
            if (NS_FAILED(rv)) {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestInterface");
              return false;
            }
          }
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
          return false;
        }
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalObjectRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalObjectRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalObjectRecord_methodinfo = {
  { (JSJitGetterOp)passOptionalObjectRecord },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passExternalInterfaceRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passExternalInterfaceRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passExternalInterfaceRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passExternalInterfaceRecord", 1)) {
    return false;
  }
  Record<nsString, RefPtr<mozilla::dom::TestExternalInterface>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, RefPtr<mozilla::dom::TestExternalInterface>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      RefPtr<mozilla::dom::TestExternalInterface>& slot = entry->mValue;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
        RefPtr<mozilla::dom::TestExternalInterface> tempHolder;
        JS::Rooted<JSObject*> source(cx, &temp.toObject());
        if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(tempHolder)))) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestExternalInterface");
          return false;
        }
        MOZ_ASSERT(tempHolder);
        slot = tempHolder;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassExternalInterfaceRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassExternalInterfaceRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passExternalInterfaceRecord_methodinfo = {
  { (JSJitGetterOp)passExternalInterfaceRecord },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableExternalInterfaceRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableExternalInterfaceRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableExternalInterfaceRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableExternalInterfaceRecord", 1)) {
    return false;
  }
  Record<nsString, RefPtr<mozilla::dom::TestExternalInterface>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, RefPtr<mozilla::dom::TestExternalInterface>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      RefPtr<mozilla::dom::TestExternalInterface>& slot = entry->mValue;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestExternalInterface>::value, "We can only store refcounted classes.");
        RefPtr<mozilla::dom::TestExternalInterface> tempHolder;
        JS::Rooted<JSObject*> source(cx, &temp.toObject());
        if (NS_FAILED(UnwrapArg<mozilla::dom::TestExternalInterface>(cx, source, getter_AddRefs(tempHolder)))) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "TestExternalInterface");
          return false;
        }
        MOZ_ASSERT(tempHolder);
        slot = tempHolder;
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableExternalInterfaceRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableExternalInterfaceRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableExternalInterfaceRecord_methodinfo = {
  { (JSJitGetterOp)passNullableExternalInterfaceRecord },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passStringRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passStringRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passStringRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passStringRecord", 1)) {
    return false;
  }
  Record<nsString, nsString> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, nsString>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      nsString& slot = entry->mValue;
      if (!ConvertJSValueToString(cx, temp, eStringify, eStringify, slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassStringRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassStringRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passStringRecord_methodinfo = {
  { (JSJitGetterOp)passStringRecord },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passByteStringRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passByteStringRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passByteStringRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passByteStringRecord", 1)) {
    return false;
  }
  Record<nsString, nsCString> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, nsCString>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      nsCString& slot = entry->mValue;
      if (!ConvertJSValueToByteString(cx, temp, false, "value in argument 1", slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassByteStringRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassByteStringRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passByteStringRecord_methodinfo = {
  { (JSJitGetterOp)passByteStringRecord },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUTF8StringRecord(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUTF8StringRecord");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUTF8StringRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passUTF8StringRecord", 1)) {
    return false;
  }
  Record<nsString, nsCString> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, nsCString>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      nsCString& slot = entry->mValue;
      if (!ConvertJSValueToString(cx, temp, eStringify, eStringify, slot)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUTF8StringRecord(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUTF8StringRecord(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUTF8StringRecord_methodinfo = {
  { (JSJitGetterOp)passUTF8StringRecord },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfRecords(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passRecordOfRecords");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passRecordOfRecords", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passRecordOfRecords", 1)) {
    return false;
  }
  Record<nsString, Record<nsString, int32_t>> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, Record<nsString, int32_t>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Record<nsString, int32_t>& slot = entry->mValue;
      if (temp.isObject()) {
        auto& recordEntries = slot.Entries();

        JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
        JS::RootedVector<jsid> ids(cx);
        if (!js::GetPropertyKeys(cx, recordObj,
                                 JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
          return false;
        }
        if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Rooted<JS::Value> propNameValue(cx);
        JS::Rooted<JS::Value> temp(cx);
        JS::Rooted<jsid> curId(cx);
        JS::Rooted<JS::Value> idVal(cx);
        // Use a hashset to keep track of ids seen, to avoid
        // introducing nasty O(N^2) behavior scanning for them all the
        // time.  Ideally we'd use a data structure with O(1) lookup
        // _and_ ordering for the MozMap, but we don't have one lying
        // around.
        nsTHashtable<nsStringHashKey> idsSeen;
        for (size_t i = 0; i < ids.length(); ++i) {
          curId = ids[i];

          JS::Rooted<JS::PropertyDescriptor> desc(cx);
          if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                               &desc)) {
            return false;
          }

          if (!desc.object() /* == undefined in spec terms */ ||
              !desc.enumerable()) {
            continue;
          }

          idVal = js::IdToValue(curId);
          nsString propName;
          // This will just throw if idVal is a Symbol, like the spec says
          // to do.
          if (!ConvertJSValueToString(cx, idVal, "key of value in argument 1", propName)) {
            return false;
          }

          if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
            return false;
          }

          Record<nsString, int32_t>::EntryType* entry;
          if (!idsSeen.EnsureInserted(propName)) {
            // Find the existing entry.
            auto idx = recordEntries.IndexOf(propName);
            MOZ_ASSERT(idx != recordEntries.NoIndex,
                       "Why is it not found?");
            // Now blow it away to make it look like it was just added
            // to the array, because it's not obvious that it's
            // safe to write to its already-initialized mValue via our
            // normal codegen conversions.  For example, the value
            // could be a union and this would change its type, but
            // codegen assumes we won't do that.
            entry = recordEntries.ReconstructElementAt(idx);
          } else {
            // Safe to do an infallible append here, because we did a
            // SetCapacity above to the right capacity.
            entry = recordEntries.AppendElement();
          }
          entry->mKey = propName;
          int32_t& slot = entry->mValue;
          if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in value in argument 1", &slot)) {
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfRecords(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfRecords(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfRecords_methodinfo = {
  { (JSJitGetterOp)passRecordOfRecords },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveRecord(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Record<nsString, int32_t> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveRecord(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveRecord(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
  if (!returnObj) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (auto& entry : result.Entries()) {
      auto& recordValue0 = entry.mValue;
      // Control block to let us common up the JS_DefineUCProperty calls when there
      // are different ways to succeed at wrapping the value.
      do {
        tmp.setInt32(int32_t(recordValue0));
        break;
      } while (false);
      if (!JS_DefineUCProperty(cx, returnObj,
                               entry.mKey.BeginReading(),
                               entry.mKey.Length(), tmp,
                               JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnObj);
  return true;
}

static const JSJitInfo receiveRecord_methodinfo = {
  { (JSJitGetterOp)receiveRecord },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableRecord(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<Record<nsString, int32_t>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableRecord(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableRecord(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
  if (!returnObj) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (auto& entry : result.Value().Entries()) {
      auto& recordValue0 = entry.mValue;
      // Control block to let us common up the JS_DefineUCProperty calls when there
      // are different ways to succeed at wrapping the value.
      do {
        tmp.setInt32(int32_t(recordValue0));
        break;
      } while (false);
      if (!JS_DefineUCProperty(cx, returnObj,
                               entry.mKey.BeginReading(),
                               entry.mKey.Length(), tmp,
                               JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnObj);
  return true;
}

static const JSJitInfo receiveNullableRecord_methodinfo = {
  { (JSJitGetterOp)receiveNullableRecord },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveRecordOfNullableInts(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveRecordOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Record<nsString, Nullable<int32_t>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveRecordOfNullableInts(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveRecordOfNullableInts(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
  if (!returnObj) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (auto& entry : result.Entries()) {
      auto& recordValue0 = entry.mValue;
      // Control block to let us common up the JS_DefineUCProperty calls when there
      // are different ways to succeed at wrapping the value.
      do {
        if (recordValue0.IsNull()) {
          tmp.setNull();
          break;
        }
        tmp.setInt32(int32_t(recordValue0.Value()));
        break;
      } while (false);
      if (!JS_DefineUCProperty(cx, returnObj,
                               entry.mKey.BeginReading(),
                               entry.mKey.Length(), tmp,
                               JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnObj);
  return true;
}

static const JSJitInfo receiveRecordOfNullableInts_methodinfo = {
  { (JSJitGetterOp)receiveRecordOfNullableInts },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableRecordOfNullableInts(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableRecordOfNullableInts", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<Record<nsString, Nullable<int32_t>>> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableRecordOfNullableInts(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableRecordOfNullableInts(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }

  JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
  if (!returnObj) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (auto& entry : result.Value().Entries()) {
      auto& recordValue0 = entry.mValue;
      // Control block to let us common up the JS_DefineUCProperty calls when there
      // are different ways to succeed at wrapping the value.
      do {
        if (recordValue0.IsNull()) {
          tmp.setNull();
          break;
        }
        tmp.setInt32(int32_t(recordValue0.Value()));
        break;
      } while (false);
      if (!JS_DefineUCProperty(cx, returnObj,
                               entry.mKey.BeginReading(),
                               entry.mKey.Length(), tmp,
                               JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnObj);
  return true;
}

static const JSJitInfo receiveNullableRecordOfNullableInts_methodinfo = {
  { (JSJitGetterOp)receiveNullableRecordOfNullableInts },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveAnyRecord(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveAnyRecord", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Record<nsString, JS::Value> result;
  RecordRooter<nsString, JS::Value> resultRooter(cx, &result);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveAnyRecord(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveAnyRecord(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  JS::Rooted<JSObject*> returnObj(cx, JS_NewPlainObject(cx));
  if (!returnObj) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (auto& entry : result.Entries()) {
      auto& recordValue0 = entry.mValue;
      // Control block to let us common up the JS_DefineUCProperty calls when there
      // are different ways to succeed at wrapping the value.
      do {
        JS::ExposeValueToActiveJS(recordValue0);
        tmp.set(recordValue0);
        if (!MaybeWrapValue(cx, &tmp)) {
          return false;
        }
        break;
      } while (false);
      if (!JS_DefineUCProperty(cx, returnObj,
                               entry.mKey.BeginReading(),
                               entry.mKey.Length(), tmp,
                               JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnObj);
  return true;
}

static const JSJitInfo receiveAnyRecord_methodinfo = {
  { (JSJitGetterOp)receiveAnyRecord },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passArrayBuffer", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<ArrayBuffer> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBuffer");
      return false;
    }
    if (JS::IsSharedArrayBufferObject(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferMaybeShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passArrayBuffer },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableArrayBuffer", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Nullable<ArrayBuffer>> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.SetValue().Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferOrNull");
      return false;
    }
    if (JS::IsSharedArrayBufferObject(arg0.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferMaybeShared(arg0.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passNullableArrayBuffer },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<ArrayBuffer> arg0;
  Maybe<SpiderMonkeyInterfaceRooter<ArrayBuffer>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value());
    if (args[0].isObject()) {
      if (!arg0.Value().Init(&args[0].toObject())) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBuffer");
        return false;
      }
      if (JS::IsSharedArrayBufferObject(arg0.Value().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
        return false;
      }
      if (JS::IsLargeArrayBufferMaybeShared(arg0.Value().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
        return false;
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passOptionalArrayBuffer },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Nullable<ArrayBuffer>> arg0;
  Maybe<SpiderMonkeyInterfaceRooter<ArrayBuffer>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      if (!arg0.Value().SetValue().Init(&args[0].toObject())) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferOrNull");
        return false;
      }
      if (JS::IsSharedArrayBufferObject(arg0.Value().SetValue().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
        return false;
      }
      if (JS::IsLargeArrayBufferMaybeShared(arg0.Value().SetValue().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
        return false;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableArrayBuffer },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableArrayBufferWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableArrayBufferWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableArrayBufferWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedSpiderMonkeyInterface<Nullable<ArrayBuffer>> arg0(cx);
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      if (!arg0.SetValue().Init(&args[0].toObject())) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferOrNull");
        return false;
      }
      if (JS::IsSharedArrayBufferObject(arg0.SetValue().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
        return false;
      }
      if (JS::IsLargeArrayBufferMaybeShared(arg0.SetValue().Obj())) {
        cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
        return false;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0.SetNull();
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableArrayBufferWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableArrayBufferWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableArrayBufferWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableArrayBufferWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passArrayBufferView(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passArrayBufferView");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passArrayBufferView", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<ArrayBufferView> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferView");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassArrayBufferView(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassArrayBufferView(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passArrayBufferView_methodinfo = {
  { (JSJitGetterOp)passArrayBufferView },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passInt8Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passInt8Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passInt8Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passInt8Array", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Int8Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Int8Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassInt8Array(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassInt8Array(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passInt8Array_methodinfo = {
  { (JSJitGetterOp)passInt8Array },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passInt16Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passInt16Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passInt16Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passInt16Array", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Int16Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Int16Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassInt16Array(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassInt16Array(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passInt16Array_methodinfo = {
  { (JSJitGetterOp)passInt16Array },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passInt32Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passInt32Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passInt32Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passInt32Array", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Int32Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Int32Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassInt32Array(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassInt32Array(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passInt32Array_methodinfo = {
  { (JSJitGetterOp)passInt32Array },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUint8Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUint8Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUint8Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passUint8Array", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Uint8Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Uint8Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUint8Array(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUint8Array(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUint8Array_methodinfo = {
  { (JSJitGetterOp)passUint8Array },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUint16Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUint16Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUint16Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passUint16Array", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Uint16Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Uint16Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUint16Array(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUint16Array(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUint16Array_methodinfo = {
  { (JSJitGetterOp)passUint16Array },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUint32Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUint32Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUint32Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passUint32Array", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Uint32Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Uint32Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUint32Array(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUint32Array(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUint32Array_methodinfo = {
  { (JSJitGetterOp)passUint32Array },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUint8ClampedArray(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUint8ClampedArray");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUint8ClampedArray", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passUint8ClampedArray", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Uint8ClampedArray> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Uint8ClampedArray");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUint8ClampedArray(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUint8ClampedArray(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUint8ClampedArray_methodinfo = {
  { (JSJitGetterOp)passUint8ClampedArray },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passFloat32Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passFloat32Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passFloat32Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passFloat32Array", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Float32Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Float32Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassFloat32Array(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassFloat32Array(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passFloat32Array_methodinfo = {
  { (JSJitGetterOp)passFloat32Array },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passFloat64Array(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passFloat64Array");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passFloat64Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passFloat64Array", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Float64Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Float64Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassFloat64Array(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassFloat64Array(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passFloat64Array_methodinfo = {
  { (JSJitGetterOp)passFloat64Array },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfArrayBuffers(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passSequenceOfArrayBuffers");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passSequenceOfArrayBuffers", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passSequenceOfArrayBuffers", 1)) {
    return false;
  }
  binding_detail::AutoSequence<ArrayBuffer> arg0;
  SequenceRooter<ArrayBuffer> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<ArrayBuffer> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      ArrayBuffer* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      ArrayBuffer& slot = *slotPtr;
      if (temp.isObject()) {
        if (!slot.Init(&temp.toObject())) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "ArrayBuffer");
          return false;
        }
        if (JS::IsSharedArrayBufferObject(slot.Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Element of argument 1");
          return false;
        }
        if (JS::IsLargeArrayBufferMaybeShared(slot.Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Element of argument 1");
          return false;
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfArrayBuffers(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfArrayBuffers(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfArrayBuffers_methodinfo = {
  { (JSJitGetterOp)passSequenceOfArrayBuffers },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfNullableArrayBuffers(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passSequenceOfNullableArrayBuffers");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passSequenceOfNullableArrayBuffers", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passSequenceOfNullableArrayBuffers", 1)) {
    return false;
  }
  binding_detail::AutoSequence<Nullable<ArrayBuffer>> arg0;
  SequenceRooter<Nullable<ArrayBuffer>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Nullable<ArrayBuffer>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<ArrayBuffer>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<ArrayBuffer>& slot = *slotPtr;
      if (temp.isObject()) {
        if (!slot.SetValue().Init(&temp.toObject())) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Element of argument 1", "ArrayBufferOrNull");
          return false;
        }
        if (JS::IsSharedArrayBufferObject(slot.SetValue().Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Element of argument 1");
          return false;
        }
        if (JS::IsLargeArrayBufferMaybeShared(slot.SetValue().Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Element of argument 1");
          return false;
        }
      } else if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfNullableArrayBuffers(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfNullableArrayBuffers(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfNullableArrayBuffers_methodinfo = {
  { (JSJitGetterOp)passSequenceOfNullableArrayBuffers },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfArrayBuffers(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passRecordOfArrayBuffers");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passRecordOfArrayBuffers", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passRecordOfArrayBuffers", 1)) {
    return false;
  }
  Record<nsString, ArrayBuffer> arg0;
  RecordRooter<nsString, ArrayBuffer> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, ArrayBuffer>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      ArrayBuffer& slot = entry->mValue;
      if (temp.isObject()) {
        if (!slot.Init(&temp.toObject())) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "ArrayBuffer");
          return false;
        }
        if (JS::IsSharedArrayBufferObject(slot.Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Value in argument 1");
          return false;
        }
        if (JS::IsLargeArrayBufferMaybeShared(slot.Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value in argument 1");
          return false;
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfArrayBuffers(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfArrayBuffers(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfArrayBuffers_methodinfo = {
  { (JSJitGetterOp)passRecordOfArrayBuffers },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfNullableArrayBuffers(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passRecordOfNullableArrayBuffers");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passRecordOfNullableArrayBuffers", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passRecordOfNullableArrayBuffers", 1)) {
    return false;
  }
  Record<nsString, Nullable<ArrayBuffer>> arg0;
  RecordRooter<nsString, Nullable<ArrayBuffer>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, Nullable<ArrayBuffer>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Nullable<ArrayBuffer>& slot = entry->mValue;
      if (temp.isObject()) {
        if (!slot.SetValue().Init(&temp.toObject())) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value in argument 1", "ArrayBufferOrNull");
          return false;
        }
        if (JS::IsSharedArrayBufferObject(slot.SetValue().Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Value in argument 1");
          return false;
        }
        if (JS::IsLargeArrayBufferMaybeShared(slot.SetValue().Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value in argument 1");
          return false;
        }
      } else if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfNullableArrayBuffers(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfNullableArrayBuffers(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfNullableArrayBuffers_methodinfo = {
  { (JSJitGetterOp)passRecordOfNullableArrayBuffers },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicTypedArray(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passVariadicTypedArray");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passVariadicTypedArray", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  AutoSequence<Float32Array> arg0;
  SequenceRooter<Float32Array> arg0_holder(cx, &arg0);
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      Float32Array& slot = *arg0.AppendElement();
      if (args[variadicArg].isObject()) {
        if (!slot.Init(&args[variadicArg].toObject())) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Float32Array");
          return false;
        }
        if (JS::IsArrayBufferViewShared(slot.Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
          return false;
        }
        if (JS::IsLargeArrayBufferView(slot.Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
          return false;
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicTypedArray(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicTypedArray(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicTypedArray_methodinfo = {
  { (JSJitGetterOp)passVariadicTypedArray },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicNullableTypedArray(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passVariadicNullableTypedArray");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passVariadicNullableTypedArray", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  AutoSequence<Nullable<Float32Array>> arg0;
  SequenceRooter<Nullable<Float32Array>> arg0_holder(cx, &arg0);
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      Nullable<Float32Array>& slot = *arg0.AppendElement();
      if (args[variadicArg].isObject()) {
        if (!slot.SetValue().Init(&args[variadicArg].toObject())) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Float32ArrayOrNull");
          return false;
        }
        if (JS::IsArrayBufferViewShared(slot.SetValue().Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
          return false;
        }
        if (JS::IsLargeArrayBufferView(slot.SetValue().Obj())) {
          cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
          return false;
        }
      } else if (args[variadicArg].isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicNullableTypedArray(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicNullableTypedArray(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicNullableTypedArray_methodinfo = {
  { (JSJitGetterOp)passVariadicNullableTypedArray },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUint8Array(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveUint8Array", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveUint8Array(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveUint8Array(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapNonDOMObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveUint8Array_methodinfo = {
  { (JSJitGetterOp)receiveUint8Array },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_uint8ArrayAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "uint8ArrayAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetUint8ArrayAttr(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetUint8ArrayAttr(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapNonDOMObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_uint8ArrayAttr(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.uint8ArrayAttr setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "uint8ArrayAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedSpiderMonkeyInterface<Uint8Array> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "Uint8Array");
      return false;
    }
    if (JS::IsArrayBufferViewShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Value being assigned");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value being assigned");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetUint8ArrayAttr(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetUint8ArrayAttr(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo uint8ArrayAttr_getterinfo = {
  { get_uint8ArrayAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo uint8ArrayAttr_setterinfo = {
  { (JSJitGetterOp)set_uint8ArrayAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passString", 1)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassString(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassString(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passString_methodinfo = {
  { (JSJitGetterOp)passString },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableString", 1)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableString(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableString(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableString_methodinfo = {
  { (JSJitGetterOp)passNullableString },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<nsAString> arg0;
  binding_detail::FakeString<char16_t> arg0_holder;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0_holder)) {
      return false;
    }
    arg0 = &arg0_holder;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalString(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalString(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalString_methodinfo = {
  { (JSJitGetterOp)passOptionalString },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalStringWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalStringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  binding_detail::FakeString<char16_t> arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
      return false;
    }
  } else {
    arg0.AssignLiteral(u"abc");
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalStringWithDefaultValue(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalStringWithDefaultValue(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalStringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalStringWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<nsAString> arg0;
  binding_detail::FakeString<char16_t> arg0_holder;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0_holder)) {
      return false;
    }
    arg0 = &arg0_holder;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableString(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableString(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableString_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableString },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableStringWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableStringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  binding_detail::FakeString<char16_t> arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
      return false;
    }
  } else {
    arg0.SetIsVoid(true);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableStringWithDefaultValue(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableStringWithDefaultValue(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableStringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableStringWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passVariadicString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  AutoSequence<nsString> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      nsString& slot = *arg0.AppendElement();
      if (!ConvertJSValueToString(cx, args[variadicArg], eStringify, eStringify, slot)) {
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicString(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicString(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicString_methodinfo = {
  { (JSJitGetterOp)passVariadicString },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passByteString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passByteString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passByteString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passByteString", 1)) {
    return false;
  }
  nsCString arg0;
  if (!ConvertJSValueToByteString(cx, args[0], false, "argument 1", arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassByteString(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassByteString(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passByteString_methodinfo = {
  { (JSJitGetterOp)passByteString },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableByteString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableByteString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableByteString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableByteString", 1)) {
    return false;
  }
  nsCString arg0;
  if (!ConvertJSValueToByteString(cx, args[0], true, "argument 1", arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableByteString(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableByteString(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableByteString_methodinfo = {
  { (JSJitGetterOp)passNullableByteString },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalByteString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalByteString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalByteString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<nsCString> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ConvertJSValueToByteString(cx, args[0], false, "argument 1", arg0.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalByteString(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalByteString(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalByteString_methodinfo = {
  { (JSJitGetterOp)passOptionalByteString },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalByteStringWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalByteStringWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalByteStringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  nsCString arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToByteString(cx, args[0], false, "argument 1", arg0)) {
      return false;
    }
  } else {
    arg0.AssignLiteral("abc");
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalByteStringWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalByteStringWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalByteStringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalByteStringWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableByteString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableByteString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableByteString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<nsCString> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ConvertJSValueToByteString(cx, args[0], true, "argument 1", arg0.Value())) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableByteString(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableByteString(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableByteString_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableByteString },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableByteStringWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableByteStringWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableByteStringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  nsCString arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToByteString(cx, args[0], true, "argument 1", arg0)) {
      return false;
    }
  } else {
    arg0.SetIsVoid(true);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableByteStringWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableByteStringWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableByteStringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableByteStringWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicByteString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passVariadicByteString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passVariadicByteString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  AutoSequence<nsCString> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      nsCString& slot = *arg0.AppendElement();
      if (!ConvertJSValueToByteString(cx, args[variadicArg], false, "argument 1", slot)) {
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicByteString(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicByteString(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicByteString_methodinfo = {
  { (JSJitGetterOp)passVariadicByteString },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionByteString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionByteString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionByteString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passUnionByteString", 1)) {
    return false;
  }
  ByteStringOrLong arg0;
  ByteStringOrLongArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    do {
      if (args[0].isNumber()) {
        done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
        break;
      }
      done = (failed = !arg0_holder.TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
      break;
    } while (false);
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionByteString(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionByteString(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionByteString_methodinfo = {
  { (JSJitGetterOp)passUnionByteString },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnionByteString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalUnionByteString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalUnionByteString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<ByteStringOrLong> arg0;
  Maybe<ByteStringOrLongArgument> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(arg0.Value());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnionByteString(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnionByteString(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnionByteString_methodinfo = {
  { (JSJitGetterOp)passOptionalUnionByteString },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnionByteStringWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalUnionByteStringWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalUnionByteStringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  ByteStringOrLong arg0;
  ByteStringOrLongArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral("abc");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnionByteStringWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnionByteStringWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnionByteStringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalUnionByteStringWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUTF8String(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUTF8String", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passUTF8String", 1)) {
    return false;
  }
  binding_detail::FakeString<char> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUTF8String(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUTF8String(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUTF8String_methodinfo = {
  { (JSJitGetterOp)passUTF8String },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUTF8String(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUTF8String", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableUTF8String", 1)) {
    return false;
  }
  binding_detail::FakeString<char> arg0;
  if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUTF8String(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUTF8String(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUTF8String_methodinfo = {
  { (JSJitGetterOp)passNullableUTF8String },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUTF8String(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalUTF8String", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<nsACString> arg0;
  binding_detail::FakeString<char> arg0_holder;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0_holder)) {
      return false;
    }
    arg0 = &arg0_holder;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUTF8String(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUTF8String(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUTF8String_methodinfo = {
  { (JSJitGetterOp)passOptionalUTF8String },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUTF8StringWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalUTF8StringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  binding_detail::FakeString<char> arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
      return false;
    }
  } else {
    arg0.AssignLiteral("abc");
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUTF8StringWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUTF8StringWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUTF8StringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalUTF8StringWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableUTF8String(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableUTF8String", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<nsACString> arg0;
  binding_detail::FakeString<char> arg0_holder;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0_holder)) {
      return false;
    }
    arg0 = &arg0_holder;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableUTF8String(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableUTF8String(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableUTF8String_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableUTF8String },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableUTF8StringWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableUTF8StringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  binding_detail::FakeString<char> arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
      return false;
    }
  } else {
    arg0.SetIsVoid(true);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableUTF8StringWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableUTF8StringWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableUTF8StringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableUTF8StringWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicUTF8String(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passVariadicUTF8String", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  AutoSequence<nsCString> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      nsCString& slot = *arg0.AppendElement();
      if (!ConvertJSValueToString(cx, args[variadicArg], eStringify, eStringify, slot)) {
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicUTF8String(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicUTF8String(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicUTF8String_methodinfo = {
  { (JSJitGetterOp)passVariadicUTF8String },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionUTF8String(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionUTF8String");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionUTF8String", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passUnionUTF8String", 1)) {
    return false;
  }
  UTF8StringOrLong arg0;
  UTF8StringOrLongArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    do {
      if (args[0].isNumber()) {
        done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
        break;
      }
      done = (failed = !arg0_holder.TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
      break;
    } while (false);
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionUTF8String(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionUTF8String(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionUTF8String_methodinfo = {
  { (JSJitGetterOp)passUnionUTF8String },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnionUTF8String(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalUnionUTF8String");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalUnionUTF8String", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<UTF8StringOrLong> arg0;
  Maybe<UTF8StringOrLongArgument> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(arg0.Value());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnionUTF8String(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnionUTF8String(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnionUTF8String_methodinfo = {
  { (JSJitGetterOp)passOptionalUnionUTF8String },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnionUTF8StringWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalUnionUTF8StringWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalUnionUTF8StringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  UTF8StringOrLong arg0;
  UTF8StringOrLongArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral("abc");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnionUTF8StringWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnionUTF8StringWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnionUTF8StringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalUnionUTF8StringWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSVS(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passSVS", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passSVS", 1)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  if (!NormalizeUSVString(arg0)) {
    JS_ReportOutOfMemory(cx);
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSVS(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSVS(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSVS_methodinfo = {
  { (JSJitGetterOp)passSVS },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableSVS(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableSVS", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableSVS", 1)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
    return false;
  }
  if (!NormalizeUSVString(arg0)) {
    JS_ReportOutOfMemory(cx);
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableSVS(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableSVS(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableSVS_methodinfo = {
  { (JSJitGetterOp)passNullableSVS },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSVS(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalSVS", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<nsAString> arg0;
  binding_detail::FakeString<char16_t> arg0_holder;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0_holder)) {
      return false;
    }
    if (!NormalizeUSVString(arg0_holder)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    arg0 = &arg0_holder;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSVS(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSVS(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSVS_methodinfo = {
  { (JSJitGetterOp)passOptionalSVS },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSVSWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalSVSWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  binding_detail::FakeString<char16_t> arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
      return false;
    }
    if (!NormalizeUSVString(arg0)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
  } else {
    arg0.AssignLiteral(u"abc");
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSVSWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSVSWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSVSWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalSVSWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSVS(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableSVS", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<nsAString> arg0;
  binding_detail::FakeString<char16_t> arg0_holder;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0_holder)) {
      return false;
    }
    if (!NormalizeUSVString(arg0_holder)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    arg0 = &arg0_holder;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSVS(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSVS(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSVS_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSVS },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSVSWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableSVSWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  binding_detail::FakeString<char16_t> arg0;
  if (args.hasDefined(0)) {
    if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
      return false;
    }
    if (!NormalizeUSVString(arg0)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
  } else {
    arg0.SetIsVoid(true);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSVSWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSVSWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSVSWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSVSWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicSVS(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passVariadicSVS", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  AutoSequence<nsString> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      nsString& slot = *arg0.AppendElement();
      if (!ConvertJSValueToString(cx, args[variadicArg], eStringify, eStringify, slot)) {
        return false;
      }
      if (!NormalizeUSVString(slot)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicSVS(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicSVS(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicSVS_methodinfo = {
  { (JSJitGetterOp)passVariadicSVS },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveSVS(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveSVS", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  DOMString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveSVS(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveSVS(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveSVS_methodinfo = {
  { (JSJitGetterOp)receiveSVS },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passJSString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passJSString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passJSString", 1)) {
    return false;
  }
  JS::Rooted<JSString*> arg0(cx);
  if (!(arg0 = ConvertJSValueToJSString(cx, args[0]))) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassJSString(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassJSString(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passJSString_methodinfo = {
  { (JSJitGetterOp)passJSString },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalJSStringWithDefaultValue(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalJSStringWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JSString*> arg0(cx);
  if (args.hasDefined(0)) {
    if (!(arg0 = ConvertJSValueToJSString(cx, args[0]))) {
      return false;
    }
  } else {
    static const char data[] = { 'a', 'b', 'c', 0 };
    arg0 = JS_NewStringCopyN(cx, data, ArrayLength(data) - 1);
    if (!arg0) {
        return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalJSStringWithDefaultValue(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalJSStringWithDefaultValue(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalJSStringWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalJSStringWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveJSString(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveJSString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JSString*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveJSString(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveJSString(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setString(result);
  if (!MaybeWrapStringValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveJSString_methodinfo = {
  { (JSJitGetterOp)receiveJSString },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyJSStringAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "readonlyJSStringAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JSString*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlyJSStringAttr(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlyJSStringAttr(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setString(result);
  if (!MaybeWrapStringValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo readonlyJSStringAttr_getterinfo = {
  { get_readonlyJSStringAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_jsStringAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "jsStringAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JSString*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetJsStringAttr(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetJsStringAttr(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setString(result);
  if (!MaybeWrapStringValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_jsStringAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "jsStringAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JSString*> arg0(cx);
  if (!(arg0 = ConvertJSValueToJSString(cx, args[0]))) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetJsStringAttr(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetJsStringAttr(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo jsStringAttr_getterinfo = {
  { get_jsStringAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo jsStringAttr_setterinfo = {
  { (JSJitGetterOp)set_jsStringAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passEnum(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passEnum");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passEnum", 1)) {
    return false;
  }
  TestEnum arg0;
  {
    int index;
    if (!FindEnumStringIndex<true>(cx, args[0], TestEnumValues::strings, "TestEnum", "argument 1", &index)) {
      return false;
    }
    MOZ_ASSERT(index >= 0);
    arg0 = static_cast<TestEnum>(index);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassEnum(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassEnum(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passEnum_methodinfo = {
  { (JSJitGetterOp)passEnum },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableEnum(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableEnum");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableEnum", 1)) {
    return false;
  }
  Nullable<TestEnum> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    {
      int index;
      if (!FindEnumStringIndex<true>(cx, args[0], TestEnumValues::strings, "TestEnum", "argument 1", &index)) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      arg0.SetValue() = static_cast<TestEnum>(index);
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableEnum(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableEnum(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableEnum_methodinfo = {
  { (JSJitGetterOp)passNullableEnum },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalEnum(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalEnum");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<TestEnum> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    {
      int index;
      if (!FindEnumStringIndex<true>(cx, args[0], TestEnumValues::strings, "TestEnum", "argument 1", &index)) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      arg0.Value() = static_cast<TestEnum>(index);
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalEnum(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalEnum(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalEnum_methodinfo = {
  { (JSJitGetterOp)passOptionalEnum },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passEnumWithDefault(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passEnumWithDefault");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passEnumWithDefault", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  TestEnum arg0;
  if (args.hasDefined(0)) {
    {
      int index;
      if (!FindEnumStringIndex<true>(cx, args[0], TestEnumValues::strings, "TestEnum", "argument 1", &index)) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      arg0 = static_cast<TestEnum>(index);
    }
  } else {
    arg0 = TestEnum::A;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassEnumWithDefault(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassEnumWithDefault(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passEnumWithDefault_methodinfo = {
  { (JSJitGetterOp)passEnumWithDefault },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableEnum(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableEnum");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Nullable<TestEnum>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      {
        int index;
        if (!FindEnumStringIndex<true>(cx, args[0], TestEnumValues::strings, "TestEnum", "argument 1", &index)) {
          return false;
        }
        MOZ_ASSERT(index >= 0);
        arg0.Value().SetValue() = static_cast<TestEnum>(index);
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableEnum(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableEnum(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableEnum_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableEnum },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableEnumWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableEnumWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableEnumWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<TestEnum> arg0;
  if (args.hasDefined(0)) {
    if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      {
        int index;
        if (!FindEnumStringIndex<true>(cx, args[0], TestEnumValues::strings, "TestEnum", "argument 1", &index)) {
          return false;
        }
        MOZ_ASSERT(index >= 0);
        arg0.SetValue() = static_cast<TestEnum>(index);
      }
    }
  } else {
    arg0.SetNull();
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableEnumWithDefaultValue(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableEnumWithDefaultValue(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableEnumWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableEnumWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableEnumWithDefaultValue2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableEnumWithDefaultValue2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableEnumWithDefaultValue2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<TestEnum> arg0;
  if (args.hasDefined(0)) {
    if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      {
        int index;
        if (!FindEnumStringIndex<true>(cx, args[0], TestEnumValues::strings, "TestEnum", "argument 1", &index)) {
          return false;
        }
        MOZ_ASSERT(index >= 0);
        arg0.SetValue() = static_cast<TestEnum>(index);
      }
    }
  } else {
    arg0.SetValue() = TestEnum::A;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableEnumWithDefaultValue2(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableEnumWithDefaultValue2(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableEnumWithDefaultValue2_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableEnumWithDefaultValue2 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveEnum(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  TestEnum result(MOZ_KnownLive(self)->ReceiveEnum());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveEnum_methodinfo = {
  { (JSJitGetterOp)receiveEnum },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableEnum(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<TestEnum> result(MOZ_KnownLive(self)->ReceiveNullableEnum());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  } else {
    if (!ToJSValue(cx, result.Value(), args.rval())) {
      return false;
    }
    return true;
  }
}

static const JSJitInfo receiveNullableEnum_methodinfo = {
  { (JSJitGetterOp)receiveNullableEnum },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_enumAttribute(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "enumAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  TestEnum result(MOZ_KnownLive(self)->EnumAttribute());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_enumAttribute(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.enumAttribute setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "enumAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  TestEnum arg0;
  {
    int index;
    if (!FindEnumStringIndex<false>(cx, args[0], TestEnumValues::strings, "TestEnum", "value being assigned", &index)) {
      return false;
    }
    if (index < 0) {
      return true;
    }
    arg0 = static_cast<TestEnum>(index);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetEnumAttribute(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetEnumAttribute(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo enumAttribute_getterinfo = {
  { get_enumAttribute },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo enumAttribute_setterinfo = {
  { (JSJitGetterOp)set_enumAttribute },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyEnumAttribute(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "readonlyEnumAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  TestEnum result(MOZ_KnownLive(self)->ReadonlyEnumAttribute());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo readonlyEnumAttribute_getterinfo = {
  { get_readonlyEnumAttribute },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passCallback(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passCallback");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passCallback", 1)) {
    return false;
  }
  RootedCallback<OwningNonNull<binding_detail::FastTestCallback>> arg0(cx);
  if (args[0].isObject()) {
    if (JS::IsCallable(&args[0].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestCallback(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassCallback(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassCallback(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passCallback_methodinfo = {
  { (JSJitGetterOp)passCallback },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableCallback(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableCallback");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableCallback", 1)) {
    return false;
  }
  RootedCallback<RefPtr<binding_detail::FastTestCallback>> arg0(cx);
  if (args[0].isObject()) {
    if (JS::IsCallable(&args[0].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestCallback(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
      return false;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableCallback(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableCallback(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableCallback_methodinfo = {
  { (JSJitGetterOp)passNullableCallback },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalCallback(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalCallback");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<OwningNonNull<TestCallback>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      if (JS::IsCallable(&args[0].toObject())) {
      { // scope for tempRoot and tempGlobalRoot if needed
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
        arg0.Value() = new TestCallback(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
      }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
        return false;
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalCallback(MOZ_KnownLive(NonNullHelper(Constify(arg0)))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalCallback(MOZ_KnownLive(NonNullHelper(Constify(arg0))));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalCallback_methodinfo = {
  { (JSJitGetterOp)passOptionalCallback },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableCallback(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableCallback");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<RefPtr<TestCallback>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      if (JS::IsCallable(&args[0].toObject())) {
      { // scope for tempRoot and tempGlobalRoot if needed
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
        arg0.Value() = new TestCallback(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
      }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
        return false;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value() = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableCallback(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableCallback(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableCallback_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableCallback },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableCallbackWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableCallbackWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableCallbackWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedCallback<RefPtr<binding_detail::FastTestCallback>> arg0(cx);
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      if (JS::IsCallable(&args[0].toObject())) {
      { // scope for tempRoot and tempGlobalRoot if needed
        arg0 = new binding_detail::FastTestCallback(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
      }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
        return false;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableCallbackWithDefaultValue(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableCallbackWithDefaultValue(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableCallbackWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableCallbackWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveCallback(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RefPtr<TestCallback> result(MOZ_KnownLive(self)->ReceiveCallback());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveCallback_methodinfo = {
  { (JSJitGetterOp)receiveCallback },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableCallback(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RefPtr<TestCallback> result(MOZ_KnownLive(self)->ReceiveNullableCallback());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static const JSJitInfo receiveNullableCallback_methodinfo = {
  { (JSJitGetterOp)receiveNullableCallback },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableTreatAsNullCallback(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableTreatAsNullCallback");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableTreatAsNullCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableTreatAsNullCallback", 1)) {
    return false;
  }
  RootedCallback<RefPtr<binding_detail::FastTestTreatAsNullCallback>> arg0(cx);
  if (args[0].isObject()) {
    if (JS::IsCallable(&args[0].toObject())) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestTreatAsNullCallback(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
      return false;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableTreatAsNullCallback(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableTreatAsNullCallback(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableTreatAsNullCallback_methodinfo = {
  { (JSJitGetterOp)passNullableTreatAsNullCallback },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableTreatAsNullCallback(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableTreatAsNullCallback");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableTreatAsNullCallback", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<RefPtr<TestTreatAsNullCallback>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isObject()) {
      if (JS::IsCallable(&args[0].toObject())) {
      { // scope for tempRoot and tempGlobalRoot if needed
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        JS::Rooted<JSObject*> tempGlobalRoot(cx, JS::CurrentGlobalOrNull(cx));
        arg0.Value() = new TestTreatAsNullCallback(cx, tempRoot, tempGlobalRoot, GetIncumbentGlobal());
      }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
        return false;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value() = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableTreatAsNullCallback(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableTreatAsNullCallback(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableTreatAsNullCallback_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableTreatAsNullCallback },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableTreatAsNullCallbackWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableTreatAsNullCallbackWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableTreatAsNullCallbackWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedCallback<RefPtr<binding_detail::FastTestTreatAsNullCallback>> arg0(cx);
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      if (JS::IsCallable(&args[0].toObject())) {
      { // scope for tempRoot and tempGlobalRoot if needed
        arg0 = new binding_detail::FastTestTreatAsNullCallback(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
      }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_CALLABLE>("Argument 1");
        return false;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableTreatAsNullCallbackWithDefaultValue(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableTreatAsNullCallbackWithDefaultValue(MOZ_KnownLive(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableTreatAsNullCallbackWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableTreatAsNullCallbackWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAny(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passAny", 1)) {
    return false;
  }
  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAny(cx, arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAny(cx, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAny_methodinfo = {
  { (JSJitGetterOp)passAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicAny(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passVariadicAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  AutoSequence<JS::Value> arg0;
  SequenceRooter<JS::Value> arg0_holder(cx, &arg0);
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      JS::Value& slot = *arg0.AppendElement();
      slot = args[variadicArg];
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicAny_methodinfo = {
  { (JSJitGetterOp)passVariadicAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalAny(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JS::Value> arg0(cx);
  if (args.hasDefined(0)) {
    arg0 = args[0];
  } else {
    arg0 = JS::UndefinedValue();
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalAny(cx, arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalAny(cx, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalAny_methodinfo = {
  { (JSJitGetterOp)passOptionalAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAnyDefaultNull(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passAnyDefaultNull", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JS::Value> arg0(cx);
  if (args.hasDefined(0)) {
    arg0 = args[0];
  } else {
    arg0 = JS::NullValue();
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAnyDefaultNull(cx, arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAnyDefaultNull(cx, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAnyDefaultNull_methodinfo = {
  { (JSJitGetterOp)passAnyDefaultNull },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passSequenceOfAny", 1)) {
    return false;
  }
  binding_detail::AutoSequence<JS::Value> arg0;
  SequenceRooter<JS::Value> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<JS::Value> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Value& slot = *slotPtr;
      slot = temp;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passSequenceOfAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableSequenceOfAny", 1)) {
    return false;
  }
  Nullable<Sequence<JS::Value>> arg0;
  SequenceRooter<JS::Value> arg0_holder(cx, &arg0.SetValue());
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    Sequence<JS::Value> &arr = arg0.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Value& slot = *slotPtr;
      slot = temp;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableSequenceOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableSequenceOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passNullableSequenceOfAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Sequence<JS::Value>> arg0;
  Maybe<SequenceRooter<JS::Value>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value());
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<JS::Value> &arr = arg0.Value();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Value& slot = *slotPtr;
        slot = temp;
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSequenceOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSequenceOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalSequenceOfAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Nullable<Sequence<JS::Value>>> arg0;
  Maybe<SequenceRooter<JS::Value>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<JS::Value> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Value& slot = *slotPtr;
        slot = temp;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceOfAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalSequenceOfAnyWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalSequenceOfAnyWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalSequenceOfAnyWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<Sequence<JS::Value>> arg0;
  SequenceRooter<JS::Value> arg0_holder(cx, &arg0.SetValue());
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<JS::Value> &arr = arg0.SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        JS::Value* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Value& slot = *slotPtr;
        slot = temp;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  } else {
    arg0.SetNull();
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalSequenceOfAnyWithDefaultValue(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalSequenceOfAnyWithDefaultValue(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalSequenceOfAnyWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalSequenceOfAnyWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passSequenceOfSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passSequenceOfSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passSequenceOfSequenceOfAny", 1)) {
    return false;
  }
  binding_detail::AutoSequence<Sequence<JS::Value>> arg0;
  SequenceRooter<Sequence<JS::Value>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Sequence<JS::Value>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Sequence<JS::Value>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Sequence<JS::Value>& slot = *slotPtr;
      if (temp.isObject()) {
        JS::ForOfIterator iter1(cx);
        if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
          return false;
        }
        if (!iter1.valueIsIterable()) {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
        Sequence<JS::Value> &arr1 = slot;
        JS::Rooted<JS::Value> temp1(cx);
        while (true) {
          bool done1;
          if (!iter1.next(&temp1, &done1)) {
            return false;
          }
          if (done1) {
            break;
          }
          JS::Value* slotPtr1 = arr1.AppendElement(mozilla::fallible);
          if (!slotPtr1) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Value& slot1 = *slotPtr1;
          slot1 = temp1;
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfSequenceOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfSequenceOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passSequenceOfSequenceOfAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfNullableSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passSequenceOfNullableSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passSequenceOfNullableSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passSequenceOfNullableSequenceOfAny", 1)) {
    return false;
  }
  binding_detail::AutoSequence<Nullable<Sequence<JS::Value>>> arg0;
  SequenceRooter<Nullable<Sequence<JS::Value>>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Nullable<Sequence<JS::Value>>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<Sequence<JS::Value>>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<Sequence<JS::Value>>& slot = *slotPtr;
      if (temp.isObject()) {
        JS::ForOfIterator iter1(cx);
        if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
          return false;
        }
        if (!iter1.valueIsIterable()) {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
        Sequence<JS::Value> &arr1 = slot.SetValue();
        JS::Rooted<JS::Value> temp1(cx);
        while (true) {
          bool done1;
          if (!iter1.next(&temp1, &done1)) {
            return false;
          }
          if (done1) {
            break;
          }
          JS::Value* slotPtr1 = arr1.AppendElement(mozilla::fallible);
          if (!slotPtr1) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Value& slot1 = *slotPtr1;
          slot1 = temp1;
        }
      } else if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfNullableSequenceOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfNullableSequenceOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfNullableSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passSequenceOfNullableSequenceOfAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableSequenceOfNullableSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableSequenceOfNullableSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableSequenceOfNullableSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableSequenceOfNullableSequenceOfAny", 1)) {
    return false;
  }
  Nullable<Sequence<Nullable<Sequence<JS::Value>>>> arg0;
  SequenceRooter<Nullable<Sequence<JS::Value>>> arg0_holder(cx, &arg0.SetValue());
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    Sequence<Nullable<Sequence<JS::Value>>> &arr = arg0.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<Sequence<JS::Value>>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<Sequence<JS::Value>>& slot = *slotPtr;
      if (temp.isObject()) {
        JS::ForOfIterator iter1(cx);
        if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
          return false;
        }
        if (!iter1.valueIsIterable()) {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
        Sequence<JS::Value> &arr1 = slot.SetValue();
        JS::Rooted<JS::Value> temp1(cx);
        while (true) {
          bool done1;
          if (!iter1.next(&temp1, &done1)) {
            return false;
          }
          if (done1) {
            break;
          }
          JS::Value* slotPtr1 = arr1.AppendElement(mozilla::fallible);
          if (!slotPtr1) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Value& slot1 = *slotPtr1;
          slot1 = temp1;
        }
      } else if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableSequenceOfNullableSequenceOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableSequenceOfNullableSequenceOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableSequenceOfNullableSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passNullableSequenceOfNullableSequenceOfAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceOfNullableSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableSequenceOfNullableSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableSequenceOfNullableSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Nullable<Sequence<Nullable<Sequence<JS::Value>>>>> arg0;
  Maybe<SequenceRooter<Nullable<Sequence<JS::Value>>>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<Nullable<Sequence<JS::Value>>> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Nullable<Sequence<JS::Value>>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Nullable<Sequence<JS::Value>>& slot = *slotPtr;
        if (temp.isObject()) {
          JS::ForOfIterator iter1(cx);
          if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter1.valueIsIterable()) {
            cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
            return false;
          }
          Sequence<JS::Value> &arr1 = slot.SetValue();
          JS::Rooted<JS::Value> temp1(cx);
          while (true) {
            bool done1;
            if (!iter1.next(&temp1, &done1)) {
              return false;
            }
            if (done1) {
              break;
            }
            JS::Value* slotPtr1 = arr1.AppendElement(mozilla::fallible);
            if (!slotPtr1) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            JS::Value& slot1 = *slotPtr1;
            slot1 = temp1;
          }
        } else if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableSequenceOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableSequenceOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceOfNullableSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceOfNullableSequenceOfAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passRecordOfAny", 1)) {
    return false;
  }
  Record<nsString, JS::Value> arg0;
  RecordRooter<nsString, JS::Value> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, JS::Value>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      JS::Value& slot = entry->mValue;
      slot = temp;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passRecordOfAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableRecordOfAny", 1)) {
    return false;
  }
  Nullable<Record<nsString, JS::Value>> arg0;
  RecordRooter<nsString, JS::Value> arg0_holder(cx, &arg0.SetValue());
  if (args[0].isObject()) {
    auto& recordEntries = arg0.SetValue().Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, JS::Value>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      JS::Value& slot = entry->mValue;
      slot = temp;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableRecordOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableRecordOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passNullableRecordOfAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Record<nsString, JS::Value>> arg0;
  Maybe<RecordRooter<nsString, JS::Value>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value());
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, JS::Value>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        JS::Value& slot = entry->mValue;
        slot = temp;
      }
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalRecordOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalRecordOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalRecordOfAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Nullable<Record<nsString, JS::Value>>> arg0;
  Maybe<RecordRooter<nsString, JS::Value>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, JS::Value>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        JS::Value& slot = entry->mValue;
        slot = temp;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableRecordOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableRecordOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableRecordOfAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalRecordOfAnyWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalRecordOfAnyWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalRecordOfAnyWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<Record<nsString, JS::Value>> arg0;
  RecordRooter<nsString, JS::Value> arg0_holder(cx, &arg0.SetValue());
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      auto& recordEntries = arg0.SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, JS::Value>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        JS::Value& slot = entry->mValue;
        slot = temp;
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0.SetNull();
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalRecordOfAnyWithDefaultValue(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalRecordOfAnyWithDefaultValue(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalRecordOfAnyWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalRecordOfAnyWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passRecordOfRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passRecordOfRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passRecordOfRecordOfAny", 1)) {
    return false;
  }
  Record<nsString, Record<nsString, JS::Value>> arg0;
  RecordRooter<nsString, Record<nsString, JS::Value>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, Record<nsString, JS::Value>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Record<nsString, JS::Value>& slot = entry->mValue;
      if (temp.isObject()) {
        auto& recordEntries = slot.Entries();

        JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
        JS::RootedVector<jsid> ids(cx);
        if (!js::GetPropertyKeys(cx, recordObj,
                                 JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
          return false;
        }
        if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Rooted<JS::Value> propNameValue(cx);
        JS::Rooted<JS::Value> temp(cx);
        JS::Rooted<jsid> curId(cx);
        JS::Rooted<JS::Value> idVal(cx);
        // Use a hashset to keep track of ids seen, to avoid
        // introducing nasty O(N^2) behavior scanning for them all the
        // time.  Ideally we'd use a data structure with O(1) lookup
        // _and_ ordering for the MozMap, but we don't have one lying
        // around.
        nsTHashtable<nsStringHashKey> idsSeen;
        for (size_t i = 0; i < ids.length(); ++i) {
          curId = ids[i];

          JS::Rooted<JS::PropertyDescriptor> desc(cx);
          if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                               &desc)) {
            return false;
          }

          if (!desc.object() /* == undefined in spec terms */ ||
              !desc.enumerable()) {
            continue;
          }

          idVal = js::IdToValue(curId);
          nsString propName;
          // This will just throw if idVal is a Symbol, like the spec says
          // to do.
          if (!ConvertJSValueToString(cx, idVal, "key of value in argument 1", propName)) {
            return false;
          }

          if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
            return false;
          }

          Record<nsString, JS::Value>::EntryType* entry;
          if (!idsSeen.EnsureInserted(propName)) {
            // Find the existing entry.
            auto idx = recordEntries.IndexOf(propName);
            MOZ_ASSERT(idx != recordEntries.NoIndex,
                       "Why is it not found?");
            // Now blow it away to make it look like it was just added
            // to the array, because it's not obvious that it's
            // safe to write to its already-initialized mValue via our
            // normal codegen conversions.  For example, the value
            // could be a union and this would change its type, but
            // codegen assumes we won't do that.
            entry = recordEntries.ReconstructElementAt(idx);
          } else {
            // Safe to do an infallible append here, because we did a
            // SetCapacity above to the right capacity.
            entry = recordEntries.AppendElement();
          }
          entry->mKey = propName;
          JS::Value& slot = entry->mValue;
          slot = temp;
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfRecordOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfRecordOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passRecordOfRecordOfAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfNullableRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passRecordOfNullableRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passRecordOfNullableRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passRecordOfNullableRecordOfAny", 1)) {
    return false;
  }
  Record<nsString, Nullable<Record<nsString, JS::Value>>> arg0;
  RecordRooter<nsString, Nullable<Record<nsString, JS::Value>>> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, Nullable<Record<nsString, JS::Value>>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Nullable<Record<nsString, JS::Value>>& slot = entry->mValue;
      if (temp.isObject()) {
        auto& recordEntries = slot.SetValue().Entries();

        JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
        JS::RootedVector<jsid> ids(cx);
        if (!js::GetPropertyKeys(cx, recordObj,
                                 JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
          return false;
        }
        if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Rooted<JS::Value> propNameValue(cx);
        JS::Rooted<JS::Value> temp(cx);
        JS::Rooted<jsid> curId(cx);
        JS::Rooted<JS::Value> idVal(cx);
        // Use a hashset to keep track of ids seen, to avoid
        // introducing nasty O(N^2) behavior scanning for them all the
        // time.  Ideally we'd use a data structure with O(1) lookup
        // _and_ ordering for the MozMap, but we don't have one lying
        // around.
        nsTHashtable<nsStringHashKey> idsSeen;
        for (size_t i = 0; i < ids.length(); ++i) {
          curId = ids[i];

          JS::Rooted<JS::PropertyDescriptor> desc(cx);
          if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                               &desc)) {
            return false;
          }

          if (!desc.object() /* == undefined in spec terms */ ||
              !desc.enumerable()) {
            continue;
          }

          idVal = js::IdToValue(curId);
          nsString propName;
          // This will just throw if idVal is a Symbol, like the spec says
          // to do.
          if (!ConvertJSValueToString(cx, idVal, "key of value in argument 1", propName)) {
            return false;
          }

          if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
            return false;
          }

          Record<nsString, JS::Value>::EntryType* entry;
          if (!idsSeen.EnsureInserted(propName)) {
            // Find the existing entry.
            auto idx = recordEntries.IndexOf(propName);
            MOZ_ASSERT(idx != recordEntries.NoIndex,
                       "Why is it not found?");
            // Now blow it away to make it look like it was just added
            // to the array, because it's not obvious that it's
            // safe to write to its already-initialized mValue via our
            // normal codegen conversions.  For example, the value
            // could be a union and this would change its type, but
            // codegen assumes we won't do that.
            entry = recordEntries.ReconstructElementAt(idx);
          } else {
            // Safe to do an infallible append here, because we did a
            // SetCapacity above to the right capacity.
            entry = recordEntries.AppendElement();
          }
          entry->mKey = propName;
          JS::Value& slot = entry->mValue;
          slot = temp;
        }
      } else if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfNullableRecordOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfNullableRecordOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfNullableRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passRecordOfNullableRecordOfAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableRecordOfNullableRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableRecordOfNullableRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableRecordOfNullableRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableRecordOfNullableRecordOfAny", 1)) {
    return false;
  }
  Nullable<Record<nsString, Nullable<Record<nsString, JS::Value>>>> arg0;
  RecordRooter<nsString, Nullable<Record<nsString, JS::Value>>> arg0_holder(cx, &arg0.SetValue());
  if (args[0].isObject()) {
    auto& recordEntries = arg0.SetValue().Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, Nullable<Record<nsString, JS::Value>>>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      Nullable<Record<nsString, JS::Value>>& slot = entry->mValue;
      if (temp.isObject()) {
        auto& recordEntries = slot.SetValue().Entries();

        JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
        JS::RootedVector<jsid> ids(cx);
        if (!js::GetPropertyKeys(cx, recordObj,
                                 JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
          return false;
        }
        if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        JS::Rooted<JS::Value> propNameValue(cx);
        JS::Rooted<JS::Value> temp(cx);
        JS::Rooted<jsid> curId(cx);
        JS::Rooted<JS::Value> idVal(cx);
        // Use a hashset to keep track of ids seen, to avoid
        // introducing nasty O(N^2) behavior scanning for them all the
        // time.  Ideally we'd use a data structure with O(1) lookup
        // _and_ ordering for the MozMap, but we don't have one lying
        // around.
        nsTHashtable<nsStringHashKey> idsSeen;
        for (size_t i = 0; i < ids.length(); ++i) {
          curId = ids[i];

          JS::Rooted<JS::PropertyDescriptor> desc(cx);
          if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                               &desc)) {
            return false;
          }

          if (!desc.object() /* == undefined in spec terms */ ||
              !desc.enumerable()) {
            continue;
          }

          idVal = js::IdToValue(curId);
          nsString propName;
          // This will just throw if idVal is a Symbol, like the spec says
          // to do.
          if (!ConvertJSValueToString(cx, idVal, "key of value in argument 1", propName)) {
            return false;
          }

          if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
            return false;
          }

          Record<nsString, JS::Value>::EntryType* entry;
          if (!idsSeen.EnsureInserted(propName)) {
            // Find the existing entry.
            auto idx = recordEntries.IndexOf(propName);
            MOZ_ASSERT(idx != recordEntries.NoIndex,
                       "Why is it not found?");
            // Now blow it away to make it look like it was just added
            // to the array, because it's not obvious that it's
            // safe to write to its already-initialized mValue via our
            // normal codegen conversions.  For example, the value
            // could be a union and this would change its type, but
            // codegen assumes we won't do that.
            entry = recordEntries.ReconstructElementAt(idx);
          } else {
            // Safe to do an infallible append here, because we did a
            // SetCapacity above to the right capacity.
            entry = recordEntries.AppendElement();
          }
          entry->mKey = propName;
          JS::Value& slot = entry->mValue;
          slot = temp;
        }
      } else if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableRecordOfNullableRecordOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableRecordOfNullableRecordOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableRecordOfNullableRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passNullableRecordOfNullableRecordOfAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableRecordOfNullableRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableRecordOfNullableRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableRecordOfNullableRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Nullable<Record<nsString, Nullable<Record<nsString, JS::Value>>>>> arg0;
  Maybe<RecordRooter<nsString, Nullable<Record<nsString, JS::Value>>>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, Nullable<Record<nsString, JS::Value>>>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        Nullable<Record<nsString, JS::Value>>& slot = entry->mValue;
        if (temp.isObject()) {
          auto& recordEntries = slot.SetValue().Entries();

          JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
          JS::RootedVector<jsid> ids(cx);
          if (!js::GetPropertyKeys(cx, recordObj,
                                   JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
            return false;
          }
          if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Rooted<JS::Value> propNameValue(cx);
          JS::Rooted<JS::Value> temp(cx);
          JS::Rooted<jsid> curId(cx);
          JS::Rooted<JS::Value> idVal(cx);
          // Use a hashset to keep track of ids seen, to avoid
          // introducing nasty O(N^2) behavior scanning for them all the
          // time.  Ideally we'd use a data structure with O(1) lookup
          // _and_ ordering for the MozMap, but we don't have one lying
          // around.
          nsTHashtable<nsStringHashKey> idsSeen;
          for (size_t i = 0; i < ids.length(); ++i) {
            curId = ids[i];

            JS::Rooted<JS::PropertyDescriptor> desc(cx);
            if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                                 &desc)) {
              return false;
            }

            if (!desc.object() /* == undefined in spec terms */ ||
                !desc.enumerable()) {
              continue;
            }

            idVal = js::IdToValue(curId);
            nsString propName;
            // This will just throw if idVal is a Symbol, like the spec says
            // to do.
            if (!ConvertJSValueToString(cx, idVal, "key of value in argument 1", propName)) {
              return false;
            }

            if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
              return false;
            }

            Record<nsString, JS::Value>::EntryType* entry;
            if (!idsSeen.EnsureInserted(propName)) {
              // Find the existing entry.
              auto idx = recordEntries.IndexOf(propName);
              MOZ_ASSERT(idx != recordEntries.NoIndex,
                         "Why is it not found?");
              // Now blow it away to make it look like it was just added
              // to the array, because it's not obvious that it's
              // safe to write to its already-initialized mValue via our
              // normal codegen conversions.  For example, the value
              // could be a union and this would change its type, but
              // codegen assumes we won't do that.
              entry = recordEntries.ReconstructElementAt(idx);
            } else {
              // Safe to do an infallible append here, because we did a
              // SetCapacity above to the right capacity.
              entry = recordEntries.AppendElement();
            }
            entry->mKey = propName;
            JS::Value& slot = entry->mValue;
            slot = temp;
          }
        } else if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableRecordOfNullableRecordOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableRecordOfNullableRecordOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableRecordOfNullableRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableRecordOfNullableRecordOfAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableRecordOfNullableSequenceOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableRecordOfNullableSequenceOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableRecordOfNullableSequenceOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Nullable<Record<nsString, Nullable<Sequence<JS::Value>>>>> arg0;
  Maybe<RecordRooter<nsString, Nullable<Sequence<JS::Value>>>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      auto& recordEntries = arg0.Value().SetValue().Entries();

      JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
      JS::RootedVector<jsid> ids(cx);
      if (!js::GetPropertyKeys(cx, recordObj,
                               JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
        return false;
      }
      if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JS::Rooted<JS::Value> propNameValue(cx);
      JS::Rooted<JS::Value> temp(cx);
      JS::Rooted<jsid> curId(cx);
      JS::Rooted<JS::Value> idVal(cx);
      // Use a hashset to keep track of ids seen, to avoid
      // introducing nasty O(N^2) behavior scanning for them all the
      // time.  Ideally we'd use a data structure with O(1) lookup
      // _and_ ordering for the MozMap, but we don't have one lying
      // around.
      nsTHashtable<nsStringHashKey> idsSeen;
      for (size_t i = 0; i < ids.length(); ++i) {
        curId = ids[i];

        JS::Rooted<JS::PropertyDescriptor> desc(cx);
        if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                             &desc)) {
          return false;
        }

        if (!desc.object() /* == undefined in spec terms */ ||
            !desc.enumerable()) {
          continue;
        }

        idVal = js::IdToValue(curId);
        nsString propName;
        // This will just throw if idVal is a Symbol, like the spec says
        // to do.
        if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
          return false;
        }

        if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
          return false;
        }

        Record<nsString, Nullable<Sequence<JS::Value>>>::EntryType* entry;
        if (!idsSeen.EnsureInserted(propName)) {
          // Find the existing entry.
          auto idx = recordEntries.IndexOf(propName);
          MOZ_ASSERT(idx != recordEntries.NoIndex,
                     "Why is it not found?");
          // Now blow it away to make it look like it was just added
          // to the array, because it's not obvious that it's
          // safe to write to its already-initialized mValue via our
          // normal codegen conversions.  For example, the value
          // could be a union and this would change its type, but
          // codegen assumes we won't do that.
          entry = recordEntries.ReconstructElementAt(idx);
        } else {
          // Safe to do an infallible append here, because we did a
          // SetCapacity above to the right capacity.
          entry = recordEntries.AppendElement();
        }
        entry->mKey = propName;
        Nullable<Sequence<JS::Value>>& slot = entry->mValue;
        if (temp.isObject()) {
          JS::ForOfIterator iter1(cx);
          if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter1.valueIsIterable()) {
            cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Value in argument 1");
            return false;
          }
          Sequence<JS::Value> &arr1 = slot.SetValue();
          JS::Rooted<JS::Value> temp1(cx);
          while (true) {
            bool done1;
            if (!iter1.next(&temp1, &done1)) {
              return false;
            }
            if (done1) {
              break;
            }
            JS::Value* slotPtr1 = arr1.AppendElement(mozilla::fallible);
            if (!slotPtr1) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            JS::Value& slot1 = *slotPtr1;
            slot1 = temp1;
          }
        } else if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Value in argument 1");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableRecordOfNullableSequenceOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableRecordOfNullableSequenceOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableRecordOfNullableSequenceOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableRecordOfNullableSequenceOfAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceOfNullableRecordOfAny(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableSequenceOfNullableRecordOfAny");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableSequenceOfNullableRecordOfAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Nullable<Sequence<Nullable<Record<nsString, JS::Value>>>>> arg0;
  Maybe<SequenceRooter<Nullable<Record<nsString, JS::Value>>>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<Nullable<Record<nsString, JS::Value>>> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Nullable<Record<nsString, JS::Value>>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Nullable<Record<nsString, JS::Value>>& slot = *slotPtr;
        if (temp.isObject()) {
          auto& recordEntries = slot.SetValue().Entries();

          JS::Rooted<JSObject*> recordObj(cx, &temp.toObject());
          JS::RootedVector<jsid> ids(cx);
          if (!js::GetPropertyKeys(cx, recordObj,
                                   JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
            return false;
          }
          if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Rooted<JS::Value> propNameValue(cx);
          JS::Rooted<JS::Value> temp(cx);
          JS::Rooted<jsid> curId(cx);
          JS::Rooted<JS::Value> idVal(cx);
          // Use a hashset to keep track of ids seen, to avoid
          // introducing nasty O(N^2) behavior scanning for them all the
          // time.  Ideally we'd use a data structure with O(1) lookup
          // _and_ ordering for the MozMap, but we don't have one lying
          // around.
          nsTHashtable<nsStringHashKey> idsSeen;
          for (size_t i = 0; i < ids.length(); ++i) {
            curId = ids[i];

            JS::Rooted<JS::PropertyDescriptor> desc(cx);
            if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                                 &desc)) {
              return false;
            }

            if (!desc.object() /* == undefined in spec terms */ ||
                !desc.enumerable()) {
              continue;
            }

            idVal = js::IdToValue(curId);
            nsString propName;
            // This will just throw if idVal is a Symbol, like the spec says
            // to do.
            if (!ConvertJSValueToString(cx, idVal, "key of element of argument 1", propName)) {
              return false;
            }

            if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
              return false;
            }

            Record<nsString, JS::Value>::EntryType* entry;
            if (!idsSeen.EnsureInserted(propName)) {
              // Find the existing entry.
              auto idx = recordEntries.IndexOf(propName);
              MOZ_ASSERT(idx != recordEntries.NoIndex,
                         "Why is it not found?");
              // Now blow it away to make it look like it was just added
              // to the array, because it's not obvious that it's
              // safe to write to its already-initialized mValue via our
              // normal codegen conversions.  For example, the value
              // could be a union and this would change its type, but
              // codegen assumes we won't do that.
              entry = recordEntries.ReconstructElementAt(idx);
            } else {
              // Safe to do an infallible append here, because we did a
              // SetCapacity above to the right capacity.
              entry = recordEntries.AppendElement();
            }
            entry->mKey = propName;
            JS::Value& slot = entry->mValue;
            slot = temp;
          }
        } else if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableRecordOfAny(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableRecordOfAny(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceOfNullableRecordOfAny_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceOfNullableRecordOfAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveAny(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveAny", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JS::Value> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveAny(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveAny(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveAny_methodinfo = {
  { (JSJitGetterOp)receiveAny },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passObject", 1)) {
    return false;
  }
  JS::Rooted<JSObject*> arg0(cx);
  if (args[0].isObject()) {
    arg0 = &args[0].toObject();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassObject(cx, arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassObject(cx, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passObject_methodinfo = {
  { (JSJitGetterOp)passObject },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passVariadicObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passVariadicObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  AutoSequence<JSObject*> arg0;
  SequenceRooter<JSObject*> arg0_holder(cx, &arg0);
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      JSObject*& slot = *arg0.AppendElement(nullptr);
      if (args[variadicArg].isObject()) {
        slot = &args[variadicArg].toObject();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicObject_methodinfo = {
  { (JSJitGetterOp)passVariadicObject },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableObject", 1)) {
    return false;
  }
  JS::Rooted<JSObject*> arg0(cx);
  if (args[0].isObject()) {
    arg0 = &args[0].toObject();
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableObject(cx, arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableObject(cx, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableObject_methodinfo = {
  { (JSJitGetterOp)passNullableObject },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicNullableObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passVariadicNullableObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passVariadicNullableObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  AutoSequence<JSObject*> arg0;
  SequenceRooter<JSObject*> arg0_holder(cx, &arg0);
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      JSObject*& slot = *arg0.AppendElement(nullptr);
      if (args[variadicArg].isObject()) {
        slot = &args[variadicArg].toObject();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicNullableObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicNullableObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicNullableObject_methodinfo = {
  { (JSJitGetterOp)passVariadicNullableObject },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<JS::Handle<JSObject*>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct(cx);
    if (args[0].isObject()) {
      arg0.Value() = &args[0].toObject();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalObject_methodinfo = {
  { (JSJitGetterOp)passOptionalObject },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<JS::Handle<JSObject*>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct(cx);
    if (args[0].isObject()) {
      arg0.Value() = &args[0].toObject();
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value() = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableObject_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableObject },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableObjectWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableObjectWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableObjectWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JSObject*> arg0(cx);
  if (args.hasDefined(0)) {
    if (args[0].isObject()) {
      arg0 = &args[0].toObject();
    } else if (args[0].isNullOrUndefined()) {
      arg0 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
      return false;
    }
  } else {
    arg0 = nullptr;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableObjectWithDefaultValue(cx, arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableObjectWithDefaultValue(cx, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableObjectWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableObjectWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passSequenceOfObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passSequenceOfObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passSequenceOfObject", 1)) {
    return false;
  }
  binding_detail::AutoSequence<JSObject*> arg0;
  SequenceRooter<JSObject*> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<JSObject*> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      JSObject** slotPtr = arr.AppendElement(nullptr, mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JSObject*& slot = *slotPtr;
      if (temp.isObject()) {
        slot = &temp.toObject();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfObject_methodinfo = {
  { (JSJitGetterOp)passSequenceOfObject },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfNullableObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passSequenceOfNullableObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passSequenceOfNullableObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passSequenceOfNullableObject", 1)) {
    return false;
  }
  binding_detail::AutoSequence<JSObject*> arg0;
  SequenceRooter<JSObject*> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<JSObject*> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      JSObject** slotPtr = arr.AppendElement(nullptr, mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JSObject*& slot = *slotPtr;
      if (temp.isObject()) {
        slot = &temp.toObject();
      } else if (temp.isNullOrUndefined()) {
        slot = nullptr;
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfNullableObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfNullableObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfNullableObject_methodinfo = {
  { (JSJitGetterOp)passSequenceOfNullableObject },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableSequenceOfObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableSequenceOfObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableSequenceOfObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableSequenceOfObject", 1)) {
    return false;
  }
  Nullable<Sequence<JSObject*>> arg0;
  SequenceRooter<JSObject*> arg0_holder(cx, &arg0.SetValue());
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    Sequence<JSObject*> &arr = arg0.SetValue();
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      JSObject** slotPtr = arr.AppendElement(nullptr, mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      JSObject*& slot = *slotPtr;
      if (temp.isObject()) {
        slot = &temp.toObject();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of argument 1");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableSequenceOfObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableSequenceOfObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableSequenceOfObject_methodinfo = {
  { (JSJitGetterOp)passNullableSequenceOfObject },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceOfNullableSequenceOfObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableSequenceOfNullableSequenceOfObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableSequenceOfNullableSequenceOfObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Nullable<Sequence<Nullable<Sequence<JSObject*>>>>> arg0;
  Maybe<SequenceRooter<Nullable<Sequence<JSObject*>>>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<Nullable<Sequence<JSObject*>>> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Nullable<Sequence<JSObject*>>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Nullable<Sequence<JSObject*>>& slot = *slotPtr;
        if (temp.isObject()) {
          JS::ForOfIterator iter1(cx);
          if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter1.valueIsIterable()) {
            cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
            return false;
          }
          Sequence<JSObject*> &arr1 = slot.SetValue();
          JS::Rooted<JS::Value> temp1(cx);
          while (true) {
            bool done1;
            if (!iter1.next(&temp1, &done1)) {
              return false;
            }
            if (done1) {
              break;
            }
            JSObject** slotPtr1 = arr1.AppendElement(nullptr, mozilla::fallible);
            if (!slotPtr1) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            JSObject*& slot1 = *slotPtr1;
            if (temp1.isObject()) {
              slot1 = &temp1.toObject();
            } else {
              cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of element of argument 1");
              return false;
            }
          }
        } else if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableSequenceOfObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableSequenceOfObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceOfNullableSequenceOfObject_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceOfNullableSequenceOfObject },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableSequenceOfNullableSequenceOfNullableObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableSequenceOfNullableSequenceOfNullableObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableSequenceOfNullableSequenceOfNullableObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Nullable<Sequence<Nullable<Sequence<JSObject*>>>>> arg0;
  Maybe<SequenceRooter<Nullable<Sequence<JSObject*>>>> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(cx, &arg0.Value().SetValue());
    if (args[0].isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
        return false;
      }
      Sequence<Nullable<Sequence<JSObject*>>> &arr = arg0.Value().SetValue();
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        Nullable<Sequence<JSObject*>>* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        Nullable<Sequence<JSObject*>>& slot = *slotPtr;
        if (temp.isObject()) {
          JS::ForOfIterator iter1(cx);
          if (!iter1.init(temp, JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter1.valueIsIterable()) {
            cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
            return false;
          }
          Sequence<JSObject*> &arr1 = slot.SetValue();
          JS::Rooted<JS::Value> temp1(cx);
          while (true) {
            bool done1;
            if (!iter1.next(&temp1, &done1)) {
              return false;
            }
            if (done1) {
              break;
            }
            JSObject** slotPtr1 = arr1.AppendElement(nullptr, mozilla::fallible);
            if (!slotPtr1) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            JSObject*& slot1 = *slotPtr1;
            if (temp1.isObject()) {
              slot1 = &temp1.toObject();
            } else if (temp1.isNullOrUndefined()) {
              slot1 = nullptr;
            } else {
              cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Element of element of argument 1");
              return false;
            }
          }
        } else if (temp.isNullOrUndefined()) {
          slot.SetNull();
        } else {
          cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Element of argument 1");
          return false;
        }
      }
    } else if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableSequenceOfNullableObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableSequenceOfNullableSequenceOfNullableObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableSequenceOfNullableSequenceOfNullableObject_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableSequenceOfNullableSequenceOfNullableObject },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passRecordOfObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passRecordOfObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passRecordOfObject", 1)) {
    return false;
  }
  Record<nsString, JSObject*> arg0;
  RecordRooter<nsString, JSObject*> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, JSObject*>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      JSObject*& slot = entry->mValue;
      if (temp.isObject()) {
        slot = &temp.toObject();
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value in argument 1");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfObject_methodinfo = {
  { (JSJitGetterOp)passRecordOfObject },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveObject(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveObject(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveObject(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveObject_methodinfo = {
  { (JSJitGetterOp)receiveObject },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableObject(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableObject(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableObject(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
                JS::ExposeObjectToActiveJS(result);
              }
              args.rval().setObjectOrNull(result);
  if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableObject_methodinfo = {
  { (JSJitGetterOp)receiveNullableObject },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnion");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passUnion", 1)) {
    return false;
  }
  ObjectOrLong arg0;
  ObjectOrLongArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      if (!arg0_holder.SetToObject(cx, &args[0].toObject(), false)) {
        return false;
      }
      done = true;
    } else {
      do {
        done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnion(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnion(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnion_methodinfo = {
  { (JSJitGetterOp)passUnion },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithNullable(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithNullable");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithNullable", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passUnionWithNullable", 1)) {
    return false;
  }
  ObjectOrNullOrLong arg0;
  ObjectOrNullOrLongArgument arg0_holder(arg0);
  if (args[0].isNullOrUndefined()) {
    arg0_holder.SetNull();
  } else {
    {
      bool done = false, failed = false, tryNext;
      if (args[0].isObject()) {
        if (!arg0_holder.SetToObject(cx, &args[0].toObject(), false)) {
          return false;
        }
        done = true;
      } else {
        do {
          done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithNullable(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithNullable(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithNullable_methodinfo = {
  { (JSJitGetterOp)passUnionWithNullable },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnion");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passNullableUnion", 1)) {
    return false;
  }
  Nullable<ObjectOrLong > arg0;
  Maybe<ObjectOrLongArgument> arg0_holder;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      if (args[0].isObject()) {
        if (!arg0_holder.ref().SetToObject(cx, &args[0].toObject(), false)) {
          return false;
        }
        done = true;
      } else {
        do {
          done = (failed = !arg0_holder.ref().TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnion(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnion(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnion_methodinfo = {
  { (JSJitGetterOp)passNullableUnion },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalUnion");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<ObjectOrLong> arg0;
  Maybe<ObjectOrLongArgument> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    arg0_holder.emplace(arg0.Value());
    {
      bool done = false, failed = false, tryNext;
      if (args[0].isObject()) {
        if (!arg0_holder.ref().SetToObject(cx, &args[0].toObject(), false)) {
          return false;
        }
        done = true;
      } else {
        do {
          done = (failed = !arg0_holder.ref().TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalUnion(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalUnion(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalUnion_methodinfo = {
  { (JSJitGetterOp)passOptionalUnion },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableUnion");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<Nullable<ObjectOrLong >> arg0;
  Maybe<ObjectOrLongArgument> arg0_holder;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (args[0].isNullOrUndefined()) {
      arg0.Value().SetNull();
    } else {
      arg0_holder.emplace(arg0.Value().SetValue());
      {
        bool done = false, failed = false, tryNext;
        if (args[0].isObject()) {
          if (!arg0_holder.ref().SetToObject(cx, &args[0].toObject(), false)) {
            return false;
          }
          done = true;
        } else {
          do {
            done = (failed = !arg0_holder.ref().TrySetToLong(cx, args[0], tryNext)) || !tryNext;
            break;
          } while (false);
        }
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableUnion(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableUnion(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableUnion_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableUnion },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalNullableUnionWithDefaultValue(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOptionalNullableUnionWithDefaultValue");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalNullableUnionWithDefaultValue", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<ObjectOrLong > arg0;
  Maybe<ObjectOrLongArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      if (args[0].isObject()) {
        if (!arg0_holder.ref().SetToObject(cx, &args[0].toObject(), false)) {
          return false;
        }
        done = true;
      } else {
        do {
          done = (failed = !arg0_holder.ref().TrySetToLong(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalNullableUnionWithDefaultValue(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalNullableUnionWithDefaultValue(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalNullableUnionWithDefaultValue_methodinfo = {
  { (JSJitGetterOp)passOptionalNullableUnionWithDefaultValue },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passUnionWithArrayBuffer", 1)) {
    return false;
  }
  ArrayBufferOrLong arg0;
  ArrayBufferOrLongArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      done = (failed = !arg0_holder.TrySetToArrayBuffer(cx, args[0], tryNext, false)) || !tryNext;

    }
    if (!done) {
      do {
        done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "ArrayBuffer");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passUnionWithArrayBuffer },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithString(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithString");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithString", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passUnionWithString", 1)) {
    return false;
  }
  StringOrObject arg0;
  StringOrObjectArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      if (!arg0_holder.SetToObject(cx, &args[0].toObject(), false)) {
        return false;
      }
      done = true;
    } else {
      do {
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithString(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithString(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithString_methodinfo = {
  { (JSJitGetterOp)passUnionWithString },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithEnum(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithEnum");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithEnum", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passUnionWithEnum", 1)) {
    return false;
  }
  SupportedTypeOrObject arg0;
  SupportedTypeOrObjectArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      if (!arg0_holder.SetToObject(cx, &args[0].toObject(), false)) {
        return false;
      }
      done = true;
    } else {
      do {
        done = (failed = !arg0_holder.TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithEnum(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithEnum(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithEnum_methodinfo = {
  { (JSJitGetterOp)passUnionWithEnum },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithObject(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithObject");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithObject", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passUnionWithObject", 1)) {
    return false;
  }
  ObjectOrLong arg0;
  ObjectOrLongArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      if (!arg0_holder.SetToObject(cx, &args[0].toObject(), false)) {
        return false;
      }
      done = true;
    } else {
      do {
        done = (failed = !arg0_holder.TrySetToLong(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "object");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithObject(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithObject(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithObject_methodinfo = {
  { (JSJitGetterOp)passUnionWithObject },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue1(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue1");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue1", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  DoubleOrString arg0;
  DoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral(u"");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue1(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue1(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue1_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue1 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  DoubleOrString arg0;
  DoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.0;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue2(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue2(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue2_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue2 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue3(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue3");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  DoubleOrString arg0;
  DoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.5;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue3(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue3(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue3_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue3 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue4(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue4");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue4", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  FloatOrString arg0;
  FloatOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral(u"");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue4(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue4(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue4_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue4 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue5(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue5");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue5", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  FloatOrString arg0;
  FloatOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsFloat() = 1.0F;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue5(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue5(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue5_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue5 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue6(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue6");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue6", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  FloatOrString arg0;
  FloatOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsFloat() = 1.5F;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue6(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue6(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue6_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue6 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue7(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue7");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue7", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  UnrestrictedDoubleOrString arg0;
  UnrestrictedDoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral(u"");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue7(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue7(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue7_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue7 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue8(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue8");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue8", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  UnrestrictedDoubleOrString arg0;
  UnrestrictedDoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsUnrestrictedDouble() = 1.0;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue8(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue8(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue8_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue8 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue9(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue9");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue9", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  UnrestrictedDoubleOrString arg0;
  UnrestrictedDoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsUnrestrictedDouble() = 1.5;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue9(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue9(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue9_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue9 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue10(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue10");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue10", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  UnrestrictedDoubleOrString arg0;
  UnrestrictedDoubleOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsUnrestrictedDouble() = mozilla::PositiveInfinity<double>();
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue10(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue10(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue10_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue10 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue11(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue11");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue11", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  UnrestrictedFloatOrString arg0;
  UnrestrictedFloatOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral(u"");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue11(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue11(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue11_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue11 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue12(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue12");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue12", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  UnrestrictedFloatOrString arg0;
  UnrestrictedFloatOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsUnrestrictedFloat() = 1.0F;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue12(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue12(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue12_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue12 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue13(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue13");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue13", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  UnrestrictedFloatOrString arg0;
  UnrestrictedFloatOrStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsUnrestrictedFloat() = mozilla::PositiveInfinity<float>();
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToUnrestrictedFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue13(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue13(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue13_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue13 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue14(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue14");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue14", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  DoubleOrByteString arg0;
  DoubleOrByteStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral("");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue14(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue14(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue14_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue14 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue15(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue15");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue15", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  DoubleOrByteString arg0;
  DoubleOrByteStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.0;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue15(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue15(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue15_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue15 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue16(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue16");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue16", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  DoubleOrByteString arg0;
  DoubleOrByteStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.5;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue16(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue16(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue16_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue16 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue17(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue17");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue17", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  DoubleOrSupportedType arg0;
  DoubleOrSupportedTypeArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsSupportedType() = SupportedType::Text_html;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue17(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue17(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue17_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue17 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue18(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue18");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue18", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  DoubleOrSupportedType arg0;
  DoubleOrSupportedTypeArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.0;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue18(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue18(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue18_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue18 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue19(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue19");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue19", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  DoubleOrSupportedType arg0;
  DoubleOrSupportedTypeArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.5;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue19(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue19(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue19_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue19 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue20(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue20");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue20", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  DoubleOrUSVString arg0;
  DoubleOrUSVStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral(u"abc");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue20(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue20(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue20_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue20 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue21(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue21");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue21", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  DoubleOrUSVString arg0;
  DoubleOrUSVStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.0;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue21(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue21(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue21_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue21 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue22(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue22");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue22", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  DoubleOrUSVString arg0;
  DoubleOrUSVStringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.5;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue22(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue22(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue22_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue22 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue23(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue23");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue23", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  DoubleOrUTF8String arg0;
  DoubleOrUTF8StringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0_holder.SetStringLiteral("");
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue23(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue23(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue23_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue23 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue24(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue24");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue24", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  DoubleOrUTF8String arg0;
  DoubleOrUTF8StringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.0;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue24(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue24(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue24_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue24 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionWithDefaultValue25(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionWithDefaultValue25");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionWithDefaultValue25", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  DoubleOrUTF8String arg0;
  DoubleOrUTF8StringArgument arg0_holder(arg0);
  if (!(args.hasDefined(0))) {
    arg0.RawSetAsDouble() = 1.5;
  } else {
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionWithDefaultValue25(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionWithDefaultValue25(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionWithDefaultValue25_methodinfo = {
  { (JSJitGetterOp)passUnionWithDefaultValue25 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue1(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue1");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue1", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<DoubleOrString > arg0;
  Maybe<DoubleOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral(u"");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue1(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue1(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue1_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue1 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<DoubleOrString > arg0;
  Maybe<DoubleOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.0;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue2(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue2(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue2_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue2 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue3(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue3");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<DoubleOrString > arg0;
  Maybe<DoubleOrStringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue3(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue3(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue3_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue3 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue4(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue4");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue4", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<FloatOrString > arg0;
  Maybe<FloatOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral(u"");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToFloat(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue4(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue4(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue4_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue4 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue5(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue5");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue5", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<FloatOrString > arg0;
  Maybe<FloatOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsFloat() = 1.0F;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToFloat(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue5(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue5(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue5_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue5 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue6(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue6");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue6", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<FloatOrString > arg0;
  Maybe<FloatOrStringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue6(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue6(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue6_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue6 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue7(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue7");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue7", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<UnrestrictedDoubleOrString > arg0;
  Maybe<UnrestrictedDoubleOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral(u"");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue7(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue7(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue7_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue7 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue8(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue8");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue8", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<UnrestrictedDoubleOrString > arg0;
  Maybe<UnrestrictedDoubleOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsUnrestrictedDouble() = 1.0;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue8(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue8(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue8_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue8 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue9(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue9");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue9", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<UnrestrictedDoubleOrString > arg0;
  Maybe<UnrestrictedDoubleOrStringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToUnrestrictedDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue9(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue9(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue9_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue9 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue10(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue10");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue10", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<UnrestrictedFloatOrString > arg0;
  Maybe<UnrestrictedFloatOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral(u"");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToUnrestrictedFloat(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue10(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue10(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue10_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue10 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue11(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue11");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue11", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<UnrestrictedFloatOrString > arg0;
  Maybe<UnrestrictedFloatOrStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsUnrestrictedFloat() = 1.0F;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToUnrestrictedFloat(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue11(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue11(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue11_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue11 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue12(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue12");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue12", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<UnrestrictedFloatOrString > arg0;
  Maybe<UnrestrictedFloatOrStringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToUnrestrictedFloat(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue12(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue12(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue12_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue12 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue13(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue13");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue13", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<DoubleOrByteString > arg0;
  Maybe<DoubleOrByteStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral("");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue13(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue13(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue13_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue13 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue14(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue14");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue14", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<DoubleOrByteString > arg0;
  Maybe<DoubleOrByteStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.0;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue14(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue14(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue14_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue14 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue15(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue15");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue15", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<DoubleOrByteString > arg0;
  Maybe<DoubleOrByteStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.5;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue15(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue15(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue15_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue15 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue16(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue16");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue16", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<DoubleOrByteString > arg0;
  Maybe<DoubleOrByteStringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToByteString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue16(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue16(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue16_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue16 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue17(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue17");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue17", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<DoubleOrSupportedType > arg0;
  Maybe<DoubleOrSupportedTypeArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsSupportedType() = SupportedType::Text_html;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue17(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue17(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue17_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue17 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue18(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue18");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue18", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<DoubleOrSupportedType > arg0;
  Maybe<DoubleOrSupportedTypeArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.0;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue18(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue18(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue18_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue18 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue19(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue19");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue19", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<DoubleOrSupportedType > arg0;
  Maybe<DoubleOrSupportedTypeArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.5;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue19(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue19(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue19_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue19 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue20(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue20");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue20", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<DoubleOrSupportedType > arg0;
  Maybe<DoubleOrSupportedTypeArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToSupportedType(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue20(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue20(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue20_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue20 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue21(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue21");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue21", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<DoubleOrUSVString > arg0;
  Maybe<DoubleOrUSVStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral(u"abc");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue21(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue21(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue21_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue21 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue22(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue22");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue22", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<DoubleOrUSVString > arg0;
  Maybe<DoubleOrUSVStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.0;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue22(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue22(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue22_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue22 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue23(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue23");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue23", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<DoubleOrUSVString > arg0;
  Maybe<DoubleOrUSVStringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.5;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue23(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue23(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue23_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue23 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue24(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue24");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue24", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<DoubleOrUSVString > arg0;
  Maybe<DoubleOrUSVStringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToUSVString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue24(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue24(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue24_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue24 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue25(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue25");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue25", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<DoubleOrUTF8String > arg0;
  Maybe<DoubleOrUTF8StringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0_holder.ref().SetStringLiteral("");
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue25(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue25(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue25_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue25 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue26(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue26");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue26", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<DoubleOrUTF8String > arg0;
  Maybe<DoubleOrUTF8StringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.0;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue26(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue26(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue26_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue26 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue27(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue27");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue27", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<DoubleOrUTF8String > arg0;
  Maybe<DoubleOrUTF8StringArgument> arg0_holder;
  if ((args.hasDefined(0)) && args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    if (!(args.hasDefined(0))) {
      arg0.SetValue().RawSetAsDouble() = 1.5;
    } else {
      {
        bool done = false, failed = false, tryNext;
        do {
          if (args[0].isNumber()) {
            done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
            break;
          }
          done = (failed = !arg0_holder.ref().TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
          break;
        } while (false);
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue27(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue27(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue27_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue27 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passNullableUnionWithDefaultValue28(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passNullableUnionWithDefaultValue28");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passNullableUnionWithDefaultValue28", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<DoubleOrUTF8String > arg0;
  Maybe<DoubleOrUTF8StringArgument> arg0_holder;
  if (!(args.hasDefined(0)) || args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      do {
        if (args[0].isNumber()) {
          done = (failed = !arg0_holder.ref().TrySetToDouble(cx, args[0], tryNext)) || !tryNext;
          break;
        }
        done = (failed = !arg0_holder.ref().TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue28(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassNullableUnionWithDefaultValue28(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passNullableUnionWithDefaultValue28_methodinfo = {
  { (JSJitGetterOp)passNullableUnionWithDefaultValue28 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfUnions(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passSequenceOfUnions");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passSequenceOfUnions", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passSequenceOfUnions", 1)) {
    return false;
  }
  binding_detail::AutoSequence<OwningCanvasPatternOrCanvasGradient> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<OwningCanvasPatternOrCanvasGradient> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      OwningCanvasPatternOrCanvasGradient* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      OwningCanvasPatternOrCanvasGradient& slot = *slotPtr;
      {
        bool done = false, failed = false, tryNext;
        if (temp.isObject()) {
          done = (failed = !slot.TrySetToCanvasPattern(cx, temp, tryNext, false)) || !tryNext ||
                 (failed = !slot.TrySetToCanvasGradient(cx, temp, tryNext, false)) || !tryNext;

        }
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Element of argument 1", "CanvasPattern, CanvasGradient");
          return false;
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfUnions(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfUnions(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfUnions_methodinfo = {
  { (JSJitGetterOp)passSequenceOfUnions },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfUnions2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passSequenceOfUnions2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passSequenceOfUnions2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passSequenceOfUnions2", 1)) {
    return false;
  }
  binding_detail::AutoSequence<OwningObjectOrLong> arg0;
  SequenceRooter<OwningObjectOrLong> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<OwningObjectOrLong> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      OwningObjectOrLong* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      OwningObjectOrLong& slot = *slotPtr;
      {
        bool done = false, failed = false, tryNext;
        if (temp.isObject()) {
          if (!slot.SetToObject(cx, &temp.toObject(), false)) {
            return false;
          }
          done = true;
        } else {
          do {
            done = (failed = !slot.TrySetToLong(cx, temp, tryNext)) || !tryNext;
            break;
          } while (false);
        }
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Element of argument 1", "object");
          return false;
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfUnions2(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfUnions2(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfUnions2_methodinfo = {
  { (JSJitGetterOp)passSequenceOfUnions2 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passVariadicUnion");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passVariadicUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  AutoSequence<OwningCanvasPatternOrCanvasGradient> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      OwningCanvasPatternOrCanvasGradient& slot = *arg0.AppendElement();
      {
        bool done = false, failed = false, tryNext;
        if (args[variadicArg].isObject()) {
          done = (failed = !slot.TrySetToCanvasPattern(cx, args[variadicArg], tryNext, false)) || !tryNext ||
                 (failed = !slot.TrySetToCanvasGradient(cx, args[variadicArg], tryNext, false)) || !tryNext;

        }
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "CanvasPattern, CanvasGradient");
          return false;
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicUnion(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicUnion(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicUnion_methodinfo = {
  { (JSJitGetterOp)passVariadicUnion },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfNullableUnions(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passSequenceOfNullableUnions");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passSequenceOfNullableUnions", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passSequenceOfNullableUnions", 1)) {
    return false;
  }
  binding_detail::AutoSequence<Nullable<OwningCanvasPatternOrCanvasGradient >> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Nullable<OwningCanvasPatternOrCanvasGradient >> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Nullable<OwningCanvasPatternOrCanvasGradient >* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Nullable<OwningCanvasPatternOrCanvasGradient >& slot = *slotPtr;
      if (temp.isNullOrUndefined()) {
        slot.SetNull();
      } else {
        {
          bool done = false, failed = false, tryNext;
          if (temp.isObject()) {
            done = (failed = !slot.SetValue().TrySetToCanvasPattern(cx, temp, tryNext, false)) || !tryNext ||
                   (failed = !slot.SetValue().TrySetToCanvasGradient(cx, temp, tryNext, false)) || !tryNext;

          }
          if (failed) {
            return false;
          }
          if (!done) {
            cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Element of argument 1", "CanvasPattern, CanvasGradient");
            return false;
          }
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfNullableUnions(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfNullableUnions(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfNullableUnions_methodinfo = {
  { (JSJitGetterOp)passSequenceOfNullableUnions },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicNullableUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passVariadicNullableUnion");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passVariadicNullableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  AutoSequence<Nullable<OwningCanvasPatternOrCanvasGradient >> arg0;
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      Nullable<OwningCanvasPatternOrCanvasGradient >& slot = *arg0.AppendElement();
      if (args[variadicArg].isNullOrUndefined()) {
        slot.SetNull();
      } else {
        {
          bool done = false, failed = false, tryNext;
          if (args[variadicArg].isObject()) {
            done = (failed = !slot.SetValue().TrySetToCanvasPattern(cx, args[variadicArg], tryNext, false)) || !tryNext ||
                   (failed = !slot.SetValue().TrySetToCanvasGradient(cx, args[variadicArg], tryNext, false)) || !tryNext;

          }
          if (failed) {
            return false;
          }
          if (!done) {
            cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "CanvasPattern, CanvasGradient");
            return false;
          }
        }
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicNullableUnion(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicNullableUnion(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicNullableUnion_methodinfo = {
  { (JSJitGetterOp)passVariadicNullableUnion },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfUnions(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passRecordOfUnions");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passRecordOfUnions", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passRecordOfUnions", 1)) {
    return false;
  }
  Record<nsString, OwningCanvasPatternOrCanvasGradient> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, OwningCanvasPatternOrCanvasGradient>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      OwningCanvasPatternOrCanvasGradient& slot = entry->mValue;
      {
        bool done = false, failed = false, tryNext;
        if (temp.isObject()) {
          done = (failed = !slot.TrySetToCanvasPattern(cx, temp, tryNext, false)) || !tryNext ||
                 (failed = !slot.TrySetToCanvasGradient(cx, temp, tryNext, false)) || !tryNext;

        }
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Value in argument 1", "CanvasPattern, CanvasGradient");
          return false;
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfUnions(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfUnions(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfUnions_methodinfo = {
  { (JSJitGetterOp)passRecordOfUnions },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUnion(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  OwningCanvasPatternOrCanvasGradient result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveUnion(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveUnion(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveUnion_methodinfo = {
  { (JSJitGetterOp)receiveUnion },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUnion2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveUnion2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedUnion<OwningObjectOrLong> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveUnion2(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveUnion2(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveUnion2_methodinfo = {
  { (JSJitGetterOp)receiveUnion2 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveUnionContainingNull(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveUnionContainingNull", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  OwningCanvasPatternOrNullOrCanvasGradient result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveUnionContainingNull(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveUnionContainingNull(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveUnionContainingNull_methodinfo = {
  { (JSJitGetterOp)receiveUnionContainingNull },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableUnion(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<OwningCanvasPatternOrCanvasGradient> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableUnion(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableUnion(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  if (!result.Value().ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableUnion_methodinfo = {
  { (JSJitGetterOp)receiveNullableUnion },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableUnion2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableUnion2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  NullableRootedUnion<OwningObjectOrLong> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableUnion2(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableUnion2(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  if (!result.Value().ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableUnion2_methodinfo = {
  { (JSJitGetterOp)receiveNullableUnion2 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnion(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  OwningCanvasPatternOrCanvasGradient result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetWritableUnion(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetWritableUnion(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.writableUnion setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  CanvasPatternOrCanvasGradient arg0;
  CanvasPatternOrCanvasGradientArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      done = (failed = !arg0_holder.TrySetToCanvasPattern(cx, args[0], tryNext, false)) || !tryNext ||
             (failed = !arg0_holder.TrySetToCanvasGradient(cx, args[0], tryNext, false)) || !tryNext;

    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Value being assigned", "CanvasPattern, CanvasGradient");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnion(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnion(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnion_getterinfo = {
  { get_writableUnion },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableUnion_setterinfo = {
  { (JSJitGetterOp)set_writableUnion },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableUnionContainingNull(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableUnionContainingNull", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  OwningCanvasPatternOrNullOrCanvasGradient result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetWritableUnionContainingNull(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetWritableUnionContainingNull(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableUnionContainingNull(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.writableUnionContainingNull setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableUnionContainingNull", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  CanvasPatternOrNullOrCanvasGradient arg0;
  CanvasPatternOrNullOrCanvasGradientArgument arg0_holder(arg0);
  if (args[0].isNullOrUndefined()) {
    arg0_holder.SetNull();
  } else {
    {
      bool done = false, failed = false, tryNext;
      if (args[0].isObject()) {
        done = (failed = !arg0_holder.TrySetToCanvasPattern(cx, args[0], tryNext, false)) || !tryNext ||
               (failed = !arg0_holder.TrySetToCanvasGradient(cx, args[0], tryNext, false)) || !tryNext;

      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Value being assigned", "CanvasPattern, CanvasGradient");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableUnionContainingNull(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableUnionContainingNull(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableUnionContainingNull_getterinfo = {
  { get_writableUnionContainingNull },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableUnionContainingNull_setterinfo = {
  { (JSJitGetterOp)set_writableUnionContainingNull },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableNullableUnion(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableNullableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<OwningCanvasPatternOrCanvasGradient> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetWritableNullableUnion(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetWritableNullableUnion(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  if (!result.Value().ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableNullableUnion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.writableNullableUnion setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableNullableUnion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<CanvasPatternOrCanvasGradient > arg0;
  Maybe<CanvasPatternOrCanvasGradientArgument> arg0_holder;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    arg0_holder.emplace(arg0.SetValue());
    {
      bool done = false, failed = false, tryNext;
      if (args[0].isObject()) {
        done = (failed = !arg0_holder.ref().TrySetToCanvasPattern(cx, args[0], tryNext, false)) || !tryNext ||
               (failed = !arg0_holder.ref().TrySetToCanvasGradient(cx, args[0], tryNext, false)) || !tryNext;

      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Value being assigned", "CanvasPattern, CanvasGradient");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableNullableUnion(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableNullableUnion(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo writableNullableUnion_getterinfo = {
  { get_writableNullableUnion },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo writableNullableUnion_setterinfo = {
  { (JSJitGetterOp)set_writableNullableUnion },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passPromise(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passPromise", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passPromise", 1)) {
    return false;
  }
  OwningNonNull<Promise> arg0;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoRealm,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx);
    globalObj = JS::CurrentGlobalOrNull(cx);
    JSAutoRealm ar(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      return false;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, args[0]);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      return false;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      MOZ_ALWAYS_TRUE(promiseRv.MaybeSetPendingException(cx));
      return false;
    }
    arg0 = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassPromise(NonNullHelper(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassPromise(NonNullHelper(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passPromise_methodinfo = {
  { (JSJitGetterOp)passPromise },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOptionalPromise(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOptionalPromise", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<OwningNonNull<Promise>> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    { // Scope for our GlobalObject, FastErrorResult, JSAutoRealm,
      // etc.

      JS::Rooted<JSObject*> globalObj(cx);
      globalObj = JS::CurrentGlobalOrNull(cx);
      JSAutoRealm ar(cx, globalObj);
      GlobalObject promiseGlobal(cx, globalObj);
      if (promiseGlobal.Failed()) {
        return false;
      }

      JS::Rooted<JS::Value> valueToResolve(cx, args[0]);
      if (!JS_WrapValue(cx, &valueToResolve)) {
        return false;
      }
      binding_detail::FastErrorResult promiseRv;
      nsCOMPtr<nsIGlobalObject> global =
        do_QueryInterface(promiseGlobal.GetAsSupports());
      if (!global) {
        promiseRv.Throw(NS_ERROR_UNEXPECTED);
        MOZ_ALWAYS_TRUE(promiseRv.MaybeSetPendingException(cx));
        return false;
      }
      arg0.Value() = Promise::Resolve(global, cx, valueToResolve,
                                      promiseRv);
      if (promiseRv.MaybeSetPendingException(cx)) {
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOptionalPromise(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOptionalPromise(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOptionalPromise_methodinfo = {
  { (JSJitGetterOp)passOptionalPromise },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passPromiseSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passPromiseSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passPromiseSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passPromiseSequence", 1)) {
    return false;
  }
  binding_detail::AutoSequence<OwningNonNull<Promise>> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<OwningNonNull<Promise>> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      OwningNonNull<Promise>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      OwningNonNull<Promise>& slot = *slotPtr;
      { // Scope for our GlobalObject, FastErrorResult, JSAutoRealm,
        // etc.

        JS::Rooted<JSObject*> globalObj(cx);
        globalObj = JS::CurrentGlobalOrNull(cx);
        JSAutoRealm ar(cx, globalObj);
        GlobalObject promiseGlobal(cx, globalObj);
        if (promiseGlobal.Failed()) {
          return false;
        }

        JS::Rooted<JS::Value> valueToResolve(cx, temp);
        if (!JS_WrapValue(cx, &valueToResolve)) {
          return false;
        }
        binding_detail::FastErrorResult promiseRv;
        nsCOMPtr<nsIGlobalObject> global =
          do_QueryInterface(promiseGlobal.GetAsSupports());
        if (!global) {
          promiseRv.Throw(NS_ERROR_UNEXPECTED);
          MOZ_ALWAYS_TRUE(promiseRv.MaybeSetPendingException(cx));
          return false;
        }
        slot = Promise::Resolve(global, cx, valueToResolve,
                                        promiseRv);
        if (promiseRv.MaybeSetPendingException(cx)) {
          return false;
        }
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassPromiseSequence(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassPromiseSequence(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passPromiseSequence_methodinfo = {
  { (JSJitGetterOp)passPromiseSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receivePromise(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receivePromise", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<Promise>(MOZ_KnownLive(self)->ReceivePromise()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
receivePromise_promiseWrapper(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  bool ok = receivePromise(cx, obj, void_self, args);
  if (ok) {
    return true;
  }
  return ConvertExceptionToPromise(cx, args.rval());
}

static const JSJitInfo receivePromise_methodinfo = {
  { (JSJitGetterOp)receivePromise_promiseWrapper },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveAddrefedPromise(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveAddrefedPromise", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<Promise>(MOZ_KnownLive(self)->ReceiveAddrefedPromise()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
receiveAddrefedPromise_promiseWrapper(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  bool ok = receiveAddrefedPromise(cx, obj, void_self, args);
  if (ok) {
    return true;
  }
  return ConvertExceptionToPromise(cx, args.rval());
}

static const JSJitInfo receiveAddrefedPromise_methodinfo = {
  { (JSJitGetterOp)receiveAddrefedPromise_promiseWrapper },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
methodRenamedFrom(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.methodRenamedFrom");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "methodRenamedFrom", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->MethodRenamedTo())>, "Should be returning void here");
      MOZ_KnownLive(self)->MethodRenamedTo();
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      int8_t arg0;
      if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->MethodRenamedTo(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->MethodRenamedTo(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo methodRenamedFrom_methodinfo = {
  { (JSJitGetterOp)methodRenamedFrom },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_attributeGetterRenamedFrom(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "attributeGetterRenamedFrom", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->AttributeGetterRenamedTo());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo attributeGetterRenamedFrom_getterinfo = {
  { get_attributeGetterRenamedFrom },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_attributeRenamedFrom(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "attributeRenamedFrom", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->AttributeRenamedTo());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_attributeRenamedFrom(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "attributeRenamedFrom", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAttributeRenamedTo(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAttributeRenamedTo(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo attributeRenamedFrom_getterinfo = {
  { get_attributeRenamedFrom },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo attributeRenamedFrom_setterinfo = {
  { (JSJitGetterOp)set_attributeRenamedFrom },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passDictionary(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passDictionary");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedDictionary<binding_detail::FastDict> arg0(cx);
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictionary(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassDictionary(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passDictionary_methodinfo = {
  { (JSJitGetterOp)passDictionary },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passDictionary2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passDictionary2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passDictionary2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passDictionary2", 1)) {
    return false;
  }
  RootedDictionary<binding_detail::FastDict> arg0(cx);
  if (!arg0.Init(cx, args[0], "Argument 1", false)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictionary2(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassDictionary2(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passDictionary2_methodinfo = {
  { (JSJitGetterOp)passDictionary2 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyDictionary(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "readonlyDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 9) : (DOM_INSTANCE_RESERVED_SLOTS + 9);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectValue(cx, args.rval());
    }
  }

  RootedDictionary<Dict> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlyDictionary(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlyDictionary(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      if (!result.ToObjectInternal(cx, args.rval())) {
        return false;
      }
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectValue(cx, args.rval());
}

static const JSJitInfo readonlyDictionary_getterinfo = {
  { get_readonlyDictionary },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 9)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 9) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 9) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyNullableDictionary(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "readonlyNullableDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 10) : (DOM_INSTANCE_RESERVED_SLOTS + 10);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectOrNullValue(cx, args.rval());
    }
  }

  NullableRootedDictionary<Dict> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlyNullableDictionary(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlyNullableDictionary(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      if (result.IsNull()) {
        args.rval().setNull();
        break;
      }
      if (!result.Value().ToObjectInternal(cx, args.rval())) {
        return false;
      }
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectOrNullValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectOrNullValue(cx, args.rval());
}

static const JSJitInfo readonlyNullableDictionary_getterinfo = {
  { get_readonlyNullableDictionary },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 10)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 10) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 10) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableDictionary(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 11) : (DOM_INSTANCE_RESERVED_SLOTS + 11);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectValue(cx, args.rval());
    }
  }

  RootedDictionary<Dict> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetWritableDictionary(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetWritableDictionary(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      if (!result.ToObjectInternal(cx, args.rval())) {
        return false;
      }
      break;
    } while (false);
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectValue(cx, args.rval());
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableDictionary(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.writableDictionary setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedDictionary<binding_detail::FastDict> arg0(cx);
  if (!arg0.Init(cx, args[0], "Value being assigned", false)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableDictionary(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableDictionary(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  ClearCachedWritableDictionaryValue(self);
  return true;
}

static const JSJitInfo writableDictionary_getterinfo = {
  { get_writableDictionary },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 11)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 11) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 11) < 16, "There is no slot for us");
static const JSJitInfo writableDictionary_setterinfo = {
  { (JSJitGetterOp)set_writableDictionary },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyFrozenDictionary(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "readonlyFrozenDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 12) : (DOM_INSTANCE_RESERVED_SLOTS + 12);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectValue(cx, args.rval());
    }
  }

  RootedDictionary<Dict> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlyFrozenDictionary(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlyFrozenDictionary(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      if (!result.ToObjectInternal(cx, args.rval())) {
        return false;
      }
      break;
    } while (false);
    JS::Rooted<JSObject*> rvalObj(cx, &args.rval().toObject());
    if (!JS_FreezeObject(cx, rvalObj)) {
      return false;
    }
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectValue(cx, args.rval());
}

static const JSJitInfo readonlyFrozenDictionary_getterinfo = {
  { get_readonlyFrozenDictionary },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 12)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 12) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 12) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_readonlyFrozenNullableDictionary(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "readonlyFrozenNullableDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 13) : (DOM_INSTANCE_RESERVED_SLOTS + 13);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectOrNullValue(cx, args.rval());
    }
  }

  NullableRootedDictionary<Dict> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetReadonlyFrozenNullableDictionary(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetReadonlyFrozenNullableDictionary(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      if (result.IsNull()) {
        args.rval().setNull();
        break;
      }
      if (!result.Value().ToObjectInternal(cx, args.rval())) {
        return false;
      }
      break;
    } while (false);
    if (args.rval().isObject()) {
      JS::Rooted<JSObject*> rvalObj(cx, &args.rval().toObject());
      if (!JS_FreezeObject(cx, rvalObj)) {
        return false;
      }
    }
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectOrNullValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectOrNullValue(cx, args.rval());
}

static const JSJitInfo readonlyFrozenNullableDictionary_getterinfo = {
  { get_readonlyFrozenNullableDictionary },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 13)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 13) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 13) < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_writableFrozenDictionary(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableFrozenDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // Have to either root across the getter call or reget after.
  bool isXray;
  JS::Rooted<JSObject*> slotStorage(cx, GetCachedSlotStorageObject(cx, obj, &isXray));
  if (!slotStorage) {
    return false;
  }
  const size_t slotIndex = isXray ? (xpc::JSSLOT_EXPANDO_COUNT + 14) : (DOM_INSTANCE_RESERVED_SLOTS + 14);
  MOZ_ASSERT(JSCLASS_RESERVED_SLOTS(JS::GetClass(slotStorage)) > slotIndex);
  {
    // Scope for cachedVal
    JS::Value cachedVal = JS::GetReservedSlot(slotStorage, slotIndex);
    if (!cachedVal.isUndefined()) {
      args.rval().set(cachedVal);
      // The cached value is in the compartment of slotStorage,
      // so wrap into the caller compartment as needed.
      return MaybeWrapNonDOMObjectValue(cx, args.rval());
    }
  }

  RootedDictionary<Dict> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetWritableFrozenDictionary(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetWritableFrozenDictionary(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  {
    JS::Rooted<JSObject*> conversionScope(cx, isXray ? JS::CurrentGlobalOrNull(cx) : slotStorage);
    JSAutoRealm ar(cx, conversionScope);
    do { // block we break out of when done wrapping
      if (!result.ToObjectInternal(cx, args.rval())) {
        return false;
      }
      break;
    } while (false);
    JS::Rooted<JSObject*> rvalObj(cx, &args.rval().toObject());
    if (!JS_FreezeObject(cx, rvalObj)) {
      return false;
    }
  }
  { // And now store things in the realm of our slotStorage.
    JSAutoRealm ar(cx, slotStorage);
    // Make a copy so that we don't do unnecessary wrapping on args.rval().
    JS::Rooted<JS::Value> storedVal(cx, args.rval());
    if (!MaybeWrapNonDOMObjectValue(cx, &storedVal)) {
      return false;
    }
    JS::SetReservedSlot(slotStorage, slotIndex, storedVal);
    if (!isXray) {
      // In the Xray case we don't need to do this, because getting the
      // expando object already preserved our wrapper.
      PreserveWrapper(self);
    }
  }
  // And now make sure args.rval() is in the caller realm.
  return MaybeWrapNonDOMObjectValue(cx, args.rval());
}

MOZ_CAN_RUN_SCRIPT static bool
set_writableFrozenDictionary(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.writableFrozenDictionary setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "writableFrozenDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedDictionary<binding_detail::FastDict> arg0(cx);
  if (!arg0.Init(cx, args[0], "Value being assigned", false)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetWritableFrozenDictionary(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetWritableFrozenDictionary(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  ClearCachedWritableFrozenDictionaryValue(self);
  return true;
}

static const JSJitInfo writableFrozenDictionary_getterinfo = {
  { get_writableFrozenDictionary },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasDOMSets, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  true,  /* isMovable.  Not relevant for setters. */
  true, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  true, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  (DOM_INSTANCE_RESERVED_SLOTS + 14)   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 14) <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert((DOM_INSTANCE_RESERVED_SLOTS + 14) < 16, "There is no slot for us");
static const JSJitInfo writableFrozenDictionary_setterinfo = {
  { (JSJitGetterOp)set_writableFrozenDictionary },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveDictionary(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedDictionary<Dict> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveDictionary(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveDictionary(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToObjectInternal(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveDictionary_methodinfo = {
  { (JSJitGetterOp)receiveDictionary },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveNullableDictionary(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveNullableDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  NullableRootedDictionary<Dict> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveNullableDictionary(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveNullableDictionary(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  if (!result.Value().ToObjectInternal(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveNullableDictionary_methodinfo = {
  { (JSJitGetterOp)receiveNullableDictionary },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passOtherDictionary(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passOtherDictionary");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passOtherDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  binding_detail::FastGrandparentDict arg0;
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassOtherDictionary(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassOtherDictionary(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passOtherDictionary_methodinfo = {
  { (JSJitGetterOp)passOtherDictionary },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passSequenceOfDictionaries(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passSequenceOfDictionaries");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passSequenceOfDictionaries", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passSequenceOfDictionaries", 1)) {
    return false;
  }
  binding_detail::AutoSequence<Dict> arg0;
  SequenceRooter<Dict> arg0_holder(cx, &arg0);
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<Dict> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      Dict* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      Dict& slot = *slotPtr;
      if (!slot.Init(cx, temp, "Element of argument 1", false)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassSequenceOfDictionaries(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassSequenceOfDictionaries(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passSequenceOfDictionaries_methodinfo = {
  { (JSJitGetterOp)passSequenceOfDictionaries },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRecordOfDictionaries(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passRecordOfDictionaries");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passRecordOfDictionaries", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passRecordOfDictionaries", 1)) {
    return false;
  }
  Record<nsString, GrandparentDict> arg0;
  if (args[0].isObject()) {
    auto& recordEntries = arg0.Entries();

    JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
    JS::RootedVector<jsid> ids(cx);
    if (!js::GetPropertyKeys(cx, recordObj,
                             JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
      return false;
    }
    if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    JS::Rooted<JS::Value> propNameValue(cx);
    JS::Rooted<JS::Value> temp(cx);
    JS::Rooted<jsid> curId(cx);
    JS::Rooted<JS::Value> idVal(cx);
    // Use a hashset to keep track of ids seen, to avoid
    // introducing nasty O(N^2) behavior scanning for them all the
    // time.  Ideally we'd use a data structure with O(1) lookup
    // _and_ ordering for the MozMap, but we don't have one lying
    // around.
    nsTHashtable<nsStringHashKey> idsSeen;
    for (size_t i = 0; i < ids.length(); ++i) {
      curId = ids[i];

      JS::Rooted<JS::PropertyDescriptor> desc(cx);
      if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                           &desc)) {
        return false;
      }

      if (!desc.object() /* == undefined in spec terms */ ||
          !desc.enumerable()) {
        continue;
      }

      idVal = js::IdToValue(curId);
      nsString propName;
      // This will just throw if idVal is a Symbol, like the spec says
      // to do.
      if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
        return false;
      }

      if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
        return false;
      }

      Record<nsString, GrandparentDict>::EntryType* entry;
      if (!idsSeen.EnsureInserted(propName)) {
        // Find the existing entry.
        auto idx = recordEntries.IndexOf(propName);
        MOZ_ASSERT(idx != recordEntries.NoIndex,
                   "Why is it not found?");
        // Now blow it away to make it look like it was just added
        // to the array, because it's not obvious that it's
        // safe to write to its already-initialized mValue via our
        // normal codegen conversions.  For example, the value
        // could be a union and this would change its type, but
        // codegen assumes we won't do that.
        entry = recordEntries.ReconstructElementAt(idx);
      } else {
        // Safe to do an infallible append here, because we did a
        // SetCapacity above to the right capacity.
        entry = recordEntries.AppendElement();
      }
      entry->mKey = propName;
      GrandparentDict& slot = entry->mValue;
      if (!slot.Init(cx, temp, "Value in argument 1", false)) {
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRecordOfDictionaries(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRecordOfDictionaries(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRecordOfDictionaries_methodinfo = {
  { (JSJitGetterOp)passRecordOfDictionaries },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passDictionaryOrLong(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passDictionaryOrLong");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passDictionaryOrLong", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      RootedDictionary<binding_detail::FastDict> arg0(cx);
      if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictionaryOrLong(cx, Constify(arg0)))>, "Should be returning void here");
      MOZ_KnownLive(self)->PassDictionaryOrLong(cx, Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isNullOrUndefined()) {
        RootedDictionary<binding_detail::FastDict> arg0(cx);
        if (!arg0.Init(cx, args[0], "Argument 1", false)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictionaryOrLong(cx, Constify(arg0)))>, "Should be returning void here");
        MOZ_KnownLive(self)->PassDictionaryOrLong(cx, Constify(arg0));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isObject()) {
        do {
          RootedDictionary<binding_detail::FastDict> arg0(cx);
          if (!arg0.Init(cx, args[0], "Argument 1", false)) {
            return false;
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictionaryOrLong(cx, Constify(arg0)))>, "Should be returning void here");
          MOZ_KnownLive(self)->PassDictionaryOrLong(cx, Constify(arg0));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictionaryOrLong(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->PassDictionaryOrLong(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo passDictionaryOrLong_methodinfo = {
  { (JSJitGetterOp)passDictionaryOrLong },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passDictContainingDict(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passDictContainingDict");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passDictContainingDict", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedDictionary<binding_detail::FastDictContainingDict> arg0(cx);
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictContainingDict(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassDictContainingDict(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passDictContainingDict_methodinfo = {
  { (JSJitGetterOp)passDictContainingDict },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passDictContainingSequence(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passDictContainingSequence");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passDictContainingSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedDictionary<binding_detail::FastDictContainingSequence> arg0(cx);
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassDictContainingSequence(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassDictContainingSequence(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passDictContainingSequence_methodinfo = {
  { (JSJitGetterOp)passDictContainingSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
receiveDictContainingSequence(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "receiveDictContainingSequence", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedDictionary<DictContainingSequence> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ReceiveDictContainingSequence(cx, result))>, "Should be returning void here");
  MOZ_KnownLive(self)->ReceiveDictContainingSequence(cx, result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToObjectInternal(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo receiveDictContainingSequence_methodinfo = {
  { (JSJitGetterOp)receiveDictContainingSequence },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicDictionary(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passVariadicDictionary");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passVariadicDictionary", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  AutoSequence<Dict> arg0;
  SequenceRooter<Dict> arg0_holder(cx, &arg0);
  if (args.length() > 0) {
    if (!arg0.SetCapacity(args.length() - 0, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 0; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      Dict& slot = *arg0.AppendElement();
      if (!slot.Init(cx, args[variadicArg], "Argument 1", false)) {
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicDictionary(cx, Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicDictionary(cx, Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicDictionary_methodinfo = {
  { (JSJitGetterOp)passVariadicDictionary },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
dontEnforceRangeOrClamp(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "dontEnforceRangeOrClamp", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.dontEnforceRangeOrClamp", 1)) {
    return false;
  }
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DontEnforceRangeOrClamp(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->DontEnforceRangeOrClamp(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo dontEnforceRangeOrClamp_methodinfo = {
  { (JSJitGetterOp)dontEnforceRangeOrClamp },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
doEnforceRange(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.doEnforceRange");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "doEnforceRange", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.doEnforceRange", 1)) {
    return false;
  }
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eEnforceRange>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DoEnforceRange(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->DoEnforceRange(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo doEnforceRange_methodinfo = {
  { (JSJitGetterOp)doEnforceRange },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
doEnforceRangeNullable(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.doEnforceRangeNullable");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "doEnforceRangeNullable", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.doEnforceRangeNullable", 1)) {
    return false;
  }
  Nullable<int8_t> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<int8_t, eEnforceRange>(cx, args[0], "Argument 1", &arg0.SetValue())) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DoEnforceRangeNullable(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->DoEnforceRangeNullable(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo doEnforceRangeNullable_methodinfo = {
  { (JSJitGetterOp)doEnforceRangeNullable },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
doClamp(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "doClamp", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.doClamp", 1)) {
    return false;
  }
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eClamp>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DoClamp(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->DoClamp(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo doClamp_methodinfo = {
  { (JSJitGetterOp)doClamp },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
doClampNullable(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "doClampNullable", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.doClampNullable", 1)) {
    return false;
  }
  Nullable<int8_t> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<int8_t, eClamp>(cx, args[0], "Argument 1", &arg0.SetValue())) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DoClampNullable(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->DoClampNullable(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo doClampNullable_methodinfo = {
  { (JSJitGetterOp)doClampNullable },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_enforcedByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "enforcedByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->EnforcedByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_enforcedByte(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.enforcedByte setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "enforcedByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eEnforceRange>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetEnforcedByte(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetEnforcedByte(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo enforcedByte_getterinfo = {
  { get_enforcedByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo enforcedByte_setterinfo = {
  { (JSJitGetterOp)set_enforcedByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_enforcedByteNullable(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "enforcedByteNullable", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<int8_t> result(MOZ_KnownLive(self)->GetEnforcedByteNullable());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  args.rval().setInt32(int32_t(result.Value()));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_enforcedByteNullable(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.enforcedByteNullable setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "enforcedByteNullable", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<int8_t> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<int8_t, eEnforceRange>(cx, args[0], "Value being assigned", &arg0.SetValue())) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetEnforcedByteNullable(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetEnforcedByteNullable(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo enforcedByteNullable_getterinfo = {
  { get_enforcedByteNullable },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo enforcedByteNullable_setterinfo = {
  { (JSJitGetterOp)set_enforcedByteNullable },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_clampedByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "clampedByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->ClampedByte());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_clampedByte(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "clampedByte", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eClamp>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetClampedByte(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetClampedByte(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo clampedByte_getterinfo = {
  { get_clampedByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo clampedByte_setterinfo = {
  { (JSJitGetterOp)set_clampedByte },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_clampedByteNullable(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "clampedByteNullable", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<int8_t> result(MOZ_KnownLive(self)->GetClampedByteNullable());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  args.rval().setInt32(int32_t(result.Value()));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_clampedByteNullable(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "clampedByteNullable", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Nullable<int8_t> arg0;
  if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else if (!ValueToPrimitive<int8_t, eClamp>(cx, args[0], "Value being assigned", &arg0.SetValue())) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetClampedByteNullable(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetClampedByteNullable(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo clampedByteNullable_getterinfo = {
  { get_clampedByteNullable },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo clampedByteNullable_setterinfo = {
  { (JSJitGetterOp)set_clampedByteNullable },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
exerciseTypedefInterfaces1(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.exerciseTypedefInterfaces1");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "exerciseTypedefInterfaces1", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.exerciseTypedefInterfaces1", 1)) {
    return false;
  }
  NonNull<mozilla::dom::TestInterface> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ExerciseTypedefInterfaces1(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ExerciseTypedefInterfaces1(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo exerciseTypedefInterfaces1_methodinfo = {
  { (JSJitGetterOp)exerciseTypedefInterfaces1 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
exerciseTypedefInterfaces2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.exerciseTypedefInterfaces2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "exerciseTypedefInterfaces2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.exerciseTypedefInterfaces2", 1)) {
    return false;
  }
  mozilla::dom::TestInterface* arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
        return false;
      }
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0 = nullptr;
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->ExerciseTypedefInterfaces2(MOZ_KnownLive(Constify(arg0)))));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo exerciseTypedefInterfaces2_methodinfo = {
  { (JSJitGetterOp)exerciseTypedefInterfaces2 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
exerciseTypedefInterfaces3(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.exerciseTypedefInterfaces3");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "exerciseTypedefInterfaces3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.exerciseTypedefInterfaces3", 1)) {
    return false;
  }
  NonNull<mozilla::dom::TestInterface> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ExerciseTypedefInterfaces3(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->ExerciseTypedefInterfaces3(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo exerciseTypedefInterfaces3_methodinfo = {
  { (JSJitGetterOp)exerciseTypedefInterfaces3 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_deprecatedAttribute(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "deprecatedAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  bool result(MOZ_KnownLive(self)->DeprecatedAttribute());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_deprecatedAttribute(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "deprecatedAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetDeprecatedAttribute(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetDeprecatedAttribute(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo deprecatedAttribute_getterinfo = {
  { get_deprecatedAttribute },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo deprecatedAttribute_setterinfo = {
  { (JSJitGetterOp)set_deprecatedAttribute },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
deprecatedMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "deprecatedMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.deprecatedMethod", 1)) {
    return false;
  }
  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DeprecatedMethod(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->DeprecatedMethod(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo deprecatedMethod_methodinfo = {
  { (JSJitGetterOp)deprecatedMethod },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
deprecatedMethodWithContext(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "deprecatedMethodWithContext", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.deprecatedMethodWithContext", 1)) {
    return false;
  }
  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DeprecatedMethodWithContext(cx, arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->DeprecatedMethodWithContext(cx, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo deprecatedMethodWithContext_methodinfo = {
  { (JSJitGetterOp)deprecatedMethodWithContext },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_staticAttribute(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "staticAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  bool result(mozilla::dom::TestExampleInterface::StaticAttribute(global));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_staticAttribute(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "staticAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "staticAttribute setter", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::TestExampleInterface::SetStaticAttribute(global, arg0))>, "Should be returning void here");
  mozilla::dom::TestExampleInterface::SetStaticAttribute(global, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
staticMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "staticMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "TestExampleInterface.staticMethod", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::TestExampleInterface::StaticMethod(global, arg0))>, "Should be returning void here");
  mozilla::dom::TestExampleInterface::StaticMethod(global, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
staticMethodWithContext(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "staticMethodWithContext", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "TestExampleInterface.staticMethodWithContext", 1)) {
    return false;
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::TestExampleInterface::StaticMethodWithContext(global, arg0))>, "Should be returning void here");
  mozilla::dom::TestExampleInterface::StaticMethodWithContext(global, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
get_staticDeprecatedAttribute(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "staticDeprecatedAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  bool result(mozilla::dom::TestExampleInterface::StaticDeprecatedAttribute(global));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_staticDeprecatedAttribute(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "staticDeprecatedAttribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "staticDeprecatedAttribute setter", 1)) {
    return false;
  }
  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::TestExampleInterface::SetStaticDeprecatedAttribute(global, arg0))>, "Should be returning void here");
  mozilla::dom::TestExampleInterface::SetStaticDeprecatedAttribute(global, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
staticDeprecatedMethod(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "staticDeprecatedMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "TestExampleInterface.staticDeprecatedMethod", 1)) {
    return false;
  }
  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::TestExampleInterface::StaticDeprecatedMethod(global, arg0))>, "Should be returning void here");
  mozilla::dom::TestExampleInterface::StaticDeprecatedMethod(global, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
staticDeprecatedMethodWithContext(JSContext* cx, unsigned argc, JS::Value* vp)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "staticDeprecatedMethodWithContext", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (!args.requireAtLeast(cx, "TestExampleInterface.staticDeprecatedMethodWithContext", 1)) {
    return false;
  }
  DeprecationWarning(cx, obj, DeprecatedOperations::eComponents);
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(mozilla::dom::TestExampleInterface::StaticDeprecatedMethodWithContext(global, arg0))>, "Should be returning void here");
  mozilla::dom::TestExampleInterface::StaticDeprecatedMethodWithContext(global, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
overload1(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.overload1");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "overload1", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 2u);
  switch (argcount) {
    case 1: {
      NonNull<mozilla::dom::TestInterface> arg0;
      if (args[0].isObject()) {
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
      bool result(MOZ_KnownLive(self)->Overload1(MOZ_KnownLive(NonNullHelper(arg0))));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setBoolean(result);
      return true;
      break;
    }
    case 2: {
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      NonNull<mozilla::dom::TestInterface> arg1;
      if (args[1].isObject()) {
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[1], arg1, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 2", "TestInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 2");
        return false;
      }
      auto result(StrongOrRawPtr<mozilla::dom::TestInterface>(MOZ_KnownLive(self)->Overload1(NonNullHelper(Constify(arg0)), MOZ_KnownLive(NonNullHelper(arg1)))));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload1_methodinfo = {
  { (JSJitGetterOp)overload1 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.overload2");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "overload2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      RootedDictionary<binding_detail::FastDict> arg0(cx);
      if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload2(cx, Constify(arg0)))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload2(cx, Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isNullOrUndefined()) {
        RootedDictionary<binding_detail::FastDict> arg0(cx);
        if (!arg0.Init(cx, args[0], "Argument 1", false)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload2(cx, Constify(arg0)))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload2(cx, Constify(arg0));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload2(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload2(MOZ_KnownLive(NonNullHelper(arg0)));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          RootedDictionary<binding_detail::FastDict> arg0(cx);
          if (!arg0.Init(cx, args[0], "Argument 1", false)) {
            return false;
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload2(cx, Constify(arg0)))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload2(cx, Constify(arg0));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      if (args[0].isBoolean()) {
        bool arg0;
        if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload2(arg0))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload2(arg0);
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload2(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload2(NonNullHelper(Constify(arg0)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload2_methodinfo = {
  { (JSJitGetterOp)overload2 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload3(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.overload3");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "overload3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload3(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload3(MOZ_KnownLive(NonNullHelper(arg0)));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          RootedCallback<OwningNonNull<binding_detail::FastTestCallback>> arg0(cx);
          if (JS::IsCallable(&args[0].toObject())) {
          { // scope for tempRoot and tempGlobalRoot if needed
            arg0 = new binding_detail::FastTestCallback(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
          }
          } else {
            break;
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload3(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload3(MOZ_KnownLive(NonNullHelper(arg0)));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      bool arg0;
      if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload3(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload3(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload3_methodinfo = {
  { (JSJitGetterOp)overload3 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload4(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.overload4");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "overload4", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload4(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload4(MOZ_KnownLive(NonNullHelper(arg0)));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          RootedCallback<OwningNonNull<binding_detail::FastTestCallbackInterface>> arg0(cx);
          { // scope for tempRoot and tempGlobalRoot if needed
            arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload4(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload4(MOZ_KnownLive(NonNullHelper(arg0)));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload4(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload4(NonNullHelper(Constify(arg0)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload4_methodinfo = {
  { (JSJitGetterOp)overload4 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload5(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.overload5");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "overload5", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isNumber()) {
        int32_t arg0;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload5(arg0))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload5(arg0);
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      TestEnum arg0;
      {
        int index;
        if (!FindEnumStringIndex<true>(cx, args[0], TestEnumValues::strings, "TestEnum", "argument 1", &index)) {
          return false;
        }
        MOZ_ASSERT(index >= 0);
        arg0 = static_cast<TestEnum>(index);
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload5(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload5(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload5_methodinfo = {
  { (JSJitGetterOp)overload5 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload6(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.overload6");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "overload6", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isBoolean()) {
        bool arg0;
        if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload6(arg0))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload6(arg0);
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload6(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload6(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload6_methodinfo = {
  { (JSJitGetterOp)overload6 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload7(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.overload7");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "overload7", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isBoolean()) {
        bool arg0;
        if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload7(arg0))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload7(arg0);
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isNumber()) {
        int32_t arg0;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload7(arg0))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload7(arg0);
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      nsCString arg0;
      if (!ConvertJSValueToByteString(cx, args[0], false, "argument 1", arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload7(Constify(arg0)))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload7(Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload7_methodinfo = {
  { (JSJitGetterOp)overload7 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload8(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.overload8");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "overload8", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload8(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload8(MOZ_KnownLive(NonNullHelper(arg0)));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload8(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload8(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload8_methodinfo = {
  { (JSJitGetterOp)overload8 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload9(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.overload9");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "overload9", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isNullOrUndefined()) {
        Nullable<int32_t> arg0;
        if (args[0].isNullOrUndefined()) {
          arg0.SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload9(Constify(arg0)))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload9(Constify(arg0));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isNumber()) {
        Nullable<int32_t> arg0;
        if (args[0].isNullOrUndefined()) {
          arg0.SetNull();
        } else if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload9(Constify(arg0)))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload9(Constify(arg0));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload9(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload9(NonNullHelper(Constify(arg0)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload9_methodinfo = {
  { (JSJitGetterOp)overload9 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload10(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.overload10");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "overload10", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isObject()) {
        do {
          JS::Rooted<JSObject*> arg0(cx);
          arg0 = &args[0].toObject();
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload10(cx, arg0))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload10(cx, arg0);
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      Nullable<int32_t> arg0;
      if (args[0].isNullOrUndefined()) {
        arg0.SetNull();
      } else if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload10(Constify(arg0)))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload10(Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload10_methodinfo = {
  { (JSJitGetterOp)overload10 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload11(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.overload11");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "overload11", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isNumber()) {
        int32_t arg0;
        if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload11(arg0))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload11(arg0);
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eNull, eNull, arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload11(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload11(NonNullHelper(Constify(arg0)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload11_methodinfo = {
  { (JSJitGetterOp)overload11 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload12(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.overload12");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "overload12", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isNullOrUndefined()) {
        Nullable<bool> arg0;
        if (args[0].isNullOrUndefined()) {
          arg0.SetNull();
        } else if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload12(Constify(arg0)))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload12(Constify(arg0));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isBoolean()) {
        Nullable<bool> arg0;
        if (args[0].isNullOrUndefined()) {
          arg0.SetNull();
        } else if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload12(Constify(arg0)))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload12(Constify(arg0));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload12(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload12(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload12_methodinfo = {
  { (JSJitGetterOp)overload12 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload13(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.overload13");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "overload13", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isBoolean()) {
        bool arg0;
        if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Argument 1", &arg0)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload13(arg0))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload13(arg0);
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      Nullable<int32_t> arg0;
      if (args[0].isNullOrUndefined()) {
        arg0.SetNull();
      } else if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.SetValue())) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload13(Constify(arg0)))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload13(Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload13_methodinfo = {
  { (JSJitGetterOp)overload13 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload14(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.overload14");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "overload14", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      Optional<int32_t> arg0;
      if (args.hasDefined(0)) {
        arg0.Construct();
        if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
          return false;
        }
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload14(Constify(arg0)))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload14(Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload14(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload14(MOZ_KnownLive(NonNullHelper(arg0)));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      Optional<int32_t> arg0;
      if (args.hasDefined(0)) {
        arg0.Construct();
        if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
          return false;
        }
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload14(Constify(arg0)))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload14(Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload14_methodinfo = {
  { (JSJitGetterOp)overload14 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload15(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.overload15");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "overload15", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      Optional<NonNull<mozilla::dom::TestInterface>> arg0;
      if (args.hasDefined(0)) {
        arg0.Construct();
        if (args[0].isObject()) {
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0.Value(), cx);
            if (NS_FAILED(rv)) {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
              return false;
            }
          }
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
          return false;
        }
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload15(MOZ_KnownLive(NonNullHelper(Constify(arg0)))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload15(MOZ_KnownLive(NonNullHelper(Constify(arg0))));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isUndefined()) {
        Optional<NonNull<mozilla::dom::TestInterface>> arg0;
        if (args.hasDefined(0)) {
          arg0.Construct();
          if (args[0].isObject()) {
            {
              // Our JSContext should be in the right global to do unwrapping in.
              nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0.Value(), cx);
              if (NS_FAILED(rv)) {
                cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
                return false;
              }
            }
          } else {
            cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
            return false;
          }
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload15(MOZ_KnownLive(NonNullHelper(Constify(arg0)))))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload15(MOZ_KnownLive(NonNullHelper(Constify(arg0))));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isObject()) {
        do {
          Optional<NonNull<mozilla::dom::TestInterface>> arg0;
          if (args.hasDefined(0)) {
            arg0.Construct();
            {
              // Our JSContext should be in the right global to do unwrapping in.
              nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0.Value(), cx);
              if (NS_FAILED(rv)) {
                break;
              }
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload15(MOZ_KnownLive(NonNullHelper(Constify(arg0)))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload15(MOZ_KnownLive(NonNullHelper(Constify(arg0))));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload15(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload15(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload15_methodinfo = {
  { (JSJitGetterOp)overload15 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload16(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.overload16");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "overload16", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      Optional<mozilla::dom::TestInterface*> arg0;
      if (args.hasDefined(0)) {
        arg0.Construct();
        if (args[0].isObject()) {
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0.Value(), cx);
            if (NS_FAILED(rv)) {
              cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestInterface");
              return false;
            }
          }
        } else if (args[0].isNullOrUndefined()) {
          arg0.Value() = nullptr;
        } else {
          cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
          return false;
        }
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload16(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload16(MOZ_KnownLive(Constify(arg0)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isNullOrUndefined()) {
        Optional<mozilla::dom::TestInterface*> arg0;
        if (args.hasDefined(0)) {
          arg0.Construct();
          arg0.Value() = nullptr;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload16(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload16(MOZ_KnownLive(Constify(arg0)));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isObject()) {
        do {
          Optional<mozilla::dom::TestInterface*> arg0;
          if (args.hasDefined(0)) {
            arg0.Construct();
            {
              // Our JSContext should be in the right global to do unwrapping in.
              nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0.Value(), cx);
              if (NS_FAILED(rv)) {
                break;
              }
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload16(MOZ_KnownLive(Constify(arg0))))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload16(MOZ_KnownLive(Constify(arg0)));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload16(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload16(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload16_methodinfo = {
  { (JSJitGetterOp)overload16 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload17(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.overload17");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "overload17", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isObject()) {
        do {
          binding_detail::AutoSequence<int32_t> arg0;
          JS::ForOfIterator iter(cx);
          if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter.valueIsIterable()) {
            break;
          }
          binding_detail::AutoSequence<int32_t> &arr = arg0;
          JS::Rooted<JS::Value> temp(cx);
          while (true) {
            bool done;
            if (!iter.next(&temp, &done)) {
              return false;
            }
            if (done) {
              break;
            }
            int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
            if (!slotPtr) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            int32_t& slot = *slotPtr;
            if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
              return false;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload17(Constify(arg0)))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload17(Constify(arg0));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          Record<nsString, int32_t> arg0;
          auto& recordEntries = arg0.Entries();

          JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
          JS::RootedVector<jsid> ids(cx);
          if (!js::GetPropertyKeys(cx, recordObj,
                                   JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
            return false;
          }
          if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Rooted<JS::Value> propNameValue(cx);
          JS::Rooted<JS::Value> temp(cx);
          JS::Rooted<jsid> curId(cx);
          JS::Rooted<JS::Value> idVal(cx);
          // Use a hashset to keep track of ids seen, to avoid
          // introducing nasty O(N^2) behavior scanning for them all the
          // time.  Ideally we'd use a data structure with O(1) lookup
          // _and_ ordering for the MozMap, but we don't have one lying
          // around.
          nsTHashtable<nsStringHashKey> idsSeen;
          for (size_t i = 0; i < ids.length(); ++i) {
            curId = ids[i];

            JS::Rooted<JS::PropertyDescriptor> desc(cx);
            if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                                 &desc)) {
              return false;
            }

            if (!desc.object() /* == undefined in spec terms */ ||
                !desc.enumerable()) {
              continue;
            }

            idVal = js::IdToValue(curId);
            nsString propName;
            // This will just throw if idVal is a Symbol, like the spec says
            // to do.
            if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
              return false;
            }

            if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
              return false;
            }

            Record<nsString, int32_t>::EntryType* entry;
            if (!idsSeen.EnsureInserted(propName)) {
              // Find the existing entry.
              auto idx = recordEntries.IndexOf(propName);
              MOZ_ASSERT(idx != recordEntries.NoIndex,
                         "Why is it not found?");
              // Now blow it away to make it look like it was just added
              // to the array, because it's not obvious that it's
              // safe to write to its already-initialized mValue via our
              // normal codegen conversions.  For example, the value
              // could be a union and this would change its type, but
              // codegen assumes we won't do that.
              entry = recordEntries.ReconstructElementAt(idx);
            } else {
              // Safe to do an infallible append here, because we did a
              // SetCapacity above to the right capacity.
              entry = recordEntries.AppendElement();
            }
            entry->mKey = propName;
            int32_t& slot = entry->mValue;
            if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Value in argument 1", &slot)) {
              return false;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload17(Constify(arg0)))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload17(Constify(arg0));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      return cx.ThrowErrorMessage<MSG_OVERLOAD_RESOLUTION_FAILED>("1", "1");
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload17_methodinfo = {
  { (JSJitGetterOp)overload17 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload18(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.overload18");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "overload18", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 1: {
      if (args[0].isObject()) {
        do {
          binding_detail::AutoSequence<nsString> arg0;
          JS::ForOfIterator iter(cx);
          if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter.valueIsIterable()) {
            break;
          }
          binding_detail::AutoSequence<nsString> &arr = arg0;
          JS::Rooted<JS::Value> temp(cx);
          while (true) {
            bool done;
            if (!iter.next(&temp, &done)) {
              return false;
            }
            if (done) {
              break;
            }
            nsString* slotPtr = arr.AppendElement(mozilla::fallible);
            if (!slotPtr) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            nsString& slot = *slotPtr;
            if (!ConvertJSValueToString(cx, temp, eStringify, eStringify, slot)) {
              return false;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload18(Constify(arg0)))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload18(Constify(arg0));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          Record<nsString, nsString> arg0;
          auto& recordEntries = arg0.Entries();

          JS::Rooted<JSObject*> recordObj(cx, &args[0].toObject());
          JS::RootedVector<jsid> ids(cx);
          if (!js::GetPropertyKeys(cx, recordObj,
                                   JSITER_OWNONLY | JSITER_HIDDEN | JSITER_SYMBOLS, &ids)) {
            return false;
          }
          if (!recordEntries.SetCapacity(ids.length(), mozilla::fallible)) {
            JS_ReportOutOfMemory(cx);
            return false;
          }
          JS::Rooted<JS::Value> propNameValue(cx);
          JS::Rooted<JS::Value> temp(cx);
          JS::Rooted<jsid> curId(cx);
          JS::Rooted<JS::Value> idVal(cx);
          // Use a hashset to keep track of ids seen, to avoid
          // introducing nasty O(N^2) behavior scanning for them all the
          // time.  Ideally we'd use a data structure with O(1) lookup
          // _and_ ordering for the MozMap, but we don't have one lying
          // around.
          nsTHashtable<nsStringHashKey> idsSeen;
          for (size_t i = 0; i < ids.length(); ++i) {
            curId = ids[i];

            JS::Rooted<JS::PropertyDescriptor> desc(cx);
            if (!JS_GetOwnPropertyDescriptorById(cx, recordObj, curId,
                                                 &desc)) {
              return false;
            }

            if (!desc.object() /* == undefined in spec terms */ ||
                !desc.enumerable()) {
              continue;
            }

            idVal = js::IdToValue(curId);
            nsString propName;
            // This will just throw if idVal is a Symbol, like the spec says
            // to do.
            if (!ConvertJSValueToString(cx, idVal, "key of argument 1", propName)) {
              return false;
            }

            if (!JS_GetPropertyById(cx, recordObj, curId, &temp)) {
              return false;
            }

            Record<nsString, nsString>::EntryType* entry;
            if (!idsSeen.EnsureInserted(propName)) {
              // Find the existing entry.
              auto idx = recordEntries.IndexOf(propName);
              MOZ_ASSERT(idx != recordEntries.NoIndex,
                         "Why is it not found?");
              // Now blow it away to make it look like it was just added
              // to the array, because it's not obvious that it's
              // safe to write to its already-initialized mValue via our
              // normal codegen conversions.  For example, the value
              // could be a union and this would change its type, but
              // codegen assumes we won't do that.
              entry = recordEntries.ReconstructElementAt(idx);
            } else {
              // Safe to do an infallible append here, because we did a
              // SetCapacity above to the right capacity.
              entry = recordEntries.AppendElement();
            }
            entry->mKey = propName;
            nsString& slot = entry->mValue;
            if (!ConvertJSValueToString(cx, temp, eStringify, eStringify, slot)) {
              return false;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload18(Constify(arg0)))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload18(Constify(arg0));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      return cx.ThrowErrorMessage<MSG_OVERLOAD_RESOLUTION_FAILED>("1", "1");
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload18_methodinfo = {
  { (JSJitGetterOp)overload18 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload19(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.overload19");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "overload19", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      RootedDictionary<binding_detail::FastDict> arg0(cx);
      if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload19(cx, Constify(arg0)))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload19(cx, Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isNullOrUndefined()) {
        RootedDictionary<binding_detail::FastDict> arg0(cx);
        if (!arg0.Init(cx, args[0], "Argument 1", false)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload19(cx, Constify(arg0)))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload19(cx, Constify(arg0));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isObject()) {
        do {
          binding_detail::AutoSequence<int32_t> arg0;
          JS::ForOfIterator iter(cx);
          if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter.valueIsIterable()) {
            break;
          }
          binding_detail::AutoSequence<int32_t> &arr = arg0;
          JS::Rooted<JS::Value> temp(cx);
          while (true) {
            bool done;
            if (!iter.next(&temp, &done)) {
              return false;
            }
            if (done) {
              break;
            }
            int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
            if (!slotPtr) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            int32_t& slot = *slotPtr;
            if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
              return false;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload19(Constify(arg0)))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload19(Constify(arg0));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          RootedDictionary<binding_detail::FastDict> arg0(cx);
          if (!arg0.Init(cx, args[0], "Argument 1", false)) {
            return false;
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload19(cx, Constify(arg0)))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload19(cx, Constify(arg0));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      return cx.ThrowErrorMessage<MSG_OVERLOAD_RESOLUTION_FAILED>("1", "1");
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload19_methodinfo = {
  { (JSJitGetterOp)overload19 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
overload20(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.overload20");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "overload20", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      RootedDictionary<binding_detail::FastDict> arg0(cx);
      if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload20(cx, Constify(arg0)))>, "Should be returning void here");
      MOZ_KnownLive(self)->Overload20(cx, Constify(arg0));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isNullOrUndefined()) {
        RootedDictionary<binding_detail::FastDict> arg0(cx);
        if (!arg0.Init(cx, args[0], "Argument 1", false)) {
          return false;
        }
        // NOTE: This assert does NOT call the function.
        static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload20(cx, Constify(arg0)))>, "Should be returning void here");
        MOZ_KnownLive(self)->Overload20(cx, Constify(arg0));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        args.rval().setUndefined();
        return true;
      }
      if (args[0].isObject()) {
        do {
          binding_detail::AutoSequence<int32_t> arg0;
          JS::ForOfIterator iter(cx);
          if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
            return false;
          }
          if (!iter.valueIsIterable()) {
            break;
          }
          binding_detail::AutoSequence<int32_t> &arr = arg0;
          JS::Rooted<JS::Value> temp(cx);
          while (true) {
            bool done;
            if (!iter.next(&temp, &done)) {
              return false;
            }
            if (done) {
              break;
            }
            int32_t* slotPtr = arr.AppendElement(mozilla::fallible);
            if (!slotPtr) {
              JS_ReportOutOfMemory(cx);
              return false;
            }
            int32_t& slot = *slotPtr;
            if (!ValueToPrimitive<int32_t, eDefault>(cx, temp, "Element of argument 1", &slot)) {
              return false;
            }
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload20(Constify(arg0)))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload20(Constify(arg0));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
        do {
          RootedDictionary<binding_detail::FastDict> arg0(cx);
          if (!arg0.Init(cx, args[0], "Argument 1", false)) {
            return false;
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Overload20(cx, Constify(arg0)))>, "Should be returning void here");
          MOZ_KnownLive(self)->Overload20(cx, Constify(arg0));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      return cx.ThrowErrorMessage<MSG_OVERLOAD_RESOLUTION_FAILED>("1", "1");
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo overload20_methodinfo = {
  { (JSJitGetterOp)overload20 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passVariadicThirdArg(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passVariadicThirdArg");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passVariadicThirdArg", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passVariadicThirdArg", 2)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  }
  AutoSequence<OwningNonNull<mozilla::dom::TestInterface>> arg2;
  if (args.length() > 2) {
    if (!arg2.SetCapacity(args.length() - 2, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 2; variadicArg < args.length(); ++variadicArg) {
      // OK to do infallible append here, since we ensured capacity already.
      OwningNonNull<mozilla::dom::TestInterface>& slot = *arg2.AppendElement();
      if (args[variadicArg].isObject()) {
        static_assert(IsRefcounted<mozilla::dom::TestInterface>::value, "We can only store refcounted classes.");
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[variadicArg], slot, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 3", "TestInterface");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 3");
        return false;
      }
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassVariadicThirdArg(NonNullHelper(Constify(arg0)), arg1, MOZ_KnownLive(NonNullHelper(Constify(arg2)))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassVariadicThirdArg(NonNullHelper(Constify(arg0)), arg1, MOZ_KnownLive(NonNullHelper(Constify(arg2))));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passVariadicThirdArg_methodinfo = {
  { (JSJitGetterOp)passVariadicThirdArg },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable1(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "prefable1", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable1());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable1_getterinfo = {
  { get_prefable1 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "prefable2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable2());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable2_getterinfo = {
  { get_prefable2 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable3(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "prefable3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable3());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable3_getterinfo = {
  { get_prefable3 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable4(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "prefable4", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable4());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable4_getterinfo = {
  { get_prefable4 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable5(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "prefable5", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable5());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable5_getterinfo = {
  { get_prefable5 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable6(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "prefable6", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable6());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable6_getterinfo = {
  { get_prefable6 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable7(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "prefable7", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable7());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable7_getterinfo = {
  { get_prefable7 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable8(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "prefable8", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable8());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable8_getterinfo = {
  { get_prefable8 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable9(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "prefable9", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable9());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable9_getterinfo = {
  { get_prefable9 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
prefable10(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "prefable10", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Prefable10())>, "Should be returning void here");
  MOZ_KnownLive(self)->Prefable10();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo prefable10_methodinfo = {
  { (JSJitGetterOp)prefable10 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
prefable11(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "prefable11", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Prefable11())>, "Should be returning void here");
  MOZ_KnownLive(self)->Prefable11();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo prefable11_methodinfo = {
  { (JSJitGetterOp)prefable11 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable12(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "prefable12", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable12());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable12_getterinfo = {
  { get_prefable12 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
prefable13(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "prefable13", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Prefable13())>, "Should be returning void here");
  MOZ_KnownLive(self)->Prefable13();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo prefable13_methodinfo = {
  { (JSJitGetterOp)prefable13 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable14(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "prefable14", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable14());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable14_getterinfo = {
  { get_prefable14 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable15(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "prefable15", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable15());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable15_getterinfo = {
  { get_prefable15 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_prefable16(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "prefable16", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->Prefable16());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo prefable16_getterinfo = {
  { get_prefable16 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
prefable17(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "prefable17", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Prefable17())>, "Should be returning void here");
  MOZ_KnownLive(self)->Prefable17();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo prefable17_methodinfo = {
  { (JSJitGetterOp)prefable17 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
prefable18(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "prefable18", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Prefable18())>, "Should be returning void here");
  MOZ_KnownLive(self)->Prefable18();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo prefable18_methodinfo = {
  { (JSJitGetterOp)prefable18 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
prefable19(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "prefable19", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Prefable19())>, "Should be returning void here");
  MOZ_KnownLive(self)->Prefable19();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo prefable19_methodinfo = {
  { (JSJitGetterOp)prefable19 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_conditionalOnSecureContext1(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "conditionalOnSecureContext1", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->ConditionalOnSecureContext1());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo conditionalOnSecureContext1_getterinfo = {
  { get_conditionalOnSecureContext1 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_conditionalOnSecureContext2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "conditionalOnSecureContext2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->ConditionalOnSecureContext2());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo conditionalOnSecureContext2_getterinfo = {
  { get_conditionalOnSecureContext2 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_conditionalOnSecureContext3(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "conditionalOnSecureContext3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->ConditionalOnSecureContext3());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo conditionalOnSecureContext3_getterinfo = {
  { get_conditionalOnSecureContext3 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_conditionalOnSecureContext4(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "conditionalOnSecureContext4", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->ConditionalOnSecureContext4());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

static const JSJitInfo conditionalOnSecureContext4_getterinfo = {
  { get_conditionalOnSecureContext4 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
conditionalOnSecureContext5(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "conditionalOnSecureContext5", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ConditionalOnSecureContext5())>, "Should be returning void here");
  MOZ_KnownLive(self)->ConditionalOnSecureContext5();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo conditionalOnSecureContext5_methodinfo = {
  { (JSJitGetterOp)conditionalOnSecureContext5 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
conditionalOnSecureContext6(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "conditionalOnSecureContext6", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ConditionalOnSecureContext6())>, "Should be returning void here");
  MOZ_KnownLive(self)->ConditionalOnSecureContext6();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo conditionalOnSecureContext6_methodinfo = {
  { (JSJitGetterOp)conditionalOnSecureContext6 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
conditionalOnSecureContext7(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "conditionalOnSecureContext7", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ConditionalOnSecureContext7())>, "Should be returning void here");
  MOZ_KnownLive(self)->ConditionalOnSecureContext7();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo conditionalOnSecureContext7_methodinfo = {
  { (JSJitGetterOp)conditionalOnSecureContext7 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
conditionalOnSecureContext8(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "conditionalOnSecureContext8", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ConditionalOnSecureContext8())>, "Should be returning void here");
  MOZ_KnownLive(self)->ConditionalOnSecureContext8();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo conditionalOnSecureContext8_methodinfo = {
  { (JSJitGetterOp)conditionalOnSecureContext8 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_attrWithLenientThis(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "attrWithLenientThis", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int32_t result(MOZ_KnownLive(self)->AttrWithLenientThis());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_attrWithLenientThis(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "attrWithLenientThis", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAttrWithLenientThis(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAttrWithLenientThis(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo attrWithLenientThis_getterinfo = {
  { get_attrWithLenientThis },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo attrWithLenientThis_setterinfo = {
  { (JSJitGetterOp)set_attrWithLenientThis },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_unforgeableAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "unforgeableAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int32_t result(MOZ_KnownLive(self)->UnforgeableAttr());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo unforgeableAttr_getterinfo = {
  { get_unforgeableAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_unforgeableAttr2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "unforgeableAttr2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int32_t result(MOZ_KnownLive(self)->UnforgeableAttr2());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo unforgeableAttr2_getterinfo = {
  { get_unforgeableAttr2 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
unforgeableMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "unforgeableMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int32_t result(MOZ_KnownLive(self)->UnforgeableMethod());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo unforgeableMethod_methodinfo = {
  { (JSJitGetterOp)unforgeableMethod },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
unforgeableMethod2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "unforgeableMethod2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int32_t result(MOZ_KnownLive(self)->UnforgeableMethod2());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo unforgeableMethod2_methodinfo = {
  { (JSJitGetterOp)unforgeableMethod2 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
__stringifier(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "__stringifier", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  DOMString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Stringify(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->Stringify(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo __stringifier_methodinfo = {
  { (JSJitGetterOp)__stringifier },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passRenamedInterface(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passRenamedInterface");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passRenamedInterface", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passRenamedInterface", 1)) {
    return false;
  }
  NonNull<nsRenamedInterface> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestRenamedInterface, nsRenamedInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "TestRenamedInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassRenamedInterface(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassRenamedInterface(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passRenamedInterface_methodinfo = {
  { (JSJitGetterOp)passRenamedInterface },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_putForwardsAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "putForwardsAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestExampleInterface>(MOZ_KnownLive(self)->PutForwardsAttr()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_putForwardsAttr(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.putForwardsAttr setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "putForwardsAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::Rooted<JS::Value> v(cx);
  if (!JS_GetProperty(cx, obj, "putForwardsAttr", &v)) {
    return false;
  }

  if (!v.isObject()) {
    return cx.ThrowErrorMessage<MSG_NOT_OBJECT>("TestExampleInterface.putForwardsAttr");
  }

  JS::Rooted<JSObject*> targetObj(cx, &v.toObject());
  return JS_SetProperty(cx, targetObj, "writableByte", args[0]);
}

static const JSJitInfo putForwardsAttr_getterinfo = {
  { get_putForwardsAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo putForwardsAttr_setterinfo = {
  { (JSJitGetterOp)set_putForwardsAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_putForwardsAttr2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "putForwardsAttr2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestExampleInterface>(MOZ_KnownLive(self)->PutForwardsAttr2()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_putForwardsAttr2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.putForwardsAttr2 setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "putForwardsAttr2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::Rooted<JS::Value> v(cx);
  if (!JS_GetProperty(cx, obj, "putForwardsAttr2", &v)) {
    return false;
  }

  if (!v.isObject()) {
    return cx.ThrowErrorMessage<MSG_NOT_OBJECT>("TestExampleInterface.putForwardsAttr2");
  }

  JS::Rooted<JSObject*> targetObj(cx, &v.toObject());
  return JS_SetProperty(cx, targetObj, "writableByte", args[0]);
}

static const JSJitInfo putForwardsAttr2_getterinfo = {
  { get_putForwardsAttr2 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo putForwardsAttr2_setterinfo = {
  { (JSJitGetterOp)set_putForwardsAttr2 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_putForwardsAttr3(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "putForwardsAttr3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestExampleInterface>(MOZ_KnownLive(self)->PutForwardsAttr3()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_putForwardsAttr3(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.putForwardsAttr3 setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "putForwardsAttr3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::Rooted<JS::Value> v(cx);
  if (!JS_GetProperty(cx, obj, "putForwardsAttr3", &v)) {
    return false;
  }

  if (!v.isObject()) {
    return cx.ThrowErrorMessage<MSG_NOT_OBJECT>("TestExampleInterface.putForwardsAttr3");
  }

  JS::Rooted<JSObject*> targetObj(cx, &v.toObject());
  return JS_SetProperty(cx, targetObj, "writableByte", args[0]);
}

static const JSJitInfo putForwardsAttr3_getterinfo = {
  { get_putForwardsAttr3 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo putForwardsAttr3_setterinfo = {
  { (JSJitGetterOp)set_putForwardsAttr3 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
throwingMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "throwingMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ThrowingMethod(rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->ThrowingMethod(rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestExampleInterface.throwingMethod"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo throwingMethod_methodinfo = {
  { (JSJitGetterOp)throwingMethod },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_throwingAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "throwingAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetThrowingAttr(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestExampleInterface.throwingAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_throwingAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "throwingAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetThrowingAttr(arg0, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetThrowingAttr(arg0, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestExampleInterface.throwingAttr setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo throwingAttr_getterinfo = {
  { get_throwingAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo throwingAttr_setterinfo = {
  { (JSJitGetterOp)set_throwingAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_throwingGetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "throwingGetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetThrowingGetterAttr(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestExampleInterface.throwingGetterAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_throwingGetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "throwingGetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetThrowingGetterAttr(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetThrowingGetterAttr(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo throwingGetterAttr_getterinfo = {
  { get_throwingGetterAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo throwingGetterAttr_setterinfo = {
  { (JSJitGetterOp)set_throwingGetterAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_throwingSetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "throwingSetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->ThrowingSetterAttr());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_throwingSetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "throwingSetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetThrowingSetterAttr(arg0, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetThrowingSetterAttr(arg0, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestExampleInterface.throwingSetterAttr setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo throwingSetterAttr_getterinfo = {
  { get_throwingSetterAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo throwingSetterAttr_setterinfo = {
  { (JSJitGetterOp)set_throwingSetterAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
canOOMMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "canOOMMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->CanOOMMethod(OOMReporter::From(rv)))>, "Should be returning void here");
  MOZ_KnownLive(self)->CanOOMMethod(OOMReporter::From(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestExampleInterface.canOOMMethod"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo canOOMMethod_methodinfo = {
  { (JSJitGetterOp)canOOMMethod },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_canOOMAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "canOOMAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetCanOOMAttr(OOMReporter::From(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestExampleInterface.canOOMAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_canOOMAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "canOOMAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetCanOOMAttr(arg0, OOMReporter::From(rv)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetCanOOMAttr(arg0, OOMReporter::From(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestExampleInterface.canOOMAttr setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo canOOMAttr_getterinfo = {
  { get_canOOMAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo canOOMAttr_setterinfo = {
  { (JSJitGetterOp)set_canOOMAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_canOOMGetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "canOOMGetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  FastErrorResult rv;
  bool result(MOZ_KnownLive(self)->GetCanOOMGetterAttr(OOMReporter::From(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestExampleInterface.canOOMGetterAttr getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_canOOMGetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "canOOMGetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetCanOOMGetterAttr(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetCanOOMGetterAttr(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo canOOMGetterAttr_getterinfo = {
  { get_canOOMGetterAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo canOOMGetterAttr_setterinfo = {
  { (JSJitGetterOp)set_canOOMGetterAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_canOOMSetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "canOOMSetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->CanOOMSetterAttr());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_canOOMSetterAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "canOOMSetterAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetCanOOMSetterAttr(arg0, OOMReporter::From(rv)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetCanOOMSetterAttr(arg0, OOMReporter::From(rv));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestExampleInterface.canOOMSetterAttr setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo canOOMSetterAttr_getterinfo = {
  { get_canOOMSetterAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo canOOMSetterAttr_setterinfo = {
  { (JSJitGetterOp)set_canOOMSetterAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
needsSubjectPrincipalMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "needsSubjectPrincipalMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  NonNull<nsIPrincipal> subjectPrincipal;
  {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);

    subjectPrincipal = principal;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NeedsSubjectPrincipalMethod(MOZ_KnownLive(NonNullHelper(subjectPrincipal))))>, "Should be returning void here");
  MOZ_KnownLive(self)->NeedsSubjectPrincipalMethod(MOZ_KnownLive(NonNullHelper(subjectPrincipal)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo needsSubjectPrincipalMethod_methodinfo = {
  { (JSJitGetterOp)needsSubjectPrincipalMethod },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_needsSubjectPrincipalAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "needsSubjectPrincipalAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  NonNull<nsIPrincipal> subjectPrincipal;
  {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);

    subjectPrincipal = principal;
  }
  bool result(MOZ_KnownLive(self)->NeedsSubjectPrincipalAttr(MOZ_KnownLive(NonNullHelper(subjectPrincipal))));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_needsSubjectPrincipalAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "needsSubjectPrincipalAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  NonNull<nsIPrincipal> subjectPrincipal;
  {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);

    subjectPrincipal = principal;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNeedsSubjectPrincipalAttr(arg0, MOZ_KnownLive(NonNullHelper(subjectPrincipal))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNeedsSubjectPrincipalAttr(arg0, MOZ_KnownLive(NonNullHelper(subjectPrincipal)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo needsSubjectPrincipalAttr_getterinfo = {
  { get_needsSubjectPrincipalAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo needsSubjectPrincipalAttr_setterinfo = {
  { (JSJitGetterOp)set_needsSubjectPrincipalAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
needsNonSystemSubjectPrincipalMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "needsNonSystemSubjectPrincipalMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  nsIPrincipal* subjectPrincipal;
  {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);
    if (principal->IsSystemPrincipal()) {
      principal = nullptr;
    }

    subjectPrincipal = principal;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NeedsNonSystemSubjectPrincipalMethod(MOZ_KnownLive(subjectPrincipal)))>, "Should be returning void here");
  MOZ_KnownLive(self)->NeedsNonSystemSubjectPrincipalMethod(MOZ_KnownLive(subjectPrincipal));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo needsNonSystemSubjectPrincipalMethod_methodinfo = {
  { (JSJitGetterOp)needsNonSystemSubjectPrincipalMethod },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_needsNonSystemSubjectPrincipalAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "needsNonSystemSubjectPrincipalAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  nsIPrincipal* subjectPrincipal;
  {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);
    if (principal->IsSystemPrincipal()) {
      principal = nullptr;
    }

    subjectPrincipal = principal;
  }
  bool result(MOZ_KnownLive(self)->NeedsNonSystemSubjectPrincipalAttr(MOZ_KnownLive(subjectPrincipal)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_needsNonSystemSubjectPrincipalAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "needsNonSystemSubjectPrincipalAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  nsIPrincipal* subjectPrincipal;
  {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);
    if (principal->IsSystemPrincipal()) {
      principal = nullptr;
    }

    subjectPrincipal = principal;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNeedsNonSystemSubjectPrincipalAttr(arg0, MOZ_KnownLive(subjectPrincipal)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNeedsNonSystemSubjectPrincipalAttr(arg0, MOZ_KnownLive(subjectPrincipal));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo needsNonSystemSubjectPrincipalAttr_getterinfo = {
  { get_needsNonSystemSubjectPrincipalAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo needsNonSystemSubjectPrincipalAttr_setterinfo = {
  { (JSJitGetterOp)set_needsNonSystemSubjectPrincipalAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
needsCallerTypeMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "needsCallerTypeMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NeedsCallerTypeMethod(nsContentUtils::IsSystemCaller(cx) ? CallerType::System : CallerType::NonSystem))>, "Should be returning void here");
  MOZ_KnownLive(self)->NeedsCallerTypeMethod(nsContentUtils::IsSystemCaller(cx) ? CallerType::System : CallerType::NonSystem);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo needsCallerTypeMethod_methodinfo = {
  { (JSJitGetterOp)needsCallerTypeMethod },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_needsCallerTypeAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "needsCallerTypeAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->NeedsCallerTypeAttr(nsContentUtils::IsSystemCaller(cx) ? CallerType::System : CallerType::NonSystem));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_needsCallerTypeAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "needsCallerTypeAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNeedsCallerTypeAttr(arg0, nsContentUtils::IsSystemCaller(cx) ? CallerType::System : CallerType::NonSystem))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNeedsCallerTypeAttr(arg0, nsContentUtils::IsSystemCaller(cx) ? CallerType::System : CallerType::NonSystem);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo needsCallerTypeAttr_getterinfo = {
  { get_needsCallerTypeAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo needsCallerTypeAttr_setterinfo = {
  { (JSJitGetterOp)set_needsCallerTypeAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
ceReactionsMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "ceReactionsMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Maybe<AutoCEReaction> ceReaction;
  DocGroup* docGroup = self->GetDocGroup();
  if (docGroup) {
    ceReaction.emplace(docGroup->CustomElementReactionsStack(), cx);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->CeReactionsMethod())>, "Should be returning void here");
  MOZ_KnownLive(self)->CeReactionsMethod();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo ceReactionsMethod_methodinfo = {
  { (JSJitGetterOp)ceReactionsMethod },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
ceReactionsMethodOverload(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.ceReactionsMethodOverload");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "ceReactionsMethodOverload", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      Maybe<AutoCEReaction> ceReaction;
      DocGroup* docGroup = self->GetDocGroup();
      if (docGroup) {
        ceReaction.emplace(docGroup->CustomElementReactionsStack(), cx);
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->CeReactionsMethodOverload())>, "Should be returning void here");
      MOZ_KnownLive(self)->CeReactionsMethodOverload();
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      Maybe<AutoCEReaction> ceReaction;
      DocGroup* docGroup = self->GetDocGroup();
      if (docGroup) {
        ceReaction.emplace(docGroup->CustomElementReactionsStack(), cx);
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->CeReactionsMethodOverload(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
      MOZ_KnownLive(self)->CeReactionsMethodOverload(NonNullHelper(Constify(arg0)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo ceReactionsMethodOverload_methodinfo = {
  { (JSJitGetterOp)ceReactionsMethodOverload },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_ceReactionsAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "ceReactionsAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->CeReactionsAttr());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_ceReactionsAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "ceReactionsAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  Maybe<AutoCEReaction> ceReaction;
  DocGroup* docGroup = self->GetDocGroup();
  if (docGroup) {
    ceReaction.emplace(docGroup->CustomElementReactionsStack(), cx);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetCeReactionsAttr(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetCeReactionsAttr(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ceReactionsAttr_getterinfo = {
  { get_ceReactionsAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo ceReactionsAttr_setterinfo = {
  { (JSJitGetterOp)set_ceReactionsAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passArgsWithDefaults(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passArgsWithDefaults");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passArgsWithDefaults", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  Optional<int32_t> arg0;
  if (args.hasDefined(0)) {
    arg0.Construct();
    if (!ValueToPrimitive<int32_t, eDefault>(cx, args[0], "Argument 1", &arg0.Value())) {
      return false;
    }
  }
  mozilla::dom::TestInterface* arg1;
  if (args.hasDefined(1)) {
    if (args[1].isObject()) {
      {
        // Our JSContext should be in the right global to do unwrapping in.
        nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[1], arg1, cx);
        if (NS_FAILED(rv)) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 2", "TestInterface");
          return false;
        }
      }
    } else if (args[1].isNullOrUndefined()) {
      arg1 = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 2");
      return false;
    }
  } else {
    arg1 = nullptr;
  }
  RootedDictionary<binding_detail::FastDict> arg2(cx);
  if (!arg2.Init(cx, (args.hasDefined(2)) ? args[2] : JS::NullHandleValue, "Argument 3", false)) {
    return false;
  }
  double arg3;
  if (args.hasDefined(3)) {
    if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
      return false;
    } else if (!mozilla::IsFinite(arg3)) {
      cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 4");
      return false;
    }
  } else {
    arg3 = 5.0;
  }
  Optional<float> arg4;
  if (args.hasDefined(4)) {
    arg4.Construct();
    if (!ValueToPrimitive<float, eDefault>(cx, args[4], "Argument 5", &arg4.Value())) {
      return false;
    } else if (!mozilla::IsFinite(arg4.Value())) {
      cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 5");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassArgsWithDefaults(cx, Constify(arg0), MOZ_KnownLive(Constify(arg1)), Constify(arg2), arg3, Constify(arg4)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassArgsWithDefaults(cx, Constify(arg0), MOZ_KnownLive(Constify(arg1)), Constify(arg2), arg3, Constify(arg4));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passArgsWithDefaults_methodinfo = {
  { (JSJitGetterOp)passArgsWithDefaults },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_toJSONShouldSkipThis(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "toJSONShouldSkipThis", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JS::Value> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetToJSONShouldSkipThis(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetToJSONShouldSkipThis(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeValueToActiveJS(result);
  args.rval().set(result);
  if (!MaybeWrapValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_toJSONShouldSkipThis(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "toJSONShouldSkipThis", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JS::Value> arg0(cx);
  arg0 = args[0];
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetToJSONShouldSkipThis(cx, arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetToJSONShouldSkipThis(cx, arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo toJSONShouldSkipThis_getterinfo = {
  { get_toJSONShouldSkipThis },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo toJSONShouldSkipThis_setterinfo = {
  { (JSJitGetterOp)set_toJSONShouldSkipThis },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_toJSONShouldSkipThis2(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "toJSONShouldSkipThis2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestParentInterface>(MOZ_KnownLive(self)->ToJSONShouldSkipThis2()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_toJSONShouldSkipThis2(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.toJSONShouldSkipThis2 setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "toJSONShouldSkipThis2", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  NonNull<mozilla::dom::TestParentInterface> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestParentInterface, mozilla::dom::TestParentInterface>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "TestParentInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetToJSONShouldSkipThis2(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetToJSONShouldSkipThis2(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo toJSONShouldSkipThis2_getterinfo = {
  { get_toJSONShouldSkipThis2 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo toJSONShouldSkipThis2_setterinfo = {
  { (JSJitGetterOp)set_toJSONShouldSkipThis2 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_toJSONShouldSkipThis3(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "toJSONShouldSkipThis3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::TestCallbackInterface>(MOZ_KnownLive(self)->ToJSONShouldSkipThis3()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setObjectOrNull(GetCallbackFromCallbackObject(cx, result));
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_toJSONShouldSkipThis3(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.toJSONShouldSkipThis3 setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "toJSONShouldSkipThis3", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedCallback<OwningNonNull<binding_detail::FastTestCallbackInterface>> arg0(cx);
  if (args[0].isObject()) {
    { // scope for tempRoot and tempGlobalRoot if needed
      arg0 = new binding_detail::FastTestCallbackInterface(&args[0].toObject(), JS::CurrentGlobalOrNull(cx));
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetToJSONShouldSkipThis3(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetToJSONShouldSkipThis3(MOZ_KnownLive(NonNullHelper(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo toJSONShouldSkipThis3_getterinfo = {
  { get_toJSONShouldSkipThis3 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo toJSONShouldSkipThis3_setterinfo = {
  { (JSJitGetterOp)set_toJSONShouldSkipThis3 },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_dashed_attribute(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "dashed-attribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t result(MOZ_KnownLive(self)->Dashed_attribute());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_dashed_attribute(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "dashed-attribute", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  int8_t arg0;
  if (!ValueToPrimitive<int8_t, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetDashed_attribute(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetDashed_attribute(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo dashed_attribute_getterinfo = {
  { get_dashed_attribute },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo dashed_attribute_setterinfo = {
  { (JSJitGetterOp)set_dashed_attribute },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
dashed_method(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "dashed-method", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Dashed_method())>, "Should be returning void here");
  MOZ_KnownLive(self)->Dashed_method();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo dashed_method_methodinfo = {
  { (JSJitGetterOp)dashed_method },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_nonEnumerableAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "nonEnumerableAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->NonEnumerableAttr());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_nonEnumerableAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "nonEnumerableAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNonEnumerableAttr(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNonEnumerableAttr(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo nonEnumerableAttr_getterinfo = {
  { get_nonEnumerableAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo nonEnumerableAttr_setterinfo = {
  { (JSJitGetterOp)set_nonEnumerableAttr },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
nonEnumerableMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "nonEnumerableMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NonEnumerableMethod())>, "Should be returning void here");
  MOZ_KnownLive(self)->NonEnumerableMethod();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo nonEnumerableMethod_methodinfo = {
  { (JSJitGetterOp)nonEnumerableMethod },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_allowSharedArrayBufferViewTypedef(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "allowSharedArrayBufferViewTypedef", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetAllowSharedArrayBufferViewTypedef(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetAllowSharedArrayBufferViewTypedef(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapNonDOMObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_allowSharedArrayBufferViewTypedef(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.allowSharedArrayBufferViewTypedef setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "allowSharedArrayBufferViewTypedef", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedSpiderMonkeyInterface<ArrayBufferView> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "ArrayBufferView");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value being assigned");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAllowSharedArrayBufferViewTypedef(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAllowSharedArrayBufferViewTypedef(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo allowSharedArrayBufferViewTypedef_getterinfo = {
  { get_allowSharedArrayBufferViewTypedef },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo allowSharedArrayBufferViewTypedef_setterinfo = {
  { (JSJitGetterOp)set_allowSharedArrayBufferViewTypedef },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_allowSharedArrayBufferView(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "allowSharedArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetAllowSharedArrayBufferView(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetAllowSharedArrayBufferView(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapNonDOMObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_allowSharedArrayBufferView(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.allowSharedArrayBufferView setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "allowSharedArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedSpiderMonkeyInterface<ArrayBufferView> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "ArrayBufferView");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value being assigned");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAllowSharedArrayBufferView(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAllowSharedArrayBufferView(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo allowSharedArrayBufferView_getterinfo = {
  { get_allowSharedArrayBufferView },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo allowSharedArrayBufferView_setterinfo = {
  { (JSJitGetterOp)set_allowSharedArrayBufferView },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_allowSharedNullableArrayBufferView(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "allowSharedNullableArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetAllowSharedNullableArrayBufferView(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetAllowSharedNullableArrayBufferView(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
                JS::ExposeObjectToActiveJS(result);
              }
              args.rval().setObjectOrNull(result);
  if (!MaybeWrapNonDOMObjectOrNullValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_allowSharedNullableArrayBufferView(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.allowSharedNullableArrayBufferView setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "allowSharedNullableArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedSpiderMonkeyInterface<Nullable<ArrayBufferView>> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.SetValue().Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "ArrayBufferViewOrNull");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value being assigned");
      return false;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAllowSharedNullableArrayBufferView(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAllowSharedNullableArrayBufferView(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo allowSharedNullableArrayBufferView_getterinfo = {
  { get_allowSharedNullableArrayBufferView },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo allowSharedNullableArrayBufferView_setterinfo = {
  { (JSJitGetterOp)set_allowSharedNullableArrayBufferView },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_allowSharedArrayBuffer(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "allowSharedArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetAllowSharedArrayBuffer(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetAllowSharedArrayBuffer(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapNonDOMObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_allowSharedArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.allowSharedArrayBuffer setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "allowSharedArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedSpiderMonkeyInterface<ArrayBuffer> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "ArrayBuffer");
      return false;
    }
    if (JS::IsLargeArrayBufferMaybeShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value being assigned");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAllowSharedArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAllowSharedArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo allowSharedArrayBuffer_getterinfo = {
  { get_allowSharedArrayBuffer },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo allowSharedArrayBuffer_setterinfo = {
  { (JSJitGetterOp)set_allowSharedArrayBuffer },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_allowSharedNullableArrayBuffer(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "allowSharedNullableArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetAllowSharedNullableArrayBuffer(cx, &result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetAllowSharedNullableArrayBuffer(cx, &result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
                JS::ExposeObjectToActiveJS(result);
              }
              args.rval().setObjectOrNull(result);
  if (!MaybeWrapNonDOMObjectOrNullValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_allowSharedNullableArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.allowSharedNullableArrayBuffer setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "allowSharedNullableArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  RootedSpiderMonkeyInterface<Nullable<ArrayBuffer>> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.SetValue().Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Value being assigned", "ArrayBufferOrNull");
      return false;
    }
    if (JS::IsLargeArrayBufferMaybeShared(arg0.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Value being assigned");
      return false;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetAllowSharedNullableArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetAllowSharedNullableArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo allowSharedNullableArrayBuffer_getterinfo = {
  { get_allowSharedNullableArrayBuffer },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");
static const JSJitInfo allowSharedNullableArrayBuffer_setterinfo = {
  { (JSJitGetterOp)set_allowSharedNullableArrayBuffer },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAllowSharedArrayBufferViewTypedef(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passAllowSharedArrayBufferViewTypedef");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passAllowSharedArrayBufferViewTypedef", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passAllowSharedArrayBufferViewTypedef", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<ArrayBufferView> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferView");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAllowSharedArrayBufferViewTypedef(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAllowSharedArrayBufferViewTypedef(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAllowSharedArrayBufferViewTypedef_methodinfo = {
  { (JSJitGetterOp)passAllowSharedArrayBufferViewTypedef },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAllowSharedArrayBufferView(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passAllowSharedArrayBufferView");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passAllowSharedArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passAllowSharedArrayBufferView", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<ArrayBufferView> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferView");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAllowSharedArrayBufferView(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAllowSharedArrayBufferView(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAllowSharedArrayBufferView_methodinfo = {
  { (JSJitGetterOp)passAllowSharedArrayBufferView },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAllowSharedNullableArrayBufferView(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passAllowSharedNullableArrayBufferView");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passAllowSharedNullableArrayBufferView", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passAllowSharedNullableArrayBufferView", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Nullable<ArrayBufferView>> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.SetValue().Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferViewOrNull");
      return false;
    }
    if (JS::IsLargeArrayBufferView(arg0.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAllowSharedNullableArrayBufferView(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAllowSharedNullableArrayBufferView(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAllowSharedNullableArrayBufferView_methodinfo = {
  { (JSJitGetterOp)passAllowSharedNullableArrayBufferView },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAllowSharedArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passAllowSharedArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passAllowSharedArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passAllowSharedArrayBuffer", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<ArrayBuffer> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBuffer");
      return false;
    }
    if (JS::IsLargeArrayBufferMaybeShared(arg0.Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAllowSharedArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAllowSharedArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAllowSharedArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passAllowSharedArrayBuffer },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passAllowSharedNullableArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passAllowSharedNullableArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passAllowSharedNullableArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passAllowSharedNullableArrayBuffer", 1)) {
    return false;
  }
  RootedSpiderMonkeyInterface<Nullable<ArrayBuffer>> arg0(cx);
  if (args[0].isObject()) {
    if (!arg0.SetValue().Init(&args[0].toObject())) {
      cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ArrayBufferOrNull");
      return false;
    }
    if (JS::IsLargeArrayBufferMaybeShared(arg0.SetValue().Obj())) {
      cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
      return false;
    }
  } else if (args[0].isNullOrUndefined()) {
    arg0.SetNull();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassAllowSharedNullableArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassAllowSharedNullableArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passAllowSharedNullableArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passAllowSharedNullableArrayBuffer },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passUnionArrayBuffer", 1)) {
    return false;
  }
  StringOrArrayBuffer arg0;
  StringOrArrayBufferArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      done = (failed = !arg0_holder.TrySetToArrayBuffer(cx, args[0], tryNext, false)) || !tryNext;

    }
    if (!done) {
      do {
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "ArrayBuffer");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passUnionArrayBuffer },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
passUnionAllowSharedArrayBuffer(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "TestExampleInterface.passUnionAllowSharedArrayBuffer");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "passUnionAllowSharedArrayBuffer", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleInterface.passUnionAllowSharedArrayBuffer", 1)) {
    return false;
  }
  StringOrMaybeSharedArrayBuffer arg0;
  StringOrMaybeSharedArrayBufferArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      done = (failed = !arg0_holder.TrySetToArrayBuffer(cx, args[0], tryNext, false)) || !tryNext;

    }
    if (!done) {
      do {
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "ArrayBuffer");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PassUnionAllowSharedArrayBuffer(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->PassUnionAllowSharedArrayBuffer(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo passUnionAllowSharedArrayBuffer_methodinfo = {
  { (JSJitGetterOp)passUnionAllowSharedArrayBuffer },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
toJSON(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "toJSON", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleInterface*>(void_self);
  JS::Rooted<JSObject*> result(cx, JS_NewPlainObject(cx));
  if (!result) {
    return false;
  }
  if (!TestExampleInterface_Binding::CollectJSONAttributes(cx, obj, MOZ_KnownLive(self), result)) {
    return false;
  }
  args.rval().setObject(*result);
  return true;
}

static const JSJitInfo toJSON_methodinfo = {
  { (JSJitGetterOp)toJSON },
  { prototypes::id::TestExampleInterface },
  { PrototypeTraits<prototypes::id::TestExampleInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 16, "There is no slot for us");

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestExampleInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestExampleInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestExampleInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestExampleInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestExampleInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestExampleInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestExampleInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestExampleInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestExampleInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sStaticMethods_specs[] = {
  JS_FNSPEC("staticMethod", staticMethod, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("staticMethodWithContext", staticMethodWithContext, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("staticDeprecatedMethod", staticDeprecatedMethod, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("staticDeprecatedMethodWithContext", staticDeprecatedMethodWithContext, nullptr, 1, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sStaticMethods[] = {
  { nullptr, &sStaticMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(4 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sStaticAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("staticAttribute", JSPROP_ENUMERATE, get_staticAttribute, nullptr, set_staticAttribute, nullptr),
  JSPropertySpec::nativeAccessors("staticDeprecatedAttribute", JSPROP_ENUMERATE, get_staticDeprecatedAttribute, nullptr, set_staticDeprecatedAttribute, nullptr),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sStaticAttributes[] = {
  { nullptr, &sStaticAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(2 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("passByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passByte_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalByteBeforeRequired", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalByteBeforeRequired_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalByteWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalByteWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalByteWithDefaultBeforeRequired", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalByteWithDefaultBeforeRequired_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableByte_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("returnByteSideEffectFree", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&returnByteSideEffectFree_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("returnDOMDependentByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&returnDOMDependentByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("returnConstantByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&returnConstantByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("returnDeviceStateDependentByte", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&returnDeviceStateDependentByte_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passShort", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passShort_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveShort", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveShort_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalShort", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalShort_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalShortWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalShortWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passLong_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalLongWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalLongWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passLongLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passLongLong_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveLongLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveLongLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalLongLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalLongLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalLongLongWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalLongLongWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOctet", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOctet_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveOctet", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveOctet_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalOctet", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalOctet_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalOctetWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalOctetWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnsignedShort", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnsignedShort_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUnsignedShort", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUnsignedShort_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnsignedShort", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnsignedShort_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnsignedShortWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnsignedShortWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnsignedLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnsignedLong_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUnsignedLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUnsignedLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnsignedLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnsignedLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnsignedLongWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnsignedLongWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnsignedLongLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnsignedLongLong_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUnsignedLongLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUnsignedLongLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnsignedLongLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnsignedLongLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnsignedLongLongWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnsignedLongLongWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passFloat", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passFloat_methodinfo), 16, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passLenientFloat", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passLenientFloat_methodinfo), 16, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveSelf_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableSelf_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakSelf_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakNullableSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakNullableSelf_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSelf_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableSelf_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSelf_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNonNullSelf", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNonNullSelf_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSelfWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSelfWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNonWrapperCacheInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNonWrapperCacheInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableNonWrapperCacheInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableNonWrapperCacheInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNonWrapperCacheInterfaceSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNonWrapperCacheInterfaceSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableNonWrapperCacheInterfaceSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableNonWrapperCacheInterfaceSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNonWrapperCacheInterfaceNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNonWrapperCacheInterfaceNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableNonWrapperCacheInterfaceNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableNonWrapperCacheInterfaceNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveExternal_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableExternal_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakExternal_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakNullableExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakNullableExternal_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passExternal_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableExternal_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalExternal_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNonNullExternal", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNonNullExternal_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalExternalWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalExternalWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveCallbackInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableCallbackInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakCallbackInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakNullableCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakNullableCallbackInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passCallbackInterface_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableCallbackInterface_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalCallbackInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNonNullCallbackInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNonNullCallbackInterface_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalCallbackInterfaceWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalCallbackInterfaceWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveSequenceOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveSequenceOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableSequenceOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableSequenceOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfNullableInts_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSequenceOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSequenceOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveCastableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveCastableObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveCallbackObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveCallbackObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableCastableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableCastableObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableCallbackObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableCallbackObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveCastableObjectNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveCastableObjectNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableCastableObjectNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableCastableObjectNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakCastableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakCastableObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakNullableCastableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakNullableCastableObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakCastableObjectNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakCastableObjectNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveWeakNullableCastableObjectNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveWeakNullableCastableObjectNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passCastableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passCastableObjectSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableCastableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableCastableObjectSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passCastableObjectNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passCastableObjectNullableSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableCastableObjectNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableCastableObjectNullableSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSequenceWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSequenceWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceWithDefaultValue2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceWithDefaultValue2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passExternalInterfaceSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passExternalInterfaceSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableExternalInterfaceSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableExternalInterfaceSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveStringSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveStringSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passStringSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passStringSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveByteStringSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveByteStringSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passByteStringSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passByteStringSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUTF8StringSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUTF8StringSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUTF8StringSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUTF8StringSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveAnySequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveAnySequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableAnySequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableAnySequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableObjectSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableObjectSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfSequences", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfSequences_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfSequencesOfSequences", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfSequencesOfSequences_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfNullableInts_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalRecordOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalRecordOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableRecordOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableRecordOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passCastableObjectRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passCastableObjectRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableCastableObjectRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableCastableObjectRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passCastableObjectNullableRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passCastableObjectNullableRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableCastableObjectNullableRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableCastableObjectNullableRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalRecord_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableRecord_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableRecordWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableRecordWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalObjectRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalObjectRecord_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passExternalInterfaceRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passExternalInterfaceRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableExternalInterfaceRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableExternalInterfaceRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passStringRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passStringRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passByteStringRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passByteStringRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUTF8StringRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUTF8StringRecord_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfRecords", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfRecords_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveRecord_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableRecord_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveRecordOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveRecordOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableRecordOfNullableInts", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableRecordOfNullableInts_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveAnyRecord", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveAnyRecord_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalArrayBuffer_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableArrayBuffer_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableArrayBufferWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableArrayBufferWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passArrayBufferView", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passArrayBufferView_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passInt8Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passInt8Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passInt16Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passInt16Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passInt32Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passInt32Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUint8Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUint8Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUint16Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUint16Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUint32Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUint32Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUint8ClampedArray", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUint8ClampedArray_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passFloat32Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passFloat32Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passFloat64Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passFloat64Array_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfArrayBuffers", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfArrayBuffers_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfNullableArrayBuffers", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfNullableArrayBuffers_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfArrayBuffers", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfArrayBuffers_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfNullableArrayBuffers", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfNullableArrayBuffers_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicTypedArray", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicTypedArray_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicNullableTypedArray", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicNullableTypedArray_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUint8Array", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUint8Array_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passString_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableString_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalStringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalStringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableStringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableStringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passByteString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passByteString_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableByteString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableByteString_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalByteString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalByteString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalByteStringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalByteStringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableByteString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableByteString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableByteStringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableByteStringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicByteString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicByteString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionByteString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionByteString_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnionByteString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnionByteString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnionByteStringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnionByteStringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUTF8String", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUTF8String_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUTF8String", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUTF8String_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUTF8String", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUTF8String_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUTF8StringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUTF8StringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableUTF8String", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableUTF8String_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableUTF8StringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableUTF8StringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicUTF8String", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicUTF8String_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionUTF8String", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionUTF8String_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnionUTF8String", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnionUTF8String_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnionUTF8StringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnionUTF8StringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSVS", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSVS_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableSVS", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableSVS_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSVS", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSVS_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSVSWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSVSWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSVS", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSVS_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSVSWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSVSWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicSVS", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicSVS_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveSVS", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveSVS_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passJSString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passJSString_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalJSStringWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalJSStringWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveJSString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveJSString_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passEnum_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableEnum_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalEnum_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passEnumWithDefault", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passEnumWithDefault_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableEnum_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableEnumWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableEnumWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableEnumWithDefaultValue2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableEnumWithDefaultValue2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveEnum_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableEnum_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passCallback_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableCallback_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalCallback_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableCallback_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableCallbackWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableCallbackWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveCallback_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableCallback_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableTreatAsNullCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableTreatAsNullCallback_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableTreatAsNullCallback", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableTreatAsNullCallback_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableTreatAsNullCallbackWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableTreatAsNullCallbackWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passAnyDefaultNull", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAnyDefaultNull_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableSequenceOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSequenceOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalSequenceOfAnyWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalSequenceOfAnyWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfSequenceOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfNullableSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfNullableSequenceOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableSequenceOfNullableSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableSequenceOfNullableSequenceOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceOfNullableSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceOfNullableSequenceOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableRecordOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalRecordOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableRecordOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalRecordOfAnyWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalRecordOfAnyWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfRecordOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfNullableRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfNullableRecordOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableRecordOfNullableRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableRecordOfNullableRecordOfAny_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableRecordOfNullableRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableRecordOfNullableRecordOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableRecordOfNullableSequenceOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableRecordOfNullableSequenceOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceOfNullableRecordOfAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceOfNullableRecordOfAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveAny", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveAny_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicNullableObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicNullableObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableObjectWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableObjectWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfNullableObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfNullableObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableSequenceOfObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableSequenceOfObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceOfNullableSequenceOfObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceOfNullableSequenceOfObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableSequenceOfNullableSequenceOfNullableObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableSequenceOfNullableSequenceOfNullableObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableObject_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnion_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithNullable", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithNullable_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnion_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalUnion_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableUnion_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalNullableUnionWithDefaultValue", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalNullableUnionWithDefaultValue_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithString_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithEnum", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithEnum_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithObject", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithObject_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue1", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue1_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue3", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue3_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue4", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue4_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue5", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue5_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue6", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue6_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue7", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue7_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue8", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue8_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue9", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue9_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue10", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue10_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue11", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue11_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue12", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue12_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue13", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue13_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue14", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue14_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue15", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue15_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue16", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue16_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue17", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue17_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue18", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue18_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue19", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue19_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue20", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue20_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue21", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue21_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue22", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue22_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue23", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue23_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue24", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue24_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionWithDefaultValue25", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionWithDefaultValue25_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue1", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue1_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue3", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue3_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue4", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue4_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue5", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue5_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue6", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue6_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue7", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue7_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue8", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue8_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue9", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue9_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue10", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue10_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue11", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue11_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue12", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue12_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue13", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue13_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue14", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue14_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue15", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue15_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue16", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue16_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue17", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue17_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue18", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue18_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue19", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue19_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue20", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue20_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue21", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue21_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue22", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue22_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue23", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue23_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue24", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue24_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue25", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue25_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue26", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue26_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue27", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue27_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passNullableUnionWithDefaultValue28", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passNullableUnionWithDefaultValue28_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfUnions", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfUnions_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfUnions2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfUnions2_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicUnion_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfNullableUnions", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfNullableUnions_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicNullableUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicNullableUnion_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfUnions", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfUnions_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUnion_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUnion2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUnion2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveUnionContainingNull", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveUnionContainingNull_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableUnion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableUnion_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableUnion2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableUnion2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passPromise", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passPromise_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOptionalPromise", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOptionalPromise_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passPromiseSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passPromiseSequence_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receivePromise", (GenericMethod<NormalThisPolicy, ConvertExceptionsToPromises>), reinterpret_cast<const JSJitInfo*>(&receivePromise_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveAddrefedPromise", (GenericMethod<NormalThisPolicy, ConvertExceptionsToPromises>), reinterpret_cast<const JSJitInfo*>(&receiveAddrefedPromise_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("methodRenamedFrom", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&methodRenamedFrom_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passDictionary", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passDictionary_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passDictionary2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passDictionary2_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveDictionary", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveDictionary_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveNullableDictionary", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveNullableDictionary_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passOtherDictionary", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passOtherDictionary_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passSequenceOfDictionaries", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passSequenceOfDictionaries_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passRecordOfDictionaries", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRecordOfDictionaries_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passDictionaryOrLong", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passDictionaryOrLong_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passDictContainingDict", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passDictContainingDict_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passDictContainingSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passDictContainingSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("receiveDictContainingSequence", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&receiveDictContainingSequence_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicDictionary", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicDictionary_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("dontEnforceRangeOrClamp", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&dontEnforceRangeOrClamp_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("doEnforceRange", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&doEnforceRange_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("doEnforceRangeNullable", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&doEnforceRangeNullable_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("doClamp", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&doClamp_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("doClampNullable", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&doClampNullable_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("exerciseTypedefInterfaces1", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&exerciseTypedefInterfaces1_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("exerciseTypedefInterfaces2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&exerciseTypedefInterfaces2_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("exerciseTypedefInterfaces3", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&exerciseTypedefInterfaces3_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("deprecatedMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&deprecatedMethod_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("deprecatedMethodWithContext", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&deprecatedMethodWithContext_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload1", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload1_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload2_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload3", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload3_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload4", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload4_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload5", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload5_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload6", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload6_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload7", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload7_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload8", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload8_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload9", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload9_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload10", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload10_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload11", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload11_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload12", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload12_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload13", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload13_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload14", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload14_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload15", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload15_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload16", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload16_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload17", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload17_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload18", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload18_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload19", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload19_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("overload20", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&overload20_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passVariadicThirdArg", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passVariadicThirdArg_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("prefable10", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&prefable10_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("prefable11", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&prefable11_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("prefable13", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&prefable13_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("prefable17", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&prefable17_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("prefable18", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&prefable18_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("prefable19", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&prefable19_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("conditionalOnSecureContext5", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&conditionalOnSecureContext5_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("conditionalOnSecureContext6", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&conditionalOnSecureContext6_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("conditionalOnSecureContext7", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&conditionalOnSecureContext7_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("conditionalOnSecureContext8", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&conditionalOnSecureContext8_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("passRenamedInterface", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passRenamedInterface_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("throwingMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&throwingMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("canOOMMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&canOOMMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("needsSubjectPrincipalMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&needsSubjectPrincipalMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("needsNonSystemSubjectPrincipalMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&needsNonSystemSubjectPrincipalMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("needsCallerTypeMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&needsCallerTypeMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("ceReactionsMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&ceReactionsMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("ceReactionsMethodOverload", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&ceReactionsMethodOverload_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passArgsWithDefaults", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passArgsWithDefaults_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("toJSON", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&toJSON_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("dashed-method", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&dashed_method_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("nonEnumerableMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&nonEnumerableMethod_methodinfo), 0, 0, nullptr),
  JS_FNSPEC("passAllowSharedArrayBufferViewTypedef", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAllowSharedArrayBufferViewTypedef_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passAllowSharedArrayBufferView", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAllowSharedArrayBufferView_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passAllowSharedNullableArrayBufferView", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAllowSharedNullableArrayBufferView_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passAllowSharedArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAllowSharedArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passAllowSharedNullableArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passAllowSharedNullableArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("passUnionAllowSharedArrayBuffer", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&passUnionAllowSharedArrayBuffer_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("toString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&__stringifier_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};

static const PrefableDisablers sMethods_disablers386 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, nullptr
};

static const PrefableDisablers sMethods_disablers388 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, &nsGenericHTMLElement::LegacyTouchAPIEnabled
};

static const PrefableDisablers sMethods_disablers391 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, &TestFuncControlledMember
};

static const PrefableDisablers sMethods_disablers393 = {
  WebIDLPrefIndex::NoPref, false, 0, &TestFuncControlledMember
};

static const PrefableDisablers sMethods_disablers396 = {
  WebIDLPrefIndex::NoPref, true, 0, nullptr
};

static const PrefableDisablers sMethods_disablers398 = {
  WebIDLPrefIndex::dom_webidl_test1, true, 0, nullptr
};

static const PrefableDisablers sMethods_disablers400 = {
  WebIDLPrefIndex::dom_webidl_test1, true, 0, &nsGenericHTMLElement::LegacyTouchAPIEnabled
};

static const PrefableDisablers sMethods_disablers402 = {
  WebIDLPrefIndex::dom_webidl_test1, true, 0, &TestFuncControlledMember
};

static const Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { &sMethods_disablers386, &sMethods_specs[386] },
  { &sMethods_disablers388, &sMethods_specs[388] },
  { &sMethods_disablers391, &sMethods_specs[391] },
  { &sMethods_disablers393, &sMethods_specs[393] },
  { &sMethods_disablers396, &sMethods_specs[396] },
  { &sMethods_disablers398, &sMethods_specs[398] },
  { &sMethods_disablers400, &sMethods_specs[400] },
  { &sMethods_disablers402, &sMethods_specs[402] },
  { nullptr, &sMethods_specs[404] },
  { nullptr, nullptr }
};

static_assert(10 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(385 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("readonlyByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyByte_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableByte_getterinfo, GenericSetter<NormalThisPolicy>, &writableByte_setterinfo),
  JSPropertySpec::nativeAccessors("cachedByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &cachedByte_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("cachedConstantByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &cachedConstantByte_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("cachedWritableByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &cachedWritableByte_getterinfo, GenericSetter<NormalThisPolicy>, &cachedWritableByte_setterinfo),
  JSPropertySpec::nativeAccessors("sideEffectFreeByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &sideEffectFreeByte_getterinfo, GenericSetter<NormalThisPolicy>, &sideEffectFreeByte_setterinfo),
  JSPropertySpec::nativeAccessors("domDependentByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &domDependentByte_getterinfo, GenericSetter<NormalThisPolicy>, &domDependentByte_setterinfo),
  JSPropertySpec::nativeAccessors("constantByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &constantByte_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("deviceStateDependentByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &deviceStateDependentByte_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("readonlyShort", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyShort_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableShort", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableShort_getterinfo, GenericSetter<NormalThisPolicy>, &writableShort_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyLong_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableLong_getterinfo, GenericSetter<NormalThisPolicy>, &writableLong_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyLongLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyLongLong_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableLongLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableLongLong_getterinfo, GenericSetter<NormalThisPolicy>, &writableLongLong_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyOctet", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyOctet_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableOctet", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableOctet_getterinfo, GenericSetter<NormalThisPolicy>, &writableOctet_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyUnsignedShort", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyUnsignedShort_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableUnsignedShort", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnsignedShort_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnsignedShort_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyUnsignedLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyUnsignedLong_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableUnsignedLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnsignedLong_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnsignedLong_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyUnsignedLongLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyUnsignedLongLong_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableUnsignedLongLong", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnsignedLongLong_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnsignedLongLong_setterinfo),
  JSPropertySpec::nativeAccessors("writableFloat", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableFloat_getterinfo, GenericSetter<NormalThisPolicy>, &writableFloat_setterinfo),
  JSPropertySpec::nativeAccessors("writableUnrestrictedFloat", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnrestrictedFloat_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnrestrictedFloat_setterinfo),
  JSPropertySpec::nativeAccessors("writableNullableFloat", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableNullableFloat_getterinfo, GenericSetter<NormalThisPolicy>, &writableNullableFloat_setterinfo),
  JSPropertySpec::nativeAccessors("writableNullableUnrestrictedFloat", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableNullableUnrestrictedFloat_getterinfo, GenericSetter<NormalThisPolicy>, &writableNullableUnrestrictedFloat_setterinfo),
  JSPropertySpec::nativeAccessors("writableDouble", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableDouble_getterinfo, GenericSetter<NormalThisPolicy>, &writableDouble_setterinfo),
  JSPropertySpec::nativeAccessors("writableUnrestrictedDouble", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnrestrictedDouble_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnrestrictedDouble_setterinfo),
  JSPropertySpec::nativeAccessors("writableNullableDouble", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableNullableDouble_getterinfo, GenericSetter<NormalThisPolicy>, &writableNullableDouble_setterinfo),
  JSPropertySpec::nativeAccessors("writableNullableUnrestrictedDouble", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableNullableUnrestrictedDouble_getterinfo, GenericSetter<NormalThisPolicy>, &writableNullableUnrestrictedDouble_setterinfo),
  JSPropertySpec::nativeAccessors("lenientFloatAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &lenientFloatAttr_getterinfo, GenericSetter<NormalThisPolicy>, &lenientFloatAttr_setterinfo),
  JSPropertySpec::nativeAccessors("lenientDoubleAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &lenientDoubleAttr_getterinfo, GenericSetter<NormalThisPolicy>, &lenientDoubleAttr_setterinfo),
  JSPropertySpec::nativeAccessors("nonNullSelf", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nonNullSelf_getterinfo, GenericSetter<NormalThisPolicy>, &nonNullSelf_setterinfo),
  JSPropertySpec::nativeAccessors("nullableSelf", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nullableSelf_getterinfo, GenericSetter<NormalThisPolicy>, &nullableSelf_setterinfo),
  JSPropertySpec::nativeAccessors("cachedSelf", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &cachedSelf_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("nonNullExternal", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nonNullExternal_getterinfo, GenericSetter<NormalThisPolicy>, &nonNullExternal_setterinfo),
  JSPropertySpec::nativeAccessors("nullableExternal", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nullableExternal_getterinfo, GenericSetter<NormalThisPolicy>, &nullableExternal_setterinfo),
  JSPropertySpec::nativeAccessors("nonNullCallbackInterface", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nonNullCallbackInterface_getterinfo, GenericSetter<NormalThisPolicy>, &nonNullCallbackInterface_setterinfo),
  JSPropertySpec::nativeAccessors("nullableCallbackInterface", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nullableCallbackInterface_getterinfo, GenericSetter<NormalThisPolicy>, &nullableCallbackInterface_setterinfo),
  JSPropertySpec::nativeAccessors("readonlySequence", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlySequence_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("readonlySequenceOfDictionaries", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlySequenceOfDictionaries_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("readonlyNullableSequenceOfDictionaries", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyNullableSequenceOfDictionaries_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("readonlyFrozenSequence", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyFrozenSequence_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("readonlyFrozenNullableSequence", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyFrozenNullableSequence_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("uint8ArrayAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &uint8ArrayAttr_getterinfo, GenericSetter<NormalThisPolicy>, &uint8ArrayAttr_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyJSStringAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyJSStringAttr_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("jsStringAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &jsStringAttr_getterinfo, GenericSetter<NormalThisPolicy>, &jsStringAttr_setterinfo),
  JSPropertySpec::nativeAccessors("enumAttribute", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &enumAttribute_getterinfo, GenericSetter<NormalThisPolicy>, &enumAttribute_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyEnumAttribute", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyEnumAttribute_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableUnion", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnion_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnion_setterinfo),
  JSPropertySpec::nativeAccessors("writableUnionContainingNull", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableUnionContainingNull_getterinfo, GenericSetter<NormalThisPolicy>, &writableUnionContainingNull_setterinfo),
  JSPropertySpec::nativeAccessors("writableNullableUnion", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableNullableUnion_getterinfo, GenericSetter<NormalThisPolicy>, &writableNullableUnion_setterinfo),
  JSPropertySpec::nativeAccessors("attributeGetterRenamedFrom", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &attributeGetterRenamedFrom_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("attributeRenamedFrom", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &attributeRenamedFrom_getterinfo, GenericSetter<NormalThisPolicy>, &attributeRenamedFrom_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyDictionary", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyDictionary_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("readonlyNullableDictionary", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyNullableDictionary_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableDictionary", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableDictionary_getterinfo, GenericSetter<NormalThisPolicy>, &writableDictionary_setterinfo),
  JSPropertySpec::nativeAccessors("readonlyFrozenDictionary", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyFrozenDictionary_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("readonlyFrozenNullableDictionary", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &readonlyFrozenNullableDictionary_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("writableFrozenDictionary", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &writableFrozenDictionary_getterinfo, GenericSetter<NormalThisPolicy>, &writableFrozenDictionary_setterinfo),
  JSPropertySpec::nativeAccessors("enforcedByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &enforcedByte_getterinfo, GenericSetter<NormalThisPolicy>, &enforcedByte_setterinfo),
  JSPropertySpec::nativeAccessors("enforcedByteNullable", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &enforcedByteNullable_getterinfo, GenericSetter<NormalThisPolicy>, &enforcedByteNullable_setterinfo),
  JSPropertySpec::nativeAccessors("clampedByte", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &clampedByte_getterinfo, GenericSetter<NormalThisPolicy>, &clampedByte_setterinfo),
  JSPropertySpec::nativeAccessors("clampedByteNullable", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &clampedByteNullable_getterinfo, GenericSetter<NormalThisPolicy>, &clampedByteNullable_setterinfo),
  JSPropertySpec::nativeAccessors("deprecatedAttribute", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &deprecatedAttribute_getterinfo, GenericSetter<NormalThisPolicy>, &deprecatedAttribute_setterinfo),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable1", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable1_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("prefable2", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable2_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable3", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable3_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("prefable4", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable4_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable5", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable5_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable6", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable6_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("prefable7", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable7_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable8", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable8_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable9", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable9_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable12", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable12_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("prefable14", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable14_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("prefable15", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable15_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("prefable16", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &prefable16_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("conditionalOnSecureContext1", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &conditionalOnSecureContext1_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("conditionalOnSecureContext2", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &conditionalOnSecureContext2_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("conditionalOnSecureContext3", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &conditionalOnSecureContext3_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("conditionalOnSecureContext4", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &conditionalOnSecureContext4_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("attrWithLenientThis", JSPROP_ENUMERATE, GenericGetter<LenientThisPolicy, ThrowExceptions>, &attrWithLenientThis_getterinfo, GenericSetter<LenientThisPolicy>, &attrWithLenientThis_setterinfo),
  JSPropertySpec::nativeAccessors("putForwardsAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &putForwardsAttr_getterinfo, GenericSetter<NormalThisPolicy>, &putForwardsAttr_setterinfo),
  JSPropertySpec::nativeAccessors("putForwardsAttr2", JSPROP_ENUMERATE, GenericGetter<LenientThisPolicy, ThrowExceptions>, &putForwardsAttr2_getterinfo, GenericSetter<LenientThisPolicy>, &putForwardsAttr2_setterinfo),
  JSPropertySpec::nativeAccessors("throwingAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &throwingAttr_getterinfo, GenericSetter<NormalThisPolicy>, &throwingAttr_setterinfo),
  JSPropertySpec::nativeAccessors("throwingGetterAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &throwingGetterAttr_getterinfo, GenericSetter<NormalThisPolicy>, &throwingGetterAttr_setterinfo),
  JSPropertySpec::nativeAccessors("throwingSetterAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &throwingSetterAttr_getterinfo, GenericSetter<NormalThisPolicy>, &throwingSetterAttr_setterinfo),
  JSPropertySpec::nativeAccessors("canOOMAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &canOOMAttr_getterinfo, GenericSetter<NormalThisPolicy>, &canOOMAttr_setterinfo),
  JSPropertySpec::nativeAccessors("canOOMGetterAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &canOOMGetterAttr_getterinfo, GenericSetter<NormalThisPolicy>, &canOOMGetterAttr_setterinfo),
  JSPropertySpec::nativeAccessors("canOOMSetterAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &canOOMSetterAttr_getterinfo, GenericSetter<NormalThisPolicy>, &canOOMSetterAttr_setterinfo),
  JSPropertySpec::nativeAccessors("needsSubjectPrincipalAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &needsSubjectPrincipalAttr_getterinfo, GenericSetter<NormalThisPolicy>, &needsSubjectPrincipalAttr_setterinfo),
  JSPropertySpec::nativeAccessors("needsNonSystemSubjectPrincipalAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &needsNonSystemSubjectPrincipalAttr_getterinfo, GenericSetter<NormalThisPolicy>, &needsNonSystemSubjectPrincipalAttr_setterinfo),
  JSPropertySpec::nativeAccessors("needsCallerTypeAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &needsCallerTypeAttr_getterinfo, GenericSetter<NormalThisPolicy>, &needsCallerTypeAttr_setterinfo),
  JSPropertySpec::nativeAccessors("ceReactionsAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &ceReactionsAttr_getterinfo, GenericSetter<NormalThisPolicy>, &ceReactionsAttr_setterinfo),
  JSPropertySpec::nativeAccessors("toJSONShouldSkipThis", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &toJSONShouldSkipThis_getterinfo, GenericSetter<NormalThisPolicy>, &toJSONShouldSkipThis_setterinfo),
  JSPropertySpec::nativeAccessors("toJSONShouldSkipThis2", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &toJSONShouldSkipThis2_getterinfo, GenericSetter<NormalThisPolicy>, &toJSONShouldSkipThis2_setterinfo),
  JSPropertySpec::nativeAccessors("toJSONShouldSkipThis3", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &toJSONShouldSkipThis3_getterinfo, GenericSetter<NormalThisPolicy>, &toJSONShouldSkipThis3_setterinfo),
  JSPropertySpec::nativeAccessors("dashed-attribute", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &dashed_attribute_getterinfo, GenericSetter<NormalThisPolicy>, &dashed_attribute_setterinfo),
  JSPropertySpec::nativeAccessors("nonEnumerableAttr", 0, GenericGetter<NormalThisPolicy, ThrowExceptions>, &nonEnumerableAttr_getterinfo, GenericSetter<NormalThisPolicy>, &nonEnumerableAttr_setterinfo),
  JSPropertySpec::nativeAccessors("allowSharedArrayBufferViewTypedef", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &allowSharedArrayBufferViewTypedef_getterinfo, GenericSetter<NormalThisPolicy>, &allowSharedArrayBufferViewTypedef_setterinfo),
  JSPropertySpec::nativeAccessors("allowSharedArrayBufferView", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &allowSharedArrayBufferView_getterinfo, GenericSetter<NormalThisPolicy>, &allowSharedArrayBufferView_setterinfo),
  JSPropertySpec::nativeAccessors("allowSharedNullableArrayBufferView", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &allowSharedNullableArrayBufferView_getterinfo, GenericSetter<NormalThisPolicy>, &allowSharedNullableArrayBufferView_setterinfo),
  JSPropertySpec::nativeAccessors("allowSharedArrayBuffer", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &allowSharedArrayBuffer_getterinfo, GenericSetter<NormalThisPolicy>, &allowSharedArrayBuffer_setterinfo),
  JSPropertySpec::nativeAccessors("allowSharedNullableArrayBuffer", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &allowSharedNullableArrayBuffer_getterinfo, GenericSetter<NormalThisPolicy>, &allowSharedNullableArrayBuffer_setterinfo),
  JS_STRING_SYM_PS(toStringTag, "TestExampleInterface", JSPROP_READONLY),
  JS_PS_END
};

static const PrefableDisablers sAttributes_disablers67 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, nullptr
};

static const PrefableDisablers sAttributes_disablers70 = {
  WebIDLPrefIndex::dom_webidl_test2, false, 0, nullptr
};

static const PrefableDisablers sAttributes_disablers73 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, nullptr
};

static const PrefableDisablers sAttributes_disablers75 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, &nsGenericHTMLElement::LegacyTouchAPIEnabled
};

static const PrefableDisablers sAttributes_disablers78 = {
  WebIDLPrefIndex::dom_webidl_test2, false, 0, &nsGenericHTMLElement::LegacyTouchAPIEnabled
};

static const PrefableDisablers sAttributes_disablers80 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, &nsGenericHTMLElement::LegacyTouchAPIEnabled
};

static const PrefableDisablers sAttributes_disablers82 = {
  WebIDLPrefIndex::dom_webidl_test1, false, 0, &TestFuncControlledMember
};

static const PrefableDisablers sAttributes_disablers85 = {
  WebIDLPrefIndex::NoPref, false, 0, &TestFuncControlledMember
};

static const PrefableDisablers sAttributes_disablers88 = {
  WebIDLPrefIndex::NoPref, true, 0, nullptr
};

static const PrefableDisablers sAttributes_disablers90 = {
  WebIDLPrefIndex::dom_webidl_test1, true, 0, nullptr
};

static const PrefableDisablers sAttributes_disablers92 = {
  WebIDLPrefIndex::dom_webidl_test1, true, 0, &nsGenericHTMLElement::LegacyTouchAPIEnabled
};

static const PrefableDisablers sAttributes_disablers94 = {
  WebIDLPrefIndex::dom_webidl_test1, true, 0, &TestFuncControlledMember
};

static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { &sAttributes_disablers67, &sAttributes_specs[67] },
  { &sAttributes_disablers70, &sAttributes_specs[70] },
  { &sAttributes_disablers73, &sAttributes_specs[73] },
  { &sAttributes_disablers75, &sAttributes_specs[75] },
  { &sAttributes_disablers78, &sAttributes_specs[78] },
  { &sAttributes_disablers80, &sAttributes_specs[80] },
  { &sAttributes_disablers82, &sAttributes_specs[82] },
  { &sAttributes_disablers85, &sAttributes_specs[85] },
  { &sAttributes_disablers88, &sAttributes_specs[88] },
  { &sAttributes_disablers90, &sAttributes_specs[90] },
  { &sAttributes_disablers92, &sAttributes_specs[92] },
  { &sAttributes_disablers94, &sAttributes_specs[94] },
  { nullptr, &sAttributes_specs[96] },
  { nullptr, nullptr }
};

static_assert(14 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(66 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sChromeAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("putForwardsAttr3", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &putForwardsAttr3_getterinfo, GenericSetter<NormalThisPolicy>, &putForwardsAttr3_setterinfo),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sChromeAttributes[] = {
  { nullptr, &sChromeAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sUnforgeableMethods_specs[] = {
  JS_FNSPEC("unforgeableMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&unforgeableMethod_methodinfo), 0, JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_READONLY, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sUnforgeableMethods[] = {
  { nullptr, &sUnforgeableMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sChromeUnforgeableMethods_specs[] = {
  JS_FNSPEC("unforgeableMethod2", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&unforgeableMethod2_methodinfo), 0, JSPROP_ENUMERATE | JSPROP_PERMANENT | JSPROP_READONLY, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sChromeUnforgeableMethods[] = {
  { nullptr, &sChromeUnforgeableMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sUnforgeableAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("unforgeableAttr", JSPROP_ENUMERATE | JSPROP_PERMANENT, GenericGetter<NormalThisPolicy, ThrowExceptions>, &unforgeableAttr_getterinfo, nullptr, nullptr),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sUnforgeableAttributes[] = {
  { nullptr, &sUnforgeableAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sChromeUnforgeableAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("unforgeableAttr2", JSPROP_ENUMERATE | JSPROP_PERMANENT, GenericGetter<NormalThisPolicy, ThrowExceptions>, &unforgeableAttr2_getterinfo, nullptr, nullptr),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sChromeUnforgeableAttributes[] = {
  { nullptr, &sChromeUnforgeableAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const ConstantSpec sConstants_specs[] = {
  { "myLongConstant", JS::Int32Value(5) },
  { "nonEnumerableConst", JS::BooleanValue(true) },
  { 0, JS::UndefinedValue() }
};


static const Prefable<const ConstantSpec> sConstants[] = {
  { nullptr, &sConstants_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(2 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[532];
static PropertyInfo sNativeProperties_propertyInfos[532];

static const NativePropertiesN<7> sNativeProperties = {
  true,  0 /* sStaticMethods */,
  true,  1 /* sStaticAttributes */,
  true,  2 /* sMethods */,
  true,  3 /* sAttributes */,
  true,  4 /* sUnforgeableMethods */,
  true,  5 /* sUnforgeableAttributes */,
  true,  6 /* sConstants */,
  -1,
  532,
  sNativeProperties_sortedPropertyIndices,
  {
    { sStaticMethods, &sNativeProperties_propertyInfos[0] },
    { sStaticAttributes, &sNativeProperties_propertyInfos[4] },
    { sMethods, &sNativeProperties_propertyInfos[6] },
    { sAttributes, &sNativeProperties_propertyInfos[421] },
    { sUnforgeableMethods, &sNativeProperties_propertyInfos[528] },
    { sUnforgeableAttributes, &sNativeProperties_propertyInfos[529] },
    { sConstants, &sNativeProperties_propertyInfos[530] }
  }
};
static_assert(532 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static uint16_t sChromeOnlyNativeProperties_sortedPropertyIndices[3];
static PropertyInfo sChromeOnlyNativeProperties_propertyInfos[3];

static const NativePropertiesN<3> sChromeOnlyNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sChromeAttributes */,
  true,  1 /* sChromeUnforgeableMethods */,
  true,  2 /* sChromeUnforgeableAttributes */,
  false, 0,
  -1,
  3,
  sChromeOnlyNativeProperties_sortedPropertyIndices,
  {
    { sChromeAttributes, &sChromeOnlyNativeProperties_propertyInfos[0] },
    { sChromeUnforgeableMethods, &sChromeOnlyNativeProperties_propertyInfos[1] },
    { sChromeUnforgeableAttributes, &sChromeOnlyNativeProperties_propertyInfos[2] }
  }
};
static_assert(3 < 1ull << (CHAR_BIT * sizeof(sChromeOnlyNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

MOZ_CAN_RUN_SCRIPT bool
CollectJSONAttributes(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::TestExampleInterface* self, JS::Rooted<JSObject*>& result)
{
  JS::Rooted<JSObject*> unwrappedObj(cx, js::CheckedUnwrapStatic(obj));
  if (!unwrappedObj) {
    // How did that happen?  We managed to get called with that
    // object as "this"!  Just give up on sanity.
    return false;
  }

  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_cachedByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "cachedByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_cachedConstantByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "cachedConstantByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_cachedWritableByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "cachedWritableByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_sideEffectFreeByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "sideEffectFreeByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_domDependentByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "domDependentByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_constantByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "constantByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_deviceStateDependentByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "deviceStateDependentByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyShort(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyShort", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableShort(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableShort", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyLongLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyLongLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableLongLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableLongLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyOctet(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyOctet", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableOctet(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableOctet", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyUnsignedShort(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyUnsignedShort", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableUnsignedShort(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableUnsignedShort", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyUnsignedLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyUnsignedLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableUnsignedLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableUnsignedLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyUnsignedLongLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyUnsignedLongLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableUnsignedLongLong(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableUnsignedLongLong", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableFloat(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableFloat", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableUnrestrictedFloat(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableUnrestrictedFloat", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableNullableFloat(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableNullableFloat", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableNullableUnrestrictedFloat(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableNullableUnrestrictedFloat", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableDouble(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableDouble", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableUnrestrictedDouble(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableUnrestrictedDouble", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableNullableDouble(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableNullableDouble", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_writableNullableUnrestrictedDouble(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "writableNullableUnrestrictedDouble", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_lenientFloatAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "lenientFloatAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_lenientDoubleAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "lenientDoubleAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_nonNullSelf(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "nonNullSelf", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_nullableSelf(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "nullableSelf", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_cachedSelf(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "cachedSelf", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlySequence(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlySequence", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyFrozenSequence(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyFrozenSequence", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyFrozenNullableSequence(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyFrozenNullableSequence", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyJSStringAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyJSStringAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_jsStringAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "jsStringAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_enumAttribute(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "enumAttribute", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_readonlyEnumAttribute(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "readonlyEnumAttribute", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_attributeGetterRenamedFrom(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "attributeGetterRenamedFrom", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_attributeRenamedFrom(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "attributeRenamedFrom", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_enforcedByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "enforcedByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_enforcedByteNullable(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "enforcedByteNullable", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_clampedByte(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "clampedByte", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_clampedByteNullable(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "clampedByteNullable", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_deprecatedAttribute(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "deprecatedAttribute", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable1, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable1(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable1", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable2, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable2(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable2", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable3, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable3(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable3", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable4, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable4(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable4", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable5, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable5(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable5", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable6, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable6(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable6", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable7, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable7(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable7", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable8, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable8(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable8", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable9, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable9(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable9", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable12, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable12(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable12", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable14, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable14(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable14", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable15, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable15(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable15", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_prefable16, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_prefable16(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "prefable16", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_conditionalOnSecureContext1, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_conditionalOnSecureContext1(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "conditionalOnSecureContext1", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_conditionalOnSecureContext2, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_conditionalOnSecureContext2(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "conditionalOnSecureContext2", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_conditionalOnSecureContext3, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_conditionalOnSecureContext3(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "conditionalOnSecureContext3", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  // This is unfortunately a linear scan through sAttributes, but we
  // only do it for things which _might_ be disabled, which should
  // help keep the performance problems down.
  if (IsGetterEnabled(cx, unwrappedObj, (JSJitGetterOp)get_conditionalOnSecureContext4, sAttributes)) {
    JS::Rooted<JS::Value> temp(cx);
    if (!get_conditionalOnSecureContext4(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "conditionalOnSecureContext4", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_attrWithLenientThis(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "attrWithLenientThis", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_unforgeableAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "unforgeableAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_unforgeableAttr2(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "unforgeableAttr2", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_putForwardsAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "putForwardsAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_putForwardsAttr2(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "putForwardsAttr2", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_putForwardsAttr3(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "putForwardsAttr3", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_throwingAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "throwingAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_throwingGetterAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "throwingGetterAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_throwingSetterAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "throwingSetterAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_canOOMAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "canOOMAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_canOOMGetterAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "canOOMGetterAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_canOOMSetterAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "canOOMSetterAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_needsSubjectPrincipalAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "needsSubjectPrincipalAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_needsNonSystemSubjectPrincipalAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "needsNonSystemSubjectPrincipalAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_needsCallerTypeAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "needsCallerTypeAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_ceReactionsAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "ceReactionsAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_dashed_attribute(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "dashed_attribute", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  { // scope for "temp"
    JS::Rooted<JS::Value> temp(cx);
    if (!get_nonEnumerableAttr(cx, obj, self, JSJitGetterCallArgs(&temp))) {
      return false;
    }
    if (!JS_DefineProperty(cx, result, "nonEnumerableAttr", temp, JSPROP_ENUMERATE)) {
      return false;
    }
  }
  return true;
}

static bool
_constructor(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "TestExampleInterface constructor");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleInterface", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "TestExampleInterface");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestExampleInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  unsigned argcount = std::min(args.length(), 2u);
  switch (argcount) {
    case 0: {
      GlobalObject global(cx, obj);
      if (global.Failed()) {
        return false;
      }

      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      Maybe<JSAutoRealm> ar;
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        obj = js::CheckedUnwrapStatic(obj);
        if (!obj) {
          return false;
        }
        ar.emplace(cx, obj);
        if (!JS_WrapObject(cx, &desiredProto)) {
          return false;
        }
      }
      auto result(StrongOrRawPtr<mozilla::dom::TestExampleInterface>(mozilla::dom::TestExampleInterface::Constructor(global)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case 1: {
      if (args[0].isNullOrUndefined()) {
        mozilla::dom::TestInterface* arg0;
        arg0 = nullptr;
        GlobalObject global(cx, obj);
        if (global.Failed()) {
          return false;
        }

        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        Maybe<JSAutoRealm> ar;
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          obj = js::CheckedUnwrapStatic(obj);
          if (!obj) {
            return false;
          }
          ar.emplace(cx, obj);
          if (!JS_WrapObject(cx, &desiredProto)) {
            return false;
          }
        }
        auto result(StrongOrRawPtr<mozilla::dom::TestExampleInterface>(mozilla::dom::TestExampleInterface::Constructor(global, MOZ_KnownLive(Constify(arg0)))));
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        static_assert(!std::is_pointer_v<decltype(result)>,
                      "NewObject implies that we need to keep the object alive with a strong reference.");
        if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        return true;
      }
      if (args[0].isObject()) {
        do {
          mozilla::dom::TestInterface* arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          GlobalObject global(cx, obj);
          if (global.Failed()) {
            return false;
          }

          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          Maybe<JSAutoRealm> ar;
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            obj = js::CheckedUnwrapStatic(obj);
            if (!obj) {
              return false;
            }
            ar.emplace(cx, obj);
            if (!JS_WrapObject(cx, &desiredProto)) {
              return false;
            }
          }
          auto result(StrongOrRawPtr<mozilla::dom::TestExampleInterface>(mozilla::dom::TestExampleInterface::Constructor(global, MOZ_KnownLive(Constify(arg0)))));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          static_assert(!std::is_pointer_v<decltype(result)>,
                        "NewObject implies that we need to keep the object alive with a strong reference.");
          if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (false);
        do {
          RootedSpiderMonkeyInterface<ArrayBuffer> arg0(cx);
          if (!arg0.Init(&args[0].toObject())) {
            break;
          }
          if (JS::IsSharedArrayBufferObject(arg0.Obj())) {
            cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
            return false;
          }
          if (JS::IsLargeArrayBufferMaybeShared(arg0.Obj())) {
            cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
            return false;
          }
          GlobalObject global(cx, obj);
          if (global.Failed()) {
            return false;
          }

          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          Maybe<JSAutoRealm> ar;
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            obj = js::CheckedUnwrapStatic(obj);
            if (!obj) {
              return false;
            }
            ar.emplace(cx, obj);
            if (!JS_WrapObject(cx, &desiredProto)) {
              return false;
            }
            if (!arg0.WrapIntoNewCompartment(cx)) {
              return false;
            }
          }
          auto result(StrongOrRawPtr<mozilla::dom::TestExampleInterface>(mozilla::dom::TestExampleInterface::Constructor(global, Constify(arg0))));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          static_assert(!std::is_pointer_v<decltype(result)>,
                        "NewObject implies that we need to keep the object alive with a strong reference.");
          if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (false);
        do {
          RootedSpiderMonkeyInterface<Uint8Array> arg0(cx);
          if (!arg0.Init(&args[0].toObject())) {
            break;
          }
          if (JS::IsArrayBufferViewShared(arg0.Obj())) {
            cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
            return false;
          }
          if (JS::IsLargeArrayBufferView(arg0.Obj())) {
            cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
            return false;
          }
          GlobalObject global(cx, obj);
          if (global.Failed()) {
            return false;
          }

          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          Maybe<JSAutoRealm> ar;
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            obj = js::CheckedUnwrapStatic(obj);
            if (!obj) {
              return false;
            }
            ar.emplace(cx, obj);
            if (!JS_WrapObject(cx, &desiredProto)) {
              return false;
            }
            if (!arg0.WrapIntoNewCompartment(cx)) {
              return false;
            }
          }
          auto result(StrongOrRawPtr<mozilla::dom::TestExampleInterface>(mozilla::dom::TestExampleInterface::Constructor(global, Constify(arg0))));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          static_assert(!std::is_pointer_v<decltype(result)>,
                        "NewObject implies that we need to keep the object alive with a strong reference.");
          if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (false);
      }
      GlobalObject global(cx, obj);
      if (global.Failed()) {
        return false;
      }

      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      Maybe<JSAutoRealm> ar;
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        obj = js::CheckedUnwrapStatic(obj);
        if (!obj) {
          return false;
        }
        ar.emplace(cx, obj);
        if (!JS_WrapObject(cx, &desiredProto)) {
          return false;
        }
      }
      auto result(StrongOrRawPtr<mozilla::dom::TestExampleInterface>(mozilla::dom::TestExampleInterface::Constructor(global, NonNullHelper(Constify(arg0)))));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case 2: {
      uint32_t arg0;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      if (args[1].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg1;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[1], arg1, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          GlobalObject global(cx, obj);
          if (global.Failed()) {
            return false;
          }

          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          Maybe<JSAutoRealm> ar;
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            obj = js::CheckedUnwrapStatic(obj);
            if (!obj) {
              return false;
            }
            ar.emplace(cx, obj);
            if (!JS_WrapObject(cx, &desiredProto)) {
              return false;
            }
          }
          auto result(StrongOrRawPtr<mozilla::dom::TestExampleInterface>(mozilla::dom::TestExampleInterface::Constructor(global, arg0, MOZ_KnownLive(NonNullHelper(arg1)))));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          static_assert(!std::is_pointer_v<decltype(result)>,
                        "NewObject implies that we need to keep the object alive with a strong reference.");
          if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (false);
      }
      GlobalObject global(cx, obj);
      if (global.Failed()) {
        return false;
      }

      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      Nullable<bool> arg1;
      if (args[1].isNullOrUndefined()) {
        arg1.SetNull();
      } else if (!ValueToPrimitive<bool, eDefault>(cx, args[1], "Argument 2", &arg1.SetValue())) {
        return false;
      }
      Maybe<JSAutoRealm> ar;
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        obj = js::CheckedUnwrapStatic(obj);
        if (!obj) {
          return false;
        }
        ar.emplace(cx, obj);
        if (!JS_WrapObject(cx, &desiredProto)) {
          return false;
        }
      }
      auto result(StrongOrRawPtr<mozilla::dom::TestExampleInterface>(mozilla::dom::TestExampleInterface::Constructor(global, arg0, Constify(arg1))));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSClassOps sInterfaceObjectClassOps = {
    nullptr,               /* addProperty */
    nullptr,               /* delProperty */
    nullptr,               /* enumerate */
    nullptr,               /* newEnumerate */
    nullptr,               /* resolve */
    nullptr,               /* mayResolve */
    nullptr,               /* finalize */
    _constructor, /* call */
    nullptr,               /* hasInstance */
    _constructor, /* construct */
    nullptr,               /* trace */
};

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE + 2 /* slots for the named constructors */),
    &sInterfaceObjectClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  sNativePropertyHooks,
  "function TestExampleInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

const NativePropertyHooks sNamedConstructorNativePropertyHooks = {
    nullptr,
    nullptr,
    nullptr,
    { nullptr, nullptr },
    prototypes::id::TestExampleInterface,
    constructors::id::TestExampleInterface,
    nullptr
};

static const NamedConstructor namedConstructors[] = {
  { "Example", { _Example, &sNamedConstructorNativePropertyHooks }, 0 },
  { "Example2", { _Example2, &sNamedConstructorNativePropertyHooks }, 1 },
  { nullptr, { nullptr, nullptr }, 0 }
};

MOZ_CAN_RUN_SCRIPT static bool
_legacycaller(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "TestExampleInterface legacy caller");
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  mozilla::dom::TestExampleInterface* self;
  JS::Rooted<JS::Value> rootSelf(cx, JS::ObjectValue(*obj));
  {
    // Our JSContext should be in the right global to do unwrapping in.
    nsresult rv = UnwrapObject<prototypes::id::TestExampleInterface, mozilla::dom::TestExampleInterface>(&rootSelf, self, cx);
    if (NS_FAILED(rv)) {
      MOZ_CRASH("Unexpected object in '_legacycaller' hook");
      return false;
    }
  }
  if (!args.requireAtLeast(cx, "TestExampleInterface legacy caller", 2)) {
    return false;
  }
  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  NonNull<mozilla::dom::TestInterface> arg1;
  if (args[1].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[1], arg1, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 2", "TestInterface");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 2");
    return false;
  }
  int16_t result(MOZ_KnownLive(self)->LegacyCall(args.thisv(), arg0, MOZ_KnownLive(NonNullHelper(arg1))));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestExampleInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE + 1 /* slot for the JSObject holding the unforgeable properties */),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestExampleInterface,
  PrototypeTraits<prototypes::id::TestExampleInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  _legacycaller, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestExampleInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(16),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestExampleInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestExampleInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestExampleInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestExampleInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(16 >= 16,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

static bool
UpdateMemberSlots(JSContext* aCx, JS::Handle<JSObject*> aWrapper, mozilla::dom::TestExampleInterface* aObject)
{
  JS::Rooted<JS::Value> temp(aCx);
  JSJitGetterCallArgs args(&temp);

  static_assert((DOM_INSTANCE_RESERVED_SLOTS + 1) < JS::shadow::Object::MAX_FIXED_SLOTS,
                "Not enough fixed slots to fit 'TestExampleInterface.cachedConstantByte.  Ion's visitGetDOMMemberV/visitGetDOMMemberT assume StoreInSlot things are all in fixed slots.");
  if (!get_cachedConstantByte(aCx, aWrapper, aObject, args)) {
    return false;
  }
  // Getter handled setting our reserved slots

  return true;
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestExampleInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestExampleInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestExampleInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestExampleInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestExampleInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestExampleInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);

  // Important: do unforgeable property setup after we have handed
  // over ownership of the C++ object to obj as needed, so that if
  // we fail and it ends up GCed it won't have problems in the
  // finalizer trying to drop its ownership of the C++ object.
  JS::Rooted<JSObject*> unforgeableHolder(aCx,
    &JS::GetReservedSlot(canonicalProto, DOM_INTERFACE_PROTO_SLOTS_BASE).toObject());
  if (!JS_InitializePropertiesFromCompatibleNativeObject(aCx, aReflector, unforgeableHolder)) {
    aCache->ReleaseWrapper(aObject);
    aCache->ClearWrapper();
    return false;
  }
  if (!UpdateMemberSlots(aCx, aReflector, aObject)) {
    aCache->ReleaseWrapper(aObject);
    aCache->ClearWrapper();
    return false;
  }
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

// This may allocate too many slots, because we only really need
// slots for our non-interface-typed members that we cache.  But
// allocating slots only for those would make the slot index
// computations much more complicated, so let's do this the simple
// way for now.
DEFINE_XRAY_EXPANDO_CLASS(static, sXrayExpandoObjectClass, 15);

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), sChromeOnlyNativeProperties.Upcast() },
  prototypes::id::TestExampleInterface,
  constructors::id::TestExampleInterface,
  nullptr,
  &sXrayExpandoObjectClass
} };

void
ClearCachedCachedByteValue(mozilla::dom::TestExampleInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 0), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 0));
}

void
ClearCachedCachedWritableByteValue(mozilla::dom::TestExampleInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 2), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 2));
}

void
ClearCachedCachedSelfValue(mozilla::dom::TestExampleInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 3), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 3));
}

void
ClearCachedReadonlySequenceValue(mozilla::dom::TestExampleInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 4), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 4));
}

void
ClearCachedReadonlySequenceOfDictionariesValue(mozilla::dom::TestExampleInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 5), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 5));
}

void
ClearCachedReadonlyNullableSequenceOfDictionariesValue(mozilla::dom::TestExampleInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 6), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 6));
}

void
ClearCachedReadonlyFrozenSequenceValue(mozilla::dom::TestExampleInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 7), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 7));
}

void
ClearCachedReadonlyFrozenNullableSequenceValue(mozilla::dom::TestExampleInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 8), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 8));
}

void
ClearCachedReadonlyDictionaryValue(mozilla::dom::TestExampleInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 9), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 9));
}

void
ClearCachedReadonlyNullableDictionaryValue(mozilla::dom::TestExampleInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 10), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 10));
}

void
ClearCachedWritableDictionaryValue(mozilla::dom::TestExampleInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 11), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 11));
}

void
ClearCachedReadonlyFrozenDictionaryValue(mozilla::dom::TestExampleInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 12), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 12));
}

void
ClearCachedReadonlyFrozenNullableDictionaryValue(mozilla::dom::TestExampleInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 13), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 13));
}

void
ClearCachedWritableFrozenDictionaryValue(mozilla::dom::TestExampleInterface* aObject)
{
  JSObject* obj;
  obj = aObject->GetWrapper();
  if (!obj) {
    return;
  }
  JS::SetReservedSlot(obj, (DOM_INSTANCE_RESERVED_SLOTS + 14), JS::UndefinedValue());
  xpc::ClearXrayExpandoSlots(obj, (xpc::JSSLOT_EXPANDO_COUNT + 14));
}

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    if (!InitIds(aCx, sChromeOnlyNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestExampleInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestExampleInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, namedConstructors,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              sChromeOnlyNativeProperties.Upcast(),
                              "TestExampleInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);

  JS::Rooted<JSObject*> unforgeableHolder(aCx);
  {
    JS::Rooted<JSObject*> holderProto(aCx, *protoCache);
    unforgeableHolder = JS_NewObjectWithoutMetadata(aCx, sClass.ToJSClass(), holderProto);
    if (!unforgeableHolder) {
      *protoCache = nullptr;
      if (interfaceCache) {
        *interfaceCache = nullptr;
      }
      return;
    }
  }

  if (!DefineUnforgeableAttributes(aCx, unforgeableHolder, sUnforgeableAttributes)) {
    *protoCache = nullptr;
    if (interfaceCache) {
      *interfaceCache = nullptr;
    }
    return;
  }
  if (nsContentUtils::ThreadsafeIsSystemCaller(aCx)) {
    if (!DefineUnforgeableAttributes(aCx, unforgeableHolder, sChromeUnforgeableAttributes)) {
      *protoCache = nullptr;
      if (interfaceCache) {
        *interfaceCache = nullptr;
      }
      return;
    }
  }
  if (!DefineUnforgeableMethods(aCx, unforgeableHolder, sUnforgeableMethods)) {
    *protoCache = nullptr;
    if (interfaceCache) {
      *interfaceCache = nullptr;
    }
    return;
  }
  if (nsContentUtils::ThreadsafeIsSystemCaller(aCx)) {
    if (!DefineUnforgeableMethods(aCx, unforgeableHolder, sChromeUnforgeableMethods)) {
      *protoCache = nullptr;
      if (interfaceCache) {
        *interfaceCache = nullptr;
      }
      return;
    }
  }

  if (*protoCache) {
    JS::SetReservedSlot(*protoCache, DOM_INTERFACE_PROTO_SLOTS_BASE,
                        JS::ObjectValue(*unforgeableHolder));
  }
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestExampleInterface_Binding



namespace TestExampleProxyInterface_Binding {

MOZ_CAN_RUN_SCRIPT static bool
longIndexedGetter(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleProxyInterface", "longIndexedGetter", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleProxyInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleProxyInterface.longIndexedGetter", 1)) {
    return false;
  }
  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  int32_t result(MOZ_KnownLive(self)->LongIndexedGetter(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo longIndexedGetter_methodinfo = {
  { (JSJitGetterOp)longIndexedGetter },
  { prototypes::id::TestExampleProxyInterface },
  { PrototypeTraits<prototypes::id::TestExampleProxyInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
longIndexedSetter(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleProxyInterface", "longIndexedSetter", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleProxyInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleProxyInterface.longIndexedSetter", 2)) {
    return false;
  }
  uint32_t arg0;
  if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->LongIndexedSetter(arg0, arg1))>, "Should be returning void here");
  MOZ_KnownLive(self)->LongIndexedSetter(arg0, arg1);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo longIndexedSetter_methodinfo = {
  { (JSJitGetterOp)longIndexedSetter },
  { prototypes::id::TestExampleProxyInterface },
  { PrototypeTraits<prototypes::id::TestExampleProxyInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_length(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleProxyInterface", "length", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleProxyInterface*>(void_self);
  uint32_t result(MOZ_KnownLive(self)->Length());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setNumber(result);
  return true;
}

static const JSJitInfo length_getterinfo = {
  { get_length },
  { prototypes::id::TestExampleProxyInterface },
  { PrototypeTraits<prototypes::id::TestExampleProxyInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
myStringifier(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleProxyInterface", "myStringifier", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleProxyInterface*>(void_self);
  DOMString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->MyStringifier(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->MyStringifier(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo myStringifier_methodinfo = {
  { (JSJitGetterOp)myStringifier },
  { prototypes::id::TestExampleProxyInterface },
  { PrototypeTraits<prototypes::id::TestExampleProxyInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
shortNameGetter(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleProxyInterface", "shortNameGetter", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleProxyInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleProxyInterface.shortNameGetter", 1)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  int16_t result(MOZ_KnownLive(self)->ShortNameGetter(NonNullHelper(Constify(arg0))));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setInt32(int32_t(result));
  return true;
}

static const JSJitInfo shortNameGetter_methodinfo = {
  { (JSJitGetterOp)shortNameGetter },
  { prototypes::id::TestExampleProxyInterface },
  { PrototypeTraits<prototypes::id::TestExampleProxyInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_INT32,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
shortNamedSetter(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleProxyInterface", "shortNamedSetter", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleProxyInterface*>(void_self);
  if (!args.requireAtLeast(cx, "TestExampleProxyInterface.shortNamedSetter", 2)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  int16_t arg1;
  if (!ValueToPrimitive<int16_t, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ShortNamedSetter(NonNullHelper(Constify(arg0)), arg1))>, "Should be returning void here");
  MOZ_KnownLive(self)->ShortNamedSetter(NonNullHelper(Constify(arg0)), arg1);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo shortNamedSetter_methodinfo = {
  { (JSJitGetterOp)shortNamedSetter },
  { prototypes::id::TestExampleProxyInterface },
  { PrototypeTraits<prototypes::id::TestExampleProxyInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("longIndexedGetter", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&longIndexedGetter_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("longIndexedSetter", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&longIndexedSetter_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("myStringifier", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&myStringifier_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("shortNameGetter", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&shortNameGetter_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("shortNamedSetter", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&shortNamedSetter_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_SYM_FNSPEC(iterator, nullptr, nullptr, 0, 0, "$ArrayValues"),
  JS_FNSPEC("toString", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&myStringifier_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(7 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("length", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &length_getterinfo, nullptr, nullptr),
  JS_STRING_SYM_PS(toStringTag, "TestExampleProxyInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(2 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[9];
static PropertyInfo sNativeProperties_propertyInfos[9];

static const NativePropertiesN<2> sNativeProperties = {
  false, 0,
  false, 0,
  true,  0 /* sMethods */,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  9,
  sNativeProperties_sortedPropertyIndices,
  {
    { sMethods, &sNativeProperties_propertyInfos[0] },
    { sAttributes, &sNativeProperties_propertyInfos[7] }
  }
};
static_assert(9 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestExampleProxyInterface,
  PrototypeTraits<prototypes::id::TestExampleProxyInterface>::Depth,
  sNativePropertyHooks,
  "function TestExampleProxyInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestExampleProxyInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestExampleProxyInterface,
  PrototypeTraits<prototypes::id::TestExampleProxyInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static_assert(std::is_base_of_v<nsISupports, mozilla::dom::TestExampleProxyInterface>,
                  "We don't support non-nsISupports native classes for "
                  "proxy-based bindings yet");


class DOMProxyHandler : public mozilla::dom::DOMProxyHandler
{
public:
  explicit constexpr DOMProxyHandler()
  {
  }

  bool
  getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const override;

  bool
  defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const override;

  using mozilla::dom::DOMProxyHandler::defineProperty;

  bool
  ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const override;

  bool
  hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const override;

  bool
  get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const override;

  const char*
  className(JSContext* cx, JS::Handle<JSObject*> proxy) const override;

  bool
  finalizeInBackground(const JS::Value& priv) const override;

  void
  finalize(JSFreeOp* fop, JSObject* proxy) const override;

  static const DOMProxyHandler*
  getInstance();

  bool
  delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const override;

  bool
  getElements(JSContext* cx, JS::Handle<JSObject*> proxy, uint32_t begin, uint32_t end, js::ElementAdder* adder) const override;

  bool
  setCustom(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::Value> v, bool* done) const override;

  size_t
  objectMoved(JSObject* obj, JSObject* old) const override;
};

MOZ_ALWAYS_INLINE bool
IsProxy(JSObject* obj)
{
  return js::IsProxy(obj) && js::GetProxyHandler(obj) == DOMProxyHandler::getInstance();
}

MOZ_ALWAYS_INLINE mozilla::dom::TestExampleProxyInterface*
UnwrapProxy(JSObject* obj)
{
  MOZ_ASSERT(js::IsProxy(obj));
  if (js::GetProxyHandler(obj) != DOMProxyHandler::getInstance()) {
    MOZ_ASSERT(xpc::WrapperFactory::IsXrayWrapper(obj));
    obj = js::UncheckedUnwrap(obj);
  }
  MOZ_ASSERT(IsProxy(obj));
  return static_cast<mozilla::dom::TestExampleProxyInterface*>(js::GetProxyReservedSlot(obj, DOM_OBJECT_SLOT).toPrivate());
}

bool
DOMProxyHandler::getOwnPropDescriptor(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool ignoreNamedProps, JS::MutableHandle<JS::PropertyDescriptor> desc) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    uint32_t ix = index;
    mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
    bool found = false;
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(ix, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    if (found) {
      desc.value().setInt32(int32_t(result));
      FillPropertyDescriptor(desc, proxy, false);
      return true;
    }
  }

  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = GetExpandoObject(proxy))) {
    if (!JS_GetOwnPropertyDescriptorById(cx, expando, id, desc)) {
      return false;
    }
    if (desc.object()) {
      // Pretend the property lives on the wrapper.
      desc.object().set(proxy);
      return true;
    }
  }

  bool callNamedGetter = false;
  if (!IsArrayIndex(index) && !ignoreNamedProps) {
    bool hasOnProto;
    if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
      return false;
    }
    callNamedGetter = !hasOnProto;
  }
  if (callNamedGetter) {
    FakeString<char16_t> nom;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, nom, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
      bool found = false;
      int16_t result(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(nom)), found));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));

      if (found) {
        desc.value().setInt32(int32_t(result));
        FillPropertyDescriptor(desc, proxy, false, true);
        return true;
      }
    }
  }

  desc.object().set(nullptr);
  return true;
}

bool
DOMProxyHandler::defineProperty(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::PropertyDescriptor> desc, JS::ObjectOpResult& opresult, bool* done) const
{
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    JSContext* cx = cx_;
    *done = true;
    // https://heycam.github.io/webidl/#legacy-platform-object-defineownproperty
    // Step 1.1.  The no-indexed-setter case is handled by step 1.2.
    if (!desc.isDataDescriptor()) {
      return opresult.failNotDataDescriptor();
    }

    uint32_t y = index;
    mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
    JS::Rooted<JS::Value> rootedValue(cx, desc.value());
    int32_t z;
    if (!ValueToPrimitive<int32_t, eDefault>(cx, desc.value(), "Value being assigned to TestExampleProxyInterface setter", &z)) {
      return false;
    }
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->IndexedSetter(y, z))>, "Should be returning void here");
    MOZ_KnownLive(self)->IndexedSetter(y, z);
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    return opresult.succeed();
  }
  JSContext* cx = cx_;
  FakeString<char16_t> me;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, me, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
    JS::Rooted<JS::Value> rootedValue(cx, desc.value());
    int16_t value;
    if (!ValueToPrimitive<int16_t, eDefault>(cx, desc.value(), "Value being assigned to TestExampleProxyInterface setter", &value)) {
      return false;
    }
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedSetter(NonNullHelper(Constify(me)), value))>, "Should be returning void here");
    MOZ_KnownLive(self)->NamedSetter(NonNullHelper(Constify(me)), value);
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    *done = true;
    return opresult.succeed();
  }
  return mozilla::dom::DOMProxyHandler::defineProperty(cx_, proxy, id, desc, opresult, done);
}


bool
DOMProxyHandler::ownPropNames(JSContext* cx, JS::Handle<JSObject*> proxy, unsigned flags, JS::MutableHandleVector<jsid> props) const
{
  bool isXray = xpc::WrapperFactory::IsXrayWrapper(proxy);

  uint32_t length = UnwrapProxy(proxy)->Length();
  MOZ_ASSERT(int32_t(length) >= 0);
  for (int32_t i = 0; i < int32_t(length); ++i) {
    if (!props.append(INT_TO_JSID(i))) {
      return false;
    }
  }

  nsTArray<nsString> names;
  UnwrapProxy(proxy)->GetSupportedNames(names);
  if (!AppendNamedPropertyIds(cx, proxy, names, false, props)) {
    return false;
  }

  JS::Rooted<JSObject*> expando(cx);
  if (!isXray &&(expando = DOMProxyHandler::GetExpandoObject(proxy)) &&
      !js::GetPropertyKeys(cx, expando, flags, props)) {
    return false;
  }

  return true;
}

bool
DOMProxyHandler::hasOwn(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, bool* bp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    bool found = false;
    uint32_t ix = index;
    mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(ix, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;

    *bp = found;
    return true;
  }


  JS::Rooted<JSObject*> expando(cx, GetExpandoObject(proxy));
  if (expando) {
    bool b = true;
    bool ok = JS_HasPropertyById(cx, expando, id, &b);
    *bp = !!b;
    if (!ok || *bp) {
      return ok;
    }
  }

  bool hasOnProto;
  if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
    return false;
  }
  if (!hasOnProto) {
    bool found = false;
    FakeString<char16_t> nom;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, nom, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
      int16_t result(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(nom)), found));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      (void)result;
    }

    *bp = found;
    return true;
  }
  *bp = false;
  return true;
}

bool
DOMProxyHandler::get(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<JS::Value> receiver, JS::Handle<jsid> id, JS::MutableHandle<JS::Value> vp) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
              "Should not have a XrayWrapper here");

  JS::Rooted<JS::Value> rootedReceiver(cx, receiver);

  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    uint32_t ix = index;
    mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
    bool found = false;
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(ix, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    if (found) {
      vp.setInt32(int32_t(result));
      return true;
    }
    // Even if we don't have this index, we don't forward the
    // get on to our expando object.
  } else {
    bool expandoHasProp = false;
    { // Scope for expando
      JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
      if (expando) {
        if (!JS_HasPropertyById(cx, expando, id, &expandoHasProp)) {
          return false;
        }

        if (expandoHasProp) {
          // Forward the get to the expando object, but our receiver is whatever our
          // receiver is.
          if (!JS_ForwardGetPropertyTo(cx, expando, id, rootedReceiver, vp)) {
            return false;
          }
        }
      }
    }

    if (expandoHasProp) {
      return true;
    }
  }

  bool foundOnPrototype;
  if (!GetPropertyOnPrototype(cx, proxy, rootedReceiver, id, &foundOnPrototype, vp)) {
    return false;
  }

  if (foundOnPrototype) {
    return true;
  }

  if (!IsArrayIndex(index)) {
    FakeString<char16_t> nom;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, nom, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
      bool found = false;
      int16_t result(MOZ_KnownLive(self)->NamedGetter(NonNullHelper(Constify(nom)), found));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));

      if (found) {
        vp.setInt32(int32_t(result));
        return true;
      }
    }
  }

  vp.setUndefined();
  return true;
}

const char*
DOMProxyHandler::className(JSContext* cx, JS::Handle<JSObject*> proxy) const
{
  return "TestExampleProxyInterface";
}

bool
DOMProxyHandler::finalizeInBackground(const JS::Value& priv) const
{
  return false;
}

void
DOMProxyHandler::finalize(JSFreeOp* fop, JSObject* proxy) const
{
  mozilla::dom::TestExampleProxyInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestExampleProxyInterface>(proxy);
  if (self) {
    JS::SetReservedSlot(proxy, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, proxy);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(proxy, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestExampleProxyInterface>(self);
  }
}

const DOMProxyHandler*
DOMProxyHandler::getInstance()
{
  static const DOMProxyHandler instance;
  return &instance;
}

bool
DOMProxyHandler::delete_(JSContext* cx, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
            "Should not have a XrayWrapper here");

  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    bool deleteSucceeded;
    bool found = false;
    uint32_t ix = index;
    mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(ix, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    (void)result;
    deleteSucceeded = !found;
    return deleteSucceeded ? opresult.succeed() : opresult.failCantDelete();
  }
  // Try named delete only if the named property visibility
  // algorithm says the property is visible.
  bool tryNamedDelete = true;
  { // Scope for expando
    JS::Rooted<JSObject*> expando(cx, DOMProxyHandler::GetExpandoObject(proxy));
    if (expando) {
      bool hasProp;
      if (!JS_HasPropertyById(cx, expando, id, &hasProp)) {
        return false;
      }
      tryNamedDelete = !hasProp;
    }
  }
  if (tryNamedDelete) {
    bool hasOnProto;
    if (!HasPropertyOnPrototype(cx, proxy, id, &hasOnProto)) {
      return false;
    }
    tryNamedDelete = !hasOnProto;
  }
  if (tryNamedDelete) {
    bool found = false;
    bool deleteSucceeded;
    FakeString<char16_t> nomnom;
    bool isSymbol;
    if (!ConvertIdToString(cx, id, nomnom, isSymbol)) {
      return false;
    }
    if (!isSymbol) {
      mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedDeleter(NonNullHelper(Constify(nomnom)), found))>, "Should be returning void here");
      MOZ_KnownLive(self)->NamedDeleter(NonNullHelper(Constify(nomnom)), found);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
    }
    deleteSucceeded = true;
    if (found) {
      return deleteSucceeded ? opresult.succeed() : opresult.failCantDelete();
    }
  }

  return dom::DOMProxyHandler::delete_(cx, proxy, id, opresult);
}

bool
DOMProxyHandler::getElements(JSContext* cx, JS::Handle<JSObject*> proxy, uint32_t begin, uint32_t end, js::ElementAdder* adder) const
{
  JS::Rooted<JS::Value> temp(cx);
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
             "Should not have a XrayWrapper here");

  mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
  uint32_t length = self->Length();
  // Compute the end of the indices we'll get ourselves
  uint32_t ourEnd = std::max(begin, std::min(end, length));

  for (uint32_t index = begin; index < ourEnd; ++index) {
    uint32_t ix = index;
    bool found = false;
    int32_t result(MOZ_KnownLive(self)->IndexedGetter(ix, found));
    MOZ_ASSERT(!JS_IsExceptionPending(cx));

    MOZ_ASSERT(found);
    temp.setInt32(int32_t(result));
    if (!adder->append(cx, temp)) return false;
    continue;
  }

  if (end > ourEnd) {
    JS::Rooted<JSObject*> proto(cx);
    if (!js::GetObjectProto(cx, proxy, &proto)) {
      return false;
    }
    return js::GetElementsWithAdder(cx, proto, proxy, ourEnd, end, adder);
  }

  return true;
}

bool
DOMProxyHandler::setCustom(JSContext* cx_, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::Handle<JS::Value> v, bool* done) const
{
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy),
             "Should not have a XrayWrapper here");
  uint32_t index = GetArrayIndexFromId(id);
  if (IsArrayIndex(index)) {
    JSContext* cx = cx_;
    uint32_t y = index;
    mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
    JS::Rooted<JS::Value> rootedValue(cx, v);
    int32_t z;
    if (!ValueToPrimitive<int32_t, eDefault>(cx, v, "Value being assigned to TestExampleProxyInterface setter", &z)) {
      return false;
    }
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->IndexedSetter(y, z))>, "Should be returning void here");
    MOZ_KnownLive(self)->IndexedSetter(y, z);
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
    *done = true;
    return true;
  }

  *done = false;
  return true;
}

size_t
DOMProxyHandler::objectMoved(JSObject* obj, JSObject* old) const
{
  mozilla::dom::TestExampleProxyInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestExampleProxyInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

static const DOMJSClass sClass = {
  PROXY_CLASS_DEF("TestExampleProxyInterface",
                  JSCLASS_IS_DOMJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(1)),
  { prototypes::id::TestExampleProxyInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestExampleProxyInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestExampleProxyInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestExampleProxyInterface>::Get(),
  nullptr,
  nullptr
};

bool
Wrap(JSContext* aCx, mozilla::dom::TestExampleProxyInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestExampleProxyInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestExampleProxyInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestExampleProxyInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestExampleProxyInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    DOMProxyHandler::getInstance()->finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestExampleProxyInterface> creator(aCx);
  creator.CreateProxyObject(aCx, &sClass.mBase, DOMProxyHandler::getInstance(),
                            proto, /* aLazyProto = */ false,
                            aObject, JS::UndefinedHandleValue, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

static bool
ResolveOwnProperty(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::MutableHandle<JS::PropertyDescriptor> desc)
{
  return js::GetProxyHandler(obj)->getOwnPropertyDescriptor(cx, wrapper, id, desc);
}

static bool
EnumerateOwnProperties(JSContext* cx, JS::Handle<JSObject*> wrapper, JS::Handle<JSObject*> obj, JS::MutableHandleVector<jsid> props)
{
  return js::GetProxyHandler(obj)->ownPropertyKeys(cx, wrapper, props);
}

static bool
DeleteNamedProperty(JSContext* cx, JS::Handle<JSObject*> xray, JS::Handle<JSObject*> proxy, JS::Handle<jsid> id, JS::ObjectOpResult& opresult)
{
  MOZ_ASSERT(xpc::WrapperFactory::IsXrayWrapper(xray));
  MOZ_ASSERT(js::IsProxy(proxy));
  MOZ_ASSERT(!xpc::WrapperFactory::IsXrayWrapper(proxy));
  JSAutoRealm ar(cx, proxy);
  bool deleteSucceeded = false;
  bool found = false;
  FakeString<char16_t> nomnom;
  bool isSymbol;
  if (!ConvertIdToString(cx, id, nomnom, isSymbol)) {
    return false;
  }
  if (!isSymbol) {
    mozilla::dom::TestExampleProxyInterface* self = UnwrapProxy(proxy);
    // NOTE: This assert does NOT call the function.
    static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NamedDeleter(NonNullHelper(Constify(nomnom)), found))>, "Should be returning void here");
    MOZ_KnownLive(self)->NamedDeleter(NonNullHelper(Constify(nomnom)), found);
    MOZ_ASSERT(!JS_IsExceptionPending(cx));
  }
  deleteSucceeded = true;
  if (!found || deleteSucceeded) {
    return opresult.succeed();
  }
  return opresult.failCantDelete();
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  ResolveOwnProperty,
  EnumerateOwnProperties,
  DeleteNamedProperty,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestExampleProxyInterface,
  constructors::id::TestExampleProxyInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestExampleProxyInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestExampleProxyInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestExampleProxyInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestExampleProxyInterface_Binding



namespace TestExampleThrowingConstructorInterface_Binding {

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestExampleThrowingConstructorInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestExampleThrowingConstructorInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestExampleThrowingConstructorInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestExampleThrowingConstructorInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestExampleThrowingConstructorInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestExampleThrowingConstructorInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestExampleThrowingConstructorInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestExampleThrowingConstructorInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestExampleThrowingConstructorInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "TestExampleThrowingConstructorInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static bool
_constructor(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "TestExampleThrowingConstructorInterface constructor");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleThrowingConstructorInterface", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "TestExampleThrowingConstructorInterface");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::TestExampleThrowingConstructorInterface,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  unsigned argcount = std::min(args.length(), 2u);
  switch (argcount) {
    case 0: {
      GlobalObject global(cx, obj);
      if (global.Failed()) {
        return false;
      }

      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      Maybe<JSAutoRealm> ar;
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        obj = js::CheckedUnwrapStatic(obj);
        if (!obj) {
          return false;
        }
        ar.emplace(cx, obj);
        if (!JS_WrapObject(cx, &desiredProto)) {
          return false;
        }
      }
      FastErrorResult rv;
      auto result(StrongOrRawPtr<mozilla::dom::TestExampleThrowingConstructorInterface>(mozilla::dom::TestExampleThrowingConstructorInterface::Constructor(global, rv)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestExampleThrowingConstructorInterface constructor"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case 1: {
      if (args[0].isNullOrUndefined()) {
        mozilla::dom::TestInterface* arg0;
        arg0 = nullptr;
        GlobalObject global(cx, obj);
        if (global.Failed()) {
          return false;
        }

        bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
        Maybe<JSAutoRealm> ar;
        if (objIsXray) {
          // Since our object is an Xray, we can just CheckedUnwrapStatic:
          // we know Xrays have no dynamic unwrap behavior.
          obj = js::CheckedUnwrapStatic(obj);
          if (!obj) {
            return false;
          }
          ar.emplace(cx, obj);
          if (!JS_WrapObject(cx, &desiredProto)) {
            return false;
          }
        }
        FastErrorResult rv;
        auto result(StrongOrRawPtr<mozilla::dom::TestExampleThrowingConstructorInterface>(mozilla::dom::TestExampleThrowingConstructorInterface::Constructor(global, MOZ_KnownLive(Constify(arg0)), rv)));
        if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestExampleThrowingConstructorInterface constructor"))) {
          return false;
        }
        MOZ_ASSERT(!JS_IsExceptionPending(cx));
        static_assert(!std::is_pointer_v<decltype(result)>,
                      "NewObject implies that we need to keep the object alive with a strong reference.");
        if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
          MOZ_ASSERT(JS_IsExceptionPending(cx));
          return false;
        }
        return true;
      }
      if (args[0].isObject()) {
        do {
          mozilla::dom::TestInterface* arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          GlobalObject global(cx, obj);
          if (global.Failed()) {
            return false;
          }

          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          Maybe<JSAutoRealm> ar;
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            obj = js::CheckedUnwrapStatic(obj);
            if (!obj) {
              return false;
            }
            ar.emplace(cx, obj);
            if (!JS_WrapObject(cx, &desiredProto)) {
              return false;
            }
          }
          FastErrorResult rv;
          auto result(StrongOrRawPtr<mozilla::dom::TestExampleThrowingConstructorInterface>(mozilla::dom::TestExampleThrowingConstructorInterface::Constructor(global, MOZ_KnownLive(Constify(arg0)), rv)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestExampleThrowingConstructorInterface constructor"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          static_assert(!std::is_pointer_v<decltype(result)>,
                        "NewObject implies that we need to keep the object alive with a strong reference.");
          if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (false);
        do {
          RootedSpiderMonkeyInterface<ArrayBuffer> arg0(cx);
          if (!arg0.Init(&args[0].toObject())) {
            break;
          }
          if (JS::IsSharedArrayBufferObject(arg0.Obj())) {
            cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
            return false;
          }
          if (JS::IsLargeArrayBufferMaybeShared(arg0.Obj())) {
            cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
            return false;
          }
          GlobalObject global(cx, obj);
          if (global.Failed()) {
            return false;
          }

          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          Maybe<JSAutoRealm> ar;
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            obj = js::CheckedUnwrapStatic(obj);
            if (!obj) {
              return false;
            }
            ar.emplace(cx, obj);
            if (!JS_WrapObject(cx, &desiredProto)) {
              return false;
            }
            if (!arg0.WrapIntoNewCompartment(cx)) {
              return false;
            }
          }
          FastErrorResult rv;
          auto result(StrongOrRawPtr<mozilla::dom::TestExampleThrowingConstructorInterface>(mozilla::dom::TestExampleThrowingConstructorInterface::Constructor(global, Constify(arg0), rv)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestExampleThrowingConstructorInterface constructor"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          static_assert(!std::is_pointer_v<decltype(result)>,
                        "NewObject implies that we need to keep the object alive with a strong reference.");
          if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (false);
        do {
          RootedSpiderMonkeyInterface<Uint8Array> arg0(cx);
          if (!arg0.Init(&args[0].toObject())) {
            break;
          }
          if (JS::IsArrayBufferViewShared(arg0.Obj())) {
            cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_SHARED>("Argument 1");
            return false;
          }
          if (JS::IsLargeArrayBufferView(arg0.Obj())) {
            cx.ThrowErrorMessage<MSG_TYPEDARRAY_IS_LARGE>("Argument 1");
            return false;
          }
          GlobalObject global(cx, obj);
          if (global.Failed()) {
            return false;
          }

          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          Maybe<JSAutoRealm> ar;
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            obj = js::CheckedUnwrapStatic(obj);
            if (!obj) {
              return false;
            }
            ar.emplace(cx, obj);
            if (!JS_WrapObject(cx, &desiredProto)) {
              return false;
            }
            if (!arg0.WrapIntoNewCompartment(cx)) {
              return false;
            }
          }
          FastErrorResult rv;
          auto result(StrongOrRawPtr<mozilla::dom::TestExampleThrowingConstructorInterface>(mozilla::dom::TestExampleThrowingConstructorInterface::Constructor(global, Constify(arg0), rv)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestExampleThrowingConstructorInterface constructor"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          static_assert(!std::is_pointer_v<decltype(result)>,
                        "NewObject implies that we need to keep the object alive with a strong reference.");
          if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (false);
      }
      GlobalObject global(cx, obj);
      if (global.Failed()) {
        return false;
      }

      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      Maybe<JSAutoRealm> ar;
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        obj = js::CheckedUnwrapStatic(obj);
        if (!obj) {
          return false;
        }
        ar.emplace(cx, obj);
        if (!JS_WrapObject(cx, &desiredProto)) {
          return false;
        }
      }
      FastErrorResult rv;
      auto result(StrongOrRawPtr<mozilla::dom::TestExampleThrowingConstructorInterface>(mozilla::dom::TestExampleThrowingConstructorInterface::Constructor(global, NonNullHelper(Constify(arg0)), rv)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestExampleThrowingConstructorInterface constructor"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case 2: {
      uint32_t arg0;
      if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      if (args[1].isObject()) {
        do {
          NonNull<mozilla::dom::TestInterface> arg1;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::TestInterface, mozilla::dom::TestInterface>(args[1], arg1, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          GlobalObject global(cx, obj);
          if (global.Failed()) {
            return false;
          }

          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          Maybe<JSAutoRealm> ar;
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            obj = js::CheckedUnwrapStatic(obj);
            if (!obj) {
              return false;
            }
            ar.emplace(cx, obj);
            if (!JS_WrapObject(cx, &desiredProto)) {
              return false;
            }
          }
          FastErrorResult rv;
          auto result(StrongOrRawPtr<mozilla::dom::TestExampleThrowingConstructorInterface>(mozilla::dom::TestExampleThrowingConstructorInterface::Constructor(global, arg0, MOZ_KnownLive(NonNullHelper(arg1)), rv)));
          if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestExampleThrowingConstructorInterface constructor"))) {
            return false;
          }
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          static_assert(!std::is_pointer_v<decltype(result)>,
                        "NewObject implies that we need to keep the object alive with a strong reference.");
          if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (false);
      }
      GlobalObject global(cx, obj);
      if (global.Failed()) {
        return false;
      }

      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      Nullable<bool> arg1;
      if (args[1].isNullOrUndefined()) {
        arg1.SetNull();
      } else if (!ValueToPrimitive<bool, eDefault>(cx, args[1], "Argument 2", &arg1.SetValue())) {
        return false;
      }
      Maybe<JSAutoRealm> ar;
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        obj = js::CheckedUnwrapStatic(obj);
        if (!obj) {
          return false;
        }
        ar.emplace(cx, obj);
        if (!JS_WrapObject(cx, &desiredProto)) {
          return false;
        }
      }
      FastErrorResult rv;
      auto result(StrongOrRawPtr<mozilla::dom::TestExampleThrowingConstructorInterface>(mozilla::dom::TestExampleThrowingConstructorInterface::Constructor(global, arg0, Constify(arg1), rv)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "TestExampleThrowingConstructorInterface constructor"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSClassOps sInterfaceObjectClassOps = {
    nullptr,               /* addProperty */
    nullptr,               /* delProperty */
    nullptr,               /* enumerate */
    nullptr,               /* newEnumerate */
    nullptr,               /* resolve */
    nullptr,               /* mayResolve */
    nullptr,               /* finalize */
    _constructor, /* call */
    nullptr,               /* hasInstance */
    _constructor, /* construct */
    nullptr,               /* trace */
};

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sInterfaceObjectClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestExampleThrowingConstructorInterface,
  PrototypeTraits<prototypes::id::TestExampleThrowingConstructorInterface>::Depth,
  sNativePropertyHooks,
  "function TestExampleThrowingConstructorInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestExampleThrowingConstructorInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestExampleThrowingConstructorInterface,
  PrototypeTraits<prototypes::id::TestExampleThrowingConstructorInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestExampleThrowingConstructorInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestExampleThrowingConstructorInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestExampleThrowingConstructorInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestExampleThrowingConstructorInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestExampleThrowingConstructorInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestExampleThrowingConstructorInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestExampleThrowingConstructorInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestExampleThrowingConstructorInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestExampleThrowingConstructorInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestExampleThrowingConstructorInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestExampleThrowingConstructorInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestExampleThrowingConstructorInterface,
  constructors::id::TestExampleThrowingConstructorInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestExampleThrowingConstructorInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestExampleThrowingConstructorInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestExampleThrowingConstructorInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestExampleThrowingConstructorInterface_Binding



namespace TestExampleWorkerInterface_Binding {

MOZ_CAN_RUN_SCRIPT static bool
needsSubjectPrincipalMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleWorkerInterface", "needsSubjectPrincipalMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleWorkerInterface*>(void_self);
  Maybe<nsIPrincipal*> subjectPrincipal;
  if (NS_IsMainThread()) {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);

    subjectPrincipal.emplace(principal);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NeedsSubjectPrincipalMethod(MOZ_KnownLive(subjectPrincipal)))>, "Should be returning void here");
  MOZ_KnownLive(self)->NeedsSubjectPrincipalMethod(MOZ_KnownLive(subjectPrincipal));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo needsSubjectPrincipalMethod_methodinfo = {
  { (JSJitGetterOp)needsSubjectPrincipalMethod },
  { prototypes::id::TestExampleWorkerInterface },
  { PrototypeTraits<prototypes::id::TestExampleWorkerInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_needsSubjectPrincipalAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleWorkerInterface", "needsSubjectPrincipalAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleWorkerInterface*>(void_self);
  Maybe<nsIPrincipal*> subjectPrincipal;
  if (NS_IsMainThread()) {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);

    subjectPrincipal.emplace(principal);
  }
  bool result(MOZ_KnownLive(self)->NeedsSubjectPrincipalAttr(MOZ_KnownLive(subjectPrincipal)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_needsSubjectPrincipalAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleWorkerInterface", "needsSubjectPrincipalAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleWorkerInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  Maybe<nsIPrincipal*> subjectPrincipal;
  if (NS_IsMainThread()) {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);

    subjectPrincipal.emplace(principal);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNeedsSubjectPrincipalAttr(arg0, MOZ_KnownLive(subjectPrincipal)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNeedsSubjectPrincipalAttr(arg0, MOZ_KnownLive(subjectPrincipal));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo needsSubjectPrincipalAttr_getterinfo = {
  { get_needsSubjectPrincipalAttr },
  { prototypes::id::TestExampleWorkerInterface },
  { PrototypeTraits<prototypes::id::TestExampleWorkerInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo needsSubjectPrincipalAttr_setterinfo = {
  { (JSJitGetterOp)set_needsSubjectPrincipalAttr },
  { prototypes::id::TestExampleWorkerInterface },
  { PrototypeTraits<prototypes::id::TestExampleWorkerInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
needsCallerTypeMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleWorkerInterface", "needsCallerTypeMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleWorkerInterface*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NeedsCallerTypeMethod(nsContentUtils::ThreadsafeIsSystemCaller(cx) ? CallerType::System : CallerType::NonSystem))>, "Should be returning void here");
  MOZ_KnownLive(self)->NeedsCallerTypeMethod(nsContentUtils::ThreadsafeIsSystemCaller(cx) ? CallerType::System : CallerType::NonSystem);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo needsCallerTypeMethod_methodinfo = {
  { (JSJitGetterOp)needsCallerTypeMethod },
  { prototypes::id::TestExampleWorkerInterface },
  { PrototypeTraits<prototypes::id::TestExampleWorkerInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_needsCallerTypeAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleWorkerInterface", "needsCallerTypeAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleWorkerInterface*>(void_self);
  bool result(MOZ_KnownLive(self)->NeedsCallerTypeAttr(nsContentUtils::ThreadsafeIsSystemCaller(cx) ? CallerType::System : CallerType::NonSystem));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_needsCallerTypeAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleWorkerInterface", "needsCallerTypeAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleWorkerInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNeedsCallerTypeAttr(arg0, nsContentUtils::ThreadsafeIsSystemCaller(cx) ? CallerType::System : CallerType::NonSystem))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNeedsCallerTypeAttr(arg0, nsContentUtils::ThreadsafeIsSystemCaller(cx) ? CallerType::System : CallerType::NonSystem);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo needsCallerTypeAttr_getterinfo = {
  { get_needsCallerTypeAttr },
  { prototypes::id::TestExampleWorkerInterface },
  { PrototypeTraits<prototypes::id::TestExampleWorkerInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo needsCallerTypeAttr_setterinfo = {
  { (JSJitGetterOp)set_needsCallerTypeAttr },
  { prototypes::id::TestExampleWorkerInterface },
  { PrototypeTraits<prototypes::id::TestExampleWorkerInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
needsNonSystemSubjectPrincipalMethod(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleWorkerInterface", "needsNonSystemSubjectPrincipalMethod", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleWorkerInterface*>(void_self);
  Maybe<nsIPrincipal*> subjectPrincipal;
  if (NS_IsMainThread()) {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);
    if (principal->IsSystemPrincipal()) {
      principal = nullptr;
    }

    subjectPrincipal.emplace(principal);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->NeedsNonSystemSubjectPrincipalMethod(MOZ_KnownLive(subjectPrincipal)))>, "Should be returning void here");
  MOZ_KnownLive(self)->NeedsNonSystemSubjectPrincipalMethod(MOZ_KnownLive(subjectPrincipal));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo needsNonSystemSubjectPrincipalMethod_methodinfo = {
  { (JSJitGetterOp)needsNonSystemSubjectPrincipalMethod },
  { prototypes::id::TestExampleWorkerInterface },
  { PrototypeTraits<prototypes::id::TestExampleWorkerInterface>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_needsNonSystemSubjectPrincipalAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleWorkerInterface", "needsNonSystemSubjectPrincipalAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleWorkerInterface*>(void_self);
  Maybe<nsIPrincipal*> subjectPrincipal;
  if (NS_IsMainThread()) {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);
    if (principal->IsSystemPrincipal()) {
      principal = nullptr;
    }

    subjectPrincipal.emplace(principal);
  }
  bool result(MOZ_KnownLive(self)->NeedsNonSystemSubjectPrincipalAttr(MOZ_KnownLive(subjectPrincipal)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_needsNonSystemSubjectPrincipalAttr(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TestExampleWorkerInterface", "needsNonSystemSubjectPrincipalAttr", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TestExampleWorkerInterface*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  Maybe<nsIPrincipal*> subjectPrincipal;
  if (NS_IsMainThread()) {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);
    if (principal->IsSystemPrincipal()) {
      principal = nullptr;
    }

    subjectPrincipal.emplace(principal);
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetNeedsNonSystemSubjectPrincipalAttr(arg0, MOZ_KnownLive(subjectPrincipal)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetNeedsNonSystemSubjectPrincipalAttr(arg0, MOZ_KnownLive(subjectPrincipal));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo needsNonSystemSubjectPrincipalAttr_getterinfo = {
  { get_needsNonSystemSubjectPrincipalAttr },
  { prototypes::id::TestExampleWorkerInterface },
  { PrototypeTraits<prototypes::id::TestExampleWorkerInterface>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo needsNonSystemSubjectPrincipalAttr_setterinfo = {
  { (JSJitGetterOp)set_needsNonSystemSubjectPrincipalAttr },
  { prototypes::id::TestExampleWorkerInterface },
  { PrototypeTraits<prototypes::id::TestExampleWorkerInterface>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::TestExampleWorkerInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestExampleWorkerInterface>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TestExampleWorkerInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestExampleWorkerInterface>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TestExampleWorkerInterface>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::TestExampleWorkerInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestExampleWorkerInterface>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::TestExampleWorkerInterface* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TestExampleWorkerInterface>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("needsSubjectPrincipalMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&needsSubjectPrincipalMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("needsCallerTypeMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&needsCallerTypeMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("needsNonSystemSubjectPrincipalMethod", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&needsNonSystemSubjectPrincipalMethod_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(3 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("needsSubjectPrincipalAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &needsSubjectPrincipalAttr_getterinfo, GenericSetter<NormalThisPolicy>, &needsSubjectPrincipalAttr_setterinfo),
  JSPropertySpec::nativeAccessors("needsCallerTypeAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &needsCallerTypeAttr_getterinfo, GenericSetter<NormalThisPolicy>, &needsCallerTypeAttr_setterinfo),
  JSPropertySpec::nativeAccessors("needsNonSystemSubjectPrincipalAttr", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &needsNonSystemSubjectPrincipalAttr_getterinfo, GenericSetter<NormalThisPolicy>, &needsNonSystemSubjectPrincipalAttr_setterinfo),
  JS_STRING_SYM_PS(toStringTag, "TestExampleWorkerInterface", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(4 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[7];
static PropertyInfo sNativeProperties_propertyInfos[7];

static const NativePropertiesN<2> sNativeProperties = {
  false, 0,
  false, 0,
  true,  0 /* sMethods */,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  7,
  sNativeProperties_sortedPropertyIndices,
  {
    { sMethods, &sNativeProperties_propertyInfos[0] },
    { sAttributes, &sNativeProperties_propertyInfos[3] }
  }
};
static_assert(7 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TestExampleWorkerInterface,
  PrototypeTraits<prototypes::id::TestExampleWorkerInterface>::Depth,
  sNativePropertyHooks,
  "function TestExampleWorkerInterface() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TestExampleWorkerInterfacePrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TestExampleWorkerInterface,
  PrototypeTraits<prototypes::id::TestExampleWorkerInterface>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TestExampleWorkerInterface",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TestExampleWorkerInterface, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TestExampleWorkerInterface>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TestExampleWorkerInterface>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TestExampleWorkerInterface>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TestExampleWorkerInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::TestExampleWorkerInterface>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::TestExampleWorkerInterface*>(aObject) ==
             reinterpret_cast<mozilla::dom::TestExampleWorkerInterface*>(aObject),
             "Multiple inheritance for mozilla::dom::TestExampleWorkerInterface is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TestExampleWorkerInterface> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TestExampleWorkerInterface,
  constructors::id::TestExampleWorkerInterface,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TestExampleWorkerInterface);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TestExampleWorkerInterface);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TestExampleWorkerInterface", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TestExampleWorkerInterface_Binding



} // namespace dom
} // namespace mozilla
