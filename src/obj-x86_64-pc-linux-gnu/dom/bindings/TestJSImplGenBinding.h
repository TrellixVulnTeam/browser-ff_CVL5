/* THIS FILE IS AUTOGENERATED FROM TestJSImplGen.webidl BY Codegen.py - DO NOT EDIT */

#ifndef mozilla_dom_TestJSImplGenBinding_h
#define mozilla_dom_TestJSImplGenBinding_h

#include "js/RootingAPI.h"
#include "js/TypeDecls.h"
#include "mozilla/ArrayUtils.h"
#include "mozilla/ErrorResult.h"
#include "mozilla/Span.h"
#include "mozilla/dom/BindingDeclarations.h"
#include "mozilla/dom/CallbackFunction.h"
#include "mozilla/dom/CallbackInterface.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/PrototypeList.h"
#include "mozilla/dom/Record.h"
#include "mozilla/dom/ToJSValue.h"
#include "mozilla/dom/TypedArray.h"
#include "nsWeakReference.h"

class nsRenamedInterface;

namespace mozilla {
namespace dom {

class ArrayBufferOrLong;
class ByteStringOrLong;
class CanvasPatternOrCanvasGradient;
class CanvasPatternOrNullOrCanvasGradient;
struct Dict;
struct DictContainingDict;
struct DictContainingSequence;
struct DictForConstructor;
class DocGroup;
class DoubleOrByteString;
class DoubleOrString;
class DoubleOrSupportedType;
class DoubleOrUSVString;
class DoubleOrUTF8String;
class FloatOrString;
struct GrandparentDict;
class MyTestCallback;
struct NativePropertyHooks;
class ObjectOrLong;
class ObjectOrNullOrLong;
class OwningArrayBufferOrLong;
class OwningByteStringOrLong;
class OwningCanvasPatternOrCanvasGradient;
class OwningCanvasPatternOrNullOrCanvasGradient;
class OwningDoubleOrByteString;
class OwningDoubleOrString;
class OwningDoubleOrSupportedType;
class OwningDoubleOrUSVString;
class OwningDoubleOrUTF8String;
class OwningFloatOrString;
class OwningObjectOrLong;
class OwningObjectOrNullOrLong;
class OwningStringOrArrayBuffer;
class OwningStringOrMaybeSharedArrayBuffer;
class OwningStringOrObject;
class OwningSupportedTypeOrObject;
class OwningUTF8StringOrLong;
class OwningUnrestrictedDoubleOrString;
class OwningUnrestrictedFloatOrString;
class Promise;
class ProtoAndIfaceCache;
class StringOrArrayBuffer;
class StringOrMaybeSharedArrayBuffer;
class StringOrObject;
class SupportedTypeOrObject;
class TestCImplementedInterface;
class TestCImplementedInterface2;
struct TestCImplementedInterface2Atoms;
struct TestCImplementedInterfaceAtoms;
class TestCallbackInterface;
class TestExternalInterface;
class TestInterface;
class TestJSImplInterface;
struct TestJSImplInterfaceAtoms;
class TestJSImplNoInterfaceObject;
struct TestJSImplNoInterfaceObjectAtoms;
class TestNonWrapperCacheInterface;
class TestParentInterface;
class TestTreatAsNullCallback;
class UTF8StringOrLong;
class UnrestrictedDoubleOrString;
class UnrestrictedFloatOrString;

} // namespace dom
} // namespace mozilla

namespace mozilla {
namespace dom {

enum class MyTestEnum : uint8_t {
  A,
  B,
  EndGuard_
};

namespace MyTestEnumValues {
extern const EnumEntry strings[3];

static constexpr size_t Count = 2;

// Our "strings" contains an extra entry with a null string.
static_assert(mozilla::ArrayLength(strings) - 1 == Count,
              "Mismatch between enum strings and enum count");

static_assert(static_cast<size_t>(MyTestEnum::EndGuard_) == Count,
              "Mismatch between enum value and enum count");

inline auto GetString(MyTestEnum stringId) {
  MOZ_ASSERT(static_cast<uint8_t>(stringId) < Count);
  const EnumEntry& entry = strings[static_cast<uint8_t>(stringId)];
  return Span<const char>{entry.value, entry.length};
}
} // namespace MyTestEnumValues

bool
ToJSValue(JSContext* aCx, MyTestEnum aArgument, JS::MutableHandle<JS::Value> aValue);


class MyTestCallback : public CallbackFunction
{
public:
  explicit inline MyTestCallback(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline MyTestCallback(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackFunction(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline MyTestCallback(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackFunction(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
    MOZ_ASSERT(JS::IsCallable(mCallback));
  }

  explicit inline MyTestCallback(CallbackFunction* aOther)
    : CallbackFunction(aOther)
  {
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "MyTestCallback";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    JS::Rooted<JS::Value> thisValJS(s.GetContext());
    if (!ToJSValue(s.GetContext(), thisVal, &thisValJS)) {
      aRv.Throw(NS_ERROR_FAILURE);
      return;
    }
    return Call(s.GetCallContext(), thisValJS, aRv);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(ErrorResult& aRv, const char* aExecutionReason = nullptr, ExceptionHandling aExceptionHandling = eReportExceptions, JS::Realm* aRealm = nullptr)
  {
    MOZ_ASSERT(!aRv.Failed(), "Don't pass an already-failed ErrorResult to a callback!");
    if (!aExecutionReason) {
      aExecutionReason = "MyTestCallback";
    }
    CallSetup s(this, aRv, aExecutionReason, aExceptionHandling, aRealm);
    if (!s.GetContext()) {
      MOZ_ASSERT(aRv.Failed());
      return;
    }
    return Call(s.GetCallContext(), JS::UndefinedHandleValue, aRv);
  }

  template <typename T>
  MOZ_CAN_RUN_SCRIPT inline void
  Call(const T& thisVal, const char* aExecutionReason = nullptr)
  {
    return Call(thisVal, IgnoreErrors(), aExecutionReason);
  }

  MOZ_CAN_RUN_SCRIPT inline void
  Call(const char* aExecutionReason = nullptr)
  {
    return Call(IgnoreErrors(), aExecutionReason, eReportExceptions, nullptr);
  }

  inline bool
  operator==(const MyTestCallback& aOther) const
  {
    return CallbackFunction::operator==(aOther);
  }

private:
  MOZ_CAN_RUN_SCRIPT void Call(BindingCallContext& cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv);
};


namespace binding_detail {
class FastMyTestCallback : public MyTestCallback
{
public:
  explicit inline FastMyTestCallback(JSObject* aCallback, JSObject* aCallbackGlobal)
    : MyTestCallback(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  inline void
  Trace(JSTracer* aTracer)
  {
    MyTestCallback::Trace(aTracer);
  }

  inline void
  FinishSlowJSInitIfMoreThanOneOwner(JSContext* aCx)
  {
    MyTestCallback::FinishSlowJSInitIfMoreThanOneOwner(aCx);
  }
};
} // namespace binding_detail


namespace TestCImplementedInterface_Binding {

  typedef mozilla::dom::TestCImplementedInterface NativeType;

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestCImplementedInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  JSObject*
  GetProtoObject(JSContext* aCx);

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestCImplementedInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestCImplementedInterface_Binding



namespace TestCImplementedInterface2_Binding {

  typedef mozilla::dom::TestCImplementedInterface2 NativeType;

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestCImplementedInterface2,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  JSObject*
  GetProtoObject(JSContext* aCx);

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestCImplementedInterface2,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestCImplementedInterface2_Binding



namespace TestJSImplInterface_Binding {

  typedef mozilla::dom::TestJSImplInterface NativeType;

  static const int32_t myLongConstant = 5;
  static const bool nonEnumerableConst = true;
  MOZ_CAN_RUN_SCRIPT bool
  CollectJSONAttributes(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::TestJSImplInterface* self, JS::Rooted<JSObject*>& result);

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestJSImplInterface* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestJSImplInterface,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

  JSObject*
  GetProtoObject(JSContext* aCx);

  inline JS::Handle<JSObject*> GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal = true)
  {
    /* Get the interface object for this class.  This will create the object as
       needed. */

    return GetPerInterfaceObjectHandle(aCx, constructors::id::TestJSImplInterface,
                                       &CreateInterfaceObjects,
                                       aDefineOnGlobal);
  }

  JSObject*
  GetConstructorObject(JSContext* aCx);

} // namespace TestJSImplInterface_Binding



namespace TestJSImplNoInterfaceObject_Binding {

  typedef mozilla::dom::TestJSImplNoInterfaceObject NativeType;

  const JSClass*
  GetJSClass();

  bool
  Wrap(JSContext* aCx, mozilla::dom::TestJSImplNoInterfaceObject* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector);

  template <class T>
  inline JSObject* Wrap(JSContext* aCx, T* aObject, JS::Handle<JSObject*> aGivenProto)
  {
    JS::Rooted<JSObject*> reflector(aCx);
    return Wrap(aCx, aObject, aObject, aGivenProto, &reflector) ? reflector.get() : nullptr;
  }

  // We declare this as an array so that retrieving a pointer to this
  // binding's property hooks only requires compile/link-time resolvable
  // address arithmetic.  Declaring it as a pointer instead would require
  // doing a run-time load to fetch a pointer to this binding's property
  // hooks.  And then structures which embedded a pointer to this structure
  // would require a run-time load for proper initialization, which would
  // then induce static constructors.  Lots of static constructors.
  extern const NativePropertyHooks sNativePropertyHooks[];

  void
  CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal);

  inline JS::Handle<JSObject*> GetProtoObjectHandle(JSContext* aCx)
  {
    /* Get the interface prototype object for this class.  This will create the
       object as needed. */
    return GetPerInterfaceObjectHandle(aCx, prototypes::id::TestJSImplNoInterfaceObject,
                                       &CreateInterfaceObjects,
                                       /* aDefineOnGlobal = */ true);

  }

} // namespace TestJSImplNoInterfaceObject_Binding



class TestJSImplInterfaceJSImpl : public CallbackInterface
{
public:
  explicit inline TestJSImplInterfaceJSImpl(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackInterface(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
  }

  explicit inline TestJSImplInterfaceJSImpl(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackInterface(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  explicit inline TestJSImplInterfaceJSImpl(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackInterface(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
  }

  void PassByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t ReceiveByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalByte(const Optional<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalByteBeforeRequired(const Optional<int8_t>& arg1, int8_t arg2, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalByteWithDefault(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalByteWithDefaultBeforeRequired(int8_t arg1, int8_t arg2, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableByte(const Nullable<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableByte(const Optional<Nullable<int8_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicByte(const nsTArray<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t ReturnByteSideEffectFree(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t ReturnDOMDependentByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t ReturnConstantByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t ReturnDeviceStateDependentByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassShort(int16_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int16_t ReceiveShort(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalShort(const Optional<int16_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalShortWithDefault(int16_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassLong(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int32_t ReceiveLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalLong(const Optional<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalLongWithDefault(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassLongLong(int64_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int64_t ReceiveLongLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalLongLong(const Optional<int64_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalLongLongWithDefault(int64_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOctet(uint8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  uint8_t ReceiveOctet(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalOctet(const Optional<uint8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalOctetWithDefault(uint8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnsignedShort(uint16_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  uint16_t ReceiveUnsignedShort(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnsignedShort(const Optional<uint16_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnsignedShortWithDefault(uint16_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnsignedLong(uint32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  uint32_t ReceiveUnsignedLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnsignedLong(const Optional<uint32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnsignedLongWithDefault(uint32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnsignedLongLong(uint64_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  uint64_t ReceiveUnsignedLongLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnsignedLongLong(const Optional<uint64_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnsignedLongLongWithDefault(uint64_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassFloat(float arg1, float arg2, const Nullable<float>& arg3, const Nullable<float>& arg4, double arg5, double arg6, const Nullable<double>& arg7, const Nullable<double>& arg8, const Sequence<float>& arg9, const Sequence<float>& arg10, const Sequence<Nullable<float>>& arg11, const Sequence<Nullable<float>>& arg12, const Sequence<double>& arg13, const Sequence<double>& arg14, const Sequence<Nullable<double>>& arg15, const Sequence<Nullable<double>>& arg16, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassLenientFloat(float arg1, float arg2, const Nullable<float>& arg3, const Nullable<float>& arg4, double arg5, double arg6, const Nullable<double>& arg7, const Nullable<double>& arg8, const Sequence<float>& arg9, const Sequence<float>& arg10, const Sequence<Nullable<float>>& arg11, const Sequence<Nullable<float>>& arg12, const Sequence<double>& arg13, const Sequence<double>& arg14, const Sequence<Nullable<double>>& arg15, const Sequence<Nullable<double>>& arg16, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestJSImplInterface> ReceiveSelf(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestJSImplInterface> ReceiveNullableSelf(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestJSImplInterface> ReceiveWeakSelf(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestJSImplInterface> ReceiveWeakNullableSelf(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSelf(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableSelf(TestJSImplInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalSelf(const Optional<TestJSImplInterface*>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNonNullSelf(const Optional<NonNull<TestJSImplInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalSelfWithDefault(TestJSImplInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestNonWrapperCacheInterface> ReceiveNonWrapperCacheInterface(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestNonWrapperCacheInterface> ReceiveNullableNonWrapperCacheInterface(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNonWrapperCacheInterfaceSequence(nsTArray<RefPtr<TestNonWrapperCacheInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableNonWrapperCacheInterfaceSequence(nsTArray<RefPtr<TestNonWrapperCacheInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNonWrapperCacheInterfaceNullableSequence(Nullable<nsTArray<RefPtr<TestNonWrapperCacheInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableNonWrapperCacheInterfaceNullableSequence(Nullable<nsTArray<RefPtr<TestNonWrapperCacheInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestExternalInterface> ReceiveExternal(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestExternalInterface> ReceiveNullableExternal(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestExternalInterface> ReceiveWeakExternal(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestExternalInterface> ReceiveWeakNullableExternal(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassExternal(TestExternalInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableExternal(TestExternalInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalExternal(const Optional<TestExternalInterface*>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNonNullExternal(const Optional<TestExternalInterface*>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalExternalWithDefault(TestExternalInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestCallbackInterface> ReceiveCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestCallbackInterface> ReceiveNullableCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestCallbackInterface> ReceiveWeakCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestCallbackInterface> ReceiveWeakNullableCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassCallbackInterface(TestCallbackInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableCallbackInterface(TestCallbackInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalCallbackInterface(const Optional<RefPtr<TestCallbackInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNonNullCallbackInterface(const Optional<OwningNonNull<TestCallbackInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalCallbackInterfaceWithDefault(TestCallbackInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveSequence(nsTArray<int32_t>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableSequence(Nullable<nsTArray<int32_t>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveSequenceOfNullableInts(nsTArray<Nullable<int32_t>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableSequenceOfNullableInts(Nullable<nsTArray<Nullable<int32_t>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequence(const Sequence<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableSequence(const Nullable<Sequence<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfNullableInts(const Sequence<Nullable<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalSequenceOfNullableInts(const Optional<Sequence<Nullable<int32_t>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSequenceOfNullableInts(const Optional<Nullable<Sequence<Nullable<int32_t>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveCastableObjectSequence(nsTArray<RefPtr<TestJSImplInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveCallbackObjectSequence(nsTArray<RefPtr<TestCallbackInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableCastableObjectSequence(nsTArray<RefPtr<TestJSImplInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableCallbackObjectSequence(nsTArray<RefPtr<TestCallbackInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveCastableObjectNullableSequence(Nullable<nsTArray<RefPtr<TestJSImplInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableCastableObjectNullableSequence(Nullable<nsTArray<RefPtr<TestJSImplInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveWeakCastableObjectSequence(nsTArray<RefPtr<TestJSImplInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveWeakNullableCastableObjectSequence(nsTArray<RefPtr<TestJSImplInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveWeakCastableObjectNullableSequence(Nullable<nsTArray<RefPtr<TestJSImplInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveWeakNullableCastableObjectNullableSequence(Nullable<nsTArray<RefPtr<TestJSImplInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassCastableObjectSequence(const Sequence<OwningNonNull<TestJSImplInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableCastableObjectSequence(const Sequence<RefPtr<TestJSImplInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassCastableObjectNullableSequence(const Nullable<Sequence<OwningNonNull<TestJSImplInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableCastableObjectNullableSequence(const Nullable<Sequence<RefPtr<TestJSImplInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalSequence(const Optional<Sequence<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalSequenceWithDefaultValue(const Sequence<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSequence(const Optional<Nullable<Sequence<int32_t>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSequenceWithDefaultValue(const Nullable<Sequence<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSequenceWithDefaultValue2(const Nullable<Sequence<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalObjectSequence(const Optional<Sequence<OwningNonNull<TestJSImplInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassExternalInterfaceSequence(const Sequence<RefPtr<TestExternalInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableExternalInterfaceSequence(const Sequence<RefPtr<TestExternalInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveStringSequence(nsTArray<nsString>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveByteStringSequence(nsTArray<nsCString>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveUTF8StringSequence(nsTArray<nsCString>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveAnySequence(nsTArray<JS::Value>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableAnySequence(Nullable<nsTArray<JS::Value>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveObjectSequence(nsTArray<JSObject*>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableObjectSequence(nsTArray<JSObject*>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfSequences(const Sequence<Sequence<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfSequencesOfSequences(const Sequence<Sequence<Sequence<int32_t>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecord(const Record<nsString, int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableRecord(const Nullable<Record<nsString, int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecordOfNullableInts(const Record<nsString, Nullable<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalRecordOfNullableInts(const Optional<Record<nsString, Nullable<int32_t>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableRecordOfNullableInts(const Optional<Nullable<Record<nsString, Nullable<int32_t>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassCastableObjectRecord(const Record<nsString, OwningNonNull<TestInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableCastableObjectRecord(const Record<nsString, RefPtr<TestInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassCastableObjectNullableRecord(const Nullable<Record<nsString, OwningNonNull<TestInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableCastableObjectNullableRecord(const Nullable<Record<nsString, RefPtr<TestInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalRecord(const Optional<Record<nsString, int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableRecord(const Optional<Nullable<Record<nsString, int32_t>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableRecordWithDefaultValue(const Nullable<Record<nsString, int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalObjectRecord(const Optional<Record<nsString, OwningNonNull<TestInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassExternalInterfaceRecord(const Record<nsString, RefPtr<TestExternalInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableExternalInterfaceRecord(const Record<nsString, RefPtr<TestExternalInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassStringRecord(const Record<nsString, nsString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassByteStringRecord(const Record<nsString, nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUTF8StringRecord(const Record<nsString, nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecordOfRecords(const Record<nsString, Record<nsString, int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveRecord(Record<nsString, int32_t>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableRecord(Nullable<Record<nsString, int32_t>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveRecordOfNullableInts(Record<nsString, Nullable<int32_t>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableRecordOfNullableInts(Nullable<Record<nsString, Nullable<int32_t>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveAnyRecord(Record<nsString, JS::Value>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassArrayBuffer(const ArrayBuffer& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableArrayBuffer(const Nullable<ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalArrayBuffer(const Optional<ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableArrayBuffer(const Optional<Nullable<ArrayBuffer>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableArrayBufferWithDefaultValue(const Nullable<ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassArrayBufferView(const ArrayBufferView& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassInt8Array(const Int8Array& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassInt16Array(const Int16Array& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassInt32Array(const Int32Array& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUint8Array(const Uint8Array& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUint16Array(const Uint16Array& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUint32Array(const Uint32Array& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUint8ClampedArray(const Uint8ClampedArray& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassFloat32Array(const Float32Array& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassFloat64Array(const Float64Array& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfArrayBuffers(const Sequence<ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfNullableArrayBuffers(const Sequence<Nullable<ArrayBuffer>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecordOfArrayBuffers(const Record<nsString, ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecordOfNullableArrayBuffers(const Record<nsString, Nullable<ArrayBuffer>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicTypedArray(const nsTArray<Float32Array>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicNullableTypedArray(const nsTArray<Nullable<Float32Array>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveUint8Array(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassString(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableString(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalString(const Optional<nsAString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalStringWithDefaultValue(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableString(const Optional<nsAString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableStringWithDefaultValue(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicString(const nsTArray<nsString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassByteString(const nsCString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableByteString(const nsCString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalByteString(const Optional<nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalByteStringWithDefaultValue(const nsCString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableByteString(const Optional<nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableByteStringWithDefaultValue(const nsCString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicByteString(const nsTArray<nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionByteString(const ByteStringOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnionByteString(const Optional<ByteStringOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnionByteStringWithDefaultValue(const ByteStringOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUTF8String(const nsACString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUTF8String(const nsACString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUTF8String(const Optional<nsACString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUTF8StringWithDefaultValue(const nsACString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableUTF8String(const Optional<nsACString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableUTF8StringWithDefaultValue(const nsACString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicUTF8String(const nsTArray<nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionUTF8String(const UTF8StringOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnionUTF8String(const Optional<UTF8StringOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnionUTF8StringWithDefaultValue(const UTF8StringOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSVS(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableSVS(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalSVS(const Optional<nsAString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalSVSWithDefaultValue(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSVS(const Optional<nsAString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSVSWithDefaultValue(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicSVS(const nsTArray<nsString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveSVS(nsString& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassJSString(JS::Handle<JSString*> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalJSStringWithDefaultValue(JS::Handle<JSString*> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveJSString(JS::MutableHandle<JSString*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassEnum(MyTestEnum arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableEnum(const Nullable<MyTestEnum>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalEnum(const Optional<MyTestEnum>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassEnumWithDefault(MyTestEnum arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableEnum(const Optional<Nullable<MyTestEnum>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableEnumWithDefaultValue(const Nullable<MyTestEnum>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableEnumWithDefaultValue2(const Nullable<MyTestEnum>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  MyTestEnum ReceiveEnum(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  Nullable<MyTestEnum> ReceiveNullableEnum(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassCallback(MyTestCallback& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableCallback(MyTestCallback* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalCallback(const Optional<OwningNonNull<MyTestCallback>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableCallback(const Optional<RefPtr<MyTestCallback>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableCallbackWithDefaultValue(MyTestCallback* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<MyTestCallback> ReceiveCallback(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<MyTestCallback> ReceiveNullableCallback(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableTreatAsNullCallbackWithDefaultValue(TestTreatAsNullCallback* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassAny(JS::Handle<JS::Value> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicAny(const nsTArray<JS::Value>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalAny(JS::Handle<JS::Value> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassAnyDefaultNull(JS::Handle<JS::Value> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfAny(const Sequence<JS::Value>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableSequenceOfAny(const Nullable<Sequence<JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalSequenceOfAny(const Optional<Sequence<JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSequenceOfAny(const Optional<Nullable<Sequence<JS::Value>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalSequenceOfAnyWithDefaultValue(const Nullable<Sequence<JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfSequenceOfAny(const Sequence<Sequence<JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfNullableSequenceOfAny(const Sequence<Nullable<Sequence<JS::Value>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableSequenceOfNullableSequenceOfAny(const Nullable<Sequence<Nullable<Sequence<JS::Value>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSequenceOfNullableSequenceOfAny(const Optional<Nullable<Sequence<Nullable<Sequence<JS::Value>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecordOfAny(const Record<nsString, JS::Value>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableRecordOfAny(const Nullable<Record<nsString, JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalRecordOfAny(const Optional<Record<nsString, JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableRecordOfAny(const Optional<Nullable<Record<nsString, JS::Value>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalRecordOfAnyWithDefaultValue(const Nullable<Record<nsString, JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecordOfRecordOfAny(const Record<nsString, Record<nsString, JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecordOfNullableRecordOfAny(const Record<nsString, Nullable<Record<nsString, JS::Value>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableRecordOfNullableRecordOfAny(const Nullable<Record<nsString, Nullable<Record<nsString, JS::Value>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableRecordOfNullableRecordOfAny(const Optional<Nullable<Record<nsString, Nullable<Record<nsString, JS::Value>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableRecordOfNullableSequenceOfAny(const Optional<Nullable<Record<nsString, Nullable<Sequence<JS::Value>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSequenceOfNullableRecordOfAny(const Optional<Nullable<Sequence<Nullable<Record<nsString, JS::Value>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveAny(JS::MutableHandle<JS::Value> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassObject(JS::Handle<JSObject*> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicObject(const nsTArray<JSObject*>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableObject(JS::Handle<JSObject*> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicNullableObject(const nsTArray<JSObject*>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalObject(const Optional<JS::Handle<JSObject*>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableObject(const Optional<JS::Handle<JSObject*>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableObjectWithDefaultValue(JS::Handle<JSObject*> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfObject(const Sequence<JSObject*>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfNullableObject(const Sequence<JSObject*>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableSequenceOfObject(const Nullable<Sequence<JSObject*>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSequenceOfNullableSequenceOfObject(const Optional<Nullable<Sequence<Nullable<Sequence<JSObject*>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSequenceOfNullableSequenceOfNullableObject(const Optional<Nullable<Sequence<Nullable<Sequence<JSObject*>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecordOfObject(const Record<nsString, JSObject*>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveObject(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableObject(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnion(const ObjectOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithNullable(const ObjectOrNullOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnion(const Nullable<ObjectOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnion(const Optional<ObjectOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableUnion(const Optional<Nullable<ObjectOrLong>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableUnionWithDefaultValue(const Nullable<ObjectOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithArrayBuffer(const ArrayBufferOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithString(const StringOrObject& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithEnum(const SupportedTypeOrObject& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithObject(const ObjectOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue1(const DoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue2(const DoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue3(const DoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue4(const FloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue5(const FloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue6(const FloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue7(const UnrestrictedDoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue8(const UnrestrictedDoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue9(const UnrestrictedDoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue10(const UnrestrictedDoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue11(const UnrestrictedFloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue12(const UnrestrictedFloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue13(const UnrestrictedFloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue14(const DoubleOrByteString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue15(const DoubleOrByteString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue16(const DoubleOrByteString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue17(const DoubleOrSupportedType& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue18(const DoubleOrSupportedType& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue19(const DoubleOrSupportedType& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue20(const DoubleOrUSVString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue21(const DoubleOrUSVString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue22(const DoubleOrUSVString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue23(const DoubleOrUTF8String& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue24(const DoubleOrUTF8String& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue25(const DoubleOrUTF8String& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue1(const Nullable<DoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue2(const Nullable<DoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue3(const Nullable<DoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue4(const Nullable<FloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue5(const Nullable<FloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue6(const Nullable<FloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue7(const Nullable<UnrestrictedDoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue8(const Nullable<UnrestrictedDoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue9(const Nullable<UnrestrictedDoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue10(const Nullable<UnrestrictedFloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue11(const Nullable<UnrestrictedFloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue12(const Nullable<UnrestrictedFloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue13(const Nullable<DoubleOrByteString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue14(const Nullable<DoubleOrByteString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue15(const Nullable<DoubleOrByteString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue16(const Nullable<DoubleOrByteString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue17(const Nullable<DoubleOrSupportedType>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue18(const Nullable<DoubleOrSupportedType>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue19(const Nullable<DoubleOrSupportedType>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue20(const Nullable<DoubleOrSupportedType>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue21(const Nullable<DoubleOrUSVString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue22(const Nullable<DoubleOrUSVString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue23(const Nullable<DoubleOrUSVString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue24(const Nullable<DoubleOrUSVString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue25(const Nullable<DoubleOrUTF8String>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue26(const Nullable<DoubleOrUTF8String>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue27(const Nullable<DoubleOrUTF8String>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue28(const Nullable<DoubleOrUTF8String>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfUnions(const Sequence<OwningCanvasPatternOrCanvasGradient>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfUnions2(const Sequence<OwningObjectOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicUnion(const nsTArray<OwningCanvasPatternOrCanvasGradient>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfNullableUnions(const Sequence<Nullable<OwningCanvasPatternOrCanvasGradient>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicNullableUnion(const nsTArray<Nullable<OwningCanvasPatternOrCanvasGradient>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecordOfUnions(const Record<nsString, OwningCanvasPatternOrCanvasGradient>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveUnion(OwningCanvasPatternOrCanvasGradient& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveUnion2(OwningObjectOrLong& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveUnionContainingNull(OwningCanvasPatternOrNullOrCanvasGradient& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableUnion(Nullable<OwningCanvasPatternOrCanvasGradient>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableUnion2(Nullable<OwningObjectOrLong>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassPromise(Promise& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalPromise(const Optional<OwningNonNull<Promise>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassPromiseSequence(const Sequence<OwningNonNull<Promise>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<Promise> ReceivePromise(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<Promise> ReceiveAddrefedPromise(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void MethodRenamedTo(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void MethodRenamedTo(int8_t argument, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassDictionary(const Dict& x, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassDictionary2(const Dict& x, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveDictionary(Dict& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableDictionary(Nullable<Dict>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOtherDictionary(const GrandparentDict& x, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfDictionaries(const Sequence<Dict>& x, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecordOfDictionaries(const Record<nsString, GrandparentDict>& x, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassDictionaryOrLong(const Dict& x, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassDictionaryOrLong(int32_t x, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassDictContainingDict(const DictContainingDict& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassDictContainingSequence(const DictContainingSequence& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveDictContainingSequence(DictContainingSequence& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicDictionary(const nsTArray<Dict>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void DontEnforceRangeOrClamp(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void DoEnforceRange(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void DoEnforceRangeNullable(const Nullable<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void DoClamp(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void DoClampNullable(const Nullable<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ExerciseTypedefInterfaces1(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestJSImplInterface> ExerciseTypedefInterfaces2(TestJSImplInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ExerciseTypedefInterfaces3(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t DeprecatedMethod(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void DeprecatedMethodWithContext(JS::Handle<JS::Value> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool Overload1(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestJSImplInterface> Overload1(const nsAString& strs, TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload2(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload2(const Dict& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload2(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload2(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload3(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload3(MyTestCallback& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload3(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload4(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload4(TestCallbackInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload4(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload5(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload5(MyTestEnum arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload6(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload6(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload7(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload7(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload7(const nsCString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload8(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload8(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload9(const Nullable<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload9(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload10(const Nullable<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload10(JS::Handle<JSObject*> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload11(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload11(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload12(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload12(const Nullable<bool>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload13(const Nullable<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload13(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload14(const Optional<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload14(TestInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload15(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload15(const Optional<NonNull<TestInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload16(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload16(const Optional<TestInterface*>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload17(const Sequence<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload17(const Record<nsString, int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload18(const Record<nsString, nsString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload18(const Sequence<nsString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload19(const Sequence<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload19(const Dict& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload20(const Dict& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload20(const Sequence<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicThirdArg(const nsAString& arg1, int32_t arg2, const nsTArray<OwningNonNull<TestJSImplInterface>>& arg3, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Prefable10(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Prefable11(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Prefable13(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Prefable17(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Prefable18(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Prefable19(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Prefable20(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ConditionalOnSecureContext5(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ConditionalOnSecureContext6(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ConditionalOnSecureContext7(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ConditionalOnSecureContext8(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRenamedInterface(nsRenamedInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ThrowingMethod(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void CanOOMMethod(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void CeReactionsMethod(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void CeReactionsMethodOverload(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void CeReactionsMethodOverload(const nsAString& bar, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassArgsWithDefaults(const Optional<int32_t>& arg1, TestInterface* arg2, const Dict& arg3, double arg4, const Optional<float>& arg5, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ToJSON(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Dashed_method(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void NonEnumerableMethod(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassAllowSharedArrayBufferViewTypedef(const ArrayBufferView& foo, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassAllowSharedArrayBufferView(const ArrayBufferView& foo, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassAllowSharedNullableArrayBufferView(const Nullable<ArrayBufferView>& foo, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassAllowSharedArrayBuffer(const ArrayBuffer& foo, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassAllowSharedNullableArrayBuffer(const Nullable<ArrayBuffer>& foo, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionArrayBuffer(const StringOrArrayBuffer& foo, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionAllowSharedArrayBuffer(const StringOrMaybeSharedArrayBuffer& foo, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void __Init(const nsAString& str, uint32_t num, const Nullable<bool>& boolArg, TestInterface* iface, int32_t arg1, const DictForConstructor& dict, JS::Handle<JS::Value> any1, JS::Handle<JSObject*> obj1, JS::Handle<JSObject*> obj2, const Sequence<Dict>& seq, JS::Handle<JS::Value> any2, const Optional<JS::Handle<JSObject*>>& obj3, const Optional<JS::Handle<JSObject*>>& obj4, const Uint8Array& typedArr, const ArrayBuffer& arrayBuf, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  inline bool
  operator==(const TestJSImplInterfaceJSImpl& aOther) const
  {
    return CallbackInterface::operator==(aOther);
  }

  int8_t GetReadonlyByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t GetWritableByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t GetSideEffectFreeByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t GetDomDependentByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t GetConstantByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t GetDeviceStateDependentByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int16_t GetReadonlyShort(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int16_t GetWritableShort(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int32_t GetReadonlyLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int32_t GetWritableLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int64_t GetReadonlyLongLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int64_t GetWritableLongLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  uint8_t GetReadonlyOctet(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  uint8_t GetWritableOctet(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  uint16_t GetReadonlyUnsignedShort(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  uint16_t GetWritableUnsignedShort(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  uint32_t GetReadonlyUnsignedLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  uint32_t GetWritableUnsignedLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  uint64_t GetReadonlyUnsignedLongLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  uint64_t GetWritableUnsignedLongLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  float GetWritableFloat(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  float GetWritableUnrestrictedFloat(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  Nullable<float> GetWritableNullableFloat(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  Nullable<float> GetWritableNullableUnrestrictedFloat(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  double GetWritableDouble(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  double GetWritableUnrestrictedDouble(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  Nullable<double> GetWritableNullableDouble(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  Nullable<double> GetWritableNullableUnrestrictedDouble(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  float GetLenientFloatAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  double GetLenientDoubleAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestJSImplInterface> GetNonNullSelf(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestJSImplInterface> GetNullableSelf(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestExternalInterface> GetNonNullExternal(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestExternalInterface> GetNullableExternal(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestCallbackInterface> GetNonNullCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestCallbackInterface> GetNullableCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetUint8ArrayAttr(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetReadonlyJSStringAttr(JS::MutableHandle<JSString*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetJsStringAttr(JS::MutableHandle<JSString*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  MyTestEnum GetEnumAttribute(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  MyTestEnum GetReadonlyEnumAttribute(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetWritableUnion(OwningCanvasPatternOrCanvasGradient& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetWritableUnionContainingNull(OwningCanvasPatternOrNullOrCanvasGradient& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetWritableNullableUnion(Nullable<OwningCanvasPatternOrCanvasGradient>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t GetAttributeGetterRenamedTo(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t GetAttributeRenamedTo(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t GetEnforcedByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  Nullable<int8_t> GetEnforcedByteNullable(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t GetClampedByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  Nullable<int8_t> GetClampedByteNullable(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t GetDeprecatedAttribute(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetPrefable1(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetPrefable2(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetPrefable3(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetPrefable4(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetPrefable5(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetPrefable6(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetPrefable7(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetPrefable8(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetPrefable9(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetPrefable12(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetPrefable14(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetPrefable15(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetPrefable16(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetConditionalOnSecureContext1(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetConditionalOnSecureContext2(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetConditionalOnSecureContext3(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetConditionalOnSecureContext4(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int32_t GetAttrWithLenientThis(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestJSImplInterface> GetPutForwardsAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestJSImplInterface> GetPutForwardsAttr2(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestJSImplInterface> GetPutForwardsAttr3(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetThrowingAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetThrowingGetterAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetThrowingSetterAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetCanOOMAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetCanOOMGetterAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetCanOOMSetterAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetCeReactionsAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetToJSONShouldSkipThis(JS::MutableHandle<JS::Value> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestParentInterface> GetToJSONShouldSkipThis2(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestCallbackInterface> GetToJSONShouldSkipThis3(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t GetDashed_attribute(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetNonEnumerableAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetAllowSharedArrayBufferViewTypedef(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetAllowSharedArrayBufferView(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetAllowSharedNullableArrayBufferView(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetAllowSharedArrayBuffer(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetAllowSharedNullableArrayBuffer(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetWritableByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetSideEffectFreeByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetDomDependentByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetWritableShort(int16_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetWritableLong(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetWritableLongLong(int64_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetWritableOctet(uint8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetWritableUnsignedShort(uint16_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetWritableUnsignedLong(uint32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetWritableUnsignedLongLong(uint64_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetWritableFloat(float arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetWritableUnrestrictedFloat(float arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetWritableNullableFloat(const Nullable<float>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetWritableNullableUnrestrictedFloat(const Nullable<float>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetWritableDouble(double arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetWritableUnrestrictedDouble(double arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetWritableNullableDouble(const Nullable<double>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetWritableNullableUnrestrictedDouble(const Nullable<double>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetLenientFloatAttr(float arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetLenientDoubleAttr(double arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetNonNullSelf(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetNullableSelf(TestJSImplInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetNonNullExternal(TestExternalInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetNullableExternal(TestExternalInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetNonNullCallbackInterface(TestCallbackInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetNullableCallbackInterface(TestCallbackInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetUint8ArrayAttr(const Uint8Array& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetJsStringAttr(JS::Handle<JSString*> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetEnumAttribute(MyTestEnum arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetWritableUnion(const CanvasPatternOrCanvasGradient& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetWritableUnionContainingNull(const CanvasPatternOrNullOrCanvasGradient& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetWritableNullableUnion(const Nullable<CanvasPatternOrCanvasGradient>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetAttributeRenamedTo(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetEnforcedByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetEnforcedByteNullable(const Nullable<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetClampedByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetClampedByteNullable(const Nullable<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetDeprecatedAttribute(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetAttrWithLenientThis(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetThrowingAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetThrowingGetterAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetThrowingSetterAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetCanOOMAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetCanOOMGetterAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetCanOOMSetterAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetCeReactionsAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetToJSONShouldSkipThis(JS::Handle<JS::Value> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetToJSONShouldSkipThis2(TestParentInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetToJSONShouldSkipThis3(TestCallbackInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetDashed_attribute(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetNonEnumerableAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetAllowSharedArrayBufferViewTypedef(const ArrayBufferView& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetAllowSharedArrayBufferView(const ArrayBufferView& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetAllowSharedNullableArrayBufferView(const Nullable<ArrayBufferView>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetAllowSharedArrayBuffer(const ArrayBuffer& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void SetAllowSharedNullableArrayBuffer(const Nullable<ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

private:
  static bool
  InitIds(JSContext* cx, TestJSImplInterfaceAtoms* atomsCache);
};


class TestJSImplInterface : public nsSupportsWeakReference,
                            public nsWrapperCache
{
public:
  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(TestJSImplInterface)

private:
  RefPtr<TestJSImplInterfaceJSImpl> mImpl;
  nsCOMPtr<nsIGlobalObject> mParent;

public:
  TestJSImplInterface(JS::Handle<JSObject*> aJSImplObject, JS::Handle<JSObject*> aJSImplGlobal, nsIGlobalObject* aParent);

protected:
  virtual ~TestJSImplInterface();

public:
  nsISupports* GetParentObject() const;

  DocGroup* GetDocGroup() const;

  JSObject* WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;

  static already_AddRefed<TestJSImplInterface> Constructor(const GlobalObject& global, JSContext* cx, const nsAString& str, uint32_t num, const Nullable<bool>& boolArg, TestInterface* iface, int32_t arg1, const DictForConstructor& dict, JS::Handle<JS::Value> any1, JS::Handle<JSObject*> obj1, JS::Handle<JSObject*> obj2, const Sequence<Dict>& seq, JS::Handle<JS::Value> any2, const Optional<JS::Handle<JSObject*>>& obj3, const Optional<JS::Handle<JSObject*>>& obj4, const Uint8Array& typedArr, const ArrayBuffer& arrayBuf, ErrorResult& aRv, JS::Handle<JSObject*> aGivenProto = nullptr);

  int8_t GetReadonlyByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  int8_t GetWritableByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetWritableByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t ReceiveByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalByte(const Optional<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalByteBeforeRequired(const Optional<int8_t>& arg1, int8_t arg2, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalByteWithDefault(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalByteWithDefaultBeforeRequired(int8_t arg1, int8_t arg2, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableByte(const Nullable<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableByte(const Optional<Nullable<int8_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicByte(const Sequence<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t GetSideEffectFreeByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetSideEffectFreeByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t GetDomDependentByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetDomDependentByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t GetConstantByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  int8_t GetDeviceStateDependentByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  int8_t ReturnByteSideEffectFree(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t ReturnDOMDependentByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t ReturnConstantByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t ReturnDeviceStateDependentByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int16_t GetReadonlyShort(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  int16_t GetWritableShort(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetWritableShort(int16_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassShort(int16_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int16_t ReceiveShort(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalShort(const Optional<int16_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalShortWithDefault(int16_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int32_t GetReadonlyLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  int32_t GetWritableLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetWritableLong(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassLong(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int32_t ReceiveLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalLong(const Optional<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalLongWithDefault(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int64_t GetReadonlyLongLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  int64_t GetWritableLongLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetWritableLongLong(int64_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassLongLong(int64_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int64_t ReceiveLongLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalLongLong(const Optional<int64_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalLongLongWithDefault(int64_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  uint8_t GetReadonlyOctet(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  uint8_t GetWritableOctet(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetWritableOctet(uint8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOctet(uint8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  uint8_t ReceiveOctet(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalOctet(const Optional<uint8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalOctetWithDefault(uint8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  uint16_t GetReadonlyUnsignedShort(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  uint16_t GetWritableUnsignedShort(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetWritableUnsignedShort(uint16_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnsignedShort(uint16_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  uint16_t ReceiveUnsignedShort(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnsignedShort(const Optional<uint16_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnsignedShortWithDefault(uint16_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  uint32_t GetReadonlyUnsignedLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  uint32_t GetWritableUnsignedLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetWritableUnsignedLong(uint32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnsignedLong(uint32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  uint32_t ReceiveUnsignedLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnsignedLong(const Optional<uint32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnsignedLongWithDefault(uint32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  uint64_t GetReadonlyUnsignedLongLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  uint64_t GetWritableUnsignedLongLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetWritableUnsignedLongLong(uint64_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnsignedLongLong(uint64_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  uint64_t ReceiveUnsignedLongLong(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnsignedLongLong(const Optional<uint64_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnsignedLongLongWithDefault(uint64_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  float GetWritableFloat(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetWritableFloat(float arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  float GetWritableUnrestrictedFloat(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetWritableUnrestrictedFloat(float arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  Nullable<float> GetWritableNullableFloat(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetWritableNullableFloat(const Nullable<float>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  Nullable<float> GetWritableNullableUnrestrictedFloat(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetWritableNullableUnrestrictedFloat(const Nullable<float>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  double GetWritableDouble(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetWritableDouble(double arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  double GetWritableUnrestrictedDouble(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetWritableUnrestrictedDouble(double arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  Nullable<double> GetWritableNullableDouble(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetWritableNullableDouble(const Nullable<double>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  Nullable<double> GetWritableNullableUnrestrictedDouble(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetWritableNullableUnrestrictedDouble(const Nullable<double>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassFloat(float arg1, float arg2, const Nullable<float>& arg3, const Nullable<float>& arg4, double arg5, double arg6, const Nullable<double>& arg7, const Nullable<double>& arg8, const Sequence<float>& arg9, const Sequence<float>& arg10, const Sequence<Nullable<float>>& arg11, const Sequence<Nullable<float>>& arg12, const Sequence<double>& arg13, const Sequence<double>& arg14, const Sequence<Nullable<double>>& arg15, const Sequence<Nullable<double>>& arg16, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassLenientFloat(float arg1, float arg2, const Nullable<float>& arg3, const Nullable<float>& arg4, double arg5, double arg6, const Nullable<double>& arg7, const Nullable<double>& arg8, const Sequence<float>& arg9, const Sequence<float>& arg10, const Sequence<Nullable<float>>& arg11, const Sequence<Nullable<float>>& arg12, const Sequence<double>& arg13, const Sequence<double>& arg14, const Sequence<Nullable<double>>& arg15, const Sequence<Nullable<double>>& arg16, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  float GetLenientFloatAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetLenientFloatAttr(float arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  double GetLenientDoubleAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetLenientDoubleAttr(double arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestJSImplInterface> ReceiveSelf(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestJSImplInterface> ReceiveNullableSelf(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestJSImplInterface> ReceiveWeakSelf(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestJSImplInterface> ReceiveWeakNullableSelf(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSelf(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableSelf(TestJSImplInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestJSImplInterface> GetNonNullSelf(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetNonNullSelf(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestJSImplInterface> GetNullableSelf(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetNullableSelf(TestJSImplInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalSelf(const Optional<TestJSImplInterface*>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNonNullSelf(const Optional<NonNull<TestJSImplInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalSelfWithDefault(TestJSImplInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestNonWrapperCacheInterface> ReceiveNonWrapperCacheInterface(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<TestNonWrapperCacheInterface> ReceiveNullableNonWrapperCacheInterface(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNonWrapperCacheInterfaceSequence(nsTArray<RefPtr<TestNonWrapperCacheInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableNonWrapperCacheInterfaceSequence(nsTArray<RefPtr<TestNonWrapperCacheInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNonWrapperCacheInterfaceNullableSequence(Nullable<nsTArray<RefPtr<TestNonWrapperCacheInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableNonWrapperCacheInterfaceNullableSequence(Nullable<nsTArray<RefPtr<TestNonWrapperCacheInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestExternalInterface> ReceiveExternal(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestExternalInterface> ReceiveNullableExternal(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestExternalInterface> ReceiveWeakExternal(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestExternalInterface> ReceiveWeakNullableExternal(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassExternal(TestExternalInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableExternal(TestExternalInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestExternalInterface> GetNonNullExternal(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetNonNullExternal(TestExternalInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestExternalInterface> GetNullableExternal(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetNullableExternal(TestExternalInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalExternal(const Optional<TestExternalInterface*>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNonNullExternal(const Optional<TestExternalInterface*>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalExternalWithDefault(TestExternalInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestCallbackInterface> ReceiveCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestCallbackInterface> ReceiveNullableCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestCallbackInterface> ReceiveWeakCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestCallbackInterface> ReceiveWeakNullableCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassCallbackInterface(TestCallbackInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableCallbackInterface(TestCallbackInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestCallbackInterface> GetNonNullCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetNonNullCallbackInterface(TestCallbackInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestCallbackInterface> GetNullableCallbackInterface(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetNullableCallbackInterface(TestCallbackInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalCallbackInterface(const Optional<RefPtr<TestCallbackInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNonNullCallbackInterface(const Optional<OwningNonNull<TestCallbackInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalCallbackInterfaceWithDefault(TestCallbackInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveSequence(nsTArray<int32_t>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableSequence(Nullable<nsTArray<int32_t>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveSequenceOfNullableInts(nsTArray<Nullable<int32_t>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableSequenceOfNullableInts(Nullable<nsTArray<Nullable<int32_t>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequence(const Sequence<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableSequence(const Nullable<Sequence<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfNullableInts(const Sequence<Nullable<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalSequenceOfNullableInts(const Optional<Sequence<Nullable<int32_t>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSequenceOfNullableInts(const Optional<Nullable<Sequence<Nullable<int32_t>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveCastableObjectSequence(nsTArray<RefPtr<TestJSImplInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveCallbackObjectSequence(nsTArray<RefPtr<TestCallbackInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableCastableObjectSequence(nsTArray<RefPtr<TestJSImplInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableCallbackObjectSequence(nsTArray<RefPtr<TestCallbackInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveCastableObjectNullableSequence(Nullable<nsTArray<RefPtr<TestJSImplInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableCastableObjectNullableSequence(Nullable<nsTArray<RefPtr<TestJSImplInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveWeakCastableObjectSequence(nsTArray<RefPtr<TestJSImplInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveWeakNullableCastableObjectSequence(nsTArray<RefPtr<TestJSImplInterface>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveWeakCastableObjectNullableSequence(Nullable<nsTArray<RefPtr<TestJSImplInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveWeakNullableCastableObjectNullableSequence(Nullable<nsTArray<RefPtr<TestJSImplInterface>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassCastableObjectSequence(const Sequence<OwningNonNull<TestJSImplInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableCastableObjectSequence(const Sequence<RefPtr<TestJSImplInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassCastableObjectNullableSequence(const Nullable<Sequence<OwningNonNull<TestJSImplInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableCastableObjectNullableSequence(const Nullable<Sequence<RefPtr<TestJSImplInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalSequence(const Optional<Sequence<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalSequenceWithDefaultValue(const Sequence<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSequence(const Optional<Nullable<Sequence<int32_t>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSequenceWithDefaultValue(const Nullable<Sequence<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSequenceWithDefaultValue2(const Nullable<Sequence<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalObjectSequence(const Optional<Sequence<OwningNonNull<TestJSImplInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassExternalInterfaceSequence(const Sequence<RefPtr<TestExternalInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableExternalInterfaceSequence(const Sequence<RefPtr<TestExternalInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveStringSequence(nsTArray<nsString>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveByteStringSequence(nsTArray<nsCString>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveUTF8StringSequence(nsTArray<nsCString>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveAnySequence(nsTArray<JS::Value>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableAnySequence(Nullable<nsTArray<JS::Value>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveObjectSequence(nsTArray<JSObject*>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableObjectSequence(nsTArray<JSObject*>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfSequences(const Sequence<Sequence<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfSequencesOfSequences(const Sequence<Sequence<Sequence<int32_t>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecord(const Record<nsString, int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableRecord(const Nullable<Record<nsString, int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecordOfNullableInts(const Record<nsString, Nullable<int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalRecordOfNullableInts(const Optional<Record<nsString, Nullable<int32_t>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableRecordOfNullableInts(const Optional<Nullable<Record<nsString, Nullable<int32_t>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassCastableObjectRecord(const Record<nsString, OwningNonNull<TestInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableCastableObjectRecord(const Record<nsString, RefPtr<TestInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassCastableObjectNullableRecord(const Nullable<Record<nsString, OwningNonNull<TestInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableCastableObjectNullableRecord(const Nullable<Record<nsString, RefPtr<TestInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalRecord(const Optional<Record<nsString, int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableRecord(const Optional<Nullable<Record<nsString, int32_t>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableRecordWithDefaultValue(const Nullable<Record<nsString, int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalObjectRecord(const Optional<Record<nsString, OwningNonNull<TestInterface>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassExternalInterfaceRecord(const Record<nsString, RefPtr<TestExternalInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableExternalInterfaceRecord(const Record<nsString, RefPtr<TestExternalInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassStringRecord(const Record<nsString, nsString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassByteStringRecord(const Record<nsString, nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUTF8StringRecord(const Record<nsString, nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecordOfRecords(const Record<nsString, Record<nsString, int32_t>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveRecord(Record<nsString, int32_t>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableRecord(Nullable<Record<nsString, int32_t>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveRecordOfNullableInts(Record<nsString, Nullable<int32_t>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableRecordOfNullableInts(Nullable<Record<nsString, Nullable<int32_t>>>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveAnyRecord(Record<nsString, JS::Value>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassArrayBuffer(const ArrayBuffer& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableArrayBuffer(const Nullable<ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalArrayBuffer(const Optional<ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableArrayBuffer(const Optional<Nullable<ArrayBuffer>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableArrayBufferWithDefaultValue(const Nullable<ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassArrayBufferView(const ArrayBufferView& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassInt8Array(const Int8Array& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassInt16Array(const Int16Array& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassInt32Array(const Int32Array& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUint8Array(const Uint8Array& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUint16Array(const Uint16Array& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUint32Array(const Uint32Array& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUint8ClampedArray(const Uint8ClampedArray& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassFloat32Array(const Float32Array& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassFloat64Array(const Float64Array& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfArrayBuffers(const Sequence<ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfNullableArrayBuffers(const Sequence<Nullable<ArrayBuffer>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecordOfArrayBuffers(const Record<nsString, ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecordOfNullableArrayBuffers(const Record<nsString, Nullable<ArrayBuffer>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicTypedArray(const Sequence<Float32Array>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicNullableTypedArray(const Sequence<Nullable<Float32Array>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveUint8Array(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetUint8ArrayAttr(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetUint8ArrayAttr(const Uint8Array& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassString(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableString(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalString(const Optional<nsAString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalStringWithDefaultValue(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableString(const Optional<nsAString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableStringWithDefaultValue(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicString(const Sequence<nsString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassByteString(const nsCString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableByteString(const nsCString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalByteString(const Optional<nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalByteStringWithDefaultValue(const nsCString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableByteString(const Optional<nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableByteStringWithDefaultValue(const nsCString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicByteString(const Sequence<nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionByteString(const ByteStringOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnionByteString(const Optional<ByteStringOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnionByteStringWithDefaultValue(const ByteStringOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUTF8String(const nsACString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUTF8String(const nsACString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUTF8String(const Optional<nsACString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUTF8StringWithDefaultValue(const nsACString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableUTF8String(const Optional<nsACString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableUTF8StringWithDefaultValue(const nsACString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicUTF8String(const Sequence<nsCString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionUTF8String(const UTF8StringOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnionUTF8String(const Optional<UTF8StringOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnionUTF8StringWithDefaultValue(const UTF8StringOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSVS(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableSVS(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalSVS(const Optional<nsAString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalSVSWithDefaultValue(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSVS(const Optional<nsAString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSVSWithDefaultValue(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicSVS(const Sequence<nsString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveSVS(nsString& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassJSString(JS::Handle<JSString*> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalJSStringWithDefaultValue(JS::Handle<JSString*> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveJSString(JS::MutableHandle<JSString*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetReadonlyJSStringAttr(JS::MutableHandle<JSString*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void GetJsStringAttr(JS::MutableHandle<JSString*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetJsStringAttr(JS::Handle<JSString*> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassEnum(MyTestEnum arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableEnum(const Nullable<MyTestEnum>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalEnum(const Optional<MyTestEnum>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassEnumWithDefault(MyTestEnum arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableEnum(const Optional<Nullable<MyTestEnum>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableEnumWithDefaultValue(const Nullable<MyTestEnum>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableEnumWithDefaultValue2(const Nullable<MyTestEnum>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  MyTestEnum ReceiveEnum(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  Nullable<MyTestEnum> ReceiveNullableEnum(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  MyTestEnum GetEnumAttribute(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetEnumAttribute(MyTestEnum arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  MyTestEnum GetReadonlyEnumAttribute(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void PassCallback(MyTestCallback& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableCallback(MyTestCallback* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalCallback(const Optional<OwningNonNull<MyTestCallback>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableCallback(const Optional<RefPtr<MyTestCallback>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableCallbackWithDefaultValue(MyTestCallback* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<MyTestCallback> ReceiveCallback(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  already_AddRefed<MyTestCallback> ReceiveNullableCallback(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableTreatAsNullCallbackWithDefaultValue(TestTreatAsNullCallback* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassAny(JS::Handle<JS::Value> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicAny(const Sequence<JS::Value>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalAny(JS::Handle<JS::Value> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassAnyDefaultNull(JS::Handle<JS::Value> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfAny(const Sequence<JS::Value>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableSequenceOfAny(const Nullable<Sequence<JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalSequenceOfAny(const Optional<Sequence<JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSequenceOfAny(const Optional<Nullable<Sequence<JS::Value>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalSequenceOfAnyWithDefaultValue(const Nullable<Sequence<JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfSequenceOfAny(const Sequence<Sequence<JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfNullableSequenceOfAny(const Sequence<Nullable<Sequence<JS::Value>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableSequenceOfNullableSequenceOfAny(const Nullable<Sequence<Nullable<Sequence<JS::Value>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSequenceOfNullableSequenceOfAny(const Optional<Nullable<Sequence<Nullable<Sequence<JS::Value>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecordOfAny(const Record<nsString, JS::Value>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableRecordOfAny(const Nullable<Record<nsString, JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalRecordOfAny(const Optional<Record<nsString, JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableRecordOfAny(const Optional<Nullable<Record<nsString, JS::Value>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalRecordOfAnyWithDefaultValue(const Nullable<Record<nsString, JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecordOfRecordOfAny(const Record<nsString, Record<nsString, JS::Value>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecordOfNullableRecordOfAny(const Record<nsString, Nullable<Record<nsString, JS::Value>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableRecordOfNullableRecordOfAny(const Nullable<Record<nsString, Nullable<Record<nsString, JS::Value>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableRecordOfNullableRecordOfAny(const Optional<Nullable<Record<nsString, Nullable<Record<nsString, JS::Value>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableRecordOfNullableSequenceOfAny(const Optional<Nullable<Record<nsString, Nullable<Sequence<JS::Value>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSequenceOfNullableRecordOfAny(const Optional<Nullable<Sequence<Nullable<Record<nsString, JS::Value>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveAny(JS::MutableHandle<JS::Value> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassObject(JS::Handle<JSObject*> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicObject(const Sequence<JSObject*>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableObject(JS::Handle<JSObject*> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicNullableObject(const Sequence<JSObject*>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalObject(const Optional<JS::Handle<JSObject*>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableObject(const Optional<JS::Handle<JSObject*>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableObjectWithDefaultValue(JS::Handle<JSObject*> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfObject(const Sequence<JSObject*>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfNullableObject(const Sequence<JSObject*>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableSequenceOfObject(const Nullable<Sequence<JSObject*>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSequenceOfNullableSequenceOfObject(const Optional<Nullable<Sequence<Nullable<Sequence<JSObject*>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableSequenceOfNullableSequenceOfNullableObject(const Optional<Nullable<Sequence<Nullable<Sequence<JSObject*>>>>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecordOfObject(const Record<nsString, JSObject*>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveObject(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableObject(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnion(const ObjectOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithNullable(const ObjectOrNullOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnion(const Nullable<ObjectOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalUnion(const Optional<ObjectOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableUnion(const Optional<Nullable<ObjectOrLong>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalNullableUnionWithDefaultValue(const Nullable<ObjectOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithArrayBuffer(const ArrayBufferOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithString(const StringOrObject& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithEnum(const SupportedTypeOrObject& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithObject(const ObjectOrLong& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue1(const DoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue2(const DoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue3(const DoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue4(const FloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue5(const FloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue6(const FloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue7(const UnrestrictedDoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue8(const UnrestrictedDoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue9(const UnrestrictedDoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue10(const UnrestrictedDoubleOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue11(const UnrestrictedFloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue12(const UnrestrictedFloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue13(const UnrestrictedFloatOrString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue14(const DoubleOrByteString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue15(const DoubleOrByteString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue16(const DoubleOrByteString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue17(const DoubleOrSupportedType& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue18(const DoubleOrSupportedType& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue19(const DoubleOrSupportedType& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue20(const DoubleOrUSVString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue21(const DoubleOrUSVString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue22(const DoubleOrUSVString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue23(const DoubleOrUTF8String& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue24(const DoubleOrUTF8String& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionWithDefaultValue25(const DoubleOrUTF8String& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue1(const Nullable<DoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue2(const Nullable<DoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue3(const Nullable<DoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue4(const Nullable<FloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue5(const Nullable<FloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue6(const Nullable<FloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue7(const Nullable<UnrestrictedDoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue8(const Nullable<UnrestrictedDoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue9(const Nullable<UnrestrictedDoubleOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue10(const Nullable<UnrestrictedFloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue11(const Nullable<UnrestrictedFloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue12(const Nullable<UnrestrictedFloatOrString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue13(const Nullable<DoubleOrByteString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue14(const Nullable<DoubleOrByteString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue15(const Nullable<DoubleOrByteString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue16(const Nullable<DoubleOrByteString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue17(const Nullable<DoubleOrSupportedType>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue18(const Nullable<DoubleOrSupportedType>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue19(const Nullable<DoubleOrSupportedType>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue20(const Nullable<DoubleOrSupportedType>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue21(const Nullable<DoubleOrUSVString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue22(const Nullable<DoubleOrUSVString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue23(const Nullable<DoubleOrUSVString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue24(const Nullable<DoubleOrUSVString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue25(const Nullable<DoubleOrUTF8String>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue26(const Nullable<DoubleOrUTF8String>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue27(const Nullable<DoubleOrUTF8String>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassNullableUnionWithDefaultValue28(const Nullable<DoubleOrUTF8String>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfUnions(const Sequence<OwningCanvasPatternOrCanvasGradient>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfUnions2(const Sequence<OwningObjectOrLong>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicUnion(const Sequence<OwningCanvasPatternOrCanvasGradient>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfNullableUnions(const Sequence<Nullable<OwningCanvasPatternOrCanvasGradient>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicNullableUnion(const Sequence<Nullable<OwningCanvasPatternOrCanvasGradient>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecordOfUnions(const Record<nsString, OwningCanvasPatternOrCanvasGradient>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveUnion(OwningCanvasPatternOrCanvasGradient& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveUnion2(OwningObjectOrLong& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveUnionContainingNull(OwningCanvasPatternOrNullOrCanvasGradient& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableUnion(Nullable<OwningCanvasPatternOrCanvasGradient>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableUnion2(Nullable<OwningObjectOrLong>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetWritableUnion(OwningCanvasPatternOrCanvasGradient& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetWritableUnion(const CanvasPatternOrCanvasGradient& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetWritableUnionContainingNull(OwningCanvasPatternOrNullOrCanvasGradient& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetWritableUnionContainingNull(const CanvasPatternOrNullOrCanvasGradient& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetWritableNullableUnion(Nullable<OwningCanvasPatternOrCanvasGradient>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetWritableNullableUnion(const Nullable<CanvasPatternOrCanvasGradient>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassPromise(Promise& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOptionalPromise(const Optional<OwningNonNull<Promise>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassPromiseSequence(const Sequence<OwningNonNull<Promise>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<Promise> ReceivePromise(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<Promise> ReceiveAddrefedPromise(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void MethodRenamedTo(ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void MethodRenamedTo(int8_t argument, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t GetAttributeGetterRenamedTo(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  int8_t GetAttributeRenamedTo(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetAttributeRenamedTo(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassDictionary(const Dict& x, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassDictionary2(const Dict& x, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveDictionary(Dict& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveNullableDictionary(Nullable<Dict>& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassOtherDictionary(const GrandparentDict& x, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassSequenceOfDictionaries(const Sequence<Dict>& x, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRecordOfDictionaries(const Record<nsString, GrandparentDict>& x, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassDictionaryOrLong(const Dict& x, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void PassDictionaryOrLong(int32_t x, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassDictContainingDict(const DictContainingDict& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassDictContainingSequence(const DictContainingSequence& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ReceiveDictContainingSequence(DictContainingSequence& aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicDictionary(const Sequence<Dict>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void DontEnforceRangeOrClamp(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void DoEnforceRange(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void DoEnforceRangeNullable(const Nullable<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void DoClamp(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void DoClampNullable(const Nullable<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t GetEnforcedByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetEnforcedByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  Nullable<int8_t> GetEnforcedByteNullable(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetEnforcedByteNullable(const Nullable<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t GetClampedByte(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetClampedByte(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  Nullable<int8_t> GetClampedByteNullable(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetClampedByteNullable(const Nullable<int8_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ExerciseTypedefInterfaces1(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestJSImplInterface> ExerciseTypedefInterfaces2(TestJSImplInterface* arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ExerciseTypedefInterfaces3(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t GetDeprecatedAttribute(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetDeprecatedAttribute(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t DeprecatedMethod(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void DeprecatedMethodWithContext(JS::Handle<JS::Value> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool Overload1(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestJSImplInterface> Overload1(const nsAString& strs, TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload2(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload2(const Dict& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload2(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload2(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload3(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload3(MyTestCallback& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload3(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload4(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload4(TestCallbackInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload4(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload5(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload5(MyTestEnum arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload6(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload6(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload7(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload7(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload7(const nsCString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload8(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload8(TestJSImplInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload9(const Nullable<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload9(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload10(const Nullable<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload10(JS::Handle<JSObject*> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload11(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload11(const nsAString& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload12(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload12(const Nullable<bool>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload13(const Nullable<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload13(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload14(const Optional<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload14(TestInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload15(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload15(const Optional<NonNull<TestInterface>>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload16(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload16(const Optional<TestInterface*>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload17(const Sequence<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload17(const Record<nsString, int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload18(const Record<nsString, nsString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload18(const Sequence<nsString>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload19(const Sequence<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload19(const Dict& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Overload20(const Dict& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void Overload20(const Sequence<int32_t>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassVariadicThirdArg(const nsAString& arg1, int32_t arg2, const Sequence<OwningNonNull<TestJSImplInterface>>& arg3, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetPrefable1(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  bool GetPrefable2(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  bool GetPrefable3(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  bool GetPrefable4(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  bool GetPrefable5(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  bool GetPrefable6(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  bool GetPrefable7(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  bool GetPrefable8(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  bool GetPrefable9(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void Prefable10(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Prefable11(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetPrefable12(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void Prefable13(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetPrefable14(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  bool GetPrefable15(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  bool GetPrefable16(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void Prefable17(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Prefable18(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Prefable19(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Prefable20(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetConditionalOnSecureContext1(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  bool GetConditionalOnSecureContext2(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  bool GetConditionalOnSecureContext3(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  bool GetConditionalOnSecureContext4(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void ConditionalOnSecureContext5(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ConditionalOnSecureContext6(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ConditionalOnSecureContext7(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ConditionalOnSecureContext8(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int32_t GetAttrWithLenientThis(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetAttrWithLenientThis(int32_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassRenamedInterface(nsRenamedInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestJSImplInterface> GetPutForwardsAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestJSImplInterface> GetPutForwardsAttr2(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestJSImplInterface> GetPutForwardsAttr3(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void ThrowingMethod(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetThrowingAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetThrowingAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetThrowingGetterAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetThrowingGetterAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetThrowingSetterAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetThrowingSetterAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void CanOOMMethod(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetCanOOMAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetCanOOMAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetCanOOMGetterAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetCanOOMGetterAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetCanOOMSetterAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetCanOOMSetterAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void CeReactionsMethod(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void CeReactionsMethodOverload(ErrorResult& aRv, JS::Realm* aRealm = nullptr);
  void CeReactionsMethodOverload(const nsAString& bar, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetCeReactionsAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetCeReactionsAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassArgsWithDefaults(const Optional<int32_t>& arg1, TestInterface* arg2, const Dict& arg3, double arg4, const Optional<float>& arg5, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetToJSONShouldSkipThis(JS::MutableHandle<JS::Value> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetToJSONShouldSkipThis(JS::Handle<JS::Value> arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestParentInterface> GetToJSONShouldSkipThis2(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetToJSONShouldSkipThis2(TestParentInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  // Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
  already_AddRefed<TestCallbackInterface> GetToJSONShouldSkipThis3(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetToJSONShouldSkipThis3(TestCallbackInterface& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void ToJSON(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  int8_t GetDashed_attribute(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetDashed_attribute(int8_t arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void Dashed_method(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  bool GetNonEnumerableAttr(ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetNonEnumerableAttr(bool arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void NonEnumerableMethod(ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetAllowSharedArrayBufferViewTypedef(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetAllowSharedArrayBufferViewTypedef(const ArrayBufferView& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetAllowSharedArrayBufferView(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetAllowSharedArrayBufferView(const ArrayBufferView& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetAllowSharedNullableArrayBufferView(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetAllowSharedNullableArrayBufferView(const Nullable<ArrayBufferView>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetAllowSharedArrayBuffer(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetAllowSharedArrayBuffer(const ArrayBuffer& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void GetAllowSharedNullableArrayBuffer(JS::MutableHandle<JSObject*> aRetVal, ErrorResult& aRv, JS::Realm* aRealm = nullptr) const;

  void SetAllowSharedNullableArrayBuffer(const Nullable<ArrayBuffer>& arg, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassAllowSharedArrayBufferViewTypedef(const ArrayBufferView& foo, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassAllowSharedArrayBufferView(const ArrayBufferView& foo, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassAllowSharedNullableArrayBufferView(const Nullable<ArrayBufferView>& foo, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassAllowSharedArrayBuffer(const ArrayBuffer& foo, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassAllowSharedNullableArrayBuffer(const Nullable<ArrayBuffer>& foo, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionArrayBuffer(const StringOrArrayBuffer& foo, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  void PassUnionAllowSharedArrayBuffer(const StringOrMaybeSharedArrayBuffer& foo, ErrorResult& aRv, JS::Realm* aRealm = nullptr);

  static bool
  _Create(JSContext* cx, unsigned argc, JS::Value* vp);
};


class TestJSImplNoInterfaceObjectJSImpl : public CallbackInterface
{
public:
  explicit inline TestJSImplNoInterfaceObjectJSImpl(JSContext* aCx, JS::Handle<JSObject*> aCallback, JS::Handle<JSObject*> aCallbackGlobal, nsIGlobalObject* aIncumbentGlobal)
    : CallbackInterface(aCx, aCallback, aCallbackGlobal, aIncumbentGlobal)
  {
  }

  explicit inline TestJSImplNoInterfaceObjectJSImpl(JSObject* aCallback, JSObject* aCallbackGlobal, const FastCallbackConstructor& )
    : CallbackInterface(aCallback, aCallbackGlobal, FastCallbackConstructor())
  {
  }

  explicit inline TestJSImplNoInterfaceObjectJSImpl(JSObject* aCallback, JSObject* aCallbackGlobal, JSObject* aAsyncStack, nsIGlobalObject* aIncumbentGlobal)
    : CallbackInterface(aCallback, aCallbackGlobal, aAsyncStack, aIncumbentGlobal)
  {
  }

  inline bool
  operator==(const TestJSImplNoInterfaceObjectJSImpl& aOther) const
  {
    return CallbackInterface::operator==(aOther);
  }
};


class TestJSImplNoInterfaceObject final : public nsSupportsWeakReference,
                                          public nsWrapperCache
{
public:
  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
  NS_DECL_CYCLE_COLLECTION_SCRIPT_HOLDER_CLASS(TestJSImplNoInterfaceObject)

private:
  RefPtr<TestJSImplNoInterfaceObjectJSImpl> mImpl;
  nsCOMPtr<nsIGlobalObject> mParent;

public:
  TestJSImplNoInterfaceObject(JS::Handle<JSObject*> aJSImplObject, JS::Handle<JSObject*> aJSImplGlobal, nsIGlobalObject* aParent);

private:
  ~TestJSImplNoInterfaceObject();

public:
  nsISupports* GetParentObject() const;

  JSObject* WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto) override;

  static bool
  _Create(JSContext* cx, unsigned argc, JS::Value* vp);
};


} // namespace dom
} // namespace mozilla

#endif // mozilla_dom_TestJSImplGenBinding_h
