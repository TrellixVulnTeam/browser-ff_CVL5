/* THIS FILE IS AUTOGENERATED FROM CanvasRenderingContext2D.webidl BY Codegen.py - DO NOT EDIT */

#include <type_traits>
#include "AtomList.h"
#include "CanvasPath.h"
#include "CanvasRenderingContext2DBinding.h"
#include "CanvasUtils.h"
#include "DOMMatrixBinding.h"
#include "GeckoProfiler.h"
#include "WrapperFactory.h"
#include "js/Array.h"
#include "js/ForOfIterator.h"
#include "js/Object.h"
#include "js/experimental/JitInfo.h"
#include "jsapi.h"
#include "mozilla/Atomics.h"
#include "mozilla/FloatingPoint.h"
#include "mozilla/OwningNonNull.h"
#include "mozilla/StaticPrefs_canvas.h"
#include "mozilla/dom/BindingCallContext.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/CanvasGradient.h"
#include "mozilla/dom/CanvasPattern.h"
#include "mozilla/dom/CanvasRenderingContext2D.h"
#include "mozilla/dom/DOMJSClass.h"
#include "mozilla/dom/DOMMatrix.h"
#include "mozilla/dom/Document.h"
#include "mozilla/dom/Element.h"
#include "mozilla/dom/HTMLCanvasElement.h"
#include "mozilla/dom/HTMLImageElement.h"
#include "mozilla/dom/HTMLVideoElement.h"
#include "mozilla/dom/ImageBitmap.h"
#include "mozilla/dom/ImageData.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/PrimitiveConversions.h"
#include "mozilla/dom/SVGImageElement.h"
#include "mozilla/dom/ScriptSettings.h"
#include "mozilla/dom/SimpleGlobalObject.h"
#include "mozilla/dom/TextMetrics.h"
#include "mozilla/dom/UnionConversions.h"
#include "mozilla/dom/WebIDLPrefs.h"
#include "mozilla/dom/XrayExpandoClass.h"
#include "nsContentUtils.h"
#include "nsGlobalWindow.h"

namespace mozilla {
namespace dom {

namespace binding_detail {}; // Just to make sure it's known as a namespace
using namespace mozilla::dom::binding_detail;


namespace CanvasWindingRuleValues {
extern const EnumEntry strings[3] = {
  {"nonzero", 7},
  {"evenodd", 7},
  { nullptr, 0 }
};
} // namespace CanvasWindingRuleValues

bool
ToJSValue(JSContext* aCx, CanvasWindingRule aArgument, JS::MutableHandle<JS::Value> aValue)
{
  MOZ_ASSERT(uint32_t(aArgument) < ArrayLength(CanvasWindingRuleValues::strings));
  JSString* resultStr =
    JS_NewStringCopyN(aCx, CanvasWindingRuleValues::strings[uint32_t(aArgument)].value,
                      CanvasWindingRuleValues::strings[uint32_t(aArgument)].length);
  if (!resultStr) {
    return false;
  }
  aValue.setString(resultStr);
  return true;
}


void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback, OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap& aUnion, const char* aName, uint32_t aFlags)
{
  if (aUnion.IsHTMLImageElement()) {
    ImplCycleCollectionTraverse(aCallback, aUnion.GetAsHTMLImageElement(), "mHTMLImageElement", aFlags);
  } else if (aUnion.IsSVGImageElement()) {
    ImplCycleCollectionTraverse(aCallback, aUnion.GetAsSVGImageElement(), "mSVGImageElement", aFlags);
  } else if (aUnion.IsHTMLCanvasElement()) {
    ImplCycleCollectionTraverse(aCallback, aUnion.GetAsHTMLCanvasElement(), "mHTMLCanvasElement", aFlags);
  } else if (aUnion.IsHTMLVideoElement()) {
    ImplCycleCollectionTraverse(aCallback, aUnion.GetAsHTMLVideoElement(), "mHTMLVideoElement", aFlags);
  } else if (aUnion.IsImageBitmap()) {
    ImplCycleCollectionTraverse(aCallback, aUnion.GetAsImageBitmap(), "mImageBitmap", aFlags);
  }
}


void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback, OwningUTF8StringOrCanvasGradientOrCanvasPattern& aUnion, const char* aName, uint32_t aFlags)
{
  if (aUnion.IsCanvasGradient()) {
    ImplCycleCollectionTraverse(aCallback, aUnion.GetAsCanvasGradient(), "mCanvasGradient", aFlags);
  } else if (aUnion.IsCanvasPattern()) {
    ImplCycleCollectionTraverse(aCallback, aUnion.GetAsCanvasPattern(), "mCanvasPattern", aFlags);
  }
}


void
ImplCycleCollectionUnlink(OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap& aUnion)
{
  aUnion.Uninit();
}


void
ImplCycleCollectionUnlink(OwningUTF8StringOrCanvasGradientOrCanvasPattern& aUnion)
{
  aUnion.Uninit();
}



ContextAttributes2D::ContextAttributes2D()
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}



bool
ContextAttributes2D::InitIds(JSContext* cx, ContextAttributes2DAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->willReadFrequently_id.init(cx, "willReadFrequently") ||
      !atomsCache->alpha_id.init(cx, "alpha")) {
    return false;
  }
  return true;
}

bool
ContextAttributes2D::Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  // Also evaluate isNullOrUndefined in order to avoid false-positive
  // checkers by static analysis tools
  MOZ_ASSERT_IF(!cx, val.isNull() && val.isNullOrUndefined());
  ContextAttributes2DAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<ContextAttributes2DAtoms>(cx);
    if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
        !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  if (!IsConvertibleToDictionary(val)) {
    return cx.ThrowErrorMessage<MSG_NOT_DICTIONARY>(sourceDescription);
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->alpha_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), "'alpha' member of ContextAttributes2D", &mAlpha)) {
      return false;
    }
  } else {
    mAlpha = true;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->willReadFrequently_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), "'willReadFrequently' member of ContextAttributes2D", &mWillReadFrequently)) {
      return false;
    }
  } else {
    mWillReadFrequently = false;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
ContextAttributes2D::Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // We don't want to use sourceDescription for our context here;
  // that's not really what it's formatted for.
  BindingCallContext cx(cx_, nullptr);
  return Init(cx, val, sourceDescription, passedToJSImpl);
}

void
ContextAttributes2D::TraceDictionary(JSTracer* trc)
{
}

ContextAttributes2D&
ContextAttributes2D::operator=(const ContextAttributes2D& aOther)
{
  DictionaryBase::operator=(aOther);
  mAlpha = aOther.mAlpha;
  mWillReadFrequently = aOther.mWillReadFrequently;
  return *this;
}

bool
ContextAttributes2D::operator==(const ContextAttributes2D& aOther) const
{
  if (mAlpha != aOther.mAlpha) {
      return false;
  }
  if (mWillReadFrequently != aOther.mWillReadFrequently) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail


bool
HTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const
{
  switch (mType) {
    case eUninitialized: {
      return false;
      break;
    }
    case eHTMLImageElement: {
      if (!GetOrCreateDOMReflector(cx, mValue.mHTMLImageElement.Value(), rval)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case eSVGImageElement: {
      if (!GetOrCreateDOMReflector(cx, mValue.mSVGImageElement.Value(), rval)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case eHTMLCanvasElement: {
      if (!GetOrCreateDOMReflector(cx, mValue.mHTMLCanvasElement.Value(), rval)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case eHTMLVideoElement: {
      if (!GetOrCreateDOMReflector(cx, mValue.mHTMLVideoElement.Value(), rval)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case eImageBitmap: {
      if (!GetOrCreateDOMReflector(cx, mValue.mImageBitmap.Value(), rval)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      return false;
      break;
    }
  }

  return false;
}


OwningNonNull<mozilla::dom::HTMLImageElement>&
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::RawSetAsHTMLImageElement()
{
  if (mType == eHTMLImageElement) {
    return mValue.mHTMLImageElement.Value();
  }
  MOZ_ASSERT(mType == eUninitialized);
  mType = eHTMLImageElement;
  return mValue.mHTMLImageElement.SetValue();
}

OwningNonNull<mozilla::dom::HTMLImageElement>&
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::SetAsHTMLImageElement()
{
  if (mType == eHTMLImageElement) {
    return mValue.mHTMLImageElement.Value();
  }
  Uninit();
  mType = eHTMLImageElement;
  return mValue.mHTMLImageElement.SetValue();
}

bool
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::TrySetToHTMLImageElement(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  tryNext = false;
  { // scope for memberSlot
    OwningNonNull<mozilla::dom::HTMLImageElement>& memberSlot = RawSetAsHTMLImageElement();
    static_assert(IsRefcounted<mozilla::dom::HTMLImageElement>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::HTMLImageElement, mozilla::dom::HTMLImageElement>(value, memberSlot, cx);
      if (NS_FAILED(rv)) {
        DestroyHTMLImageElement();
        tryNext = true;
        return true;
      }
    }
  }
  return true;
}

bool
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::TrySetToHTMLImageElement(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  BindingCallContext cx(cx_, nullptr);
  return TrySetToHTMLImageElement(cx, value, tryNext, passedToJSImpl);
}

void
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::DestroyHTMLImageElement()
{
  MOZ_ASSERT(IsHTMLImageElement(), "Wrong type!");
  mValue.mHTMLImageElement.Destroy();
  mType = eUninitialized;
}




OwningNonNull<mozilla::dom::SVGImageElement>&
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::RawSetAsSVGImageElement()
{
  if (mType == eSVGImageElement) {
    return mValue.mSVGImageElement.Value();
  }
  MOZ_ASSERT(mType == eUninitialized);
  mType = eSVGImageElement;
  return mValue.mSVGImageElement.SetValue();
}

OwningNonNull<mozilla::dom::SVGImageElement>&
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::SetAsSVGImageElement()
{
  if (mType == eSVGImageElement) {
    return mValue.mSVGImageElement.Value();
  }
  Uninit();
  mType = eSVGImageElement;
  return mValue.mSVGImageElement.SetValue();
}

bool
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::TrySetToSVGImageElement(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  tryNext = false;
  { // scope for memberSlot
    OwningNonNull<mozilla::dom::SVGImageElement>& memberSlot = RawSetAsSVGImageElement();
    static_assert(IsRefcounted<mozilla::dom::SVGImageElement>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::SVGImageElement, mozilla::dom::SVGImageElement>(value, memberSlot, cx);
      if (NS_FAILED(rv)) {
        DestroySVGImageElement();
        tryNext = true;
        return true;
      }
    }
  }
  return true;
}

bool
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::TrySetToSVGImageElement(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  BindingCallContext cx(cx_, nullptr);
  return TrySetToSVGImageElement(cx, value, tryNext, passedToJSImpl);
}

void
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::DestroySVGImageElement()
{
  MOZ_ASSERT(IsSVGImageElement(), "Wrong type!");
  mValue.mSVGImageElement.Destroy();
  mType = eUninitialized;
}




OwningNonNull<mozilla::dom::HTMLCanvasElement>&
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::RawSetAsHTMLCanvasElement()
{
  if (mType == eHTMLCanvasElement) {
    return mValue.mHTMLCanvasElement.Value();
  }
  MOZ_ASSERT(mType == eUninitialized);
  mType = eHTMLCanvasElement;
  return mValue.mHTMLCanvasElement.SetValue();
}

OwningNonNull<mozilla::dom::HTMLCanvasElement>&
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::SetAsHTMLCanvasElement()
{
  if (mType == eHTMLCanvasElement) {
    return mValue.mHTMLCanvasElement.Value();
  }
  Uninit();
  mType = eHTMLCanvasElement;
  return mValue.mHTMLCanvasElement.SetValue();
}

bool
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::TrySetToHTMLCanvasElement(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  tryNext = false;
  { // scope for memberSlot
    OwningNonNull<mozilla::dom::HTMLCanvasElement>& memberSlot = RawSetAsHTMLCanvasElement();
    static_assert(IsRefcounted<mozilla::dom::HTMLCanvasElement>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::HTMLCanvasElement, mozilla::dom::HTMLCanvasElement>(value, memberSlot, cx);
      if (NS_FAILED(rv)) {
        DestroyHTMLCanvasElement();
        tryNext = true;
        return true;
      }
    }
  }
  return true;
}

bool
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::TrySetToHTMLCanvasElement(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  BindingCallContext cx(cx_, nullptr);
  return TrySetToHTMLCanvasElement(cx, value, tryNext, passedToJSImpl);
}

void
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::DestroyHTMLCanvasElement()
{
  MOZ_ASSERT(IsHTMLCanvasElement(), "Wrong type!");
  mValue.mHTMLCanvasElement.Destroy();
  mType = eUninitialized;
}




OwningNonNull<mozilla::dom::HTMLVideoElement>&
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::RawSetAsHTMLVideoElement()
{
  if (mType == eHTMLVideoElement) {
    return mValue.mHTMLVideoElement.Value();
  }
  MOZ_ASSERT(mType == eUninitialized);
  mType = eHTMLVideoElement;
  return mValue.mHTMLVideoElement.SetValue();
}

OwningNonNull<mozilla::dom::HTMLVideoElement>&
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::SetAsHTMLVideoElement()
{
  if (mType == eHTMLVideoElement) {
    return mValue.mHTMLVideoElement.Value();
  }
  Uninit();
  mType = eHTMLVideoElement;
  return mValue.mHTMLVideoElement.SetValue();
}

bool
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::TrySetToHTMLVideoElement(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  tryNext = false;
  { // scope for memberSlot
    OwningNonNull<mozilla::dom::HTMLVideoElement>& memberSlot = RawSetAsHTMLVideoElement();
    static_assert(IsRefcounted<mozilla::dom::HTMLVideoElement>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::HTMLVideoElement, mozilla::dom::HTMLVideoElement>(value, memberSlot, cx);
      if (NS_FAILED(rv)) {
        DestroyHTMLVideoElement();
        tryNext = true;
        return true;
      }
    }
  }
  return true;
}

bool
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::TrySetToHTMLVideoElement(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  BindingCallContext cx(cx_, nullptr);
  return TrySetToHTMLVideoElement(cx, value, tryNext, passedToJSImpl);
}

void
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::DestroyHTMLVideoElement()
{
  MOZ_ASSERT(IsHTMLVideoElement(), "Wrong type!");
  mValue.mHTMLVideoElement.Destroy();
  mType = eUninitialized;
}




OwningNonNull<mozilla::dom::ImageBitmap>&
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::RawSetAsImageBitmap()
{
  if (mType == eImageBitmap) {
    return mValue.mImageBitmap.Value();
  }
  MOZ_ASSERT(mType == eUninitialized);
  mType = eImageBitmap;
  return mValue.mImageBitmap.SetValue();
}

OwningNonNull<mozilla::dom::ImageBitmap>&
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::SetAsImageBitmap()
{
  if (mType == eImageBitmap) {
    return mValue.mImageBitmap.Value();
  }
  Uninit();
  mType = eImageBitmap;
  return mValue.mImageBitmap.SetValue();
}

bool
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::TrySetToImageBitmap(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  tryNext = false;
  { // scope for memberSlot
    OwningNonNull<mozilla::dom::ImageBitmap>& memberSlot = RawSetAsImageBitmap();
    static_assert(IsRefcounted<mozilla::dom::ImageBitmap>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::ImageBitmap, mozilla::dom::ImageBitmap>(value, memberSlot, cx);
      if (NS_FAILED(rv)) {
        DestroyImageBitmap();
        tryNext = true;
        return true;
      }
    }
  }
  return true;
}

bool
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::TrySetToImageBitmap(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  BindingCallContext cx(cx_, nullptr);
  return TrySetToImageBitmap(cx, value, tryNext, passedToJSImpl);
}

void
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::DestroyImageBitmap()
{
  MOZ_ASSERT(IsImageBitmap(), "Wrong type!");
  mValue.mImageBitmap.Destroy();
  mType = eUninitialized;
}




void
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::Uninit()
{
  switch (mType) {
    case eUninitialized: {
      break;
    }
    case eHTMLImageElement: {
      DestroyHTMLImageElement();
      break;
    }
    case eSVGImageElement: {
      DestroySVGImageElement();
      break;
    }
    case eHTMLCanvasElement: {
      DestroyHTMLCanvasElement();
      break;
    }
    case eHTMLVideoElement: {
      DestroyHTMLVideoElement();
      break;
    }
    case eImageBitmap: {
      DestroyImageBitmap();
      break;
    }
  }
}

bool
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const
{
  switch (mType) {
    case eUninitialized: {
      return false;
      break;
    }
    case eHTMLImageElement: {
      if (!GetOrCreateDOMReflector(cx, mValue.mHTMLImageElement.Value(), rval)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case eSVGImageElement: {
      if (!GetOrCreateDOMReflector(cx, mValue.mSVGImageElement.Value(), rval)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case eHTMLCanvasElement: {
      if (!GetOrCreateDOMReflector(cx, mValue.mHTMLCanvasElement.Value(), rval)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case eHTMLVideoElement: {
      if (!GetOrCreateDOMReflector(cx, mValue.mHTMLVideoElement.Value(), rval)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case eImageBitmap: {
      if (!GetOrCreateDOMReflector(cx, mValue.mImageBitmap.Value(), rval)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      return false;
      break;
    }
  }

  return false;
}

void
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::TraceUnion(JSTracer* trc)
{
}

OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap&
OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap::operator=(const OwningHTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap& aOther)
{
  switch (aOther.mType) {
    case eUninitialized: {
      MOZ_ASSERT(mType == eUninitialized,
                 "We need to destroy ourselves?");
      break;
    }
    case eHTMLImageElement: {
      SetAsHTMLImageElement() = aOther.GetAsHTMLImageElement();
      break;
    }
    case eSVGImageElement: {
      SetAsSVGImageElement() = aOther.GetAsSVGImageElement();
      break;
    }
    case eHTMLCanvasElement: {
      SetAsHTMLCanvasElement() = aOther.GetAsHTMLCanvasElement();
      break;
    }
    case eHTMLVideoElement: {
      SetAsHTMLVideoElement() = aOther.GetAsHTMLVideoElement();
      break;
    }
    case eImageBitmap: {
      SetAsImageBitmap() = aOther.GetAsImageBitmap();
      break;
    }
  }
  return *this;
}



HitRegionOptions::HitRegionOptions()
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}



bool
HitRegionOptions::InitIds(JSContext* cx, HitRegionOptionsAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->path_id.init(cx, "path") ||
      !atomsCache->id_id.init(cx, "id") ||
      !atomsCache->control_id.init(cx, "control")) {
    return false;
  }
  return true;
}

bool
HitRegionOptions::Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  // Also evaluate isNullOrUndefined in order to avoid false-positive
  // checkers by static analysis tools
  MOZ_ASSERT_IF(!cx, val.isNull() && val.isNullOrUndefined());
  HitRegionOptionsAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<HitRegionOptionsAtoms>(cx);
    if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
        !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  if (!IsConvertibleToDictionary(val)) {
    return cx.ThrowErrorMessage<MSG_NOT_DICTIONARY>(sourceDescription);
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->control_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (temp.ref().isObject()) {
      static_assert(IsRefcounted<mozilla::dom::Element>::value, "We can only store refcounted classes.");
      {
        // Our JSContext should be in the right global to do unwrapping in.
        nsresult rv = UnwrapObject<prototypes::id::Element, mozilla::dom::Element>(temp.ptr(), mControl, cx);
        if (NS_FAILED(rv)) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("'control' member of HitRegionOptions", "Element");
          return false;
        }
      }
    } else if (temp.ref().isNullOrUndefined()) {
      mControl = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'control' member of HitRegionOptions");
      return false;
    }
  } else {
    mControl = nullptr;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->id_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ConvertJSValueToString(cx, temp.ref(), eStringify, eStringify, mId)) {
      return false;
    }
  } else {
    mId.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->path_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (temp.ref().isObject()) {
      static_assert(IsRefcounted<mozilla::dom::CanvasPath>::value, "We can only store refcounted classes.");
      {
        // Our JSContext should be in the right global to do unwrapping in.
        nsresult rv = UnwrapObject<prototypes::id::Path2D, mozilla::dom::CanvasPath>(temp.ptr(), mPath, cx);
        if (NS_FAILED(rv)) {
          cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("'path' member of HitRegionOptions", "Path2D");
          return false;
        }
      }
    } else if (temp.ref().isNullOrUndefined()) {
      mPath = nullptr;
    } else {
      cx.ThrowErrorMessage<MSG_NOT_OBJECT>("'path' member of HitRegionOptions");
      return false;
    }
  } else {
    mPath = nullptr;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
HitRegionOptions::Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // We don't want to use sourceDescription for our context here;
  // that's not really what it's formatted for.
  BindingCallContext cx(cx_, nullptr);
  return Init(cx, val, sourceDescription, passedToJSImpl);
}

void
HitRegionOptions::TraceDictionary(JSTracer* trc)
{
}



HitRegionOptions&
HitRegionOptions::operator=(const HitRegionOptions& aOther)
{
  DictionaryBase::operator=(aOther);
  mControl = aOther.mControl;
  mId = aOther.mId;
  mPath = aOther.mPath;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail


bool
UTF8StringOrCanvasGradientOrCanvasPattern::ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const
{
  switch (mType) {
    case eUninitialized: {
      return false;
      break;
    }
    case eUTF8String: {
      if (!NonVoidUTF8StringToJsval(cx, mValue.mUTF8String.Value(), rval)) {
        return false;
      }
      return true;
      break;
    }
    case eCanvasGradient: {
      if (!GetOrCreateDOMReflector(cx, mValue.mCanvasGradient.Value(), rval)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case eCanvasPattern: {
      if (!GetOrCreateDOMReflector(cx, mValue.mCanvasPattern.Value(), rval)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      return false;
      break;
    }
  }

  return false;
}


nsCString&
OwningUTF8StringOrCanvasGradientOrCanvasPattern::RawSetAsUTF8String()
{
  if (mType == eUTF8String) {
    return mValue.mUTF8String.Value();
  }
  MOZ_ASSERT(mType == eUninitialized);
  mType = eUTF8String;
  return mValue.mUTF8String.SetValue();
}

nsCString&
OwningUTF8StringOrCanvasGradientOrCanvasPattern::SetAsUTF8String()
{
  if (mType == eUTF8String) {
    return mValue.mUTF8String.Value();
  }
  Uninit();
  mType = eUTF8String;
  return mValue.mUTF8String.SetValue();
}

bool
OwningUTF8StringOrCanvasGradientOrCanvasPattern::TrySetToUTF8String(JSContext* cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  tryNext = false;
  { // scope for memberSlot
    nsCString& memberSlot = RawSetAsUTF8String();
    if (!ConvertJSValueToString(cx, value, eStringify, eStringify, memberSlot)) {
      return false;
    }
  }
  return true;
}


void
OwningUTF8StringOrCanvasGradientOrCanvasPattern::DestroyUTF8String()
{
  MOZ_ASSERT(IsUTF8String(), "Wrong type!");
  mValue.mUTF8String.Destroy();
  mType = eUninitialized;
}




OwningNonNull<mozilla::dom::CanvasGradient>&
OwningUTF8StringOrCanvasGradientOrCanvasPattern::RawSetAsCanvasGradient()
{
  if (mType == eCanvasGradient) {
    return mValue.mCanvasGradient.Value();
  }
  MOZ_ASSERT(mType == eUninitialized);
  mType = eCanvasGradient;
  return mValue.mCanvasGradient.SetValue();
}

OwningNonNull<mozilla::dom::CanvasGradient>&
OwningUTF8StringOrCanvasGradientOrCanvasPattern::SetAsCanvasGradient()
{
  if (mType == eCanvasGradient) {
    return mValue.mCanvasGradient.Value();
  }
  Uninit();
  mType = eCanvasGradient;
  return mValue.mCanvasGradient.SetValue();
}

bool
OwningUTF8StringOrCanvasGradientOrCanvasPattern::TrySetToCanvasGradient(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  tryNext = false;
  { // scope for memberSlot
    OwningNonNull<mozilla::dom::CanvasGradient>& memberSlot = RawSetAsCanvasGradient();
    static_assert(IsRefcounted<mozilla::dom::CanvasGradient>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::CanvasGradient, mozilla::dom::CanvasGradient>(value, memberSlot, cx);
      if (NS_FAILED(rv)) {
        DestroyCanvasGradient();
        tryNext = true;
        return true;
      }
    }
  }
  return true;
}

bool
OwningUTF8StringOrCanvasGradientOrCanvasPattern::TrySetToCanvasGradient(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  BindingCallContext cx(cx_, nullptr);
  return TrySetToCanvasGradient(cx, value, tryNext, passedToJSImpl);
}

void
OwningUTF8StringOrCanvasGradientOrCanvasPattern::DestroyCanvasGradient()
{
  MOZ_ASSERT(IsCanvasGradient(), "Wrong type!");
  mValue.mCanvasGradient.Destroy();
  mType = eUninitialized;
}




OwningNonNull<mozilla::dom::CanvasPattern>&
OwningUTF8StringOrCanvasGradientOrCanvasPattern::RawSetAsCanvasPattern()
{
  if (mType == eCanvasPattern) {
    return mValue.mCanvasPattern.Value();
  }
  MOZ_ASSERT(mType == eUninitialized);
  mType = eCanvasPattern;
  return mValue.mCanvasPattern.SetValue();
}

OwningNonNull<mozilla::dom::CanvasPattern>&
OwningUTF8StringOrCanvasGradientOrCanvasPattern::SetAsCanvasPattern()
{
  if (mType == eCanvasPattern) {
    return mValue.mCanvasPattern.Value();
  }
  Uninit();
  mType = eCanvasPattern;
  return mValue.mCanvasPattern.SetValue();
}

bool
OwningUTF8StringOrCanvasGradientOrCanvasPattern::TrySetToCanvasPattern(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  tryNext = false;
  { // scope for memberSlot
    OwningNonNull<mozilla::dom::CanvasPattern>& memberSlot = RawSetAsCanvasPattern();
    static_assert(IsRefcounted<mozilla::dom::CanvasPattern>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::CanvasPattern, mozilla::dom::CanvasPattern>(value, memberSlot, cx);
      if (NS_FAILED(rv)) {
        DestroyCanvasPattern();
        tryNext = true;
        return true;
      }
    }
  }
  return true;
}

bool
OwningUTF8StringOrCanvasGradientOrCanvasPattern::TrySetToCanvasPattern(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  BindingCallContext cx(cx_, nullptr);
  return TrySetToCanvasPattern(cx, value, tryNext, passedToJSImpl);
}

void
OwningUTF8StringOrCanvasGradientOrCanvasPattern::DestroyCanvasPattern()
{
  MOZ_ASSERT(IsCanvasPattern(), "Wrong type!");
  mValue.mCanvasPattern.Destroy();
  mType = eUninitialized;
}




void
OwningUTF8StringOrCanvasGradientOrCanvasPattern::Uninit()
{
  switch (mType) {
    case eUninitialized: {
      break;
    }
    case eUTF8String: {
      DestroyUTF8String();
      break;
    }
    case eCanvasGradient: {
      DestroyCanvasGradient();
      break;
    }
    case eCanvasPattern: {
      DestroyCanvasPattern();
      break;
    }
  }
}

bool
OwningUTF8StringOrCanvasGradientOrCanvasPattern::ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const
{
  switch (mType) {
    case eUninitialized: {
      return false;
      break;
    }
    case eUTF8String: {
      if (!NonVoidUTF8StringToJsval(cx, mValue.mUTF8String.Value(), rval)) {
        return false;
      }
      return true;
      break;
    }
    case eCanvasGradient: {
      if (!GetOrCreateDOMReflector(cx, mValue.mCanvasGradient.Value(), rval)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case eCanvasPattern: {
      if (!GetOrCreateDOMReflector(cx, mValue.mCanvasPattern.Value(), rval)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      return false;
      break;
    }
  }

  return false;
}

void
OwningUTF8StringOrCanvasGradientOrCanvasPattern::TraceUnion(JSTracer* trc)
{
}

OwningUTF8StringOrCanvasGradientOrCanvasPattern&
OwningUTF8StringOrCanvasGradientOrCanvasPattern::operator=(const OwningUTF8StringOrCanvasGradientOrCanvasPattern& aOther)
{
  switch (aOther.mType) {
    case eUninitialized: {
      MOZ_ASSERT(mType == eUninitialized,
                 "We need to destroy ourselves?");
      break;
    }
    case eUTF8String: {
      SetAsUTF8String() = aOther.GetAsUTF8String();
      break;
    }
    case eCanvasGradient: {
      SetAsCanvasGradient() = aOther.GetAsCanvasGradient();
      break;
    }
    case eCanvasPattern: {
      SetAsCanvasPattern() = aOther.GetAsCanvasPattern();
      break;
    }
  }
  return *this;
}


namespace CanvasGradient_Binding {

MOZ_CAN_RUN_SCRIPT static bool
addColorStop(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasGradient.addColorStop");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasGradient", "addColorStop", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasGradient*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasGradient.addColorStop", 2)) {
    return false;
  }
  float arg0;
  if (!ValueToPrimitive<float, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 1");
    return false;
  }
  binding_detail::FakeString<char> arg1;
  if (!ConvertJSValueToString(cx, args[1], eStringify, eStringify, arg1)) {
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->AddColorStop(arg0, Constify(arg1), rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->AddColorStop(arg0, Constify(arg1), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasGradient.addColorStop"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo addColorStop_methodinfo = {
  { (JSJitGetterOp)addColorStop },
  { prototypes::id::CanvasGradient },
  { PrototypeTraits<prototypes::id::CanvasGradient>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::CanvasGradient* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::CanvasGradient>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::CanvasGradient* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::CanvasGradient>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::CanvasGradient>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::CanvasGradient* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::CanvasGradient>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::CanvasGradient* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::CanvasGradient>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("addColorStop", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&addColorStop_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "CanvasGradient", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[2];
static PropertyInfo sNativeProperties_propertyInfos[2];

static const NativePropertiesN<2> sNativeProperties = {
  false, 0,
  false, 0,
  true,  0 /* sMethods */,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  2,
  sNativeProperties_sortedPropertyIndices,
  {
    { sMethods, &sNativeProperties_propertyInfos[0] },
    { sAttributes, &sNativeProperties_propertyInfos[1] }
  }
};
static_assert(2 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::CanvasGradient,
  PrototypeTraits<prototypes::id::CanvasGradient>::Depth,
  sNativePropertyHooks,
  "function CanvasGradient() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "CanvasGradientPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::CanvasGradient,
  PrototypeTraits<prototypes::id::CanvasGradient>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "CanvasGradient",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::CanvasGradient, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::CanvasGradient>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::CanvasGradient>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::CanvasGradient>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::CanvasGradient* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::CanvasGradient>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::CanvasGradient*>(aObject) ==
             reinterpret_cast<mozilla::dom::CanvasGradient*>(aObject),
             "Multiple inheritance for mozilla::dom::CanvasGradient is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::CanvasGradient> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::CanvasGradient,
  constructors::id::CanvasGradient,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::CanvasGradient);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::CanvasGradient);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "CanvasGradient", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace CanvasGradient_Binding



namespace CanvasPattern_Binding {

MOZ_CAN_RUN_SCRIPT static bool
setTransform(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasPattern.setTransform");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasPattern", "setTransform", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasPattern*>(void_self);
  binding_detail::FastDOMMatrix2DInit arg0;
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetTransform(Constify(arg0), rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetTransform(Constify(arg0), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasPattern.setTransform"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo setTransform_methodinfo = {
  { (JSJitGetterOp)setTransform },
  { prototypes::id::CanvasPattern },
  { PrototypeTraits<prototypes::id::CanvasPattern>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::CanvasPattern* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::CanvasPattern>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::CanvasPattern* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::CanvasPattern>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::CanvasPattern>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::CanvasPattern* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::CanvasPattern>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::CanvasPattern* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::CanvasPattern>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("setTransform", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&setTransform_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "CanvasPattern", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[2];
static PropertyInfo sNativeProperties_propertyInfos[2];

static const NativePropertiesN<2> sNativeProperties = {
  false, 0,
  false, 0,
  true,  0 /* sMethods */,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  2,
  sNativeProperties_sortedPropertyIndices,
  {
    { sMethods, &sNativeProperties_propertyInfos[0] },
    { sAttributes, &sNativeProperties_propertyInfos[1] }
  }
};
static_assert(2 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::CanvasPattern,
  PrototypeTraits<prototypes::id::CanvasPattern>::Depth,
  sNativePropertyHooks,
  "function CanvasPattern() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "CanvasPatternPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::CanvasPattern,
  PrototypeTraits<prototypes::id::CanvasPattern>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "CanvasPattern",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::CanvasPattern, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::CanvasPattern>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::CanvasPattern>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::CanvasPattern>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::CanvasPattern* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::CanvasPattern>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::CanvasPattern*>(aObject) ==
             reinterpret_cast<mozilla::dom::CanvasPattern*>(aObject),
             "Multiple inheritance for mozilla::dom::CanvasPattern is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::CanvasPattern> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::CanvasPattern,
  constructors::id::CanvasPattern,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::CanvasPattern);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::CanvasPattern);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "CanvasPattern", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace CanvasPattern_Binding



namespace CanvasRenderingContext2D_Binding {

MOZ_CAN_RUN_SCRIPT static bool
get_canvas(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "canvas", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  auto result(StrongOrRawPtr<mozilla::dom::HTMLCanvasElement>(MOZ_KnownLive(self)->GetCanvas()));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo canvas_getterinfo = {
  { get_canvas },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_mozCurrentTransform(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "mozCurrentTransform", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  FastErrorResult rv;
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetMozCurrentTransform(cx, &result, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetMozCurrentTransform(cx, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.mozCurrentTransform getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_mozCurrentTransform(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.mozCurrentTransform setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "mozCurrentTransform", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  JS::Rooted<JSObject*> arg0(cx);
  if (args[0].isObject()) {
    arg0 = &args[0].toObject();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetMozCurrentTransform(cx, arg0, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetMozCurrentTransform(cx, arg0, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.mozCurrentTransform setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo mozCurrentTransform_getterinfo = {
  { get_mozCurrentTransform },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo mozCurrentTransform_setterinfo = {
  { (JSJitGetterOp)set_mozCurrentTransform },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_mozCurrentTransformInverse(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "mozCurrentTransformInverse", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  FastErrorResult rv;
  JS::Rooted<JSObject*> result(cx);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetMozCurrentTransformInverse(cx, &result, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetMozCurrentTransformInverse(cx, &result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.mozCurrentTransformInverse getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  JS::ExposeObjectToActiveJS(result);
  args.rval().setObject(*result);
  if (!MaybeWrapObjectValue(cx, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_mozCurrentTransformInverse(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.mozCurrentTransformInverse setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "mozCurrentTransformInverse", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  JS::Rooted<JSObject*> arg0(cx);
  if (args[0].isObject()) {
    arg0 = &args[0].toObject();
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Value being assigned");
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetMozCurrentTransformInverse(cx, arg0, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetMozCurrentTransformInverse(cx, arg0, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.mozCurrentTransformInverse setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo mozCurrentTransformInverse_getterinfo = {
  { get_mozCurrentTransformInverse },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo mozCurrentTransformInverse_setterinfo = {
  { (JSJitGetterOp)set_mozCurrentTransformInverse },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_mozTextStyle(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "mozTextStyle", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  nsAutoCString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetMozTextStyle(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetMozTextStyle(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!NonVoidUTF8StringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_mozTextStyle(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "mozTextStyle", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  binding_detail::FakeString<char> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetMozTextStyle(Constify(arg0), rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetMozTextStyle(Constify(arg0), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.mozTextStyle setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo mozTextStyle_getterinfo = {
  { get_mozTextStyle },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo mozTextStyle_setterinfo = {
  { (JSJitGetterOp)set_mozTextStyle },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_mozImageSmoothingEnabled(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "mozImageSmoothingEnabled", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  DeprecationWarning(cx, obj, DeprecatedOperations::ePrefixedImageSmoothingEnabled);
  bool result(MOZ_KnownLive(self)->ImageSmoothingEnabled());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_mozImageSmoothingEnabled(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "mozImageSmoothingEnabled", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  DeprecationWarning(cx, obj, DeprecatedOperations::ePrefixedImageSmoothingEnabled);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetImageSmoothingEnabled(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetImageSmoothingEnabled(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo mozImageSmoothingEnabled_getterinfo = {
  { get_mozImageSmoothingEnabled },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo mozImageSmoothingEnabled_setterinfo = {
  { (JSJitGetterOp)set_mozImageSmoothingEnabled },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
drawWindow(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.drawWindow");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "drawWindow", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.drawWindow", 6)) {
    return false;
  }
  NonNull<nsGlobalWindowInner> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::Window, nsGlobalWindowInner>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Window");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 2");
    return false;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 3");
    return false;
  }
  double arg3;
  if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
    return false;
  } else if (!mozilla::IsFinite(arg3)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 4");
    return false;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
    return false;
  } else if (!mozilla::IsFinite(arg4)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 5");
    return false;
  }
  binding_detail::FakeString<char> arg5;
  if (!ConvertJSValueToString(cx, args[5], eStringify, eStringify, arg5)) {
    return false;
  }
  uint32_t arg6;
  if (args.hasDefined(6)) {
    if (!ValueToPrimitive<uint32_t, eDefault>(cx, args[6], "Argument 7", &arg6)) {
      return false;
    }
  } else {
    arg6 = 0U;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DrawWindow(MOZ_KnownLive(NonNullHelper(arg0)), arg1, arg2, arg3, arg4, Constify(arg5), arg6, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->DrawWindow(MOZ_KnownLive(NonNullHelper(arg0)), arg1, arg2, arg3, arg4, Constify(arg5), arg6, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.drawWindow"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo drawWindow_methodinfo = {
  { (JSJitGetterOp)drawWindow },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
demote(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "demote", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Demote())>, "Should be returning void here");
  MOZ_KnownLive(self)->Demote();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo demote_methodinfo = {
  { (JSJitGetterOp)demote },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_globalAlpha(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "globalAlpha", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  double result(MOZ_KnownLive(self)->GlobalAlpha());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_globalAlpha(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "globalAlpha", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetGlobalAlpha(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetGlobalAlpha(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo globalAlpha_getterinfo = {
  { get_globalAlpha },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo globalAlpha_setterinfo = {
  { (JSJitGetterOp)set_globalAlpha },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_globalCompositeOperation(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "globalCompositeOperation", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  FastErrorResult rv;
  DOMString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetGlobalCompositeOperation(result, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetGlobalCompositeOperation(result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.globalCompositeOperation getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_globalCompositeOperation(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "globalCompositeOperation", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetGlobalCompositeOperation(NonNullHelper(Constify(arg0)), rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetGlobalCompositeOperation(NonNullHelper(Constify(arg0)), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.globalCompositeOperation setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo globalCompositeOperation_getterinfo = {
  { get_globalCompositeOperation },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo globalCompositeOperation_setterinfo = {
  { (JSJitGetterOp)set_globalCompositeOperation },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
drawImage(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.drawImage");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "drawImage", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  unsigned argcount = std::min(args.length(), 9u);
  switch (argcount) {
    case 3: {
      bool foundNonFiniteFloat = false;
      HTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap arg0;
      HTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmapArgument arg0_holder(arg0);
      {
        bool done = false, failed = false, tryNext;
        if (args[0].isObject()) {
          done = (failed = !arg0_holder.TrySetToHTMLImageElement(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToSVGImageElement(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToHTMLCanvasElement(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToHTMLVideoElement(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToImageBitmap(cx, args[0], tryNext, false)) || !tryNext;

        }
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "HTMLImageElement, SVGImageElement, HTMLCanvasElement, HTMLVideoElement, ImageBitmap");
          return false;
        }
      }
      double arg1;
      if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
        return false;
      } else if (!mozilla::IsFinite(arg1)) {
        foundNonFiniteFloat = true;
      }
      double arg2;
      if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
        return false;
      } else if (!mozilla::IsFinite(arg2)) {
        foundNonFiniteFloat = true;
      }
      if (foundNonFiniteFloat) {
        args.rval().setUndefined();
        return true;
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DrawImage(Constify(arg0), arg1, arg2, rv))>, "Should be returning void here");
      MOZ_KnownLive(self)->DrawImage(Constify(arg0), arg1, arg2, rv);
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.drawImage"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 5: {
      bool foundNonFiniteFloat = false;
      HTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap arg0;
      HTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmapArgument arg0_holder(arg0);
      {
        bool done = false, failed = false, tryNext;
        if (args[0].isObject()) {
          done = (failed = !arg0_holder.TrySetToHTMLImageElement(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToSVGImageElement(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToHTMLCanvasElement(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToHTMLVideoElement(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToImageBitmap(cx, args[0], tryNext, false)) || !tryNext;

        }
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "HTMLImageElement, SVGImageElement, HTMLCanvasElement, HTMLVideoElement, ImageBitmap");
          return false;
        }
      }
      double arg1;
      if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
        return false;
      } else if (!mozilla::IsFinite(arg1)) {
        foundNonFiniteFloat = true;
      }
      double arg2;
      if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
        return false;
      } else if (!mozilla::IsFinite(arg2)) {
        foundNonFiniteFloat = true;
      }
      double arg3;
      if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
        return false;
      } else if (!mozilla::IsFinite(arg3)) {
        foundNonFiniteFloat = true;
      }
      double arg4;
      if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
        return false;
      } else if (!mozilla::IsFinite(arg4)) {
        foundNonFiniteFloat = true;
      }
      if (foundNonFiniteFloat) {
        args.rval().setUndefined();
        return true;
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DrawImage(Constify(arg0), arg1, arg2, arg3, arg4, rv))>, "Should be returning void here");
      MOZ_KnownLive(self)->DrawImage(Constify(arg0), arg1, arg2, arg3, arg4, rv);
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.drawImage"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 9: {
      bool foundNonFiniteFloat = false;
      HTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap arg0;
      HTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmapArgument arg0_holder(arg0);
      {
        bool done = false, failed = false, tryNext;
        if (args[0].isObject()) {
          done = (failed = !arg0_holder.TrySetToHTMLImageElement(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToSVGImageElement(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToHTMLCanvasElement(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToHTMLVideoElement(cx, args[0], tryNext, false)) || !tryNext ||
                 (failed = !arg0_holder.TrySetToImageBitmap(cx, args[0], tryNext, false)) || !tryNext;

        }
        if (failed) {
          return false;
        }
        if (!done) {
          cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "HTMLImageElement, SVGImageElement, HTMLCanvasElement, HTMLVideoElement, ImageBitmap");
          return false;
        }
      }
      double arg1;
      if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
        return false;
      } else if (!mozilla::IsFinite(arg1)) {
        foundNonFiniteFloat = true;
      }
      double arg2;
      if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
        return false;
      } else if (!mozilla::IsFinite(arg2)) {
        foundNonFiniteFloat = true;
      }
      double arg3;
      if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
        return false;
      } else if (!mozilla::IsFinite(arg3)) {
        foundNonFiniteFloat = true;
      }
      double arg4;
      if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
        return false;
      } else if (!mozilla::IsFinite(arg4)) {
        foundNonFiniteFloat = true;
      }
      double arg5;
      if (!ValueToPrimitive<double, eDefault>(cx, args[5], "Argument 6", &arg5)) {
        return false;
      } else if (!mozilla::IsFinite(arg5)) {
        foundNonFiniteFloat = true;
      }
      double arg6;
      if (!ValueToPrimitive<double, eDefault>(cx, args[6], "Argument 7", &arg6)) {
        return false;
      } else if (!mozilla::IsFinite(arg6)) {
        foundNonFiniteFloat = true;
      }
      double arg7;
      if (!ValueToPrimitive<double, eDefault>(cx, args[7], "Argument 8", &arg7)) {
        return false;
      } else if (!mozilla::IsFinite(arg7)) {
        foundNonFiniteFloat = true;
      }
      double arg8;
      if (!ValueToPrimitive<double, eDefault>(cx, args[8], "Argument 9", &arg8)) {
        return false;
      } else if (!mozilla::IsFinite(arg8)) {
        foundNonFiniteFloat = true;
      }
      if (foundNonFiniteFloat) {
        args.rval().setUndefined();
        return true;
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DrawImage(Constify(arg0), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, rv))>, "Should be returning void here");
      MOZ_KnownLive(self)->DrawImage(Constify(arg0), arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, rv);
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.drawImage"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo drawImage_methodinfo = {
  { (JSJitGetterOp)drawImage },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
beginPath(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "beginPath", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->BeginPath())>, "Should be returning void here");
  MOZ_KnownLive(self)->BeginPath();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo beginPath_methodinfo = {
  { (JSJitGetterOp)beginPath },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
fill(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.fill");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "fill", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  unsigned argcount = std::min(args.length(), 2u);
  switch (argcount) {
    case 0: {
      CanvasWindingRule arg0;
      if (args.hasDefined(0)) {
        {
          int index;
          if (!FindEnumStringIndex<true>(cx, args[0], CanvasWindingRuleValues::strings, "CanvasWindingRule", "argument 1", &index)) {
            return false;
          }
          MOZ_ASSERT(index >= 0);
          arg0 = static_cast<CanvasWindingRule>(index);
        }
      } else {
        arg0 = CanvasWindingRule::Nonzero;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Fill(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->Fill(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isObject()) {
        do {
          NonNull<mozilla::dom::CanvasPath> arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::Path2D, mozilla::dom::CanvasPath>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          CanvasWindingRule arg1;
          if (args.hasDefined(1)) {
            {
              int index;
              if (!FindEnumStringIndex<true>(cx, args[1], CanvasWindingRuleValues::strings, "CanvasWindingRule", "argument 2", &index)) {
                return false;
              }
              MOZ_ASSERT(index >= 0);
              arg1 = static_cast<CanvasWindingRule>(index);
            }
          } else {
            arg1 = CanvasWindingRule::Nonzero;
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Fill(MOZ_KnownLive(NonNullHelper(arg0)), arg1))>, "Should be returning void here");
          MOZ_KnownLive(self)->Fill(MOZ_KnownLive(NonNullHelper(arg0)), arg1);
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      CanvasWindingRule arg0;
      if (args.hasDefined(0)) {
        {
          int index;
          if (!FindEnumStringIndex<true>(cx, args[0], CanvasWindingRuleValues::strings, "CanvasWindingRule", "argument 1", &index)) {
            return false;
          }
          MOZ_ASSERT(index >= 0);
          arg0 = static_cast<CanvasWindingRule>(index);
        }
      } else {
        arg0 = CanvasWindingRule::Nonzero;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Fill(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->Fill(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 2: {
      NonNull<mozilla::dom::CanvasPath> arg0;
      if (args[0].isObject()) {
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::Path2D, mozilla::dom::CanvasPath>(args[0], arg0, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Path2D");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
      CanvasWindingRule arg1;
      if (args.hasDefined(1)) {
        {
          int index;
          if (!FindEnumStringIndex<true>(cx, args[1], CanvasWindingRuleValues::strings, "CanvasWindingRule", "argument 2", &index)) {
            return false;
          }
          MOZ_ASSERT(index >= 0);
          arg1 = static_cast<CanvasWindingRule>(index);
        }
      } else {
        arg1 = CanvasWindingRule::Nonzero;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Fill(MOZ_KnownLive(NonNullHelper(arg0)), arg1))>, "Should be returning void here");
      MOZ_KnownLive(self)->Fill(MOZ_KnownLive(NonNullHelper(arg0)), arg1);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo fill_methodinfo = {
  { (JSJitGetterOp)fill },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
stroke(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.stroke");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "stroke", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Stroke())>, "Should be returning void here");
      MOZ_KnownLive(self)->Stroke();
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      NonNull<mozilla::dom::CanvasPath> arg0;
      if (args[0].isObject()) {
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::Path2D, mozilla::dom::CanvasPath>(args[0], arg0, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Path2D");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Stroke(MOZ_KnownLive(NonNullHelper(arg0))))>, "Should be returning void here");
      MOZ_KnownLive(self)->Stroke(MOZ_KnownLive(NonNullHelper(arg0)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo stroke_methodinfo = {
  { (JSJitGetterOp)stroke },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
clip(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.clip");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "clip", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  unsigned argcount = std::min(args.length(), 2u);
  switch (argcount) {
    case 0: {
      CanvasWindingRule arg0;
      if (args.hasDefined(0)) {
        {
          int index;
          if (!FindEnumStringIndex<true>(cx, args[0], CanvasWindingRuleValues::strings, "CanvasWindingRule", "argument 1", &index)) {
            return false;
          }
          MOZ_ASSERT(index >= 0);
          arg0 = static_cast<CanvasWindingRule>(index);
        }
      } else {
        arg0 = CanvasWindingRule::Nonzero;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Clip(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->Clip(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 1: {
      if (args[0].isObject()) {
        do {
          NonNull<mozilla::dom::CanvasPath> arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::Path2D, mozilla::dom::CanvasPath>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          CanvasWindingRule arg1;
          if (args.hasDefined(1)) {
            {
              int index;
              if (!FindEnumStringIndex<true>(cx, args[1], CanvasWindingRuleValues::strings, "CanvasWindingRule", "argument 2", &index)) {
                return false;
              }
              MOZ_ASSERT(index >= 0);
              arg1 = static_cast<CanvasWindingRule>(index);
            }
          } else {
            arg1 = CanvasWindingRule::Nonzero;
          }
          // NOTE: This assert does NOT call the function.
          static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Clip(MOZ_KnownLive(NonNullHelper(arg0)), arg1))>, "Should be returning void here");
          MOZ_KnownLive(self)->Clip(MOZ_KnownLive(NonNullHelper(arg0)), arg1);
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setUndefined();
          return true;
        } while (false);
      }
      CanvasWindingRule arg0;
      if (args.hasDefined(0)) {
        {
          int index;
          if (!FindEnumStringIndex<true>(cx, args[0], CanvasWindingRuleValues::strings, "CanvasWindingRule", "argument 1", &index)) {
            return false;
          }
          MOZ_ASSERT(index >= 0);
          arg0 = static_cast<CanvasWindingRule>(index);
        }
      } else {
        arg0 = CanvasWindingRule::Nonzero;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Clip(arg0))>, "Should be returning void here");
      MOZ_KnownLive(self)->Clip(arg0);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 2: {
      NonNull<mozilla::dom::CanvasPath> arg0;
      if (args[0].isObject()) {
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::Path2D, mozilla::dom::CanvasPath>(args[0], arg0, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Path2D");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
      CanvasWindingRule arg1;
      if (args.hasDefined(1)) {
        {
          int index;
          if (!FindEnumStringIndex<true>(cx, args[1], CanvasWindingRuleValues::strings, "CanvasWindingRule", "argument 2", &index)) {
            return false;
          }
          MOZ_ASSERT(index >= 0);
          arg1 = static_cast<CanvasWindingRule>(index);
        }
      } else {
        arg1 = CanvasWindingRule::Nonzero;
      }
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Clip(MOZ_KnownLive(NonNullHelper(arg0)), arg1))>, "Should be returning void here");
      MOZ_KnownLive(self)->Clip(MOZ_KnownLive(NonNullHelper(arg0)), arg1);
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo clip_methodinfo = {
  { (JSJitGetterOp)clip },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
isPointInPath(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.isPointInPath");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "isPointInPath", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  unsigned argcount = std::min(args.length(), 4u);
  switch (argcount) {
    case 2: {
      double arg0;
      if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      double arg1;
      if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
        return false;
      }
      CanvasWindingRule arg2;
      if (args.hasDefined(2)) {
        {
          int index;
          if (!FindEnumStringIndex<true>(cx, args[2], CanvasWindingRuleValues::strings, "CanvasWindingRule", "argument 3", &index)) {
            return false;
          }
          MOZ_ASSERT(index >= 0);
          arg2 = static_cast<CanvasWindingRule>(index);
        }
      } else {
        arg2 = CanvasWindingRule::Nonzero;
      }
      NonNull<nsIPrincipal> subjectPrincipal;
      {
        JS::Realm* realm = js::GetContextRealm(cx);
        MOZ_ASSERT(realm);
        JSPrincipals* principals = JS::GetRealmPrincipals(realm);
        nsIPrincipal* principal = nsJSPrincipals::get(principals);

        subjectPrincipal = principal;
      }
      bool result(MOZ_KnownLive(self)->IsPointInPath(cx, arg0, arg1, arg2, MOZ_KnownLive(NonNullHelper(subjectPrincipal))));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setBoolean(result);
      return true;
      break;
    }
    case 3: {
      if (args[0].isObject()) {
        do {
          NonNull<mozilla::dom::CanvasPath> arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::Path2D, mozilla::dom::CanvasPath>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          double arg1;
          if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
            return false;
          }
          double arg2;
          if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
            return false;
          }
          CanvasWindingRule arg3;
          if (args.hasDefined(3)) {
            {
              int index;
              if (!FindEnumStringIndex<true>(cx, args[3], CanvasWindingRuleValues::strings, "CanvasWindingRule", "argument 4", &index)) {
                return false;
              }
              MOZ_ASSERT(index >= 0);
              arg3 = static_cast<CanvasWindingRule>(index);
            }
          } else {
            arg3 = CanvasWindingRule::Nonzero;
          }
          NonNull<nsIPrincipal> subjectPrincipal;
          {
            JS::Realm* realm = js::GetContextRealm(cx);
            MOZ_ASSERT(realm);
            JSPrincipals* principals = JS::GetRealmPrincipals(realm);
            nsIPrincipal* principal = nsJSPrincipals::get(principals);

            subjectPrincipal = principal;
          }
          bool result(MOZ_KnownLive(self)->IsPointInPath(cx, MOZ_KnownLive(NonNullHelper(arg0)), arg1, arg2, arg3, MOZ_KnownLive(NonNullHelper(subjectPrincipal))));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          args.rval().setBoolean(result);
          return true;
        } while (false);
      }
      double arg0;
      if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      double arg1;
      if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
        return false;
      }
      CanvasWindingRule arg2;
      if (args.hasDefined(2)) {
        {
          int index;
          if (!FindEnumStringIndex<true>(cx, args[2], CanvasWindingRuleValues::strings, "CanvasWindingRule", "argument 3", &index)) {
            return false;
          }
          MOZ_ASSERT(index >= 0);
          arg2 = static_cast<CanvasWindingRule>(index);
        }
      } else {
        arg2 = CanvasWindingRule::Nonzero;
      }
      NonNull<nsIPrincipal> subjectPrincipal;
      {
        JS::Realm* realm = js::GetContextRealm(cx);
        MOZ_ASSERT(realm);
        JSPrincipals* principals = JS::GetRealmPrincipals(realm);
        nsIPrincipal* principal = nsJSPrincipals::get(principals);

        subjectPrincipal = principal;
      }
      bool result(MOZ_KnownLive(self)->IsPointInPath(cx, arg0, arg1, arg2, MOZ_KnownLive(NonNullHelper(subjectPrincipal))));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setBoolean(result);
      return true;
      break;
    }
    case 4: {
      NonNull<mozilla::dom::CanvasPath> arg0;
      if (args[0].isObject()) {
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::Path2D, mozilla::dom::CanvasPath>(args[0], arg0, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Path2D");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
      double arg1;
      if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
        return false;
      }
      double arg2;
      if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
        return false;
      }
      CanvasWindingRule arg3;
      if (args.hasDefined(3)) {
        {
          int index;
          if (!FindEnumStringIndex<true>(cx, args[3], CanvasWindingRuleValues::strings, "CanvasWindingRule", "argument 4", &index)) {
            return false;
          }
          MOZ_ASSERT(index >= 0);
          arg3 = static_cast<CanvasWindingRule>(index);
        }
      } else {
        arg3 = CanvasWindingRule::Nonzero;
      }
      NonNull<nsIPrincipal> subjectPrincipal;
      {
        JS::Realm* realm = js::GetContextRealm(cx);
        MOZ_ASSERT(realm);
        JSPrincipals* principals = JS::GetRealmPrincipals(realm);
        nsIPrincipal* principal = nsJSPrincipals::get(principals);

        subjectPrincipal = principal;
      }
      bool result(MOZ_KnownLive(self)->IsPointInPath(cx, MOZ_KnownLive(NonNullHelper(arg0)), arg1, arg2, arg3, MOZ_KnownLive(NonNullHelper(subjectPrincipal))));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setBoolean(result);
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo isPointInPath_methodinfo = {
  { (JSJitGetterOp)isPointInPath },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
isPointInStroke(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.isPointInStroke");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "isPointInStroke", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  unsigned argcount = std::min(args.length(), 3u);
  switch (argcount) {
    case 2: {
      double arg0;
      if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      } else if (!mozilla::IsFinite(arg0)) {
        cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 1");
        return false;
      }
      double arg1;
      if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
        return false;
      } else if (!mozilla::IsFinite(arg1)) {
        cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 2");
        return false;
      }
      NonNull<nsIPrincipal> subjectPrincipal;
      {
        JS::Realm* realm = js::GetContextRealm(cx);
        MOZ_ASSERT(realm);
        JSPrincipals* principals = JS::GetRealmPrincipals(realm);
        nsIPrincipal* principal = nsJSPrincipals::get(principals);

        subjectPrincipal = principal;
      }
      bool result(MOZ_KnownLive(self)->IsPointInStroke(cx, arg0, arg1, MOZ_KnownLive(NonNullHelper(subjectPrincipal))));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setBoolean(result);
      return true;
      break;
    }
    case 3: {
      NonNull<mozilla::dom::CanvasPath> arg0;
      if (args[0].isObject()) {
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::Path2D, mozilla::dom::CanvasPath>(args[0], arg0, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Path2D");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
      double arg1;
      if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
        return false;
      }
      double arg2;
      if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
        return false;
      }
      NonNull<nsIPrincipal> subjectPrincipal;
      {
        JS::Realm* realm = js::GetContextRealm(cx);
        MOZ_ASSERT(realm);
        JSPrincipals* principals = JS::GetRealmPrincipals(realm);
        nsIPrincipal* principal = nsJSPrincipals::get(principals);

        subjectPrincipal = principal;
      }
      bool result(MOZ_KnownLive(self)->IsPointInStroke(cx, MOZ_KnownLive(NonNullHelper(arg0)), arg1, arg2, MOZ_KnownLive(NonNullHelper(subjectPrincipal))));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setBoolean(result);
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo isPointInStroke_methodinfo = {
  { (JSJitGetterOp)isPointInStroke },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_strokeStyle(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "strokeStyle", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  OwningUTF8StringOrCanvasGradientOrCanvasPattern result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetStrokeStyle(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetStrokeStyle(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_strokeStyle(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.strokeStyle setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "strokeStyle", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  UTF8StringOrCanvasGradientOrCanvasPattern arg0;
  UTF8StringOrCanvasGradientOrCanvasPatternArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      done = (failed = !arg0_holder.TrySetToCanvasGradient(cx, args[0], tryNext, false)) || !tryNext ||
             (failed = !arg0_holder.TrySetToCanvasPattern(cx, args[0], tryNext, false)) || !tryNext;

    }
    if (!done) {
      do {
        done = (failed = !arg0_holder.TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Value being assigned", "CanvasGradient, CanvasPattern");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetStrokeStyle(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetStrokeStyle(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo strokeStyle_getterinfo = {
  { get_strokeStyle },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo strokeStyle_setterinfo = {
  { (JSJitGetterOp)set_strokeStyle },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_fillStyle(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "fillStyle", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  OwningUTF8StringOrCanvasGradientOrCanvasPattern result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetFillStyle(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetFillStyle(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToJSVal(cx, obj, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_fillStyle(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.fillStyle setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "fillStyle", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  UTF8StringOrCanvasGradientOrCanvasPattern arg0;
  UTF8StringOrCanvasGradientOrCanvasPatternArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      done = (failed = !arg0_holder.TrySetToCanvasGradient(cx, args[0], tryNext, false)) || !tryNext ||
             (failed = !arg0_holder.TrySetToCanvasPattern(cx, args[0], tryNext, false)) || !tryNext;

    }
    if (!done) {
      do {
        done = (failed = !arg0_holder.TrySetToUTF8String(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (false);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Value being assigned", "CanvasGradient, CanvasPattern");
      return false;
    }
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetFillStyle(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetFillStyle(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo fillStyle_getterinfo = {
  { get_fillStyle },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo fillStyle_setterinfo = {
  { (JSJitGetterOp)set_fillStyle },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
createLinearGradient(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.createLinearGradient");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "createLinearGradient", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.createLinearGradient", 4)) {
    return false;
  }
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 1");
    return false;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 2");
    return false;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 3");
    return false;
  }
  double arg3;
  if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
    return false;
  } else if (!mozilla::IsFinite(arg3)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 4");
    return false;
  }
  auto result(StrongOrRawPtr<mozilla::dom::CanvasGradient>(MOZ_KnownLive(self)->CreateLinearGradient(arg0, arg1, arg2, arg3)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo createLinearGradient_methodinfo = {
  { (JSJitGetterOp)createLinearGradient },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
createRadialGradient(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.createRadialGradient");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "createRadialGradient", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.createRadialGradient", 6)) {
    return false;
  }
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 1");
    return false;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 2");
    return false;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 3");
    return false;
  }
  double arg3;
  if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
    return false;
  } else if (!mozilla::IsFinite(arg3)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 4");
    return false;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
    return false;
  } else if (!mozilla::IsFinite(arg4)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 5");
    return false;
  }
  double arg5;
  if (!ValueToPrimitive<double, eDefault>(cx, args[5], "Argument 6", &arg5)) {
    return false;
  } else if (!mozilla::IsFinite(arg5)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 6");
    return false;
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::CanvasGradient>(MOZ_KnownLive(self)->CreateRadialGradient(arg0, arg1, arg2, arg3, arg4, arg5, rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.createRadialGradient"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo createRadialGradient_methodinfo = {
  { (JSJitGetterOp)createRadialGradient },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
createConicGradient(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.createConicGradient");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "createConicGradient", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.createConicGradient", 3)) {
    return false;
  }
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 1");
    return false;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 2");
    return false;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    cx.ThrowErrorMessage<MSG_NOT_FINITE>("Argument 3");
    return false;
  }
  auto result(StrongOrRawPtr<mozilla::dom::CanvasGradient>(MOZ_KnownLive(self)->CreateConicGradient(arg0, arg1, arg2)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo createConicGradient_methodinfo = {
  { (JSJitGetterOp)createConicGradient },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
createPattern(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.createPattern");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "createPattern", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.createPattern", 2)) {
    return false;
  }
  HTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmap arg0;
  HTMLImageElementOrSVGImageElementOrHTMLCanvasElementOrHTMLVideoElementOrImageBitmapArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      done = (failed = !arg0_holder.TrySetToHTMLImageElement(cx, args[0], tryNext, false)) || !tryNext ||
             (failed = !arg0_holder.TrySetToSVGImageElement(cx, args[0], tryNext, false)) || !tryNext ||
             (failed = !arg0_holder.TrySetToHTMLCanvasElement(cx, args[0], tryNext, false)) || !tryNext ||
             (failed = !arg0_holder.TrySetToHTMLVideoElement(cx, args[0], tryNext, false)) || !tryNext ||
             (failed = !arg0_holder.TrySetToImageBitmap(cx, args[0], tryNext, false)) || !tryNext;

    }
    if (failed) {
      return false;
    }
    if (!done) {
      cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("Argument 1", "HTMLImageElement, SVGImageElement, HTMLCanvasElement, HTMLVideoElement, ImageBitmap");
      return false;
    }
  }
  binding_detail::FakeString<char16_t> arg1;
  if (!ConvertJSValueToString(cx, args[1], eEmpty, eStringify, arg1)) {
    return false;
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::CanvasPattern>(MOZ_KnownLive(self)->CreatePattern(Constify(arg0), NonNullHelper(Constify(arg1)), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.createPattern"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo createPattern_methodinfo = {
  { (JSJitGetterOp)createPattern },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_filter(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "filter", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  nsAutoCString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetFilter(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetFilter(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!NonVoidUTF8StringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_filter(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "filter", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  binding_detail::FakeString<char> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetFilter(Constify(arg0), rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetFilter(Constify(arg0), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.filter setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo filter_getterinfo = {
  { get_filter },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo filter_setterinfo = {
  { (JSJitGetterOp)set_filter },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
addHitRegion(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.addHitRegion");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "addHitRegion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  binding_detail::FastHitRegionOptions arg0;
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->AddHitRegion(Constify(arg0), rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->AddHitRegion(Constify(arg0), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.addHitRegion"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo addHitRegion_methodinfo = {
  { (JSJitGetterOp)addHitRegion },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
removeHitRegion(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "removeHitRegion", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.removeHitRegion", 1)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->RemoveHitRegion(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->RemoveHitRegion(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo removeHitRegion_methodinfo = {
  { (JSJitGetterOp)removeHitRegion },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
clearHitRegions(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "clearHitRegions", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ClearHitRegions())>, "Should be returning void here");
  MOZ_KnownLive(self)->ClearHitRegions();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo clearHitRegions_methodinfo = {
  { (JSJitGetterOp)clearHitRegions },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
createImageData(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.createImageData");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "createImageData", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  unsigned argcount = std::min(args.length(), 2u);
  switch (argcount) {
    case 1: {
      NonNull<mozilla::dom::ImageData> arg0;
      if (args[0].isObject()) {
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::ImageData, mozilla::dom::ImageData>(args[0], arg0, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ImageData");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
      FastErrorResult rv;
      auto result(StrongOrRawPtr<mozilla::dom::ImageData>(MOZ_KnownLive(self)->CreateImageData(cx, MOZ_KnownLive(NonNullHelper(arg0)), rv)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.createImageData"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, args.rval())) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case 2: {
      int32_t arg0;
      if (!ValueToPrimitive<int32_t, eEnforceRange>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      }
      int32_t arg1;
      if (!ValueToPrimitive<int32_t, eEnforceRange>(cx, args[1], "Argument 2", &arg1)) {
        return false;
      }
      FastErrorResult rv;
      auto result(StrongOrRawPtr<mozilla::dom::ImageData>(MOZ_KnownLive(self)->CreateImageData(cx, arg0, arg1, rv)));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.createImageData"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, args.rval())) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo createImageData_methodinfo = {
  { (JSJitGetterOp)createImageData },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
getImageData(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.getImageData");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "getImageData", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.getImageData", 4)) {
    return false;
  }
  int32_t arg0;
  if (!ValueToPrimitive<int32_t, eEnforceRange>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  }
  int32_t arg1;
  if (!ValueToPrimitive<int32_t, eEnforceRange>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  }
  int32_t arg2;
  if (!ValueToPrimitive<int32_t, eEnforceRange>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  }
  int32_t arg3;
  if (!ValueToPrimitive<int32_t, eEnforceRange>(cx, args[3], "Argument 4", &arg3)) {
    return false;
  }
  FastErrorResult rv;
  NonNull<nsIPrincipal> subjectPrincipal;
  {
    JS::Realm* realm = js::GetContextRealm(cx);
    MOZ_ASSERT(realm);
    JSPrincipals* principals = JS::GetRealmPrincipals(realm);
    nsIPrincipal* principal = nsJSPrincipals::get(principals);

    subjectPrincipal = principal;
  }
  auto result(StrongOrRawPtr<mozilla::dom::ImageData>(MOZ_KnownLive(self)->GetImageData(cx, arg0, arg1, arg2, arg3, MOZ_KnownLive(NonNullHelper(subjectPrincipal)), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.getImageData"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo getImageData_methodinfo = {
  { (JSJitGetterOp)getImageData },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
putImageData(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.putImageData");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "putImageData", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  unsigned argcount = std::min(args.length(), 7u);
  switch (argcount) {
    case 3: {
      NonNull<mozilla::dom::ImageData> arg0;
      if (args[0].isObject()) {
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::ImageData, mozilla::dom::ImageData>(args[0], arg0, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ImageData");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
      int32_t arg1;
      if (!ValueToPrimitive<int32_t, eEnforceRange>(cx, args[1], "Argument 2", &arg1)) {
        return false;
      }
      int32_t arg2;
      if (!ValueToPrimitive<int32_t, eEnforceRange>(cx, args[2], "Argument 3", &arg2)) {
        return false;
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PutImageData(MOZ_KnownLive(NonNullHelper(arg0)), arg1, arg2, rv))>, "Should be returning void here");
      MOZ_KnownLive(self)->PutImageData(MOZ_KnownLive(NonNullHelper(arg0)), arg1, arg2, rv);
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.putImageData"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 7: {
      NonNull<mozilla::dom::ImageData> arg0;
      if (args[0].isObject()) {
        {
          // Our JSContext should be in the right global to do unwrapping in.
          nsresult rv = UnwrapObject<prototypes::id::ImageData, mozilla::dom::ImageData>(args[0], arg0, cx);
          if (NS_FAILED(rv)) {
            cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "ImageData");
            return false;
          }
        }
      } else {
        cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
        return false;
      }
      int32_t arg1;
      if (!ValueToPrimitive<int32_t, eEnforceRange>(cx, args[1], "Argument 2", &arg1)) {
        return false;
      }
      int32_t arg2;
      if (!ValueToPrimitive<int32_t, eEnforceRange>(cx, args[2], "Argument 3", &arg2)) {
        return false;
      }
      int32_t arg3;
      if (!ValueToPrimitive<int32_t, eEnforceRange>(cx, args[3], "Argument 4", &arg3)) {
        return false;
      }
      int32_t arg4;
      if (!ValueToPrimitive<int32_t, eEnforceRange>(cx, args[4], "Argument 5", &arg4)) {
        return false;
      }
      int32_t arg5;
      if (!ValueToPrimitive<int32_t, eEnforceRange>(cx, args[5], "Argument 6", &arg5)) {
        return false;
      }
      int32_t arg6;
      if (!ValueToPrimitive<int32_t, eEnforceRange>(cx, args[6], "Argument 7", &arg6)) {
        return false;
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->PutImageData(MOZ_KnownLive(NonNullHelper(arg0)), arg1, arg2, arg3, arg4, arg5, arg6, rv))>, "Should be returning void here");
      MOZ_KnownLive(self)->PutImageData(MOZ_KnownLive(NonNullHelper(arg0)), arg1, arg2, arg3, arg4, arg5, arg6, rv);
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.putImageData"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo putImageData_methodinfo = {
  { (JSJitGetterOp)putImageData },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_imageSmoothingEnabled(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "imageSmoothingEnabled", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  bool result(MOZ_KnownLive(self)->ImageSmoothingEnabled());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setBoolean(result);
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_imageSmoothingEnabled(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "imageSmoothingEnabled", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  bool arg0;
  if (!ValueToPrimitive<bool, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetImageSmoothingEnabled(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetImageSmoothingEnabled(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo imageSmoothingEnabled_getterinfo = {
  { get_imageSmoothingEnabled },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_BOOLEAN,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo imageSmoothingEnabled_setterinfo = {
  { (JSJitGetterOp)set_imageSmoothingEnabled },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_lineWidth(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "lineWidth", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  double result(MOZ_KnownLive(self)->LineWidth());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_lineWidth(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.lineWidth setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "lineWidth", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetLineWidth(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetLineWidth(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo lineWidth_getterinfo = {
  { get_lineWidth },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo lineWidth_setterinfo = {
  { (JSJitGetterOp)set_lineWidth },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_lineCap(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "lineCap", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  DOMString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetLineCap(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetLineCap(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_lineCap(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "lineCap", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetLineCap(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetLineCap(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo lineCap_getterinfo = {
  { get_lineCap },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo lineCap_setterinfo = {
  { (JSJitGetterOp)set_lineCap },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_lineJoin(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "lineJoin", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  FastErrorResult rv;
  DOMString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetLineJoin(result, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetLineJoin(result, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.lineJoin getter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_lineJoin(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "lineJoin", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetLineJoin(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetLineJoin(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo lineJoin_getterinfo = {
  { get_lineJoin },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo lineJoin_setterinfo = {
  { (JSJitGetterOp)set_lineJoin },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_miterLimit(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "miterLimit", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  double result(MOZ_KnownLive(self)->MiterLimit());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_miterLimit(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.miterLimit setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "miterLimit", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetMiterLimit(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetMiterLimit(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo miterLimit_getterinfo = {
  { get_miterLimit },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo miterLimit_setterinfo = {
  { (JSJitGetterOp)set_miterLimit },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
setLineDash(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.setLineDash");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "setLineDash", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.setLineDash", 1)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  binding_detail::AutoSequence<double> arg0;
  if (args[0].isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(args[0], JS::ForOfIterator::AllowNonIterable)) {
      return false;
    }
    if (!iter.valueIsIterable()) {
      cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
      return false;
    }
    binding_detail::AutoSequence<double> &arr = arg0;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        return false;
      }
      if (done) {
        break;
      }
      double* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        return false;
      }
      double& slot = *slotPtr;
      if (!ValueToPrimitive<double, eDefault>(cx, temp, "Element of argument 1", &slot)) {
        return false;
      } else if (!mozilla::IsFinite(slot)) {
        foundNonFiniteFloat = true;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_SEQUENCE>("Argument 1");
    return false;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetLineDash(Constify(arg0), rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetLineDash(Constify(arg0), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.setLineDash"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo setLineDash_methodinfo = {
  { (JSJitGetterOp)setLineDash },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
getLineDash(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "getLineDash", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  nsTArray<double> result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetLineDash(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetLineDash(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        tmp.set(JS_NumberValue(double(result[sequenceIdx0])));
        break;
      } while (false);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo getLineDash_methodinfo = {
  { (JSJitGetterOp)getLineDash },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_lineDashOffset(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "lineDashOffset", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  double result(MOZ_KnownLive(self)->LineDashOffset());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_lineDashOffset(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.lineDashOffset setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "lineDashOffset", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetLineDashOffset(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetLineDashOffset(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo lineDashOffset_getterinfo = {
  { get_lineDashOffset },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo lineDashOffset_setterinfo = {
  { (JSJitGetterOp)set_lineDashOffset },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
closePath(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "closePath", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ClosePath())>, "Should be returning void here");
  MOZ_KnownLive(self)->ClosePath();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo closePath_methodinfo = {
  { (JSJitGetterOp)closePath },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
moveTo(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.moveTo");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "moveTo", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.moveTo", 2)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->MoveTo(arg0, arg1))>, "Should be returning void here");
  MOZ_KnownLive(self)->MoveTo(arg0, arg1);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo moveTo_methodinfo = {
  { (JSJitGetterOp)moveTo },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
lineTo(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.lineTo");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "lineTo", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.lineTo", 2)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->LineTo(arg0, arg1))>, "Should be returning void here");
  MOZ_KnownLive(self)->LineTo(arg0, arg1);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo lineTo_methodinfo = {
  { (JSJitGetterOp)lineTo },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
quadraticCurveTo(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.quadraticCurveTo");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "quadraticCurveTo", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.quadraticCurveTo", 4)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    foundNonFiniteFloat = true;
  }
  double arg3;
  if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
    return false;
  } else if (!mozilla::IsFinite(arg3)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->QuadraticCurveTo(arg0, arg1, arg2, arg3))>, "Should be returning void here");
  MOZ_KnownLive(self)->QuadraticCurveTo(arg0, arg1, arg2, arg3);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo quadraticCurveTo_methodinfo = {
  { (JSJitGetterOp)quadraticCurveTo },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
bezierCurveTo(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.bezierCurveTo");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "bezierCurveTo", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.bezierCurveTo", 6)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    foundNonFiniteFloat = true;
  }
  double arg3;
  if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
    return false;
  } else if (!mozilla::IsFinite(arg3)) {
    foundNonFiniteFloat = true;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
    return false;
  } else if (!mozilla::IsFinite(arg4)) {
    foundNonFiniteFloat = true;
  }
  double arg5;
  if (!ValueToPrimitive<double, eDefault>(cx, args[5], "Argument 6", &arg5)) {
    return false;
  } else if (!mozilla::IsFinite(arg5)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->BezierCurveTo(arg0, arg1, arg2, arg3, arg4, arg5))>, "Should be returning void here");
  MOZ_KnownLive(self)->BezierCurveTo(arg0, arg1, arg2, arg3, arg4, arg5);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo bezierCurveTo_methodinfo = {
  { (JSJitGetterOp)bezierCurveTo },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
arcTo(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.arcTo");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "arcTo", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.arcTo", 5)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    foundNonFiniteFloat = true;
  }
  double arg3;
  if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
    return false;
  } else if (!mozilla::IsFinite(arg3)) {
    foundNonFiniteFloat = true;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
    return false;
  } else if (!mozilla::IsFinite(arg4)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ArcTo(arg0, arg1, arg2, arg3, arg4, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->ArcTo(arg0, arg1, arg2, arg3, arg4, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.arcTo"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo arcTo_methodinfo = {
  { (JSJitGetterOp)arcTo },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
rect(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.rect");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "rect", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.rect", 4)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    foundNonFiniteFloat = true;
  }
  double arg3;
  if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
    return false;
  } else if (!mozilla::IsFinite(arg3)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Rect(arg0, arg1, arg2, arg3))>, "Should be returning void here");
  MOZ_KnownLive(self)->Rect(arg0, arg1, arg2, arg3);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo rect_methodinfo = {
  { (JSJitGetterOp)rect },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
arc(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.arc");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "arc", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.arc", 5)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    foundNonFiniteFloat = true;
  }
  double arg3;
  if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
    return false;
  } else if (!mozilla::IsFinite(arg3)) {
    foundNonFiniteFloat = true;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
    return false;
  } else if (!mozilla::IsFinite(arg4)) {
    foundNonFiniteFloat = true;
  }
  bool arg5;
  if (args.hasDefined(5)) {
    if (!ValueToPrimitive<bool, eDefault>(cx, args[5], "Argument 6", &arg5)) {
      return false;
    }
  } else {
    arg5 = false;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Arc(arg0, arg1, arg2, arg3, arg4, arg5, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->Arc(arg0, arg1, arg2, arg3, arg4, arg5, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.arc"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo arc_methodinfo = {
  { (JSJitGetterOp)arc },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
ellipse(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.ellipse");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "ellipse", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.ellipse", 7)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    foundNonFiniteFloat = true;
  }
  double arg3;
  if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
    return false;
  } else if (!mozilla::IsFinite(arg3)) {
    foundNonFiniteFloat = true;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
    return false;
  } else if (!mozilla::IsFinite(arg4)) {
    foundNonFiniteFloat = true;
  }
  double arg5;
  if (!ValueToPrimitive<double, eDefault>(cx, args[5], "Argument 6", &arg5)) {
    return false;
  } else if (!mozilla::IsFinite(arg5)) {
    foundNonFiniteFloat = true;
  }
  double arg6;
  if (!ValueToPrimitive<double, eDefault>(cx, args[6], "Argument 7", &arg6)) {
    return false;
  } else if (!mozilla::IsFinite(arg6)) {
    foundNonFiniteFloat = true;
  }
  bool arg7;
  if (args.hasDefined(7)) {
    if (!ValueToPrimitive<bool, eDefault>(cx, args[7], "Argument 8", &arg7)) {
      return false;
    }
  } else {
    arg7 = false;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Ellipse(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->Ellipse(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.ellipse"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo ellipse_methodinfo = {
  { (JSJitGetterOp)ellipse },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
clearRect(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.clearRect");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "clearRect", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.clearRect", 4)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    foundNonFiniteFloat = true;
  }
  double arg3;
  if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
    return false;
  } else if (!mozilla::IsFinite(arg3)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ClearRect(arg0, arg1, arg2, arg3))>, "Should be returning void here");
  MOZ_KnownLive(self)->ClearRect(arg0, arg1, arg2, arg3);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo clearRect_methodinfo = {
  { (JSJitGetterOp)clearRect },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
fillRect(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.fillRect");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "fillRect", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.fillRect", 4)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    foundNonFiniteFloat = true;
  }
  double arg3;
  if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
    return false;
  } else if (!mozilla::IsFinite(arg3)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->FillRect(arg0, arg1, arg2, arg3))>, "Should be returning void here");
  MOZ_KnownLive(self)->FillRect(arg0, arg1, arg2, arg3);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo fillRect_methodinfo = {
  { (JSJitGetterOp)fillRect },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
strokeRect(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.strokeRect");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "strokeRect", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.strokeRect", 4)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    foundNonFiniteFloat = true;
  }
  double arg3;
  if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
    return false;
  } else if (!mozilla::IsFinite(arg3)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->StrokeRect(arg0, arg1, arg2, arg3))>, "Should be returning void here");
  MOZ_KnownLive(self)->StrokeRect(arg0, arg1, arg2, arg3);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo strokeRect_methodinfo = {
  { (JSJitGetterOp)strokeRect },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_shadowOffsetX(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "shadowOffsetX", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  double result(MOZ_KnownLive(self)->ShadowOffsetX());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_shadowOffsetX(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.shadowOffsetX setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "shadowOffsetX", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetShadowOffsetX(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetShadowOffsetX(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo shadowOffsetX_getterinfo = {
  { get_shadowOffsetX },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo shadowOffsetX_setterinfo = {
  { (JSJitGetterOp)set_shadowOffsetX },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_shadowOffsetY(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "shadowOffsetY", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  double result(MOZ_KnownLive(self)->ShadowOffsetY());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_shadowOffsetY(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.shadowOffsetY setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "shadowOffsetY", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetShadowOffsetY(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetShadowOffsetY(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo shadowOffsetY_getterinfo = {
  { get_shadowOffsetY },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo shadowOffsetY_setterinfo = {
  { (JSJitGetterOp)set_shadowOffsetY },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_shadowBlur(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "shadowBlur", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  double result(MOZ_KnownLive(self)->ShadowBlur());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_shadowBlur(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.shadowBlur setter");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "shadowBlur", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Value being assigned", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetShadowBlur(arg0))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetShadowBlur(arg0);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo shadowBlur_getterinfo = {
  { get_shadowBlur },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo shadowBlur_setterinfo = {
  { (JSJitGetterOp)set_shadowBlur },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_shadowColor(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "shadowColor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  nsAutoCString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetShadowColor(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetShadowColor(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!NonVoidUTF8StringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_shadowColor(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "shadowColor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  binding_detail::FakeString<char> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetShadowColor(Constify(arg0)))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetShadowColor(Constify(arg0));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo shadowColor_getterinfo = {
  { get_shadowColor },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo shadowColor_setterinfo = {
  { (JSJitGetterOp)set_shadowColor },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
save(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "save", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Save())>, "Should be returning void here");
  MOZ_KnownLive(self)->Save();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo save_methodinfo = {
  { (JSJitGetterOp)save },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
restore(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "restore", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Restore())>, "Should be returning void here");
  MOZ_KnownLive(self)->Restore();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo restore_methodinfo = {
  { (JSJitGetterOp)restore },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
fillText(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.fillText");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "fillText", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.fillText", 3)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    foundNonFiniteFloat = true;
  }
  Optional<double> arg3;
  if (args.hasDefined(3)) {
    arg3.Construct();
    if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3.Value())) {
      return false;
    } else if (!mozilla::IsFinite(arg3.Value())) {
      foundNonFiniteFloat = true;
    }
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->FillText(NonNullHelper(Constify(arg0)), arg1, arg2, Constify(arg3), rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->FillText(NonNullHelper(Constify(arg0)), arg1, arg2, Constify(arg3), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.fillText"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo fillText_methodinfo = {
  { (JSJitGetterOp)fillText },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
strokeText(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.strokeText");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "strokeText", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.strokeText", 3)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    foundNonFiniteFloat = true;
  }
  Optional<double> arg3;
  if (args.hasDefined(3)) {
    arg3.Construct();
    if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3.Value())) {
      return false;
    } else if (!mozilla::IsFinite(arg3.Value())) {
      foundNonFiniteFloat = true;
    }
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->StrokeText(NonNullHelper(Constify(arg0)), arg1, arg2, Constify(arg3), rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->StrokeText(NonNullHelper(Constify(arg0)), arg1, arg2, Constify(arg3), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.strokeText"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo strokeText_methodinfo = {
  { (JSJitGetterOp)strokeText },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
measureText(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "measureText", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.measureText", 1)) {
    return false;
  }
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::TextMetrics>(MOZ_KnownLive(self)->MeasureText(NonNullHelper(Constify(arg0)), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.measureText"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!WrapNewBindingNonWrapperCachedObject(cx, obj, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo measureText_methodinfo = {
  { (JSJitGetterOp)measureText },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_font(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "font", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  nsAutoCString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetFont(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetFont(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!NonVoidUTF8StringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_font(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "font", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  binding_detail::FakeString<char> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetFont(Constify(arg0), rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetFont(Constify(arg0), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.font setter"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo font_getterinfo = {
  { get_font },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo font_setterinfo = {
  { (JSJitGetterOp)set_font },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_textAlign(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "textAlign", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  DOMString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetTextAlign(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetTextAlign(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_textAlign(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "textAlign", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetTextAlign(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetTextAlign(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo textAlign_getterinfo = {
  { get_textAlign },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo textAlign_setterinfo = {
  { (JSJitGetterOp)set_textAlign },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_textBaseline(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "textBaseline", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  DOMString result;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->GetTextBaseline(result))>, "Should be returning void here");
  MOZ_KnownLive(self)->GetTextBaseline(result);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

MOZ_CAN_RUN_SCRIPT static bool
set_textBaseline(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitSetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "textBaseline", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_SETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  binding_detail::FakeString<char16_t> arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetTextBaseline(NonNullHelper(Constify(arg0))))>, "Should be returning void here");
  MOZ_KnownLive(self)->SetTextBaseline(NonNullHelper(Constify(arg0)));
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo textBaseline_getterinfo = {
  { get_textBaseline },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo textBaseline_setterinfo = {
  { (JSJitGetterOp)set_textBaseline },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
scale(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.scale");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "scale", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.scale", 2)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Scale(arg0, arg1, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->Scale(arg0, arg1, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.scale"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo scale_methodinfo = {
  { (JSJitGetterOp)scale },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
rotate(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.rotate");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "rotate", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.rotate", 1)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Rotate(arg0, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->Rotate(arg0, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.rotate"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo rotate_methodinfo = {
  { (JSJitGetterOp)rotate },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
translate(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.translate");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "translate", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.translate", 2)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Translate(arg0, arg1, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->Translate(arg0, arg1, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.translate"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo translate_methodinfo = {
  { (JSJitGetterOp)translate },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
transform(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.transform");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "transform", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.transform", 6)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    foundNonFiniteFloat = true;
  }
  double arg3;
  if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
    return false;
  } else if (!mozilla::IsFinite(arg3)) {
    foundNonFiniteFloat = true;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
    return false;
  } else if (!mozilla::IsFinite(arg4)) {
    foundNonFiniteFloat = true;
  }
  double arg5;
  if (!ValueToPrimitive<double, eDefault>(cx, args[5], "Argument 6", &arg5)) {
    return false;
  } else if (!mozilla::IsFinite(arg5)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Transform(arg0, arg1, arg2, arg3, arg4, arg5, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->Transform(arg0, arg1, arg2, arg3, arg4, arg5, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.transform"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo transform_methodinfo = {
  { (JSJitGetterOp)transform },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
getTransform(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "getTransform", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::DOMMatrix>(MOZ_KnownLive(self)->GetTransform(rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.getTransform"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!std::is_pointer_v<decltype(result)>,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo getTransform_methodinfo = {
  { (JSJitGetterOp)getTransform },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
setTransform(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.setTransform");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "setTransform", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  unsigned argcount = std::min(args.length(), 6u);
  switch (argcount) {
    case 0: {
      [[fallthrough]];
    }
    case 1: {
      bool foundNonFiniteFloat = false;
      binding_detail::FastDOMMatrix2DInit arg0;
      if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue, "Argument 1", false)) {
        return false;
      }
      if (foundNonFiniteFloat) {
        args.rval().setUndefined();
        return true;
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetTransform(Constify(arg0), rv))>, "Should be returning void here");
      MOZ_KnownLive(self)->SetTransform(Constify(arg0), rv);
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.setTransform"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    case 6: {
      bool foundNonFiniteFloat = false;
      double arg0;
      if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
        return false;
      } else if (!mozilla::IsFinite(arg0)) {
        foundNonFiniteFloat = true;
      }
      double arg1;
      if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
        return false;
      } else if (!mozilla::IsFinite(arg1)) {
        foundNonFiniteFloat = true;
      }
      double arg2;
      if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
        return false;
      } else if (!mozilla::IsFinite(arg2)) {
        foundNonFiniteFloat = true;
      }
      double arg3;
      if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
        return false;
      } else if (!mozilla::IsFinite(arg3)) {
        foundNonFiniteFloat = true;
      }
      double arg4;
      if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
        return false;
      } else if (!mozilla::IsFinite(arg4)) {
        foundNonFiniteFloat = true;
      }
      double arg5;
      if (!ValueToPrimitive<double, eDefault>(cx, args[5], "Argument 6", &arg5)) {
        return false;
      } else if (!mozilla::IsFinite(arg5)) {
        foundNonFiniteFloat = true;
      }
      if (foundNonFiniteFloat) {
        args.rval().setUndefined();
        return true;
      }
      FastErrorResult rv;
      // NOTE: This assert does NOT call the function.
      static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->SetTransform(arg0, arg1, arg2, arg3, arg4, arg5, rv))>, "Should be returning void here");
      MOZ_KnownLive(self)->SetTransform(arg0, arg1, arg2, arg3, arg4, arg5, rv);
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.setTransform"))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      args.rval().setUndefined();
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSJitInfo setTransform_methodinfo = {
  { (JSJitGetterOp)setTransform },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
resetTransform(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "resetTransform", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ResetTransform(rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->ResetTransform(rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.resetTransform"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo resetTransform_methodinfo = {
  { (JSJitGetterOp)resetTransform },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
drawFocusIfNeeded(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "CanvasRenderingContext2D.drawFocusIfNeeded");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "CanvasRenderingContext2D", "drawFocusIfNeeded", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasRenderingContext2D*>(void_self);
  if (!args.requireAtLeast(cx, "CanvasRenderingContext2D.drawFocusIfNeeded", 1)) {
    return false;
  }
  NonNull<mozilla::dom::Element> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::Element, mozilla::dom::Element>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Element");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->DrawFocusIfNeeded(MOZ_KnownLive(NonNullHelper(arg0)), rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->DrawFocusIfNeeded(MOZ_KnownLive(NonNullHelper(arg0)), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "CanvasRenderingContext2D.drawFocusIfNeeded"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo drawFocusIfNeeded_methodinfo = {
  { (JSJitGetterOp)drawFocusIfNeeded },
  { prototypes::id::CanvasRenderingContext2D },
  { PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::CanvasRenderingContext2D* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::CanvasRenderingContext2D>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::CanvasRenderingContext2D* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::CanvasRenderingContext2D>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::CanvasRenderingContext2D>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::CanvasRenderingContext2D* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::CanvasRenderingContext2D>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::CanvasRenderingContext2D* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::CanvasRenderingContext2D>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("drawWindow", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&drawWindow_methodinfo), 6, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("drawImage", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&drawImage_methodinfo), 3, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("beginPath", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&beginPath_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("fill", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&fill_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("stroke", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&stroke_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("clip", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&clip_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("isPointInPath", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&isPointInPath_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("isPointInStroke", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&isPointInStroke_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("createLinearGradient", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&createLinearGradient_methodinfo), 4, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("createRadialGradient", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&createRadialGradient_methodinfo), 6, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("createConicGradient", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&createConicGradient_methodinfo), 3, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("createPattern", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&createPattern_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("addHitRegion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&addHitRegion_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("removeHitRegion", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&removeHitRegion_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("clearHitRegions", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&clearHitRegions_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("createImageData", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&createImageData_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getImageData", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&getImageData_methodinfo), 4, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("putImageData", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&putImageData_methodinfo), 3, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("setLineDash", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&setLineDash_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getLineDash", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&getLineDash_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("closePath", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&closePath_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("moveTo", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&moveTo_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("lineTo", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&lineTo_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("quadraticCurveTo", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&quadraticCurveTo_methodinfo), 4, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("bezierCurveTo", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&bezierCurveTo_methodinfo), 6, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("arcTo", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&arcTo_methodinfo), 5, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("rect", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&rect_methodinfo), 4, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("arc", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&arc_methodinfo), 5, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("ellipse", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&ellipse_methodinfo), 7, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("clearRect", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&clearRect_methodinfo), 4, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("fillRect", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&fillRect_methodinfo), 4, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("strokeRect", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&strokeRect_methodinfo), 4, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("save", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&save_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("restore", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&restore_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("fillText", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&fillText_methodinfo), 3, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("strokeText", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&strokeText_methodinfo), 3, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("measureText", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&measureText_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("scale", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&scale_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("rotate", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&rotate_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("translate", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&translate_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("transform", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&transform_methodinfo), 6, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getTransform", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&getTransform_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("setTransform", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&setTransform_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("resetTransform", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&resetTransform_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("drawFocusIfNeeded", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&drawFocusIfNeeded_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};

static const PrefableDisablers sMethods_disablers0 = {
  WebIDLPrefIndex::NoPref, false, 0, &CanvasUtils::HasDrawWindowPrivilege
};

static const PrefableDisablers sMethods_disablers12 = {
  WebIDLPrefIndex::canvas_createConicGradient_enabled, false, 0, nullptr
};

static const PrefableDisablers sMethods_disablers16 = {
  WebIDLPrefIndex::canvas_hitregions_enabled, false, 0, nullptr
};

static const PrefableDisablers sMethods_disablers50 = {
  WebIDLPrefIndex::canvas_focusring_enabled, false, 0, nullptr
};

static const Prefable<const JSFunctionSpec> sMethods[] = {
  { &sMethods_disablers0, &sMethods_specs[0] },
  { nullptr, &sMethods_specs[2] },
  { &sMethods_disablers12, &sMethods_specs[12] },
  { nullptr, &sMethods_specs[14] },
  { &sMethods_disablers16, &sMethods_specs[16] },
  { nullptr, &sMethods_specs[20] },
  { &sMethods_disablers50, &sMethods_specs[50] },
  { nullptr, nullptr }
};

static_assert(7 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(29 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNSPEC("demote", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&demote_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sChromeMethods[] = {
  { nullptr, &sChromeMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("canvas", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &canvas_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("mozCurrentTransform", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &mozCurrentTransform_getterinfo, GenericSetter<NormalThisPolicy>, &mozCurrentTransform_setterinfo),
  JSPropertySpec::nativeAccessors("mozCurrentTransformInverse", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &mozCurrentTransformInverse_getterinfo, GenericSetter<NormalThisPolicy>, &mozCurrentTransformInverse_setterinfo),
  JSPropertySpec::nativeAccessors("mozTextStyle", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &mozTextStyle_getterinfo, GenericSetter<NormalThisPolicy>, &mozTextStyle_setterinfo),
  JSPropertySpec::nativeAccessors("mozImageSmoothingEnabled", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &mozImageSmoothingEnabled_getterinfo, GenericSetter<NormalThisPolicy>, &mozImageSmoothingEnabled_setterinfo),
  JSPropertySpec::nativeAccessors("globalAlpha", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &globalAlpha_getterinfo, GenericSetter<NormalThisPolicy>, &globalAlpha_setterinfo),
  JSPropertySpec::nativeAccessors("globalCompositeOperation", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &globalCompositeOperation_getterinfo, GenericSetter<NormalThisPolicy>, &globalCompositeOperation_setterinfo),
  JSPropertySpec::nativeAccessors("strokeStyle", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &strokeStyle_getterinfo, GenericSetter<NormalThisPolicy>, &strokeStyle_setterinfo),
  JSPropertySpec::nativeAccessors("fillStyle", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &fillStyle_getterinfo, GenericSetter<NormalThisPolicy>, &fillStyle_setterinfo),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("filter", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &filter_getterinfo, GenericSetter<NormalThisPolicy>, &filter_setterinfo),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("imageSmoothingEnabled", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &imageSmoothingEnabled_getterinfo, GenericSetter<NormalThisPolicy>, &imageSmoothingEnabled_setterinfo),
  JSPropertySpec::nativeAccessors("lineWidth", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &lineWidth_getterinfo, GenericSetter<NormalThisPolicy>, &lineWidth_setterinfo),
  JSPropertySpec::nativeAccessors("lineCap", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &lineCap_getterinfo, GenericSetter<NormalThisPolicy>, &lineCap_setterinfo),
  JSPropertySpec::nativeAccessors("lineJoin", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &lineJoin_getterinfo, GenericSetter<NormalThisPolicy>, &lineJoin_setterinfo),
  JSPropertySpec::nativeAccessors("miterLimit", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &miterLimit_getterinfo, GenericSetter<NormalThisPolicy>, &miterLimit_setterinfo),
  JSPropertySpec::nativeAccessors("lineDashOffset", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &lineDashOffset_getterinfo, GenericSetter<NormalThisPolicy>, &lineDashOffset_setterinfo),
  JSPropertySpec::nativeAccessors("shadowOffsetX", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &shadowOffsetX_getterinfo, GenericSetter<NormalThisPolicy>, &shadowOffsetX_setterinfo),
  JSPropertySpec::nativeAccessors("shadowOffsetY", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &shadowOffsetY_getterinfo, GenericSetter<NormalThisPolicy>, &shadowOffsetY_setterinfo),
  JSPropertySpec::nativeAccessors("shadowBlur", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &shadowBlur_getterinfo, GenericSetter<NormalThisPolicy>, &shadowBlur_setterinfo),
  JSPropertySpec::nativeAccessors("shadowColor", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &shadowColor_getterinfo, GenericSetter<NormalThisPolicy>, &shadowColor_setterinfo),
  JSPropertySpec::nativeAccessors("font", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &font_getterinfo, GenericSetter<NormalThisPolicy>, &font_setterinfo),
  JSPropertySpec::nativeAccessors("textAlign", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &textAlign_getterinfo, GenericSetter<NormalThisPolicy>, &textAlign_setterinfo),
  JSPropertySpec::nativeAccessors("textBaseline", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &textBaseline_getterinfo, GenericSetter<NormalThisPolicy>, &textBaseline_setterinfo),
  JS_STRING_SYM_PS(toStringTag, "CanvasRenderingContext2D", JSPROP_READONLY),
  JS_PS_END
};

static const PrefableDisablers sAttributes_disablers10 = {
  WebIDLPrefIndex::canvas_filters_enabled, false, 0, nullptr
};

static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { &sAttributes_disablers10, &sAttributes_specs[10] },
  { nullptr, &sAttributes_specs[12] },
  { nullptr, nullptr }
};

static_assert(3 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(14 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const ConstantSpec sConstants_specs[] = {
  { "DRAWWINDOW_DRAW_CARET", JS::NumberValue(1U) },
  { "DRAWWINDOW_DO_NOT_FLUSH", JS::NumberValue(2U) },
  { "DRAWWINDOW_DRAW_VIEW", JS::NumberValue(4U) },
  { "DRAWWINDOW_USE_WIDGET_LAYERS", JS::NumberValue(8U) },
  { "DRAWWINDOW_ASYNC_DECODE_IMAGES", JS::NumberValue(16U) },
  { 0, JS::UndefinedValue() }
};

static const PrefableDisablers sConstants_disablers0 = {
  WebIDLPrefIndex::NoPref, false, 0, &CanvasUtils::HasDrawWindowPrivilege
};

static const Prefable<const ConstantSpec> sConstants[] = {
  { &sConstants_disablers0, &sConstants_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(5 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[74];
static PropertyInfo sNativeProperties_propertyInfos[74];

static const NativePropertiesN<3> sNativeProperties = {
  false, 0,
  false, 0,
  true,  0 /* sMethods */,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  true,  2 /* sConstants */,
  -1,
  74,
  sNativeProperties_sortedPropertyIndices,
  {
    { sMethods, &sNativeProperties_propertyInfos[0] },
    { sAttributes, &sNativeProperties_propertyInfos[45] },
    { sConstants, &sNativeProperties_propertyInfos[69] }
  }
};
static_assert(74 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static uint16_t sChromeOnlyNativeProperties_sortedPropertyIndices[1];
static PropertyInfo sChromeOnlyNativeProperties_propertyInfos[1];

static const NativePropertiesN<1> sChromeOnlyNativeProperties = {
  false, 0,
  false, 0,
  true,  0 /* sChromeMethods */,
  false, 0,
  false, 0,
  false, 0,
  false, 0,
  -1,
  1,
  sChromeOnlyNativeProperties_sortedPropertyIndices,
  {
    { sChromeMethods, &sChromeOnlyNativeProperties_propertyInfos[0] }
  }
};
static_assert(1 < 1ull << (CHAR_BIT * sizeof(sChromeOnlyNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::CanvasRenderingContext2D,
  PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth,
  sNativePropertyHooks,
  "function CanvasRenderingContext2D() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "CanvasRenderingContext2DPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::CanvasRenderingContext2D,
  PrototypeTraits<prototypes::id::CanvasRenderingContext2D>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "CanvasRenderingContext2D",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::CanvasRenderingContext2D, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::CanvasRenderingContext2D>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::CanvasRenderingContext2D>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::CanvasRenderingContext2D>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::CanvasRenderingContext2D* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::CanvasRenderingContext2D>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::CanvasRenderingContext2D*>(aObject) ==
             reinterpret_cast<mozilla::dom::CanvasRenderingContext2D*>(aObject),
             "Multiple inheritance for mozilla::dom::CanvasRenderingContext2D is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::CanvasRenderingContext2D> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), sChromeOnlyNativeProperties.Upcast() },
  prototypes::id::CanvasRenderingContext2D,
  constructors::id::CanvasRenderingContext2D,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    if (!InitIds(aCx, sChromeOnlyNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::CanvasRenderingContext2D);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::CanvasRenderingContext2D);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              sChromeOnlyNativeProperties.Upcast(),
                              "CanvasRenderingContext2D", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace CanvasRenderingContext2D_Binding



namespace Path2D_Binding {

MOZ_CAN_RUN_SCRIPT static bool
addPath(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "Path2D.addPath");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "Path2D", "addPath", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasPath*>(void_self);
  if (!args.requireAtLeast(cx, "Path2D.addPath", 1)) {
    return false;
  }
  NonNull<mozilla::dom::CanvasPath> arg0;
  if (args[0].isObject()) {
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::Path2D, mozilla::dom::CanvasPath>(args[0], arg0, cx);
      if (NS_FAILED(rv)) {
        cx.ThrowErrorMessage<MSG_DOES_NOT_IMPLEMENT_INTERFACE>("Argument 1", "Path2D");
        return false;
      }
    }
  } else {
    cx.ThrowErrorMessage<MSG_NOT_OBJECT>("Argument 1");
    return false;
  }
  binding_detail::FastDOMMatrix2DInit arg1;
  if (!arg1.Init(cx, (args.hasDefined(1)) ? args[1] : JS::NullHandleValue, "Argument 2", false)) {
    return false;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->AddPath(MOZ_KnownLive(NonNullHelper(arg0)), Constify(arg1), rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->AddPath(MOZ_KnownLive(NonNullHelper(arg0)), Constify(arg1), rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "Path2D.addPath"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo addPath_methodinfo = {
  { (JSJitGetterOp)addPath },
  { prototypes::id::Path2D },
  { PrototypeTraits<prototypes::id::Path2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
closePath(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "Path2D", "closePath", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasPath*>(void_self);
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ClosePath())>, "Should be returning void here");
  MOZ_KnownLive(self)->ClosePath();
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo closePath_methodinfo = {
  { (JSJitGetterOp)closePath },
  { prototypes::id::Path2D },
  { PrototypeTraits<prototypes::id::Path2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
moveTo(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "Path2D.moveTo");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "Path2D", "moveTo", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasPath*>(void_self);
  if (!args.requireAtLeast(cx, "Path2D.moveTo", 2)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->MoveTo(arg0, arg1))>, "Should be returning void here");
  MOZ_KnownLive(self)->MoveTo(arg0, arg1);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo moveTo_methodinfo = {
  { (JSJitGetterOp)moveTo },
  { prototypes::id::Path2D },
  { PrototypeTraits<prototypes::id::Path2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
lineTo(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "Path2D.lineTo");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "Path2D", "lineTo", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasPath*>(void_self);
  if (!args.requireAtLeast(cx, "Path2D.lineTo", 2)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->LineTo(arg0, arg1))>, "Should be returning void here");
  MOZ_KnownLive(self)->LineTo(arg0, arg1);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo lineTo_methodinfo = {
  { (JSJitGetterOp)lineTo },
  { prototypes::id::Path2D },
  { PrototypeTraits<prototypes::id::Path2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
quadraticCurveTo(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "Path2D.quadraticCurveTo");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "Path2D", "quadraticCurveTo", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasPath*>(void_self);
  if (!args.requireAtLeast(cx, "Path2D.quadraticCurveTo", 4)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    foundNonFiniteFloat = true;
  }
  double arg3;
  if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
    return false;
  } else if (!mozilla::IsFinite(arg3)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->QuadraticCurveTo(arg0, arg1, arg2, arg3))>, "Should be returning void here");
  MOZ_KnownLive(self)->QuadraticCurveTo(arg0, arg1, arg2, arg3);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo quadraticCurveTo_methodinfo = {
  { (JSJitGetterOp)quadraticCurveTo },
  { prototypes::id::Path2D },
  { PrototypeTraits<prototypes::id::Path2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
bezierCurveTo(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "Path2D.bezierCurveTo");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "Path2D", "bezierCurveTo", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasPath*>(void_self);
  if (!args.requireAtLeast(cx, "Path2D.bezierCurveTo", 6)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    foundNonFiniteFloat = true;
  }
  double arg3;
  if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
    return false;
  } else if (!mozilla::IsFinite(arg3)) {
    foundNonFiniteFloat = true;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
    return false;
  } else if (!mozilla::IsFinite(arg4)) {
    foundNonFiniteFloat = true;
  }
  double arg5;
  if (!ValueToPrimitive<double, eDefault>(cx, args[5], "Argument 6", &arg5)) {
    return false;
  } else if (!mozilla::IsFinite(arg5)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->BezierCurveTo(arg0, arg1, arg2, arg3, arg4, arg5))>, "Should be returning void here");
  MOZ_KnownLive(self)->BezierCurveTo(arg0, arg1, arg2, arg3, arg4, arg5);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo bezierCurveTo_methodinfo = {
  { (JSJitGetterOp)bezierCurveTo },
  { prototypes::id::Path2D },
  { PrototypeTraits<prototypes::id::Path2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
arcTo(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "Path2D.arcTo");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "Path2D", "arcTo", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasPath*>(void_self);
  if (!args.requireAtLeast(cx, "Path2D.arcTo", 5)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    foundNonFiniteFloat = true;
  }
  double arg3;
  if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
    return false;
  } else if (!mozilla::IsFinite(arg3)) {
    foundNonFiniteFloat = true;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
    return false;
  } else if (!mozilla::IsFinite(arg4)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->ArcTo(arg0, arg1, arg2, arg3, arg4, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->ArcTo(arg0, arg1, arg2, arg3, arg4, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "Path2D.arcTo"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo arcTo_methodinfo = {
  { (JSJitGetterOp)arcTo },
  { prototypes::id::Path2D },
  { PrototypeTraits<prototypes::id::Path2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
rect(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "Path2D.rect");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "Path2D", "rect", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasPath*>(void_self);
  if (!args.requireAtLeast(cx, "Path2D.rect", 4)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    foundNonFiniteFloat = true;
  }
  double arg3;
  if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
    return false;
  } else if (!mozilla::IsFinite(arg3)) {
    foundNonFiniteFloat = true;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Rect(arg0, arg1, arg2, arg3))>, "Should be returning void here");
  MOZ_KnownLive(self)->Rect(arg0, arg1, arg2, arg3);
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo rect_methodinfo = {
  { (JSJitGetterOp)rect },
  { prototypes::id::Path2D },
  { PrototypeTraits<prototypes::id::Path2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
arc(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "Path2D.arc");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "Path2D", "arc", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasPath*>(void_self);
  if (!args.requireAtLeast(cx, "Path2D.arc", 5)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    foundNonFiniteFloat = true;
  }
  double arg3;
  if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
    return false;
  } else if (!mozilla::IsFinite(arg3)) {
    foundNonFiniteFloat = true;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
    return false;
  } else if (!mozilla::IsFinite(arg4)) {
    foundNonFiniteFloat = true;
  }
  bool arg5;
  if (args.hasDefined(5)) {
    if (!ValueToPrimitive<bool, eDefault>(cx, args[5], "Argument 6", &arg5)) {
      return false;
    }
  } else {
    arg5 = false;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Arc(arg0, arg1, arg2, arg3, arg4, arg5, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->Arc(arg0, arg1, arg2, arg3, arg4, arg5, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "Path2D.arc"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo arc_methodinfo = {
  { (JSJitGetterOp)arc },
  { prototypes::id::Path2D },
  { PrototypeTraits<prototypes::id::Path2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
ellipse(JSContext* cx_, JS::Handle<JSObject*> obj, void* void_self, const JSJitMethodCallArgs& args)
{
  BindingCallContext cx(cx_, "Path2D.ellipse");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "Path2D", "ellipse", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_METHOD) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::CanvasPath*>(void_self);
  if (!args.requireAtLeast(cx, "Path2D.ellipse", 7)) {
    return false;
  }
  bool foundNonFiniteFloat = false;
  double arg0;
  if (!ValueToPrimitive<double, eDefault>(cx, args[0], "Argument 1", &arg0)) {
    return false;
  } else if (!mozilla::IsFinite(arg0)) {
    foundNonFiniteFloat = true;
  }
  double arg1;
  if (!ValueToPrimitive<double, eDefault>(cx, args[1], "Argument 2", &arg1)) {
    return false;
  } else if (!mozilla::IsFinite(arg1)) {
    foundNonFiniteFloat = true;
  }
  double arg2;
  if (!ValueToPrimitive<double, eDefault>(cx, args[2], "Argument 3", &arg2)) {
    return false;
  } else if (!mozilla::IsFinite(arg2)) {
    foundNonFiniteFloat = true;
  }
  double arg3;
  if (!ValueToPrimitive<double, eDefault>(cx, args[3], "Argument 4", &arg3)) {
    return false;
  } else if (!mozilla::IsFinite(arg3)) {
    foundNonFiniteFloat = true;
  }
  double arg4;
  if (!ValueToPrimitive<double, eDefault>(cx, args[4], "Argument 5", &arg4)) {
    return false;
  } else if (!mozilla::IsFinite(arg4)) {
    foundNonFiniteFloat = true;
  }
  double arg5;
  if (!ValueToPrimitive<double, eDefault>(cx, args[5], "Argument 6", &arg5)) {
    return false;
  } else if (!mozilla::IsFinite(arg5)) {
    foundNonFiniteFloat = true;
  }
  double arg6;
  if (!ValueToPrimitive<double, eDefault>(cx, args[6], "Argument 7", &arg6)) {
    return false;
  } else if (!mozilla::IsFinite(arg6)) {
    foundNonFiniteFloat = true;
  }
  bool arg7;
  if (args.hasDefined(7)) {
    if (!ValueToPrimitive<bool, eDefault>(cx, args[7], "Argument 8", &arg7)) {
      return false;
    }
  } else {
    arg7 = false;
  }
  if (foundNonFiniteFloat) {
    args.rval().setUndefined();
    return true;
  }
  FastErrorResult rv;
  // NOTE: This assert does NOT call the function.
  static_assert(std::is_void_v<decltype(MOZ_KnownLive(self)->Ellipse(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, rv))>, "Should be returning void here");
  MOZ_KnownLive(self)->Ellipse(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, rv);
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx, "Path2D.ellipse"))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo ellipse_methodinfo = {
  { (JSJitGetterOp)ellipse },
  { prototypes::id::Path2D },
  { PrototypeTraits<prototypes::id::Path2D>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::CanvasPath* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::CanvasPath>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::CanvasPath* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::CanvasPath>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    ClearWrapper(self, self, obj);
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::CanvasPath>(self);
  }
}

static nsWrapperCache*
_getWrapperCache(JS::Handle<JSObject*> obj)
{
  mozilla::dom::CanvasPath* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::CanvasPath>(obj);
  return self;
}

static size_t
_objectMoved(JSObject* obj, JSObject* old)
{
  mozilla::dom::CanvasPath* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::CanvasPath>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }

  return 0;
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("addPath", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&addPath_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("closePath", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&closePath_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("moveTo", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&moveTo_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("lineTo", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&lineTo_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("quadraticCurveTo", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&quadraticCurveTo_methodinfo), 4, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("bezierCurveTo", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&bezierCurveTo_methodinfo), 6, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("arcTo", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&arcTo_methodinfo), 5, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("rect", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&rect_methodinfo), 4, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("arc", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&arc_methodinfo), 5, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("ellipse", (GenericMethod<NormalThisPolicy, ThrowExceptions>), reinterpret_cast<const JSJitInfo*>(&ellipse_methodinfo), 7, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};


static const Prefable<const JSFunctionSpec> sMethods[] = {
  { nullptr, &sMethods_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(10 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JS_STRING_SYM_PS(toStringTag, "Path2D", JSPROP_READONLY),
  JS_PS_END
};


static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { nullptr, nullptr }
};

static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(1 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[11];
static PropertyInfo sNativeProperties_propertyInfos[11];

static const NativePropertiesN<2> sNativeProperties = {
  false, 0,
  false, 0,
  true,  0 /* sMethods */,
  true,  1 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  11,
  sNativeProperties_sortedPropertyIndices,
  {
    { sMethods, &sNativeProperties_propertyInfos[0] },
    { sAttributes, &sNativeProperties_propertyInfos[10] }
  }
};
static_assert(11 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static bool
_constructor(JSContext* cx_, unsigned argc, JS::Value* vp)
{
  BindingCallContext cx(cx_, "Path2D constructor");
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "Path2D", "constructor", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!args.isConstructing()) {
    return ThrowConstructorWithoutNew(cx, "Path2D");
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args,
                       prototypes::id::Path2D,
                       CreateInterfaceObjects,
                       &desiredProto)) {
    return false;
  }

  unsigned argcount = std::min(args.length(), 1u);
  switch (argcount) {
    case 0: {
      GlobalObject global(cx, obj);
      if (global.Failed()) {
        return false;
      }

      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      Maybe<JSAutoRealm> ar;
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        obj = js::CheckedUnwrapStatic(obj);
        if (!obj) {
          return false;
        }
        ar.emplace(cx, obj);
        if (!JS_WrapObject(cx, &desiredProto)) {
          return false;
        }
      }
      auto result(StrongOrRawPtr<mozilla::dom::CanvasPath>(mozilla::dom::CanvasPath::Constructor(global)));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case 1: {
      if (args[0].isObject()) {
        do {
          NonNull<mozilla::dom::CanvasPath> arg0;
          {
            // Our JSContext should be in the right global to do unwrapping in.
            nsresult rv = UnwrapObject<prototypes::id::Path2D, mozilla::dom::CanvasPath>(args[0], arg0, cx);
            if (NS_FAILED(rv)) {
              break;
            }
          }
          GlobalObject global(cx, obj);
          if (global.Failed()) {
            return false;
          }

          bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
          Maybe<JSAutoRealm> ar;
          if (objIsXray) {
            // Since our object is an Xray, we can just CheckedUnwrapStatic:
            // we know Xrays have no dynamic unwrap behavior.
            obj = js::CheckedUnwrapStatic(obj);
            if (!obj) {
              return false;
            }
            ar.emplace(cx, obj);
            if (!JS_WrapObject(cx, &desiredProto)) {
              return false;
            }
          }
          auto result(StrongOrRawPtr<mozilla::dom::CanvasPath>(mozilla::dom::CanvasPath::Constructor(global, MOZ_KnownLive(NonNullHelper(arg0)))));
          MOZ_ASSERT(!JS_IsExceptionPending(cx));
          static_assert(!std::is_pointer_v<decltype(result)>,
                        "NewObject implies that we need to keep the object alive with a strong reference.");
          if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
            MOZ_ASSERT(JS_IsExceptionPending(cx));
            return false;
          }
          return true;
        } while (false);
      }
      GlobalObject global(cx, obj);
      if (global.Failed()) {
        return false;
      }

      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      binding_detail::FakeString<char16_t> arg0;
      if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
        return false;
      }
      Maybe<JSAutoRealm> ar;
      if (objIsXray) {
        // Since our object is an Xray, we can just CheckedUnwrapStatic:
        // we know Xrays have no dynamic unwrap behavior.
        obj = js::CheckedUnwrapStatic(obj);
        if (!obj) {
          return false;
        }
        ar.emplace(cx, obj);
        if (!JS_WrapObject(cx, &desiredProto)) {
          return false;
        }
      }
      auto result(StrongOrRawPtr<mozilla::dom::CanvasPath>(mozilla::dom::CanvasPath::Constructor(global, NonNullHelper(Constify(arg0)))));
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      static_assert(!std::is_pointer_v<decltype(result)>,
                    "NewObject implies that we need to keep the object alive with a strong reference.");
      if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      // Using nsPrintfCString here would require including that
      // header.  Let's not worry about it.
      nsAutoCString argCountStr;
      argCountStr.AppendPrintf("%u", args.length());
      return cx.ThrowErrorMessage<MSG_INVALID_OVERLOAD_ARGCOUNT>(argCountStr.get());
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static const JSClassOps sInterfaceObjectClassOps = {
    nullptr,               /* addProperty */
    nullptr,               /* delProperty */
    nullptr,               /* enumerate */
    nullptr,               /* newEnumerate */
    nullptr,               /* resolve */
    nullptr,               /* mayResolve */
    nullptr,               /* finalize */
    _constructor, /* call */
    nullptr,               /* hasInstance */
    _constructor, /* construct */
    nullptr,               /* trace */
};

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sInterfaceObjectClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::Path2D,
  PrototypeTraits<prototypes::id::Path2D>::Depth,
  sNativePropertyHooks,
  "function Path2D() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "Path2DPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::Path2D,
  PrototypeTraits<prototypes::id::Path2D>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

bool
ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj)
{
  return StaticPrefs::canvas_path_enabled();
}

static const JSClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "Path2D",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::Path2D, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::CanvasPath>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::CanvasPath>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::CanvasPath>::Get(),
  nullptr,
  _getWrapperCache
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::CanvasPath* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  static_assert(!std::is_base_of_v<NonRefcountedDOMObject, mozilla::dom::CanvasPath>,
                "Shouldn't have wrappercached things that are not refcounted.");
  MOZ_ASSERT(static_cast<mozilla::dom::CanvasPath*>(aObject) ==
             reinterpret_cast<mozilla::dom::CanvasPath*>(aObject),
             "Multiple inheritance for mozilla::dom::CanvasPath is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  // If the wrapper cache contains a dead reflector then finalize that
  // now, ensuring that the finalizer for the old reflector always
  // runs before the new reflector is created and attached. This
  // avoids the awkward situation where there are multiple reflector
  // objects that contain pointers to the same native.

  if (JSObject* oldReflector = aCache->GetWrapperMaybeDead()) {
    _finalize(nullptr /* unused */, oldReflector);
    MOZ_ASSERT(!aCache->GetWrapperMaybeDead());
  }

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  JS::AssertObjectIsNotGray(global);

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoRealm ar(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::CanvasPath> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::Path2D,
  constructors::id::Path2D,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::Path2D);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::Path2D);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "Path2D", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace Path2D_Binding



namespace TextMetrics_Binding {

MOZ_CAN_RUN_SCRIPT static bool
get_width(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TextMetrics", "width", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TextMetrics*>(void_self);
  double result(MOZ_KnownLive(self)->Width());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo width_getterinfo = {
  { get_width },
  { prototypes::id::TextMetrics },
  { PrototypeTraits<prototypes::id::TextMetrics>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_actualBoundingBoxLeft(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TextMetrics", "actualBoundingBoxLeft", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TextMetrics*>(void_self);
  double result(MOZ_KnownLive(self)->ActualBoundingBoxLeft());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo actualBoundingBoxLeft_getterinfo = {
  { get_actualBoundingBoxLeft },
  { prototypes::id::TextMetrics },
  { PrototypeTraits<prototypes::id::TextMetrics>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_actualBoundingBoxRight(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TextMetrics", "actualBoundingBoxRight", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TextMetrics*>(void_self);
  double result(MOZ_KnownLive(self)->ActualBoundingBoxRight());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo actualBoundingBoxRight_getterinfo = {
  { get_actualBoundingBoxRight },
  { prototypes::id::TextMetrics },
  { PrototypeTraits<prototypes::id::TextMetrics>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_fontBoundingBoxAscent(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TextMetrics", "fontBoundingBoxAscent", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TextMetrics*>(void_self);
  double result(MOZ_KnownLive(self)->FontBoundingBoxAscent());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo fontBoundingBoxAscent_getterinfo = {
  { get_fontBoundingBoxAscent },
  { prototypes::id::TextMetrics },
  { PrototypeTraits<prototypes::id::TextMetrics>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_fontBoundingBoxDescent(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TextMetrics", "fontBoundingBoxDescent", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TextMetrics*>(void_self);
  double result(MOZ_KnownLive(self)->FontBoundingBoxDescent());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo fontBoundingBoxDescent_getterinfo = {
  { get_fontBoundingBoxDescent },
  { prototypes::id::TextMetrics },
  { PrototypeTraits<prototypes::id::TextMetrics>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_actualBoundingBoxAscent(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TextMetrics", "actualBoundingBoxAscent", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TextMetrics*>(void_self);
  double result(MOZ_KnownLive(self)->ActualBoundingBoxAscent());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo actualBoundingBoxAscent_getterinfo = {
  { get_actualBoundingBoxAscent },
  { prototypes::id::TextMetrics },
  { PrototypeTraits<prototypes::id::TextMetrics>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_actualBoundingBoxDescent(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TextMetrics", "actualBoundingBoxDescent", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TextMetrics*>(void_self);
  double result(MOZ_KnownLive(self)->ActualBoundingBoxDescent());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo actualBoundingBoxDescent_getterinfo = {
  { get_actualBoundingBoxDescent },
  { prototypes::id::TextMetrics },
  { PrototypeTraits<prototypes::id::TextMetrics>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_emHeightAscent(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TextMetrics", "emHeightAscent", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TextMetrics*>(void_self);
  double result(MOZ_KnownLive(self)->EmHeightAscent());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo emHeightAscent_getterinfo = {
  { get_emHeightAscent },
  { prototypes::id::TextMetrics },
  { PrototypeTraits<prototypes::id::TextMetrics>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_emHeightDescent(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TextMetrics", "emHeightDescent", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TextMetrics*>(void_self);
  double result(MOZ_KnownLive(self)->EmHeightDescent());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo emHeightDescent_getterinfo = {
  { get_emHeightDescent },
  { prototypes::id::TextMetrics },
  { PrototypeTraits<prototypes::id::TextMetrics>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_hangingBaseline(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TextMetrics", "hangingBaseline", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TextMetrics*>(void_self);
  double result(MOZ_KnownLive(self)->HangingBaseline());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo hangingBaseline_getterinfo = {
  { get_hangingBaseline },
  { prototypes::id::TextMetrics },
  { PrototypeTraits<prototypes::id::TextMetrics>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_alphabeticBaseline(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TextMetrics", "alphabeticBaseline", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TextMetrics*>(void_self);
  double result(MOZ_KnownLive(self)->AlphabeticBaseline());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo alphabeticBaseline_getterinfo = {
  { get_alphabeticBaseline },
  { prototypes::id::TextMetrics },
  { PrototypeTraits<prototypes::id::TextMetrics>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

MOZ_CAN_RUN_SCRIPT static bool
get_ideographicBaseline(JSContext* cx, JS::Handle<JSObject*> obj, void* void_self, JSJitGetterCallArgs args)
{
  AUTO_PROFILER_LABEL_DYNAMIC_FAST(
    "TextMetrics", "ideographicBaseline", DOM, cx,
    uint32_t(js::ProfilingStackFrame::Flags::STRING_TEMPLATE_GETTER) |
    uint32_t(js::ProfilingStackFrame::Flags::RELEVANT_FOR_JS));

  auto* self = static_cast<mozilla::dom::TextMetrics*>(void_self);
  double result(MOZ_KnownLive(self)->IdeographicBaseline());
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().set(JS_NumberValue(double(result)));
  return true;
}

static const JSJitInfo ideographicBaseline_getterinfo = {
  { get_ideographicBaseline },
  { prototypes::id::TextMetrics },
  { PrototypeTraits<prototypes::id::TextMetrics>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_DOUBLE,  /* returnType.  Not relevant for setters. */
  true,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static void
_finalize(JSFreeOp* fop, JSObject* obj)
{
  mozilla::dom::TextMetrics* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::TextMetrics>(obj);
  if (self) {
    JS::SetReservedSlot(obj, DOM_OBJECT_SLOT, JS::UndefinedValue());
    if (size_t mallocBytes = BindingJSObjectMallocBytes(self)) {
      JS::RemoveAssociatedMemory(obj, mallocBytes,
                                 JS::MemoryUse::DOMBinding);
    }
    AddForDeferredFinalization<mozilla::dom::TextMetrics>(self);
  }
}

// We deliberately use brace-elision to make Visual Studio produce better initalization code.
static const JSPropertySpec sAttributes_specs[] = {
  JSPropertySpec::nativeAccessors("width", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &width_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("actualBoundingBoxLeft", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &actualBoundingBoxLeft_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("actualBoundingBoxRight", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &actualBoundingBoxRight_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("fontBoundingBoxAscent", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &fontBoundingBoxAscent_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("fontBoundingBoxDescent", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &fontBoundingBoxDescent_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("actualBoundingBoxAscent", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &actualBoundingBoxAscent_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("actualBoundingBoxDescent", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &actualBoundingBoxDescent_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("emHeightAscent", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &emHeightAscent_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("emHeightDescent", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &emHeightDescent_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JSPropertySpec::nativeAccessors("hangingBaseline", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &hangingBaseline_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("alphabeticBaseline", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &alphabeticBaseline_getterinfo, nullptr, nullptr),
  JSPropertySpec::nativeAccessors("ideographicBaseline", JSPROP_ENUMERATE, GenericGetter<NormalThisPolicy, ThrowExceptions>, &ideographicBaseline_getterinfo, nullptr, nullptr),
  JS_PS_END,
  JS_STRING_SYM_PS(toStringTag, "TextMetrics", JSPROP_READONLY),
  JS_PS_END
};

static const PrefableDisablers sAttributes_disablers2 = {
  WebIDLPrefIndex::dom_textMetrics_actualBoundingBox_enabled, false, 0, nullptr
};

static const PrefableDisablers sAttributes_disablers5 = {
  WebIDLPrefIndex::dom_textMetrics_fontBoundingBox_enabled, false, 0, nullptr
};

static const PrefableDisablers sAttributes_disablers8 = {
  WebIDLPrefIndex::dom_textMetrics_actualBoundingBox_enabled, false, 0, nullptr
};

static const PrefableDisablers sAttributes_disablers11 = {
  WebIDLPrefIndex::dom_textMetrics_emHeight_enabled, false, 0, nullptr
};

static const PrefableDisablers sAttributes_disablers14 = {
  WebIDLPrefIndex::dom_textMetrics_baselines_enabled, false, 0, nullptr
};

static const Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { &sAttributes_disablers2, &sAttributes_specs[2] },
  { &sAttributes_disablers5, &sAttributes_specs[5] },
  { &sAttributes_disablers8, &sAttributes_specs[8] },
  { &sAttributes_disablers11, &sAttributes_specs[11] },
  { &sAttributes_disablers14, &sAttributes_specs[14] },
  { nullptr, &sAttributes_specs[18] },
  { nullptr, nullptr }
};

static_assert(7 <= 1ull << NUM_BITS_PROPERTY_INFO_PREF_INDEX,
    "We have a prefable index that is >= (1 << NUM_BITS_PROPERTY_INFO_PREF_INDEX)");
static_assert(3 <= 1ull << NUM_BITS_PROPERTY_INFO_SPEC_INDEX,
    "We have a spec index that is >= (1 << NUM_BITS_PROPERTY_INFO_SPEC_INDEX)");


static uint16_t sNativeProperties_sortedPropertyIndices[13];
static PropertyInfo sNativeProperties_propertyInfos[13];

static const NativePropertiesN<1> sNativeProperties = {
  false, 0,
  false, 0,
  false, 0,
  true,  0 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  -1,
  13,
  sNativeProperties_sortedPropertyIndices,
  {
    { sAttributes, &sNativeProperties_propertyInfos[0] }
  }
};
static_assert(13 < 1ull << (CHAR_BIT * sizeof(sNativeProperties.propertyInfoCount)),
    "We have a property info count that is oversized");

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sBoringInterfaceObjectClassClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::TextMetrics,
  PrototypeTraits<prototypes::id::TextMetrics>::Depth,
  sNativePropertyHooks,
  "function TextMetrics() {\n    [native code]\n}",
  JS::GetRealmFunctionPrototype
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "TextMetricsPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::TextMetrics,
  PrototypeTraits<prototypes::id::TextMetrics>::Depth,
  sNativePropertyHooks,
  nullptr,
  JS::GetRealmObjectPrototype
};

static const JSClassOps sClassOps = {
  nullptr, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* enumerate */
  nullptr, /* newEnumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  nullptr /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "TextMetrics",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::TextMetrics, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  std::is_base_of_v<nsISupports, mozilla::dom::TextMetrics>,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::TextMetrics>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::TextMetrics>::Get(),
  nullptr,
  nullptr
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::TextMetrics* aObject, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  MOZ_ASSERT(static_cast<mozilla::dom::TextMetrics*>(aObject) ==
             reinterpret_cast<mozilla::dom::TextMetrics*>(aObject),
             "Multiple inheritance for mozilla::dom::TextMetrics is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT_IF(aGivenProto, js::IsObjectInContextCompartment(aGivenProto, aCx));

  JS::Rooted<JSObject*> global(aCx, JS::CurrentGlobalOrNull(aCx));
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != JS::GetCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::TextMetrics> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }



  creator.InitializationSucceeded();
  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), nullptr },
  prototypes::id::TextMetrics,
  constructors::id::TextMetrics,
  nullptr,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Rooted<JSObject*> parentProto(aCx, JS::GetRealmObjectPrototype(aCx));
  if (!parentProto) {
    return;
  }

  JS::Rooted<JSObject*> constructorProto(aCx, JS::GetRealmFunctionPrototype(aCx));
  if (!constructorProto) {
    return;
  }

  static Atomic<bool, Relaxed> sIdsInited(false);
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sNativeProperties.Upcast())) {
      return;
    }
    sIdsInited = true;
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::TextMetrics);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::TextMetrics);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nullptr,
                              "TextMetrics", aDefineOnGlobal,
                              nullptr,
                              false,
                              nullptr,
                              false);
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace TextMetrics_Binding



} // namespace dom
} // namespace mozilla
