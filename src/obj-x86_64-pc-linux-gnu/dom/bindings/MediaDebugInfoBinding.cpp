/* THIS FILE IS AUTOGENERATED FROM MediaDebugInfo.webidl BY Codegen.py - DO NOT EDIT */

#include <type_traits>
#include "AtomList.h"
#include "GeckoProfiler.h"
#include "MediaDebugInfoBinding.h"
#include "js/Array.h"
#include "js/ForOfIterator.h"
#include "js/Object.h"
#include "js/experimental/JitInfo.h"
#include "mozilla/FloatingPoint.h"
#include "mozilla/OwningNonNull.h"
#include "mozilla/dom/BindingCallContext.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/PrimitiveConversions.h"
#include "mozilla/dom/ScriptSettings.h"
#include "mozilla/dom/SimpleGlobalObject.h"

namespace mozilla {
namespace dom {

namespace binding_detail {}; // Just to make sure it's known as a namespace
using namespace mozilla::dom::binding_detail;



AudioSinkDebugInfo::AudioSinkDebugInfo()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
AudioSinkDebugInfo::InitIds(JSContext* cx, AudioSinkDebugInfoAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->written_id.init(cx, "written") ||
      !atomsCache->startTime_id.init(cx, "startTime") ||
      !atomsCache->playbackComplete_id.init(cx, "playbackComplete") ||
      !atomsCache->outputRate_id.init(cx, "outputRate") ||
      !atomsCache->lastGoodPosition_id.init(cx, "lastGoodPosition") ||
      !atomsCache->isStarted_id.init(cx, "isStarted") ||
      !atomsCache->isPlaying_id.init(cx, "isPlaying") ||
      !atomsCache->hasErrored_id.init(cx, "hasErrored") ||
      !atomsCache->audioEnded_id.init(cx, "audioEnded")) {
    return false;
  }
  return true;
}

bool
AudioSinkDebugInfo::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mAudioEnded = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mHasErrored = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mIsPlaying = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mIsStarted = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mLastGoodPosition = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mOutputRate = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mPlaybackComplete = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mStartTime = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mWritten = 0LL;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
AudioSinkDebugInfo::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  AudioSinkDebugInfoAtoms* atomsCache = GetAtomCache<AudioSinkDebugInfoAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mAudioEnded;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->audioEnded_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mHasErrored;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->hasErrored_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mIsPlaying;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->isPlaying_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mIsStarted;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->isStarted_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mLastGoodPosition;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->lastGoodPosition_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mOutputRate;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->outputRate_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mPlaybackComplete;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->playbackComplete_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mStartTime;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->startTime_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mWritten;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->written_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
AudioSinkDebugInfo::TraceDictionary(JSTracer* trc)
{
}

AudioSinkDebugInfo&
AudioSinkDebugInfo::operator=(const AudioSinkDebugInfo& aOther)
{
  DictionaryBase::operator=(aOther);
  mAudioEnded = aOther.mAudioEnded;
  mHasErrored = aOther.mHasErrored;
  mIsPlaying = aOther.mIsPlaying;
  mIsStarted = aOther.mIsStarted;
  mLastGoodPosition = aOther.mLastGoodPosition;
  mOutputRate = aOther.mOutputRate;
  mPlaybackComplete = aOther.mPlaybackComplete;
  mStartTime = aOther.mStartTime;
  mWritten = aOther.mWritten;
  return *this;
}

bool
AudioSinkDebugInfo::operator==(const AudioSinkDebugInfo& aOther) const
{
  if (mAudioEnded != aOther.mAudioEnded) {
      return false;
  }
  if (mHasErrored != aOther.mHasErrored) {
      return false;
  }
  if (mIsPlaying != aOther.mIsPlaying) {
      return false;
  }
  if (mIsStarted != aOther.mIsStarted) {
      return false;
  }
  if (mLastGoodPosition != aOther.mLastGoodPosition) {
      return false;
  }
  if (mOutputRate != aOther.mOutputRate) {
      return false;
  }
  if (mPlaybackComplete != aOther.mPlaybackComplete) {
      return false;
  }
  if (mStartTime != aOther.mStartTime) {
      return false;
  }
  if (mWritten != aOther.mWritten) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



BufferRange::BufferRange()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
BufferRange::InitIds(JSContext* cx, BufferRangeAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->start_id.init(cx, "start") ||
      !atomsCache->end_id.init(cx, "end")) {
    return false;
  }
  return true;
}

bool
BufferRange::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mEnd = 0.0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mStart = 0.0;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
BufferRange::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  BufferRangeAtoms* atomsCache = GetAtomCache<BufferRangeAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    double const & currentValue = mEnd;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->end_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    double const & currentValue = mStart;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->start_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
BufferRange::TraceDictionary(JSTracer* trc)
{
}

BufferRange&
BufferRange::operator=(const BufferRange& aOther)
{
  DictionaryBase::operator=(aOther);
  mEnd = aOther.mEnd;
  mStart = aOther.mStart;
  return *this;
}

bool
BufferRange::operator==(const BufferRange& aOther) const
{
  if (mEnd != aOther.mEnd) {
      return false;
  }
  if (mStart != aOther.mStart) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



DecodedStreamDataDebugInfo::DecodedStreamDataDebugInfo()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
DecodedStreamDataDebugInfo::InitIds(JSContext* cx, DecodedStreamDataDebugInfoAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->streamVideoWritten_id.init(cx, "streamVideoWritten") ||
      !atomsCache->streamAudioWritten_id.init(cx, "streamAudioWritten") ||
      !atomsCache->nextAudioTime_id.init(cx, "nextAudioTime") ||
      !atomsCache->lastVideoStartTime_id.init(cx, "lastVideoStartTime") ||
      !atomsCache->lastVideoEndTime_id.init(cx, "lastVideoEndTime") ||
      !atomsCache->instance_id.init(cx, "instance") ||
      !atomsCache->haveSentFinishVideo_id.init(cx, "haveSentFinishVideo") ||
      !atomsCache->haveSentFinishAudio_id.init(cx, "haveSentFinishAudio") ||
      !atomsCache->audioFramesWritten_id.init(cx, "audioFramesWritten")) {
    return false;
  }
  return true;
}

bool
DecodedStreamDataDebugInfo::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mAudioFramesWritten = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mHaveSentFinishAudio = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mHaveSentFinishVideo = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mInstance.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mLastVideoEndTime = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mLastVideoStartTime = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mNextAudioTime = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mStreamAudioWritten = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mStreamVideoWritten = 0LL;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
DecodedStreamDataDebugInfo::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  DecodedStreamDataDebugInfoAtoms* atomsCache = GetAtomCache<DecodedStreamDataDebugInfoAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mAudioFramesWritten;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->audioFramesWritten_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mHaveSentFinishAudio;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->haveSentFinishAudio_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mHaveSentFinishVideo;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->haveSentFinishVideo_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mInstance;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->instance_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mLastVideoEndTime;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->lastVideoEndTime_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mLastVideoStartTime;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->lastVideoStartTime_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mNextAudioTime;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->nextAudioTime_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mStreamAudioWritten;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->streamAudioWritten_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mStreamVideoWritten;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->streamVideoWritten_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
DecodedStreamDataDebugInfo::TraceDictionary(JSTracer* trc)
{
}

DecodedStreamDataDebugInfo&
DecodedStreamDataDebugInfo::operator=(const DecodedStreamDataDebugInfo& aOther)
{
  DictionaryBase::operator=(aOther);
  mAudioFramesWritten = aOther.mAudioFramesWritten;
  mHaveSentFinishAudio = aOther.mHaveSentFinishAudio;
  mHaveSentFinishVideo = aOther.mHaveSentFinishVideo;
  mInstance = aOther.mInstance;
  mLastVideoEndTime = aOther.mLastVideoEndTime;
  mLastVideoStartTime = aOther.mLastVideoStartTime;
  mNextAudioTime = aOther.mNextAudioTime;
  mStreamAudioWritten = aOther.mStreamAudioWritten;
  mStreamVideoWritten = aOther.mStreamVideoWritten;
  return *this;
}

bool
DecodedStreamDataDebugInfo::operator==(const DecodedStreamDataDebugInfo& aOther) const
{
  if (mAudioFramesWritten != aOther.mAudioFramesWritten) {
      return false;
  }
  if (mHaveSentFinishAudio != aOther.mHaveSentFinishAudio) {
      return false;
  }
  if (mHaveSentFinishVideo != aOther.mHaveSentFinishVideo) {
      return false;
  }
  if (mInstance != aOther.mInstance) {
      return false;
  }
  if (mLastVideoEndTime != aOther.mLastVideoEndTime) {
      return false;
  }
  if (mLastVideoStartTime != aOther.mLastVideoStartTime) {
      return false;
  }
  if (mNextAudioTime != aOther.mNextAudioTime) {
      return false;
  }
  if (mStreamAudioWritten != aOther.mStreamAudioWritten) {
      return false;
  }
  if (mStreamVideoWritten != aOther.mStreamVideoWritten) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



EMEDebugInfo::EMEDebugInfo()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
EMEDebugInfo::InitIds(JSContext* cx, EMEDebugInfoAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->sessionsInfo_id.init(cx, "sessionsInfo") ||
      !atomsCache->keySystem_id.init(cx, "keySystem")) {
    return false;
  }
  return true;
}

bool
EMEDebugInfo::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mKeySystem.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mSessionsInfo.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
EMEDebugInfo::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  EMEDebugInfoAtoms* atomsCache = GetAtomCache<EMEDebugInfoAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mKeySystem;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->keySystem_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mSessionsInfo;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->sessionsInfo_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
EMEDebugInfo::TraceDictionary(JSTracer* trc)
{
}

EMEDebugInfo&
EMEDebugInfo::operator=(const EMEDebugInfo& aOther)
{
  DictionaryBase::operator=(aOther);
  mKeySystem = aOther.mKeySystem;
  mSessionsInfo = aOther.mSessionsInfo;
  return *this;
}

bool
EMEDebugInfo::operator==(const EMEDebugInfo& aOther) const
{
  if (mKeySystem != aOther.mKeySystem) {
      return false;
  }
  if (mSessionsInfo != aOther.mSessionsInfo) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



MediaCacheStreamDebugInfo::MediaCacheStreamDebugInfo()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
MediaCacheStreamDebugInfo::InitIds(JSContext* cx, MediaCacheStreamDebugInfoAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->streamLength_id.init(cx, "streamLength") ||
      !atomsCache->loadID_id.init(cx, "loadID") ||
      !atomsCache->channelOffset_id.init(cx, "channelOffset") ||
      !atomsCache->channelEnded_id.init(cx, "channelEnded") ||
      !atomsCache->cacheSuspended_id.init(cx, "cacheSuspended")) {
    return false;
  }
  return true;
}

bool
MediaCacheStreamDebugInfo::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mCacheSuspended = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mChannelEnded = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mChannelOffset = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mLoadID = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mStreamLength = 0LL;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
MediaCacheStreamDebugInfo::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  MediaCacheStreamDebugInfoAtoms* atomsCache = GetAtomCache<MediaCacheStreamDebugInfoAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mCacheSuspended;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->cacheSuspended_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mChannelEnded;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->channelEnded_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mChannelOffset;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->channelOffset_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mLoadID;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->loadID_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mStreamLength;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->streamLength_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
MediaCacheStreamDebugInfo::TraceDictionary(JSTracer* trc)
{
}

MediaCacheStreamDebugInfo&
MediaCacheStreamDebugInfo::operator=(const MediaCacheStreamDebugInfo& aOther)
{
  DictionaryBase::operator=(aOther);
  mCacheSuspended = aOther.mCacheSuspended;
  mChannelEnded = aOther.mChannelEnded;
  mChannelOffset = aOther.mChannelOffset;
  mLoadID = aOther.mLoadID;
  mStreamLength = aOther.mStreamLength;
  return *this;
}

bool
MediaCacheStreamDebugInfo::operator==(const MediaCacheStreamDebugInfo& aOther) const
{
  if (mCacheSuspended != aOther.mCacheSuspended) {
      return false;
  }
  if (mChannelEnded != aOther.mChannelEnded) {
      return false;
  }
  if (mChannelOffset != aOther.mChannelOffset) {
      return false;
  }
  if (mLoadID != aOther.mLoadID) {
      return false;
  }
  if (mStreamLength != aOther.mStreamLength) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



MediaDecoderStateMachineDecodingStateDebugInfo::MediaDecoderStateMachineDecodingStateDebugInfo()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
MediaDecoderStateMachineDecodingStateDebugInfo::InitIds(JSContext* cx, MediaDecoderStateMachineDecodingStateDebugInfoAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->isPrerolling_id.init(cx, "isPrerolling")) {
    return false;
  }
  return true;
}

bool
MediaDecoderStateMachineDecodingStateDebugInfo::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mIsPrerolling = false;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
MediaDecoderStateMachineDecodingStateDebugInfo::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  MediaDecoderStateMachineDecodingStateDebugInfoAtoms* atomsCache = GetAtomCache<MediaDecoderStateMachineDecodingStateDebugInfoAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mIsPrerolling;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->isPrerolling_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
MediaDecoderStateMachineDecodingStateDebugInfo::TraceDictionary(JSTracer* trc)
{
}

MediaDecoderStateMachineDecodingStateDebugInfo&
MediaDecoderStateMachineDecodingStateDebugInfo::operator=(const MediaDecoderStateMachineDecodingStateDebugInfo& aOther)
{
  DictionaryBase::operator=(aOther);
  mIsPrerolling = aOther.mIsPrerolling;
  return *this;
}

bool
MediaDecoderStateMachineDecodingStateDebugInfo::operator==(const MediaDecoderStateMachineDecodingStateDebugInfo& aOther) const
{
  if (mIsPrerolling != aOther.mIsPrerolling) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



MediaFrameStats::MediaFrameStats()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
MediaFrameStats::InitIds(JSContext* cx, MediaFrameStatsAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->droppedSinkFrames_id.init(cx, "droppedSinkFrames") ||
      !atomsCache->droppedDecodedFrames_id.init(cx, "droppedDecodedFrames") ||
      !atomsCache->droppedCompositorFrames_id.init(cx, "droppedCompositorFrames")) {
    return false;
  }
  return true;
}

bool
MediaFrameStats::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mDroppedCompositorFrames = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mDroppedDecodedFrames = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mDroppedSinkFrames = 0LL;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
MediaFrameStats::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  MediaFrameStatsAtoms* atomsCache = GetAtomCache<MediaFrameStatsAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mDroppedCompositorFrames;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->droppedCompositorFrames_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mDroppedDecodedFrames;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->droppedDecodedFrames_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mDroppedSinkFrames;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->droppedSinkFrames_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
MediaFrameStats::TraceDictionary(JSTracer* trc)
{
}

MediaFrameStats&
MediaFrameStats::operator=(const MediaFrameStats& aOther)
{
  DictionaryBase::operator=(aOther);
  mDroppedCompositorFrames = aOther.mDroppedCompositorFrames;
  mDroppedDecodedFrames = aOther.mDroppedDecodedFrames;
  mDroppedSinkFrames = aOther.mDroppedSinkFrames;
  return *this;
}

bool
MediaFrameStats::operator==(const MediaFrameStats& aOther) const
{
  if (mDroppedCompositorFrames != aOther.mDroppedCompositorFrames) {
      return false;
  }
  if (mDroppedDecodedFrames != aOther.mDroppedDecodedFrames) {
      return false;
  }
  if (mDroppedSinkFrames != aOther.mDroppedSinkFrames) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



MediaStateDebugInfo::MediaStateDebugInfo()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
MediaStateDebugInfo::InitIds(JSContext* cx, MediaStateDebugInfoAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->waitingPromise_id.init(cx, "waitingPromise") ||
      !atomsCache->waitingForKey_id.init(cx, "waitingForKey") ||
      !atomsCache->waitingForData_id.init(cx, "waitingForData") ||
      !atomsCache->timeTresholdHasSeeked_id.init(cx, "timeTresholdHasSeeked") ||
      !atomsCache->timeTreshold_id.init(cx, "timeTreshold") ||
      !atomsCache->queueSize_id.init(cx, "queueSize") ||
      !atomsCache->pending_id.init(cx, "pending") ||
      !atomsCache->numSamplesOutput_id.init(cx, "numSamplesOutput") ||
      !atomsCache->numSamplesInput_id.init(cx, "numSamplesInput") ||
      !atomsCache->needInput_id.init(cx, "needInput") ||
      !atomsCache->lastStreamSourceID_id.init(cx, "lastStreamSourceID") ||
      !atomsCache->hasPromise_id.init(cx, "hasPromise") ||
      !atomsCache->hasDemuxRequest_id.init(cx, "hasDemuxRequest") ||
      !atomsCache->hasDecoder_id.init(cx, "hasDecoder") ||
      !atomsCache->drainState_id.init(cx, "drainState") ||
      !atomsCache->demuxQueueSize_id.init(cx, "demuxQueueSize") ||
      !atomsCache->demuxEOS_id.init(cx, "demuxEOS")) {
    return false;
  }
  return true;
}

bool
MediaStateDebugInfo::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mDemuxEOS = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mDemuxQueueSize = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mDrainState = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mHasDecoder = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mHasDemuxRequest = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mHasPromise = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mLastStreamSourceID = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mNeedInput = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mNumSamplesInput = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mNumSamplesOutput = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mPending = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mQueueSize = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mTimeTreshold = 0.0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mTimeTresholdHasSeeked = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mWaitingForData = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mWaitingForKey = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mWaitingPromise = false;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
MediaStateDebugInfo::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  MediaStateDebugInfoAtoms* atomsCache = GetAtomCache<MediaStateDebugInfoAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mDemuxEOS;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->demuxEOS_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mDemuxQueueSize;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->demuxQueueSize_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mDrainState;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->drainState_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mHasDecoder;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->hasDecoder_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mHasDemuxRequest;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->hasDemuxRequest_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mHasPromise;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->hasPromise_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mLastStreamSourceID;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->lastStreamSourceID_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mNeedInput;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->needInput_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mNumSamplesInput;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->numSamplesInput_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mNumSamplesOutput;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->numSamplesOutput_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mPending;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->pending_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mQueueSize;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->queueSize_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    double const & currentValue = mTimeTreshold;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->timeTreshold_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mTimeTresholdHasSeeked;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->timeTresholdHasSeeked_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mWaitingForData;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->waitingForData_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mWaitingForKey;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->waitingForKey_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mWaitingPromise;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->waitingPromise_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
MediaStateDebugInfo::TraceDictionary(JSTracer* trc)
{
}

MediaStateDebugInfo&
MediaStateDebugInfo::operator=(const MediaStateDebugInfo& aOther)
{
  DictionaryBase::operator=(aOther);
  mDemuxEOS = aOther.mDemuxEOS;
  mDemuxQueueSize = aOther.mDemuxQueueSize;
  mDrainState = aOther.mDrainState;
  mHasDecoder = aOther.mHasDecoder;
  mHasDemuxRequest = aOther.mHasDemuxRequest;
  mHasPromise = aOther.mHasPromise;
  mLastStreamSourceID = aOther.mLastStreamSourceID;
  mNeedInput = aOther.mNeedInput;
  mNumSamplesInput = aOther.mNumSamplesInput;
  mNumSamplesOutput = aOther.mNumSamplesOutput;
  mPending = aOther.mPending;
  mQueueSize = aOther.mQueueSize;
  mTimeTreshold = aOther.mTimeTreshold;
  mTimeTresholdHasSeeked = aOther.mTimeTresholdHasSeeked;
  mWaitingForData = aOther.mWaitingForData;
  mWaitingForKey = aOther.mWaitingForKey;
  mWaitingPromise = aOther.mWaitingPromise;
  return *this;
}

bool
MediaStateDebugInfo::operator==(const MediaStateDebugInfo& aOther) const
{
  if (mDemuxEOS != aOther.mDemuxEOS) {
      return false;
  }
  if (mDemuxQueueSize != aOther.mDemuxQueueSize) {
      return false;
  }
  if (mDrainState != aOther.mDrainState) {
      return false;
  }
  if (mHasDecoder != aOther.mHasDecoder) {
      return false;
  }
  if (mHasDemuxRequest != aOther.mHasDemuxRequest) {
      return false;
  }
  if (mHasPromise != aOther.mHasPromise) {
      return false;
  }
  if (mLastStreamSourceID != aOther.mLastStreamSourceID) {
      return false;
  }
  if (mNeedInput != aOther.mNeedInput) {
      return false;
  }
  if (mNumSamplesInput != aOther.mNumSamplesInput) {
      return false;
  }
  if (mNumSamplesOutput != aOther.mNumSamplesOutput) {
      return false;
  }
  if (mPending != aOther.mPending) {
      return false;
  }
  if (mQueueSize != aOther.mQueueSize) {
      return false;
  }
  if (mTimeTreshold != aOther.mTimeTreshold) {
      return false;
  }
  if (mTimeTresholdHasSeeked != aOther.mTimeTresholdHasSeeked) {
      return false;
  }
  if (mWaitingForData != aOther.mWaitingForData) {
      return false;
  }
  if (mWaitingForKey != aOther.mWaitingForKey) {
      return false;
  }
  if (mWaitingPromise != aOther.mWaitingPromise) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



VideoSinkDebugInfo::VideoSinkDebugInfo()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
VideoSinkDebugInfo::InitIds(JSContext* cx, VideoSinkDebugInfoAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->videoSinkEndRequestExists_id.init(cx, "videoSinkEndRequestExists") ||
      !atomsCache->videoFrameEndTime_id.init(cx, "videoFrameEndTime") ||
      !atomsCache->size_id.init(cx, "size") ||
      !atomsCache->isStarted_id.init(cx, "isStarted") ||
      !atomsCache->isPlaying_id.init(cx, "isPlaying") ||
      !atomsCache->hasVideo_id.init(cx, "hasVideo") ||
      !atomsCache->finished_id.init(cx, "finished") ||
      !atomsCache->endPromiseHolderIsEmpty_id.init(cx, "endPromiseHolderIsEmpty")) {
    return false;
  }
  return true;
}

bool
VideoSinkDebugInfo::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mEndPromiseHolderIsEmpty = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mFinished = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mHasVideo = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mIsPlaying = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mIsStarted = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mSize = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mVideoFrameEndTime = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mVideoSinkEndRequestExists = false;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
VideoSinkDebugInfo::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  VideoSinkDebugInfoAtoms* atomsCache = GetAtomCache<VideoSinkDebugInfoAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mEndPromiseHolderIsEmpty;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->endPromiseHolderIsEmpty_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mFinished;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->finished_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mHasVideo;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->hasVideo_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mIsPlaying;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->isPlaying_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mIsStarted;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->isStarted_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mSize;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->size_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mVideoFrameEndTime;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->videoFrameEndTime_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mVideoSinkEndRequestExists;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->videoSinkEndRequestExists_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
VideoSinkDebugInfo::TraceDictionary(JSTracer* trc)
{
}

VideoSinkDebugInfo&
VideoSinkDebugInfo::operator=(const VideoSinkDebugInfo& aOther)
{
  DictionaryBase::operator=(aOther);
  mEndPromiseHolderIsEmpty = aOther.mEndPromiseHolderIsEmpty;
  mFinished = aOther.mFinished;
  mHasVideo = aOther.mHasVideo;
  mIsPlaying = aOther.mIsPlaying;
  mIsStarted = aOther.mIsStarted;
  mSize = aOther.mSize;
  mVideoFrameEndTime = aOther.mVideoFrameEndTime;
  mVideoSinkEndRequestExists = aOther.mVideoSinkEndRequestExists;
  return *this;
}

bool
VideoSinkDebugInfo::operator==(const VideoSinkDebugInfo& aOther) const
{
  if (mEndPromiseHolderIsEmpty != aOther.mEndPromiseHolderIsEmpty) {
      return false;
  }
  if (mFinished != aOther.mFinished) {
      return false;
  }
  if (mHasVideo != aOther.mHasVideo) {
      return false;
  }
  if (mIsPlaying != aOther.mIsPlaying) {
      return false;
  }
  if (mIsStarted != aOther.mIsStarted) {
      return false;
  }
  if (mSize != aOther.mSize) {
      return false;
  }
  if (mVideoFrameEndTime != aOther.mVideoFrameEndTime) {
      return false;
  }
  if (mVideoSinkEndRequestExists != aOther.mVideoSinkEndRequestExists) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



AudioSinkWrapperDebugInfo::AudioSinkWrapperDebugInfo()
  : mAudioSink(FastDictionaryInitializer())
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
AudioSinkWrapperDebugInfo::InitIds(JSContext* cx, AudioSinkWrapperDebugInfoAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->isStarted_id.init(cx, "isStarted") ||
      !atomsCache->isPlaying_id.init(cx, "isPlaying") ||
      !atomsCache->audioSink_id.init(cx, "audioSink") ||
      !atomsCache->audioEnded_id.init(cx, "audioEnded")) {
    return false;
  }
  return true;
}

bool
AudioSinkWrapperDebugInfo::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mAudioEnded = false;
  }
  mIsAnyMemberPresent = true;

  if (!mAudioSink.Init("'audioSink' member of AudioSinkWrapperDebugInfo", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mIsPlaying = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mIsStarted = false;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
AudioSinkWrapperDebugInfo::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  AudioSinkWrapperDebugInfoAtoms* atomsCache = GetAtomCache<AudioSinkWrapperDebugInfoAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mAudioEnded;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->audioEnded_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    AudioSinkDebugInfo const & currentValue = mAudioSink;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->audioSink_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mIsPlaying;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->isPlaying_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mIsStarted;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->isStarted_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
AudioSinkWrapperDebugInfo::TraceDictionary(JSTracer* trc)
{
}

AudioSinkWrapperDebugInfo&
AudioSinkWrapperDebugInfo::operator=(const AudioSinkWrapperDebugInfo& aOther)
{
  DictionaryBase::operator=(aOther);
  mAudioEnded = aOther.mAudioEnded;
  mAudioSink = aOther.mAudioSink;
  mIsPlaying = aOther.mIsPlaying;
  mIsStarted = aOther.mIsStarted;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail



DecodedStreamDebugInfo::DecodedStreamDebugInfo()
  : mData(FastDictionaryInitializer())
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
DecodedStreamDebugInfo::InitIds(JSContext* cx, DecodedStreamDebugInfoAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->startTime_id.init(cx, "startTime") ||
      !atomsCache->playing_id.init(cx, "playing") ||
      !atomsCache->lastOutputTime_id.init(cx, "lastOutputTime") ||
      !atomsCache->lastAudio_id.init(cx, "lastAudio") ||
      !atomsCache->instance_id.init(cx, "instance") ||
      !atomsCache->data_id.init(cx, "data") ||
      !atomsCache->audioQueueSize_id.init(cx, "audioQueueSize") ||
      !atomsCache->audioQueueFinished_id.init(cx, "audioQueueFinished")) {
    return false;
  }
  return true;
}

bool
DecodedStreamDebugInfo::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mAudioQueueFinished = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mAudioQueueSize = 0;
  }
  mIsAnyMemberPresent = true;

  if (!mData.Init("'data' member of DecodedStreamDebugInfo", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mInstance.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mLastAudio = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mLastOutputTime = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mPlaying = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mStartTime = 0LL;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
DecodedStreamDebugInfo::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  DecodedStreamDebugInfoAtoms* atomsCache = GetAtomCache<DecodedStreamDebugInfoAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mAudioQueueFinished;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->audioQueueFinished_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mAudioQueueSize;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->audioQueueSize_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    DecodedStreamDataDebugInfo const & currentValue = mData;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->data_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mInstance;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->instance_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mLastAudio;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->lastAudio_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mLastOutputTime;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->lastOutputTime_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mPlaying;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->playing_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mStartTime;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->startTime_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
DecodedStreamDebugInfo::TraceDictionary(JSTracer* trc)
{
}

DecodedStreamDebugInfo&
DecodedStreamDebugInfo::operator=(const DecodedStreamDebugInfo& aOther)
{
  DictionaryBase::operator=(aOther);
  mAudioQueueFinished = aOther.mAudioQueueFinished;
  mAudioQueueSize = aOther.mAudioQueueSize;
  mData = aOther.mData;
  mInstance = aOther.mInstance;
  mLastAudio = aOther.mLastAudio;
  mLastOutputTime = aOther.mLastOutputTime;
  mPlaying = aOther.mPlaying;
  mStartTime = aOther.mStartTime;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail



MediaFormatReaderDebugInfo::MediaFormatReaderDebugInfo()
  : mAudioState(FastDictionaryInitializer()),
    mFrameStats(FastDictionaryInitializer()),
    mVideoState(FastDictionaryInitializer())
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
MediaFormatReaderDebugInfo::InitIds(JSContext* cx, MediaFormatReaderDebugInfoAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->videoWidth_id.init(cx, "videoWidth") ||
      !atomsCache->videoType_id.init(cx, "videoType") ||
      !atomsCache->videoState_id.init(cx, "videoState") ||
      !atomsCache->videoRate_id.init(cx, "videoRate") ||
      !atomsCache->videoNumSamplesSkippedTotal_id.init(cx, "videoNumSamplesSkippedTotal") ||
      !atomsCache->videoNumSamplesOutputTotal_id.init(cx, "videoNumSamplesOutputTotal") ||
      !atomsCache->videoHeight_id.init(cx, "videoHeight") ||
      !atomsCache->videoHardwareAccelerated_id.init(cx, "videoHardwareAccelerated") ||
      !atomsCache->videoDecoderName_id.init(cx, "videoDecoderName") ||
      !atomsCache->frameStats_id.init(cx, "frameStats") ||
      !atomsCache->audioType_id.init(cx, "audioType") ||
      !atomsCache->audioState_id.init(cx, "audioState") ||
      !atomsCache->audioRate_id.init(cx, "audioRate") ||
      !atomsCache->audioFramesDecoded_id.init(cx, "audioFramesDecoded") ||
      !atomsCache->audioDecoderName_id.init(cx, "audioDecoderName") ||
      !atomsCache->audioChannels_id.init(cx, "audioChannels")) {
    return false;
  }
  return true;
}

bool
MediaFormatReaderDebugInfo::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mAudioChannels = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mAudioDecoderName.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mAudioFramesDecoded = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mAudioRate = 0.0;
  }
  mIsAnyMemberPresent = true;

  if (!mAudioState.Init("'audioState' member of MediaFormatReaderDebugInfo", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mAudioType.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  if (!mFrameStats.Init("'frameStats' member of MediaFormatReaderDebugInfo", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mVideoDecoderName.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mVideoHardwareAccelerated = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mVideoHeight = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mVideoNumSamplesOutputTotal = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mVideoNumSamplesSkippedTotal = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mVideoRate = 0.0;
  }
  mIsAnyMemberPresent = true;

  if (!mVideoState.Init("'videoState' member of MediaFormatReaderDebugInfo", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mVideoType.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mVideoWidth = 0;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
MediaFormatReaderDebugInfo::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  MediaFormatReaderDebugInfoAtoms* atomsCache = GetAtomCache<MediaFormatReaderDebugInfoAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mAudioChannels;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->audioChannels_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mAudioDecoderName;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->audioDecoderName_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mAudioFramesDecoded;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->audioFramesDecoded_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    double const & currentValue = mAudioRate;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->audioRate_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    MediaStateDebugInfo const & currentValue = mAudioState;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->audioState_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mAudioType;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->audioType_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    MediaFrameStats const & currentValue = mFrameStats;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->frameStats_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mVideoDecoderName;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->videoDecoderName_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mVideoHardwareAccelerated;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->videoHardwareAccelerated_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mVideoHeight;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->videoHeight_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mVideoNumSamplesOutputTotal;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->videoNumSamplesOutputTotal_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mVideoNumSamplesSkippedTotal;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->videoNumSamplesSkippedTotal_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    double const & currentValue = mVideoRate;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->videoRate_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    MediaStateDebugInfo const & currentValue = mVideoState;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->videoState_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mVideoType;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->videoType_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mVideoWidth;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->videoWidth_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
MediaFormatReaderDebugInfo::TraceDictionary(JSTracer* trc)
{
}

MediaFormatReaderDebugInfo&
MediaFormatReaderDebugInfo::operator=(const MediaFormatReaderDebugInfo& aOther)
{
  DictionaryBase::operator=(aOther);
  mAudioChannels = aOther.mAudioChannels;
  mAudioDecoderName = aOther.mAudioDecoderName;
  mAudioFramesDecoded = aOther.mAudioFramesDecoded;
  mAudioRate = aOther.mAudioRate;
  mAudioState = aOther.mAudioState;
  mAudioType = aOther.mAudioType;
  mFrameStats = aOther.mFrameStats;
  mVideoDecoderName = aOther.mVideoDecoderName;
  mVideoHardwareAccelerated = aOther.mVideoHardwareAccelerated;
  mVideoHeight = aOther.mVideoHeight;
  mVideoNumSamplesOutputTotal = aOther.mVideoNumSamplesOutputTotal;
  mVideoNumSamplesSkippedTotal = aOther.mVideoNumSamplesSkippedTotal;
  mVideoRate = aOther.mVideoRate;
  mVideoState = aOther.mVideoState;
  mVideoType = aOther.mVideoType;
  mVideoWidth = aOther.mVideoWidth;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail



MediaResourceDebugInfo::MediaResourceDebugInfo()
  : mCacheStream(FastDictionaryInitializer())
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
MediaResourceDebugInfo::InitIds(JSContext* cx, MediaResourceDebugInfoAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->cacheStream_id.init(cx, "cacheStream")) {
    return false;
  }
  return true;
}

bool
MediaResourceDebugInfo::Init(const char* sourceDescription, bool passedToJSImpl)
{
  if (!mCacheStream.Init("'cacheStream' member of MediaResourceDebugInfo", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
MediaResourceDebugInfo::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  MediaResourceDebugInfoAtoms* atomsCache = GetAtomCache<MediaResourceDebugInfoAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    MediaCacheStreamDebugInfo const & currentValue = mCacheStream;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->cacheStream_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
MediaResourceDebugInfo::TraceDictionary(JSTracer* trc)
{
}

MediaResourceDebugInfo&
MediaResourceDebugInfo::operator=(const MediaResourceDebugInfo& aOther)
{
  DictionaryBase::operator=(aOther);
  mCacheStream = aOther.mCacheStream;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail



TrackBuffersManagerDebugInfo::TrackBuffersManagerDebugInfo()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
TrackBuffersManagerDebugInfo::InitIds(JSContext* cx, TrackBuffersManagerDebugInfoAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->type_id.init(cx, "type") ||
      !atomsCache->ranges_id.init(cx, "ranges") ||
      !atomsCache->numSamples_id.init(cx, "numSamples") ||
      !atomsCache->nextSampleTime_id.init(cx, "nextSampleTime") ||
      !atomsCache->nextInsertionIndex_id.init(cx, "nextInsertionIndex") ||
      !atomsCache->nextGetSampleIndex_id.init(cx, "nextGetSampleIndex") ||
      !atomsCache->evictable_id.init(cx, "evictable") ||
      !atomsCache->bufferSize_id.init(cx, "bufferSize")) {
    return false;
  }
  return true;
}

bool
TrackBuffersManagerDebugInfo::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mBufferSize = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mEvictable = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mNextGetSampleIndex = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mNextInsertionIndex = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mNextSampleTime = 0.0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mNumSamples = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    /* mRanges array is already empty; nothing to do */
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mType.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
TrackBuffersManagerDebugInfo::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  TrackBuffersManagerDebugInfoAtoms* atomsCache = GetAtomCache<TrackBuffersManagerDebugInfoAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mBufferSize;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->bufferSize_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mEvictable;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->evictable_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mNextGetSampleIndex;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->nextGetSampleIndex_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mNextInsertionIndex;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->nextInsertionIndex_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    double const & currentValue = mNextSampleTime;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->nextSampleTime_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mNumSamples;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->numSamples_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Sequence<BufferRange> const & currentValue = mRanges;

    uint32_t length = currentValue.Length();
    JS::Rooted<JSObject*> returnArray(cx, JS::NewArrayObject(cx, length));
    if (!returnArray) {
      return false;
    }
    // Scope for 'tmp'
    {
      JS::Rooted<JS::Value> tmp(cx);
      for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
        // Control block to let us common up the JS_DefineElement calls when there
        // are different ways to succeed at wrapping the object.
        do {
          if (!currentValue[sequenceIdx0].ToObjectInternal(cx, &tmp)) {
            return false;
          }
          break;
        } while (false);
        if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                              JSPROP_ENUMERATE)) {
          return false;
        }
      }
    }
    temp.setObject(*returnArray);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->ranges_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mType;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->type_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
TrackBuffersManagerDebugInfo::TraceDictionary(JSTracer* trc)
{
}

TrackBuffersManagerDebugInfo&
TrackBuffersManagerDebugInfo::operator=(const TrackBuffersManagerDebugInfo& aOther)
{
  DictionaryBase::operator=(aOther);
  mBufferSize = aOther.mBufferSize;
  mEvictable = aOther.mEvictable;
  mNextGetSampleIndex = aOther.mNextGetSampleIndex;
  mNextInsertionIndex = aOther.mNextInsertionIndex;
  mNextSampleTime = aOther.mNextSampleTime;
  mNumSamples = aOther.mNumSamples;
  mRanges = aOther.mRanges;
  mType = aOther.mType;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail



MediaSinkDebugInfo::MediaSinkDebugInfo()
  : mAudioSinkWrapper(FastDictionaryInitializer()),
    mDecodedStream(FastDictionaryInitializer()),
    mVideoSink(FastDictionaryInitializer())
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
MediaSinkDebugInfo::InitIds(JSContext* cx, MediaSinkDebugInfoAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->videoSink_id.init(cx, "videoSink") ||
      !atomsCache->decodedStream_id.init(cx, "decodedStream") ||
      !atomsCache->audioSinkWrapper_id.init(cx, "audioSinkWrapper")) {
    return false;
  }
  return true;
}

bool
MediaSinkDebugInfo::Init(const char* sourceDescription, bool passedToJSImpl)
{
  if (!mAudioSinkWrapper.Init("'audioSinkWrapper' member of MediaSinkDebugInfo", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;

  if (!mDecodedStream.Init("'decodedStream' member of MediaSinkDebugInfo", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;

  if (!mVideoSink.Init("'videoSink' member of MediaSinkDebugInfo", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
MediaSinkDebugInfo::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  MediaSinkDebugInfoAtoms* atomsCache = GetAtomCache<MediaSinkDebugInfoAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    AudioSinkWrapperDebugInfo const & currentValue = mAudioSinkWrapper;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->audioSinkWrapper_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    DecodedStreamDebugInfo const & currentValue = mDecodedStream;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->decodedStream_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    VideoSinkDebugInfo const & currentValue = mVideoSink;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->videoSink_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
MediaSinkDebugInfo::TraceDictionary(JSTracer* trc)
{
}

MediaSinkDebugInfo&
MediaSinkDebugInfo::operator=(const MediaSinkDebugInfo& aOther)
{
  DictionaryBase::operator=(aOther);
  mAudioSinkWrapper = aOther.mAudioSinkWrapper;
  mDecodedStream = aOther.mDecodedStream;
  mVideoSink = aOther.mVideoSink;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail



MediaSourceDemuxerDebugInfo::MediaSourceDemuxerDebugInfo()
  : mAudioTrack(FastDictionaryInitializer()),
    mVideoTrack(FastDictionaryInitializer())
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
MediaSourceDemuxerDebugInfo::InitIds(JSContext* cx, MediaSourceDemuxerDebugInfoAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->videoTrack_id.init(cx, "videoTrack") ||
      !atomsCache->audioTrack_id.init(cx, "audioTrack")) {
    return false;
  }
  return true;
}

bool
MediaSourceDemuxerDebugInfo::Init(const char* sourceDescription, bool passedToJSImpl)
{
  if (!mAudioTrack.Init("'audioTrack' member of MediaSourceDemuxerDebugInfo", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;

  if (!mVideoTrack.Init("'videoTrack' member of MediaSourceDemuxerDebugInfo", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
MediaSourceDemuxerDebugInfo::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  MediaSourceDemuxerDebugInfoAtoms* atomsCache = GetAtomCache<MediaSourceDemuxerDebugInfoAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    TrackBuffersManagerDebugInfo const & currentValue = mAudioTrack;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->audioTrack_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    TrackBuffersManagerDebugInfo const & currentValue = mVideoTrack;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->videoTrack_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
MediaSourceDemuxerDebugInfo::TraceDictionary(JSTracer* trc)
{
}

MediaSourceDemuxerDebugInfo&
MediaSourceDemuxerDebugInfo::operator=(const MediaSourceDemuxerDebugInfo& aOther)
{
  DictionaryBase::operator=(aOther);
  mAudioTrack = aOther.mAudioTrack;
  mVideoTrack = aOther.mVideoTrack;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail



MediaDecoderStateMachineDebugInfo::MediaDecoderStateMachineDebugInfo()
  : mMediaSink(FastDictionaryInitializer()),
    mStateObj(FastDictionaryInitializer())
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
MediaDecoderStateMachineDebugInfo::InitIds(JSContext* cx, MediaDecoderStateMachineDebugInfoAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->videoRequestStatus_id.init(cx, "videoRequestStatus") ||
      !atomsCache->videoCompleted_id.init(cx, "videoCompleted") ||
      !atomsCache->stateObj_id.init(cx, "stateObj") ||
      !atomsCache->state_id.init(cx, "state") ||
      !atomsCache->sentFirstFrameLoadedEvent_id.init(cx, "sentFirstFrameLoadedEvent") ||
      !atomsCache->playState_id.init(cx, "playState") ||
      !atomsCache->mediaTime_id.init(cx, "mediaTime") ||
      !atomsCache->mediaSink_id.init(cx, "mediaSink") ||
      !atomsCache->isPlaying_id.init(cx, "isPlaying") ||
      !atomsCache->duration_id.init(cx, "duration") ||
      !atomsCache->decodedVideoEndTime_id.init(cx, "decodedVideoEndTime") ||
      !atomsCache->decodedAudioEndTime_id.init(cx, "decodedAudioEndTime") ||
      !atomsCache->clock_id.init(cx, "clock") ||
      !atomsCache->audioRequestStatus_id.init(cx, "audioRequestStatus") ||
      !atomsCache->audioCompleted_id.init(cx, "audioCompleted")) {
    return false;
  }
  return true;
}

bool
MediaDecoderStateMachineDebugInfo::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mAudioCompleted = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mAudioRequestStatus.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mClock = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mDecodedAudioEndTime = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mDecodedVideoEndTime = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mDuration = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mIsPlaying = false;
  }
  mIsAnyMemberPresent = true;

  if (!mMediaSink.Init("'mediaSink' member of MediaDecoderStateMachineDebugInfo", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mMediaTime = 0LL;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mPlayState = 0;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mSentFirstFrameLoadedEvent = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mState.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  if (!mStateObj.Init("'stateObj' member of MediaDecoderStateMachineDebugInfo", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mVideoCompleted = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mVideoRequestStatus.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
MediaDecoderStateMachineDebugInfo::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  MediaDecoderStateMachineDebugInfoAtoms* atomsCache = GetAtomCache<MediaDecoderStateMachineDebugInfoAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mAudioCompleted;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->audioCompleted_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mAudioRequestStatus;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->audioRequestStatus_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mClock;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->clock_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mDecodedAudioEndTime;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->decodedAudioEndTime_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mDecodedVideoEndTime;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->decodedVideoEndTime_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mDuration;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->duration_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mIsPlaying;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->isPlaying_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    MediaSinkDebugInfo const & currentValue = mMediaSink;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->mediaSink_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int64_t const & currentValue = mMediaTime;
    temp.set(JS_NumberValue(double(currentValue)));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->mediaTime_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mPlayState;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->playState_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mSentFirstFrameLoadedEvent;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->sentFirstFrameLoadedEvent_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mState;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->state_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    MediaDecoderStateMachineDecodingStateDebugInfo const & currentValue = mStateObj;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->stateObj_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mVideoCompleted;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->videoCompleted_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mVideoRequestStatus;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->videoRequestStatus_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
MediaDecoderStateMachineDebugInfo::TraceDictionary(JSTracer* trc)
{
}

MediaDecoderStateMachineDebugInfo&
MediaDecoderStateMachineDebugInfo::operator=(const MediaDecoderStateMachineDebugInfo& aOther)
{
  DictionaryBase::operator=(aOther);
  mAudioCompleted = aOther.mAudioCompleted;
  mAudioRequestStatus = aOther.mAudioRequestStatus;
  mClock = aOther.mClock;
  mDecodedAudioEndTime = aOther.mDecodedAudioEndTime;
  mDecodedVideoEndTime = aOther.mDecodedVideoEndTime;
  mDuration = aOther.mDuration;
  mIsPlaying = aOther.mIsPlaying;
  mMediaSink = aOther.mMediaSink;
  mMediaTime = aOther.mMediaTime;
  mPlayState = aOther.mPlayState;
  mSentFirstFrameLoadedEvent = aOther.mSentFirstFrameLoadedEvent;
  mState = aOther.mState;
  mStateObj = aOther.mStateObj;
  mVideoCompleted = aOther.mVideoCompleted;
  mVideoRequestStatus = aOther.mVideoRequestStatus;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail



MediaSourceDecoderDebugInfo::MediaSourceDecoderDebugInfo()
  : mDemuxer(FastDictionaryInitializer()),
    mReader(FastDictionaryInitializer())
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
MediaSourceDecoderDebugInfo::InitIds(JSContext* cx, MediaSourceDecoderDebugInfoAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->reader_id.init(cx, "reader") ||
      !atomsCache->demuxer_id.init(cx, "demuxer")) {
    return false;
  }
  return true;
}

bool
MediaSourceDecoderDebugInfo::Init(const char* sourceDescription, bool passedToJSImpl)
{
  if (!mDemuxer.Init("'demuxer' member of MediaSourceDecoderDebugInfo", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;

  if (!mReader.Init("'reader' member of MediaSourceDecoderDebugInfo", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
MediaSourceDecoderDebugInfo::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  MediaSourceDecoderDebugInfoAtoms* atomsCache = GetAtomCache<MediaSourceDecoderDebugInfoAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    MediaSourceDemuxerDebugInfo const & currentValue = mDemuxer;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->demuxer_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    MediaFormatReaderDebugInfo const & currentValue = mReader;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->reader_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
MediaSourceDecoderDebugInfo::TraceDictionary(JSTracer* trc)
{
}

MediaSourceDecoderDebugInfo&
MediaSourceDecoderDebugInfo::operator=(const MediaSourceDecoderDebugInfo& aOther)
{
  DictionaryBase::operator=(aOther);
  mDemuxer = aOther.mDemuxer;
  mReader = aOther.mReader;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail



MediaDecoderDebugInfo::MediaDecoderDebugInfo()
  : mReader(FastDictionaryInitializer()),
    mResource(FastDictionaryInitializer()),
    mStateMachine(FastDictionaryInitializer())
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
MediaDecoderDebugInfo::InitIds(JSContext* cx, MediaDecoderDebugInfoAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->stateMachine_id.init(cx, "stateMachine") ||
      !atomsCache->resource_id.init(cx, "resource") ||
      !atomsCache->reader_id.init(cx, "reader") ||
      !atomsCache->rate_id.init(cx, "rate") ||
      !atomsCache->instance_id.init(cx, "instance") ||
      !atomsCache->hasVideo_id.init(cx, "hasVideo") ||
      !atomsCache->hasAudio_id.init(cx, "hasAudio") ||
      !atomsCache->containerType_id.init(cx, "containerType") ||
      !atomsCache->channels_id.init(cx, "channels") ||
      !atomsCache->PlayState_id.init(cx, "PlayState")) {
    return false;
  }
  return true;
}

bool
MediaDecoderDebugInfo::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mPlayState.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mChannels = 0U;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mContainerType.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mHasAudio = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mHasVideo = false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mInstance.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mRate = 0U;
  }
  mIsAnyMemberPresent = true;

  if (!mReader.Init("'reader' member of MediaDecoderDebugInfo", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;

  if (!mResource.Init("'resource' member of MediaDecoderDebugInfo", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;

  if (!mStateMachine.Init("'stateMachine' member of MediaDecoderDebugInfo", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
MediaDecoderDebugInfo::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  MediaDecoderDebugInfoAtoms* atomsCache = GetAtomCache<MediaDecoderDebugInfoAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mPlayState;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->PlayState_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint32_t const & currentValue = mChannels;
    temp.setNumber(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->channels_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mContainerType;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->containerType_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mHasAudio;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->hasAudio_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mHasVideo;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->hasVideo_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mInstance;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->instance_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    uint32_t const & currentValue = mRate;
    temp.setNumber(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->rate_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    MediaFormatReaderDebugInfo const & currentValue = mReader;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->reader_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    MediaResourceDebugInfo const & currentValue = mResource;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->resource_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    MediaDecoderStateMachineDebugInfo const & currentValue = mStateMachine;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->stateMachine_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
MediaDecoderDebugInfo::TraceDictionary(JSTracer* trc)
{
}

MediaDecoderDebugInfo&
MediaDecoderDebugInfo::operator=(const MediaDecoderDebugInfo& aOther)
{
  DictionaryBase::operator=(aOther);
  mPlayState = aOther.mPlayState;
  mChannels = aOther.mChannels;
  mContainerType = aOther.mContainerType;
  mHasAudio = aOther.mHasAudio;
  mHasVideo = aOther.mHasVideo;
  mInstance = aOther.mInstance;
  mRate = aOther.mRate;
  mReader = aOther.mReader;
  mResource = aOther.mResource;
  mStateMachine = aOther.mStateMachine;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail



HTMLMediaElementDebugInfo::HTMLMediaElementDebugInfo()
  : mEMEInfo(FastDictionaryInitializer()),
    mDecoder(FastDictionaryInitializer())
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
HTMLMediaElementDebugInfo::InitIds(JSContext* cx, HTMLMediaElementDebugInfoAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->decoder_id.init(cx, "decoder") ||
      !atomsCache->compositorDroppedFrames_id.init(cx, "compositorDroppedFrames") ||
      !atomsCache->EMEInfo_id.init(cx, "EMEInfo")) {
    return false;
  }
  return true;
}

bool
HTMLMediaElementDebugInfo::Init(const char* sourceDescription, bool passedToJSImpl)
{
  if (!mEMEInfo.Init("'EMEInfo' member of HTMLMediaElementDebugInfo", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mCompositorDroppedFrames = 0;
  }
  mIsAnyMemberPresent = true;

  if (!mDecoder.Init("'decoder' member of HTMLMediaElementDebugInfo", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
HTMLMediaElementDebugInfo::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  HTMLMediaElementDebugInfoAtoms* atomsCache = GetAtomCache<HTMLMediaElementDebugInfoAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    EMEDebugInfo const & currentValue = mEMEInfo;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->EMEInfo_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    int32_t const & currentValue = mCompositorDroppedFrames;
    temp.setInt32(int32_t(currentValue));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->compositorDroppedFrames_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    MediaDecoderDebugInfo const & currentValue = mDecoder;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->decoder_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
HTMLMediaElementDebugInfo::TraceDictionary(JSTracer* trc)
{
}

HTMLMediaElementDebugInfo&
HTMLMediaElementDebugInfo::operator=(const HTMLMediaElementDebugInfo& aOther)
{
  DictionaryBase::operator=(aOther);
  mEMEInfo = aOther.mEMEInfo;
  mCompositorDroppedFrames = aOther.mCompositorDroppedFrames;
  mDecoder = aOther.mDecoder;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail


} // namespace dom
} // namespace mozilla
