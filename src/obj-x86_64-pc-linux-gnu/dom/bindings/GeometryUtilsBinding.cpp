/* THIS FILE IS AUTOGENERATED FROM GeometryUtils.webidl BY Codegen.py - DO NOT EDIT */

#include <type_traits>
#include "AtomList.h"
#include "GeckoProfiler.h"
#include "GeometryUtilsBinding.h"
#include "js/Object.h"
#include "js/experimental/JitInfo.h"
#include "jsapi.h"
#include "mozilla/OwningNonNull.h"
#include "mozilla/dom/BindingCallContext.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/Element.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/PrimitiveConversions.h"
#include "mozilla/dom/ScriptSettings.h"
#include "mozilla/dom/SimpleGlobalObject.h"
#include "mozilla/dom/UnionConversions.h"
#include "nsContentUtils.h"
#include "nsTextNode.h"

namespace mozilla {
namespace dom {

namespace binding_detail {}; // Just to make sure it's known as a namespace
using namespace mozilla::dom::binding_detail;


namespace CSSBoxTypeValues {
extern const EnumEntry strings[5] = {
  {"margin", 6},
  {"border", 6},
  {"padding", 7},
  {"content", 7},
  { nullptr, 0 }
};
} // namespace CSSBoxTypeValues

bool
ToJSValue(JSContext* aCx, CSSBoxType aArgument, JS::MutableHandle<JS::Value> aValue)
{
  MOZ_ASSERT(uint32_t(aArgument) < ArrayLength(CSSBoxTypeValues::strings));
  JSString* resultStr =
    JS_NewStringCopyN(aCx, CSSBoxTypeValues::strings[uint32_t(aArgument)].value,
                      CSSBoxTypeValues::strings[uint32_t(aArgument)].length);
  if (!resultStr) {
    return false;
  }
  aValue.setString(resultStr);
  return true;
}


void
ImplCycleCollectionTraverse(nsCycleCollectionTraversalCallback& aCallback, OwningTextOrElementOrDocument& aUnion, const char* aName, uint32_t aFlags)
{
  if (aUnion.IsText()) {
    ImplCycleCollectionTraverse(aCallback, aUnion.GetAsText(), "mText", aFlags);
  } else if (aUnion.IsElement()) {
    ImplCycleCollectionTraverse(aCallback, aUnion.GetAsElement(), "mElement", aFlags);
  } else if (aUnion.IsDocument()) {
    ImplCycleCollectionTraverse(aCallback, aUnion.GetAsDocument(), "mDocument", aFlags);
  }
}


void
ImplCycleCollectionUnlink(OwningTextOrElementOrDocument& aUnion)
{
  aUnion.Uninit();
}



ConvertCoordinateOptions::ConvertCoordinateOptions()
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}



bool
ConvertCoordinateOptions::InitIds(JSContext* cx, ConvertCoordinateOptionsAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->toBox_id.init(cx, "toBox") ||
      !atomsCache->fromBox_id.init(cx, "fromBox")) {
    return false;
  }
  return true;
}

bool
ConvertCoordinateOptions::Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  // Also evaluate isNullOrUndefined in order to avoid false-positive
  // checkers by static analysis tools
  MOZ_ASSERT_IF(!cx, val.isNull() && val.isNullOrUndefined());
  ConvertCoordinateOptionsAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<ConvertCoordinateOptionsAtoms>(cx);
    if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
        !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  if (!IsConvertibleToDictionary(val)) {
    return cx.ThrowErrorMessage<MSG_NOT_DICTIONARY>(sourceDescription);
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->fromBox_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    {
      int index;
      if (!FindEnumStringIndex<true>(cx, temp.ref(), CSSBoxTypeValues::strings, "CSSBoxType", "'fromBox' member of ConvertCoordinateOptions", &index)) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      mFromBox = static_cast<CSSBoxType>(index);
    }
  } else {
    mFromBox = CSSBoxType::Border;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->toBox_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    {
      int index;
      if (!FindEnumStringIndex<true>(cx, temp.ref(), CSSBoxTypeValues::strings, "CSSBoxType", "'toBox' member of ConvertCoordinateOptions", &index)) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      mToBox = static_cast<CSSBoxType>(index);
    }
  } else {
    mToBox = CSSBoxType::Border;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
ConvertCoordinateOptions::Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // We don't want to use sourceDescription for our context here;
  // that's not really what it's formatted for.
  BindingCallContext cx(cx_, nullptr);
  return Init(cx, val, sourceDescription, passedToJSImpl);
}

void
ConvertCoordinateOptions::TraceDictionary(JSTracer* trc)
{
}

ConvertCoordinateOptions&
ConvertCoordinateOptions::operator=(const ConvertCoordinateOptions& aOther)
{
  DictionaryBase::operator=(aOther);
  mFromBox = aOther.mFromBox;
  mToBox = aOther.mToBox;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail


bool
TextOrElementOrDocument::ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const
{
  switch (mType) {
    case eUninitialized: {
      return false;
      break;
    }
    case eText: {
      if (!GetOrCreateDOMReflector(cx, mValue.mText.Value(), rval)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case eElement: {
      if (!GetOrCreateDOMReflector(cx, mValue.mElement.Value(), rval)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case eDocument: {
      if (!GetOrCreateDOMReflector(cx, mValue.mDocument.Value(), rval)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      return false;
      break;
    }
  }

  return false;
}


OwningNonNull<mozilla::dom::Text>&
OwningTextOrElementOrDocument::RawSetAsText()
{
  if (mType == eText) {
    return mValue.mText.Value();
  }
  MOZ_ASSERT(mType == eUninitialized);
  mType = eText;
  return mValue.mText.SetValue();
}

OwningNonNull<mozilla::dom::Text>&
OwningTextOrElementOrDocument::SetAsText()
{
  if (mType == eText) {
    return mValue.mText.Value();
  }
  Uninit();
  mType = eText;
  return mValue.mText.SetValue();
}

bool
OwningTextOrElementOrDocument::TrySetToText(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  tryNext = false;
  { // scope for memberSlot
    OwningNonNull<mozilla::dom::Text>& memberSlot = RawSetAsText();
    static_assert(IsRefcounted<mozilla::dom::Text>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::Text, mozilla::dom::Text>(value, memberSlot, cx);
      if (NS_FAILED(rv)) {
        DestroyText();
        tryNext = true;
        return true;
      }
    }
  }
  return true;
}

bool
OwningTextOrElementOrDocument::TrySetToText(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  BindingCallContext cx(cx_, nullptr);
  return TrySetToText(cx, value, tryNext, passedToJSImpl);
}

void
OwningTextOrElementOrDocument::DestroyText()
{
  MOZ_ASSERT(IsText(), "Wrong type!");
  mValue.mText.Destroy();
  mType = eUninitialized;
}




OwningNonNull<mozilla::dom::Element>&
OwningTextOrElementOrDocument::RawSetAsElement()
{
  if (mType == eElement) {
    return mValue.mElement.Value();
  }
  MOZ_ASSERT(mType == eUninitialized);
  mType = eElement;
  return mValue.mElement.SetValue();
}

OwningNonNull<mozilla::dom::Element>&
OwningTextOrElementOrDocument::SetAsElement()
{
  if (mType == eElement) {
    return mValue.mElement.Value();
  }
  Uninit();
  mType = eElement;
  return mValue.mElement.SetValue();
}

bool
OwningTextOrElementOrDocument::TrySetToElement(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  tryNext = false;
  { // scope for memberSlot
    OwningNonNull<mozilla::dom::Element>& memberSlot = RawSetAsElement();
    static_assert(IsRefcounted<mozilla::dom::Element>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::Element, mozilla::dom::Element>(value, memberSlot, cx);
      if (NS_FAILED(rv)) {
        DestroyElement();
        tryNext = true;
        return true;
      }
    }
  }
  return true;
}

bool
OwningTextOrElementOrDocument::TrySetToElement(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  BindingCallContext cx(cx_, nullptr);
  return TrySetToElement(cx, value, tryNext, passedToJSImpl);
}

void
OwningTextOrElementOrDocument::DestroyElement()
{
  MOZ_ASSERT(IsElement(), "Wrong type!");
  mValue.mElement.Destroy();
  mType = eUninitialized;
}




OwningNonNull<mozilla::dom::Document>&
OwningTextOrElementOrDocument::RawSetAsDocument()
{
  if (mType == eDocument) {
    return mValue.mDocument.Value();
  }
  MOZ_ASSERT(mType == eUninitialized);
  mType = eDocument;
  return mValue.mDocument.SetValue();
}

OwningNonNull<mozilla::dom::Document>&
OwningTextOrElementOrDocument::SetAsDocument()
{
  if (mType == eDocument) {
    return mValue.mDocument.Value();
  }
  Uninit();
  mType = eDocument;
  return mValue.mDocument.SetValue();
}

bool
OwningTextOrElementOrDocument::TrySetToDocument(BindingCallContext& cx, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  tryNext = false;
  { // scope for memberSlot
    OwningNonNull<mozilla::dom::Document>& memberSlot = RawSetAsDocument();
    static_assert(IsRefcounted<mozilla::dom::Document>::value, "We can only store refcounted classes.");
    {
      // Our JSContext should be in the right global to do unwrapping in.
      nsresult rv = UnwrapObject<prototypes::id::Document, mozilla::dom::Document>(value, memberSlot, cx);
      if (NS_FAILED(rv)) {
        DestroyDocument();
        tryNext = true;
        return true;
      }
    }
  }
  return true;
}

bool
OwningTextOrElementOrDocument::TrySetToDocument(JSContext* cx_, JS::Handle<JS::Value> value, bool& tryNext, bool passedToJSImpl)
{
  BindingCallContext cx(cx_, nullptr);
  return TrySetToDocument(cx, value, tryNext, passedToJSImpl);
}

void
OwningTextOrElementOrDocument::DestroyDocument()
{
  MOZ_ASSERT(IsDocument(), "Wrong type!");
  mValue.mDocument.Destroy();
  mType = eUninitialized;
}




void
OwningTextOrElementOrDocument::Uninit()
{
  switch (mType) {
    case eUninitialized: {
      break;
    }
    case eText: {
      DestroyText();
      break;
    }
    case eElement: {
      DestroyElement();
      break;
    }
    case eDocument: {
      DestroyDocument();
      break;
    }
  }
}

bool
OwningTextOrElementOrDocument::ToJSVal(JSContext* cx, JS::Handle<JSObject*> scopeObj, JS::MutableHandle<JS::Value> rval) const
{
  switch (mType) {
    case eUninitialized: {
      return false;
      break;
    }
    case eText: {
      if (!GetOrCreateDOMReflector(cx, mValue.mText.Value(), rval)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case eElement: {
      if (!GetOrCreateDOMReflector(cx, mValue.mElement.Value(), rval)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    case eDocument: {
      if (!GetOrCreateDOMReflector(cx, mValue.mDocument.Value(), rval)) {
        MOZ_ASSERT(JS_IsExceptionPending(cx));
        return false;
      }
      return true;
      break;
    }
    default: {
      return false;
      break;
    }
  }

  return false;
}

void
OwningTextOrElementOrDocument::TraceUnion(JSTracer* trc)
{
}

OwningTextOrElementOrDocument&
OwningTextOrElementOrDocument::operator=(const OwningTextOrElementOrDocument& aOther)
{
  switch (aOther.mType) {
    case eUninitialized: {
      MOZ_ASSERT(mType == eUninitialized,
                 "We need to destroy ourselves?");
      break;
    }
    case eText: {
      SetAsText() = aOther.GetAsText();
      break;
    }
    case eElement: {
      SetAsElement() = aOther.GetAsElement();
      break;
    }
    case eDocument: {
      SetAsDocument() = aOther.GetAsDocument();
      break;
    }
  }
  return *this;
}



BoxQuadOptions::BoxQuadOptions()
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}



bool
BoxQuadOptions::InitIds(JSContext* cx, BoxQuadOptionsAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->relativeTo_id.init(cx, "relativeTo") ||
      !atomsCache->createFramesForSuppressedWhitespace_id.init(cx, "createFramesForSuppressedWhitespace") ||
      !atomsCache->box_id.init(cx, "box")) {
    return false;
  }
  return true;
}

bool
BoxQuadOptions::Init(BindingCallContext& cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  // Also evaluate isNullOrUndefined in order to avoid false-positive
  // checkers by static analysis tools
  MOZ_ASSERT_IF(!cx, val.isNull() && val.isNullOrUndefined());
  BoxQuadOptionsAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<BoxQuadOptionsAtoms>(cx);
    if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
        !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  if (!IsConvertibleToDictionary(val)) {
    return cx.ThrowErrorMessage<MSG_NOT_DICTIONARY>(sourceDescription);
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->box_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    {
      int index;
      if (!FindEnumStringIndex<true>(cx, temp.ref(), CSSBoxTypeValues::strings, "CSSBoxType", "'box' member of BoxQuadOptions", &index)) {
        return false;
      }
      MOZ_ASSERT(index >= 0);
      mBox = static_cast<CSSBoxType>(index);
    }
  } else {
    mBox = CSSBoxType::Border;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (nsContentUtils::ThreadsafeIsSystemCaller(cx)) {
      if (!JS_GetPropertyById(cx, *object, atomsCache->createFramesForSuppressedWhitespace_id, temp.ptr())) {
        return false;
      }
    } else {
      temp->setUndefined();
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), "'createFramesForSuppressedWhitespace' member of BoxQuadOptions", &mCreateFramesForSuppressedWhitespace)) {
      return false;
    }
  } else {
    mCreateFramesForSuppressedWhitespace = true;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->relativeTo_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mRelativeTo.Construct();
    {
      bool done = false, failed = false, tryNext;
      if (temp.ref().isObject()) {
        done = (failed = !(mRelativeTo.Value()).TrySetToText(cx, temp.ref(), tryNext, passedToJSImpl)) || !tryNext ||
               (failed = !(mRelativeTo.Value()).TrySetToElement(cx, temp.ref(), tryNext, passedToJSImpl)) || !tryNext ||
               (failed = !(mRelativeTo.Value()).TrySetToDocument(cx, temp.ref(), tryNext, passedToJSImpl)) || !tryNext;

      }
      if (failed) {
        return false;
      }
      if (!done) {
        cx.ThrowErrorMessage<MSG_NOT_IN_UNION>("'relativeTo' member of BoxQuadOptions", "Text, Element, Document");
        return false;
      }
    }
    mIsAnyMemberPresent = true;
  }
  return true;
}

bool
BoxQuadOptions::Init(JSContext* cx_, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // We don't want to use sourceDescription for our context here;
  // that's not really what it's formatted for.
  BindingCallContext cx(cx_, nullptr);
  return Init(cx, val, sourceDescription, passedToJSImpl);
}

void
BoxQuadOptions::TraceDictionary(JSTracer* trc)
{
}



BoxQuadOptions&
BoxQuadOptions::operator=(const BoxQuadOptions& aOther)
{
  DictionaryBase::operator=(aOther);
  mBox = aOther.mBox;
  mCreateFramesForSuppressedWhitespace = aOther.mCreateFramesForSuppressedWhitespace;
  mRelativeTo.Reset();
  if (aOther.mRelativeTo.WasPassed()) {
    mRelativeTo.Construct(aOther.mRelativeTo.Value());
  }
  return *this;
}

namespace binding_detail {
} // namespace binding_detail


} // namespace dom
} // namespace mozilla
