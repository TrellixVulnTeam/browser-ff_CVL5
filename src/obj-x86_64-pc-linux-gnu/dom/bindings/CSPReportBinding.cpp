/* THIS FILE IS AUTOGENERATED FROM CSPReport.webidl BY Codegen.py - DO NOT EDIT */

#include <type_traits>
#include "AtomList.h"
#include "CSPReportBinding.h"
#include "GeckoProfiler.h"
#include "js/Object.h"
#include "js/experimental/JitInfo.h"
#include "mozilla/OwningNonNull.h"
#include "mozilla/dom/BindingCallContext.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/PrimitiveConversions.h"
#include "mozilla/dom/ScriptSettings.h"
#include "mozilla/dom/SimpleGlobalObject.h"

namespace mozilla {
namespace dom {

namespace binding_detail {}; // Just to make sure it's known as a namespace
using namespace mozilla::dom::binding_detail;



CSPReportProperties::CSPReportProperties()
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
CSPReportProperties::InitIds(JSContext* cx, CSPReportPropertiesAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->violated_directive_id.init(cx, "violated-directive") ||
      !atomsCache->source_file_id.init(cx, "source-file") ||
      !atomsCache->script_sample_id.init(cx, "script-sample") ||
      !atomsCache->referrer_id.init(cx, "referrer") ||
      !atomsCache->original_policy_id.init(cx, "original-policy") ||
      !atomsCache->line_number_id.init(cx, "line-number") ||
      !atomsCache->document_uri_id.init(cx, "document-uri") ||
      !atomsCache->column_number_id.init(cx, "column-number") ||
      !atomsCache->blocked_uri_id.init(cx, "blocked-uri")) {
    return false;
  }
  return true;
}

bool
CSPReportProperties::Init(const char* sourceDescription, bool passedToJSImpl)
{
  {
    // scope for any temporaries our default value setting needs.
    mBlocked_uri.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mDocument_uri.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mOriginal_policy.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mReferrer.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;

  {
    // scope for any temporaries our default value setting needs.
    mViolated_directive.AssignLiteral(u"");
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
CSPReportProperties::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  CSPReportPropertiesAtoms* atomsCache = GetAtomCache<CSPReportPropertiesAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mBlocked_uri;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->blocked_uri_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mColumn_number.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      int32_t const & currentValue = mColumn_number.InternalValue();
      temp.setInt32(int32_t(currentValue));
      if (!JS_DefinePropertyById(cx, obj, atomsCache->column_number_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mDocument_uri;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->document_uri_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mLine_number.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      int32_t const & currentValue = mLine_number.InternalValue();
      temp.setInt32(int32_t(currentValue));
      if (!JS_DefinePropertyById(cx, obj, atomsCache->line_number_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mOriginal_policy;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->original_policy_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mReferrer;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->referrer_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  if (mScript_sample.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      nsString const & currentValue = mScript_sample.InternalValue();
      if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->script_sample_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  if (mSource_file.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      nsString const & currentValue = mSource_file.InternalValue();
      if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
        return false;
      }
      if (!JS_DefinePropertyById(cx, obj, atomsCache->source_file_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(false);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mViolated_directive;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->violated_directive_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

void
CSPReportProperties::TraceDictionary(JSTracer* trc)
{
}

CSPReportProperties&
CSPReportProperties::operator=(const CSPReportProperties& aOther)
{
  DictionaryBase::operator=(aOther);
  mBlocked_uri = aOther.mBlocked_uri;
  mColumn_number.Reset();
  if (aOther.mColumn_number.WasPassed()) {
    mColumn_number.Construct(aOther.mColumn_number.Value());
  }
  mDocument_uri = aOther.mDocument_uri;
  mLine_number.Reset();
  if (aOther.mLine_number.WasPassed()) {
    mLine_number.Construct(aOther.mLine_number.Value());
  }
  mOriginal_policy = aOther.mOriginal_policy;
  mReferrer = aOther.mReferrer;
  mScript_sample.Reset();
  if (aOther.mScript_sample.WasPassed()) {
    mScript_sample.Construct(aOther.mScript_sample.Value());
  }
  mSource_file.Reset();
  if (aOther.mSource_file.WasPassed()) {
    mSource_file.Construct(aOther.mSource_file.Value());
  }
  mViolated_directive = aOther.mViolated_directive;
  return *this;
}

bool
CSPReportProperties::operator==(const CSPReportProperties& aOther) const
{
  if (mBlocked_uri != aOther.mBlocked_uri) {
      return false;
  }
  if (mColumn_number != aOther.mColumn_number) {
      return false;
  }
  if (mDocument_uri != aOther.mDocument_uri) {
      return false;
  }
  if (mLine_number != aOther.mLine_number) {
      return false;
  }
  if (mOriginal_policy != aOther.mOriginal_policy) {
      return false;
  }
  if (mReferrer != aOther.mReferrer) {
      return false;
  }
  if (mScript_sample != aOther.mScript_sample) {
      return false;
  }
  if (mSource_file != aOther.mSource_file) {
      return false;
  }
  if (mViolated_directive != aOther.mViolated_directive) {
      return false;
  }
  return true;
}

namespace binding_detail {
} // namespace binding_detail



CSPReport::CSPReport()
  : mCsp_report(FastDictionaryInitializer())
{
  // Safe to pass a null context if we pass a null value
  Init();
}



bool
CSPReport::InitIds(JSContext* cx, CSPReportAtoms* atomsCache)
{
  MOZ_ASSERT(JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->csp_report_id.init(cx, "csp-report")) {
    return false;
  }
  return true;
}

bool
CSPReport::Init(const char* sourceDescription, bool passedToJSImpl)
{
  if (!mCsp_report.Init("'csp-report' member of CSPReport", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;
  return true;
}

bool
CSPReport::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  CSPReportAtoms* atomsCache = GetAtomCache<CSPReportAtoms>(cx);
  if (JSID_IS_VOID(*reinterpret_cast<jsid*>(atomsCache)) &&
      !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    CSPReportProperties const & currentValue = mCsp_report;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->csp_report_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(false);

  return true;
}

bool
CSPReport::ToJSON(nsAString& aJSON) const
{
  AutoJSAPI jsapi;
  jsapi.Init();
  JSContext *cx = jsapi.cx();
  // It's safe to use UnprivilegedJunkScopeOrWorkerGlobal here
  // because we'll only be creating objects, in ways that have no
  // side-effects, followed by a call to JS::ToJSONMaybeSafely,
  // which likewise guarantees no side-effects for the sorts of
  // things we will pass it.
  JSObject* scope = UnprivilegedJunkScopeOrWorkerGlobal(fallible);
  if (!scope) {
    JS_ReportOutOfMemory(cx);
    return false;
  }
  JSAutoRealm ar(cx, scope);
  JS::Rooted<JS::Value> val(cx);
  if (!ToObjectInternal(cx, &val)) {
    return false;
  }
  JS::Rooted<JSObject*> obj(cx, &val.toObject());
  return StringifyToJSON(cx, obj, aJSON);
}

void
CSPReport::TraceDictionary(JSTracer* trc)
{
}

CSPReport&
CSPReport::operator=(const CSPReport& aOther)
{
  DictionaryBase::operator=(aOther);
  mCsp_report = aOther.mCsp_report;
  return *this;
}

namespace binding_detail {
} // namespace binding_detail


} // namespace dom
} // namespace mozilla
